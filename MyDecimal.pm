#!/usr/bin/perl
#===============================================================================
#
# 多倍長整数の演算を実現するカスタムライブラリー
#
# bignum が提供する機能をの一部を独自に再現したもの。
#
#===============================================================================

#-------------------------------------------------------------------------------
#
# 数学用語の英語表現はややこしいのでここにメモしておく。
#
#   自然数	: natural number ( 正の整数 )
#   整数	: integer ( 自然数、0、負の整数 を包含 )
#   偶数	: even number
#   奇数	: odd number
#   素数	: prime number
#
#   小数	: decimal
#   小数点	: radix point   ( 10 進数の場合は "decimal point" )
#   整数部	: integral part ( 小数の整数部 )
#   小数部	: decimal part  ( 小数の小数部 )
#
#   分数	: fraction	( 本義は「端数」であり、小数が fraction と呼ばれることもある。 )
#   分子	: numerator
#   分母	: denominator
#   有理数	: rational number
#   無理数	: irrational number
#
#   実数	: real number ( 整数、有理数 ( 分数 )、無理数 を包含 )
#   虚数	: imaginary number
#   複素数	: complex number ( 実数、虚数 を包含 )
#   虚数単位	: imaginary unit
#
#   足し算	: addition
#   引き算	: subtraction	( 「暗算」の意味で使われることもある。 )
#   掛け算	: multiplication
#   割り算	: division
#   剰余算	: modulus operation	( modulus は「率」や「係数」の意。 )
#   		  modulo operation	( modulo は「法として」の意。 )
#   		  remainder operation
#
#   和		: the sum
#   差		: the remainder	( 「剰余」との区別が微妙。(^^;) )
#   積		: the product
#   商		: the quotient
#   剰余	: remainder	( 「差」との区別が微妙。(^^;) )
#
#   倍数	: multiple
#   約数	: divisor	( 「除数」と同じ。 )
#
#   乗数	: multiplier
#   被乗数	: multiplicand
#   除数	: divisor	( 「約数」と同じ。 )
#   被除数	: diviend
#
#   暗算	: subtraction	( 「引き算」と同じ。 )
#   		  mental arithmetic ( mental calculation )
#   筆算	: calculation on paper
#   		  calculation by writing
#
#   単位円	: unit circle
#   象限	: quadrant
#   偏角	: argument
#   半径	: radius
#   弧		: arc
#   ラジアン	: radian
#   度		: degree ( 度数法 )
#
#   順序集合	: ordered set
#   全順序集合	: totally ordered set
#   半順序集合	: partially ordered set ( poset )
#   上界	: upper bound
#   下界	: lower bound
#   上限	: supremum ( == least upper bound )
#   下限	: infinimum ( == greatest lower bound )
#   本質的上限	: essential supremum
#   本質的下限	: essential infinimum
#
#   関数	: function             ( y == f(x) )
#   多項式	: polynomial           ( y == f(x) の f(x) )
#   方程式	: equation             ( f(x) == a )
#   代入	: substitute
#   根		: root ( 多項式を方程式の左辺とみなし、これを 0 と同値とした時の方程式の解。零点 ( zero ) とも言う。 )
#   次数	: degree ( 多項式の次数 )
#   係数	: coefficients
#   最高次係数	: leading coefficient  ( 頭項係数 )
#   定数項	: constant term ( constants )
#   変数	: variables ( indeterminates )
#   独立変数	: independent variable ( 多項式関数 y == f(x) の x のこと。 )
#   従属変数	: dependent variable   ( 多項式関数 y == f(x) の y のこと。 )
#   定義域	: domain               ( 独立変数が採りうる値の全体 ( 独立変数の変域 ) )
#   値域	: range                ( 従属変数が採りうる値の全体 ( 従属変数の変域 ) )
#
#-------------------------------------------------------------------------------

=encoding utf8

=head1 NAME 

 MyDecimal - Math package for decimal numbers.

=head1 DESCRIPTION

 This package provides big interger numbers, big decimal numbers, and some other mathematical numbers and functions.
 In generally, the functions and methods of this package can be too slow, because the all functions and methods are implemented with pure perl.

=head1 OBJECTS

 This package provides some basic object.

=head2 Decimal object
 
 This object class defined for big integer value and big decimal value.
 By default, the maximum digits of decimal part is set to 40.
 The integer part has no limit about the size of digits, but too large number cause too slow calculation.

 + or - Infinity and 'NaN' is not defined and not supported.
 In generally, when the calculation is failed, the functions and methods will return "undef".


   print 12345678901234567890 + 10 ;                                             # 1.23456789012346e+019 ( perl standard )

   use MyDecimal ;
   print decimal( '12345678901234567890' ) + 10 ;                                # 12345678901234567900
   print decimal( '12345678901234567890' ) / '10_000_000_000_000_000' ;          # 1234.506789123456789

 Some methods can accept the digits of decimal part.

   print decimal( '12345678901234567890' )->divide( '10_000_000' ) ;             # 1234567890123.456789
   print decimal( '12345678901234567890' )->divide( '10_000_000' , 1 ) ;         # 1234567890123.4
   print decimal( '12345678901234567890' )->divide( '10_000_000' )->round( 1 ) ; # 1234567890123.5

 In some cases, the digits of decimal part can be over 40.

   my $x = decimal( 0.1234567890 ) ** 5 ;
   print $x ;                                           # 0.000028679718602997181072337614380936720482949
   print length( $x ) ;                                 # 47 ( The decimal part length is ( 47 - 2 ) == 45. )

=head2 Fraction object

 This object class defined for fraction numbers.

   print fraction( 1 , 3 ) ;                            # 1/3

 The finite decimal numbers and the recurring decimal numbers will be converted to short size fraction numbers. 
 ( These numbers are called "rational numbers". )

   print fraction( 1.5 ) ;                              # 3/2                     ( finite decimal )

   my $x = 1/3 ;                                        # $x == 0.333333333333333 ( pure recurring decimal )
   print fraction( $x ) ;                               # 1/3
   print fraction( $x )->inverse()                      # 3

   my $y = 1/7 ;                                        # $y == 0.142857142857143 ( mixed recurring decimal )
   print fraction( $y ) ;                               # 1/7
   print fraction( $y )->inverse()                      # 7

 You can also converts "irrational numbers" to fraction numbers, but it will have too large numerator and denominator.

   print fraction( sqrt(2) ) ;                          # 14142135623731/10000000000000

   my $x = decimal( 2 )->sqrt()->fraction() ;
   print $x ;
   -> 5660873562744821731006755327748606552613925359253050/4002842083624608724044459561979995319315986481080071

 But, the Fraction object can be converted to the Decimal object easily.

   my $x = decimal( 2 )->sqrt()->fraction() ;
   print $x->decimal() ;                                # 1.4142135623843673880650279703807937716298


=head2 Complex object

  This object class defined for complex numbers.

    print complex( [ 1 , 2 ] ) ;                             # 1 + 2 i

    print complex( { arg    => pi() / 4 , radius => 2 } )    # 1.414213562373095 + 1.414213562373095 i
    print complex( { arg    => pi() / 4 , abs    => 2 } )    # 1.414213562373095 + 1.414213562373095 i
    print complex( { theta  => pi() / 4 , radius => 2 } )    # 1.414213562373095 + 1.414213562373095 i
    print complex( { radian => pi() / 4 , radius => 2 } )    # 1.414213562373095 + 1.414213562373095 i
    print complex( { degree => 45       , radius => 2 } )    # 1.414213562373095 + 1.414213562373095 i

    my $sqrt2 = decimal( 2 )->sqrt() ;
    my $z = complex( [ $sqrt2 , $sqrt2 ] ) ;                 # $z == 1.414213562373095 + 1.414213562373095 i
    print $z->abs()->round( 15 ) ;                           # 2
    print $z->arg()->degree() ;                              # 45 ( PI / 4 )


    print join ' , ' , complex( [ 4 ] )->sqrt() ;            # 2 , -2

    print join "\n"  , complex( [ 8 ] )->root( 3 ) ;         # 2
                                                             # -1 + 1.732050807568877 i
                                                             # -1 - 1.732050807568877 i

=head2 Vector object

 This object class defined for vector and matrix.

   print vector( 1 , 2 , 3 ) ;
   -> [              1.00000 ]
      [              2.00000 ]
      [              3.00000 ]

   print vector( 1 , 2 , 3 )->transpose() ;
   -> [              1.00000 ,              2.00000 ,              3.00000 ]

   print matrix( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) ;
   -> [              1.00000 ,              2.00000 ,              3.00000 ]
      [              4.00000 ,              5.00000 ,              6.00000 ]
   
   print vector( 1 , 2 , 3 ) * vector( 1 , 2 , 3 )->transpose() ;
   -> [              1.00000 ,              2.00000 ,              3.00000 ]
      [              2.00000 ,              4.00000 ,              6.00000 ]
      [              3.00000 ,              6.00000 ,              9.00000 ]

   print vector( 1 , 2 , 3 )->transpose() * vector( 1 , 2 , 3 ) ;
   -> 14


=head1 FUNCIOTNS

 This package provides some functions.

=head2 pi( $digits )

 Returns PI.

 If "digits" is specified as numeric number, returns truncated or expanded value.
 By default, the decimal part of the result has 40 digits.

   print pi() ;                                       # 3.1415926535897932384626433832795028841972
   print pi( 2 ) ;                                    # 3.14
   print pi( 50 ) ;                                   # 3.14159265358979323846264338327950288419716939937512

 This function will return the Decimal object.

=head2 radian( $degree )

 Returns radian value converted from "degree".

   print radian( 90 ) ;                              # 1.5707963267948966192313216916397514420986
   print radian( 45 ) ;                              # 0.7853981633974483096156608458198757210493
   print radian( -45 ) ;                             # -0.7853981633974483096156608458198757210493

 This function will return the Decimal object.

=head2 npi( $radian )

 Returns the value, which the "radian" divided by PI.

   print npi( radian( 90 ) ) ;                      # 0.5
   print npi( radian( -45 ) )->fraction() ;         # -1/4

 This function will return the Decimal object.

=head2 gcd( @n )

 Returns the great common divisor.

   print gcd( 27 , 6 ) ;                           # 3
   print gcd( 10 , 15 , 20 , 25 , 30 , 35 ) ;      # 5

 This function will return the Decimal object.

=head2 lcm( @n )

  Returns the least common multiple.

   print lcm( 27 , 6 ) ;                           # 54
   print lcm( 10 , 15 , 20 , 25 , 30 , 35 ) ;      # 210

 This function will return the Decimal object.

=head1 METHODS

=head2 The basic methods

=head3 Decimal object

 print decimal( '-1.25' )->abs() ;                # 1.25
 print decimal( '2' )->is_even()                  # 1 ( true )
 print decimal( '2' )->is_odd()                   # 0 ( false )

 print decimal( '2' )->is_integer()               # 1 ( true )
 print decimal( '2' )->is_decimal()               # 1 ( always true )
 print decimal( '2' )->is_fraction()              # 0 ( always false )
 print decimal( '2' )->is_complex()               # 0 ( always false )
 print decimal( '2' )->is_vector()                # 0 ( always false )
 print decimal( '2' )->is_matrix()                # 0 ( always false )

 print decimal( '2' )->can_decimal()              # 1 ( always true )
 print decimal( '2' )->can_fraction()             # 1 ( always ture )
 print decimal( '2' )->can_complex()              # 1 ( always true )

 print decimal( '-1.25' )->integer() ;            # -1 ( rounding towards 0 ; RZ )
 print decimal( '-1.25' )->floor() ;              # -2 ( rounding towards minus infinity ; RM )
 print decimal( '-1.25' )->ceil() ;               # -1 ( rounding towards plus infinity ; RP )

 print decimal( '-1.25' )->integer_part() ;       # -2 ( same to "floor" )
 print decimal( '-1.25' )->decimal_part() ;       # 0.75 ( $result = $decimal - $decimal->integer_part() )

 print decimal( '-1.25' )->integer_digits() ;     # 1 ( length( $decimal->abs()->integer() ) )
 print decimal( '-1.25' )->decimal_digits() ;     # 2 ( length( $decimal->abs() ) - ( $decimal->integer_digits() + 2 ) )

 print decimal(  '1.25' )->round( 1 ) ;           #  1.3
 print decimal(  '1.24' )->round( 1 ) ;           #  1.2
 print decimal( '-1.25' )->round( 1 ) ;           # -1.2 == int( ( -1.25 + 0.05 ) * 100 / 100 )

 print decimal(  '1.25' )->round_up( 1 ) ;        #  1.3
 print decimal(  '1.24' )->round_up( 1 ) ;        #  1.3
 print decimal( '-1.24' )->round_up( 1 ) ;        # -1.2 ( RP )

 print decimal(  '1.25' )->round_down( 1 ) ;      #  1.2
 print decimal(  '1.24' )->round_down( 1 ) ;      #  1.2
 print decimal( '-1.25' )->round_down( 1 ) ;      # -1.3 ( RM )

=head3 Fraction object

 print fraction( -1 , 2 )->abs() ;                # 1/2

 print fraction( -1 , 2 )->is_integer() ;         # 0 ( always false )
 print fraction( -1 , 2 )->is_decimal() ;         # 0 ( always false )
 print fraction( -1 , 2 )->is_fraction() ;        # 1 ( always true  )
 print fraction( -1 , 2 )->is_complex() ;         # 0 ( always false )
 print fraction( -1 , 2 )->is_vector() ;          # 0 ( always false )
 print fraction( -1 , 2 )->is_matrix() ;          # 0 ( always false )

 print fraction( -1 , 2 )->can_integer() ;        # 0 ( return ( denominator == 1 ) ? 1 : 0 )
 print fraction( -1 , 2 )->can_decimal() ;        # 1 ( always true )

 print fraction( -3 , 2 )->integer() ;            # return int( -1.5 ) ==  -1   ( Decimal object )
 print fraction( -3 , 2 )->decimal() ;            # return -1.5                 ( Decimal object )

 print fraction( -3 , 2 )->integer_part() ;       # return floor( -1.5 )        ==  -2 ( Decimal object )
 print fraction( -3 , 2 )->decimal_part() ;       # return -1.5 - floor( -1.5 ) == 0.5 ( Decimal object )

 print fraction( -2 , 4 )->numerator() ;          # -1 ( Decimal object )
 print fraction( -2 , 4 )->denominator() ;        #  2 ( Decimal object )
 print fraction( -1 , 2 )->numer() ;              # -1 ( same to numerator )
 print fraction( -1 , 2 )->denom() ;              #  2 ( same to denominator )

=head3 Complex object

 print complex( [ 1 , 2 ] ) ;                     # 1 + 2 i
 print complex( [ 1 , 2 ] )->real() ;             # 1       ( Decimal object )
 print complex( [ 1 , 2 ] )->imag() ;             # 2       ( Decimal object )
 print complex( [ 1 , 2 ] )->conj() ;             # 1 - 2 i

 print complex( [ 1 , 2 ] )->is_integer() ;       # 0 ( always false )
 print complex( [ 1 , 2 ] )->is_decimal() ;       # 0 ( always false )
 print complex( [ 1 , 2 ] )->is_fraction() ;      # 0 ( always false )
 print complex( [ 1 , 2 ] )->is_complex() ;       # 1 ( always true  )
 print complex( [ 1 , 2 ] )->is_vector() ;        # 0 ( always false )
 print complex( [ 1 , 2 ] )->is_matrix() ;        # 0 ( always false )

 my $z = complex( [ 1 , 2 ] ) ;
 print $z->is_real() ;                            # 0
 print $z->is_imag() ;                            # 1

 my $z = complex( [ 2 , 0 ] ) ;
 print $z->is_real() ;                            # 1
 print $z->is_imag() ;                            # 0

 my $z = complex( [ 1 , 2 ] ) ;
 print $z->can_integer() ;                        # 0
 print $z->can_decimal() ;                        # 0
 print $z->integer() ;                            # undef
 print $z->decimal() ;                            # undef

 my $z = complex( [ 2 , 0 ] ) ;
 print $z->can_integer() ;                        # 1
 print $z->can_decimal() ;                        # 1
 print $z->integer() ;                            # 2     ( Decimal object )
 print $z->decimal() ;                            # 2     ( Decimal object )

 my $z = complex( [ 2.5 , 0 ] ) ;
 print $z->can_integer() ;                        # 0
 print $z->can_decimal() ;                        # 1
 print $z->integer() ;                            # undef ( Decimal object )
 print $z->decimal() ;                            # 2.5   ( Decimal object )

 my $z = complex( [ 1 , 1 ] ) ;
 print $z->det() ;                                # 2     ( Decimal object )
 print $z->abs()->round( 3 ) ;                    # 1.414 ( Decimal object )
 print $z->radius()->round( 3 ) ;                 # 1.414 ( Decimal object )

 my $z = complex( [ 1 , 1 ] ) ;
 print $z->arg() ;                                # 0.7853981633974483096156608458198757210493 ( Decimal object )
 print $z->radian() ;                             # 0.78539 ( Decimal object )
 print $z->degree() ;                             # 45      ( Decimal object )
 print $z->npi() ;                                # 1/4     ( Fraction object )

 my $z = complex( [ 1 , 1 ] ) ;
 print $z ;                                       # 1 + i                                                  ( string )
 print $z->orthogonal() ;                         # 1 + i                                                  ( string )
 print $z->pollar_form() ;                        # 1.41421 * ( cos( 1/4 * PI ) + i * sin( 1/4 * PI ) )    ( string )
 print $z->exp_form() ;                           # 1.41421 * exp( i * ( 1/4 * PI ) )                      ( string )

 my $z = complex( [ 1 , 1 ] ) ;
 print $z->matrix_form() ;                        # [        1 ,       -1 ]                                ( string )
						  # [        1 ,        1 ]

=head3 Vector object

 print vector( 1 , 2 )->is_decimal() ;                  # 0 ( always false )
 print vector( 1 , 2 )->is_fraction() ;                 # 0 ( always false )
 print vector( 1 , 2 )->is_complex() ;                  # 0 ( always false )
 print vector( 1 , 2 )->is_vector() ;                   # 1
 print vector( 1 , 2 )->is_matrix() ;                   # 0

 print matrix( [ 1 , 2 ] , [ 3 , 4 ] )->is_vector() ;   # 0
 print matrix( [ 1 , 2 ] , [ 3 , 4 ] )->is_matrix() ;   # 1

 print vector( 1 , 2 )->is_cvector() ;                  # 1 ( The Vector object is a column vector, by default )
 print vector( 1 , 2 )->traspose()->is_cvector() ;      # 0 ( After transpose, it is not be a "column" vector. )

 print vector( 1 , 2 )->is_rvector() ;                  # 0 ( The Vector object is not a row vector, by default )
 print vector( 1 , 2 )->traspose()->is_rvector() ;      # 1 ( After transpose, it becomes a "row" vector. )

=cut


package MyDecimal ;

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

our $VERSION = '0.02' ;
our @ISA = qw(Exporter) ;
our @EXPORT = qw(
        decimal fraction complex vector matrix complex_vector complex_matrix
	imag imag_matrix
	polynomial
	bin2dec oct2dec hex2dec
	gcd lcm exgcd crt
	pi radian npi
	sine cosine tangent arctan arctan2
	variance covariance sd
	napier
	nCk nCkAll
	solve2 solve3 solve4 solven
	fft ifft dct idct dct2d idct2d
	rft irft ntt intt
	cf2frac cf2frac2
) ;
our @EXPORT_OK = qw(
	min max mean median percentile quantile hinge tertile quintile decil
);

use overload
	'""'    => 'value'		,
	'0+'    => 'value'		,
	'+'	=> 'ov_add'		,
	'-'	=> 'ov_subtract'	,
	'*'	=> 'multiply'		,
	'/'	=> 'ov_divide'		,
	'%'	=> 'modulus'		,
	'**'    => 'power'		,
	'<<'	=> 'bitshiftup'		,
	'>>'	=> 'bitshiftdown'	,
	'=='	=> 'equal'		,
	'!='	=> 'not_equal'		,
	'>'	=> 'greater_than'	,
	'>='	=> 'greater_equal'	,
	'<'	=> 'less_than'		,
	'<='	=> 'less_equal'		,
	'<=>'	=> 'compare'		,
;

use constant {
	#
	# 基数 ( 10^n で定義 )
	#
	# 繰り上がりと繰り下がりを制御する。
	#
	# 2 の冪を用いた方が一桁で表現できる数値を大きくすることができるが、
	# 基数変換に余分なコストがかかるため 10 の冪を用いている。
	# 10 の冪以外の基数を用いるのに必要なロジックは実装していない。
	#
	# 基数は Perl の数値をそのまま使用するので、有効桁数は 10 進数 15 桁程度。
	# ただし、乗算の結果が 10^14 程度の数値に納まる必要があるので、 10^7 程度が限界。 ( 10^8 以上では誤動作を起こす。 )
	# 64 bit Perl ではもう少し大きい値が使えるかもしれない。
	#
	#INT_BASE	=> 1000 ,
	INT_BASE	=> 10000000 ,
} ;

my $_DIGLEN = length( INT_BASE ) - 1 ;		# 桁を区切る長さ

our $DECIMAL_PART_LENGTH_LIMIT = 40 ;		# 商を求める際の小数点以下の桁数の上限
our $DENOMINATOR_LIMIT = 1_000_000_000 ;	# 分数の分母に用いる整数値の上限 ( 有効桁数 15 桁程度の精度なる )

=head1 Functions for construction.

=cut

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------
sub new {
	#-----------------------------------------------------------------------
	#
	# コンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;

	return undef	unless ( defined $n ) ;
	$n = $n->bstr()		if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;

	#
	# 引数を検査
	#
	if ( my $ref = ref( $n ) ) {
		#
		# 引数がオブジェクトであればコピーして返す。
		# 配列参照やハッシュ参照は受け付けない。
		#
		return $n->copy()	if ( $ref eq __PACKAGE__ ) ;
		return $n->copy()	if ( $ref =~ /^(?:Fraction|Complex|Vector|Polynomial)$/ ) ;
		return undef ;
	}
	elsif ( $n =~ /^[+-]{0,1}0+$/ ) {
		#
		# 0 とみなせる整数値
		#
		return __PACKAGE__->_new_small_integer( 0 , 1 ) ;
	}
	elsif ( $n =~ /^([+-]{0,1})(\d+)$/ ) {
		#
		# 単純且つ小さな整数値
		#
		if ( length( $2 ) <= $_DIGLEN ) {
			return __PACKAGE__->_new_small_integer( $2 ,  1 )	if ( ! defined $1 or $1 eq '' or $1 eq '+' ) ;
			return __PACKAGE__->_new_small_integer( $2 , -1 ) ;
		}
	}

	#
	# 指数部を持つ数値
	#
	if ( $n =~ /^(\d+\.{0,1}\d*)e([+-])(\d+)$/ ) {
		my( $i , $sgn , $d ) = ( $1 , $2 , $3 ) ;
		my $obj = __PACKAGE__->new( $i ) ;
		if ( $sgn eq '+' )	{ $obj *= __PACKAGE__->new( 10 )->power( $d ) ; }
		else			{ $obj *= __PACKAGE__->new( '0.1' )->power( $d ) ; }
		return $obj ;
	}

	#-------------------------------
	#
	# コンストラクション
	#
	#-------------------------------
	my( $class ) = ref( $self ) || $self ;

	my $conf = {
		'sgn'	=> 1 ,		# 符号 ( -1 or 1 )
		'val'	=> [] ,		# 数値配列 ( 添え字が基数に対する冪数となる。 )
		'dlen'	=> 0 ,		# 小数点以下の桁数 ( decimal part length )
		'dirty'	=> 0 ,		# ダーティフラグ ( 正規化を行うべきかどうかを示すフラグ )
	} ;

	$n =~ s/[\'\"_]//g ;

	if ( substr( $n , 0 , 1 ) eq '-' ) {
		$conf->{'sgn'} = -1 ;
		$n = substr( $n , 1 ) ;
	}

	if ( index( $n , '.' ) >= 0 ) {
		my( $intp , $decp ) = split( /\./ , $n , 2 ) ;
		return undef	if ( index( $decp , '.' ) >= 0 ) ;
		$conf->{'dlen'} = length( $decp ) ;
		$n = join( '' , $intp , $decp ) ;
	}
	return undef	unless ( $n =~ /^\d+$/ ) ;

	#
	# 数値文字列を右方向から予め定められた桁数で分割し、これを逆順に並べた配列を値として保持する。
	# 分割する桁数が 1 であれば、この配列は左から右に 10^n ( n = 0 -> ∞ ) 桁を表す数値配列 ( 10 進数 ; 基数 10 の整数 ) となる。
	# 同様に、桁数が 2 であれば、配列要素は順に 100^n ( n = 0 -> ∞ ) 桁を表す数値配列となり、 100 進数 ( 基数 100 の整数 ) を表すことになる。
	#
	my @v ;
	my $pos = $_DIGLEN * ( -1 ) ;
	while ( length( $n ) >= $_DIGLEN ) {
		my $lv = substr( $n , $pos ) ;
		push( @v , $lv ) ;
		$n = substr( $n , 0 , $pos ) ;
	}
	push( @v , $n )	if ( defined $n and length( $n ) > 0 ) ;
	
	$conf->{'val'} = [ @v ] ;

	my $obj = bless $conf , $class ;

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# クローニング ( コピーコンストラクター )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $p = {} ;
	while ( my( $k , $v ) = each %{ $self } ) {
		$p->{ $k } = $v ;
	}
	$p->{'val'} = [ @{ $p->{'val'} } ] ;

	my( $class ) = ref( $self ) || $self ;
	my $obj = bless $p , $class ;

	if ( $obj->{'dirty'} != 0 ) {
		$obj->_regulate() ;
	}
	
	return $obj ;
}

sub convert{
	#-----------------------------------------------------------------------
	#
	# 基数変換を伴うコンストラクション
	#
	#   任意の基数を使用した位取り記数法で表現された正の実数を受け取り、新規オブジェクトとして返す。
	#
	#   2 進数で表現された 1.1010 を 10 進数に変換する場合、
	#
	#     整数部
	#       
	#       0b1 == 1 * 2^0 == 1
	#
	#     小数部
	#       
	#       0b1010 / 2^4 == 10 / 16
	#                    == 5 / 8
	#                    == 0.625
	#
	#     -> 0b1.1010 == 1 + 0.625 == 1.625
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $radix , $n ) = @_ ;
	return undef	unless ( defined $n ) ;

	unless ( ref( $radix ) eq __PACKAGE__ ) {
		$radix = __PACKAGE__->new( $radix ) ;
	}
	return undef	unless ( defined $radix ) ;

	if ( ref( $n ) eq 'ARRAY' and @{ $n } == 1 ) {
		$n = $n->[0] ;
	}

	#
	# 引数が配列であれば整数値の各桁を要素として持つ数値配列とみなして変換
	#
	return __PACKAGE__->convert_integer( $radix , $n )	if ( ref( $n ) eq 'ARRAY' ) ;

	#
	# 文字列で表現された数値を整数部と小数部に分解
	#
	my( $intp , $decp ) = ( $n =~ /\./ )
		? split( /\./ , $n )
		: ( $n , undef )
	;

	#
	# 整数部を変換
	#
	my $r = __PACKAGE__->convert_integer( $radix , $intp ) ;

	#
	# 小数部を変換して加算
	#
	if ( defined $decp ) {
		my $f = fraction(
			__PACKAGE__->convert_integer( $radix , $decp )		,
			__PACKAGE__->new( $radix )->power( length( $decp ) )	,
		) ;
		$r += $f->decimal() ;
	}

	return $r ;
}

sub convert_integer {
	#-----------------------------------------------------------------------
	#
	# 基数変換を伴うコンストラクション
	#
	#   任意の基数を使用した位取り記数法で表現された正の整数を受け取り、新規オブジェクトとして返す。
	#
	#   第一引数として基数を、第二引数にその基数の下での正の整数を受け取る。
	#
	#   第二引数が配列参照で渡されている場合には、先頭が最上位桁となる数値配列として扱う。
	#   各桁がその基数における正しい値を示しているかどうかは検査されず、桁あふれとして処理される。
	#
	#   例 )
	#     2 進数 [ 1 , 0 , 0 , 0 ] は  0b1000 ( 10 進数  8 ) となる。 ( 2^3 )
	#     2 進数 [ 1 , 0 , 0 , 4 ] は  0b1100 ( 10 進数 12 ) となる。 ( 2^3 +  4 * 2^0 )
	#     2 進数 [ 1 , 10 ]        は  0b1100 ( 10 進数 12 ) となる。 ( 2^1 + 10 * 2^0 )
	#     2 進数 [ 1 , 0 , 4 , 0 ] は 0b10000 ( 10 進数 16 ) となる。 ( 2^3 +  4 * 2^1 )
	#
	#   第二引数で与えられる数値には 'A' .. 'Z' , 'a' .. 'z' , '+' , '/' の計 54 種類の文字を一桁を表す数値として使用することができる。
	#   この場合、 'A' == 10 , 'a' == 36 , '+' == 62 , '/' == 63 と解釈される。
	#   これに 0 .. 9 の 10 種類を加えた 64 種類を一桁を表す数値として使用することができる。
	#   配列参照で値を表現する場合、0 .. 9 を除く文字は単一の文字として使用する必要がある。
	#   数値のみの表現であれば 10 以上の任意の数値を使用することができる。
	#
	#   例 )
	#     2 進数 [  '/' ]     は  0b111111 ( 10 進数 63 ) となる。 ( 63 * 2^0 )
	#     2 進数 [ '1 , '/' ] は 0b1000001 ( 10 進数 65 ) となる。 ( 2^1 + 63 * 2^0 )
	#     2 進数 '1/'         は 0b1000001 ( 10 進数 65 ) となる。 ( 2^1 + 63 * 2^0 )
	#     2 進数 '15'         は     0b111 ( 10 進数  7 ) となる。 ( 2^1 +  5 * 2^0 )
	#     2 進数 [ '15' ]     は    0b1111 ( 10 進数 15 ) となる。 ( 15 * 2^0 )
	#     2 進数 [ '1/' ]     は エラー。
	#
	#-----------------------------------------------------------------------
	my( $self , $radix , $n ) = @_ ;
	return undef	unless ( defined $n ) ;

	unless ( ref( $radix ) eq __PACKAGE__ ) {
		$radix = __PACKAGE__->new( $radix ) ;
	}
	return undef	unless ( defined $radix ) ;

	#
	# 与えられた数値を桁ごとに分解し、配列に格納する。
	# 桁の並び順は逆順に並べ替える。
	#
	my @v = ( ref( $n ) eq 'ARRAY' )
		? reverse( @{ $n } )
		: reverse( split( '' , $n ) )
	;

	#
	# Base64 の変換ルールを参考に 0 .. 9 以外の文字を 10 以上の数値にマップする。
	# Base64 では 0 .. 9 が 52 .. 61 にマップされるが、ここでは 0 .. 9 はそのままとし、
	# 'A' .. 'Z' を 10 .. 35 , 'a' .. 'z' を 36 .. 61 に、 '+' を 62 , '/' を 63 にマップする。
	#
	# my $base64_chars = join( '' , 'A' .. 'Z' , 'a' .. 'z' ,   0 .. 9   , '+' , '/' ) ;
	#
	my $chars = join( '' ,  0 .. 9 , 'A' .. 'Z' , 'a' .. 'z' , '+' , '/' ) ;
	foreach ( @v ) {
		#
		# 1 文字以上の数値はそのまま採用する。
		# それ以外の 2 文字以上の文字は拒否。
		#
		next	if ( /^\d+$/ ) ;
		if ( length( $_ ) != 1 ) {
			croak( "Failed to map \"$_\" to numeric value.\n" ) ;
		}

		$_ = uc( $_ )	if ( $radix == 16 ) ;

		#
		# 数値以外の文字を 1 対 1 で数値に変換。
		#
		$_ = index( $chars , $_ ) ;
		if ( $_ < 0 ) {
			croak( "Failed to map \"$_\" to numeric value.\n" ) ; 
		}
	}

	#
	# $v[0] でオブジェクトを初期化し、指定された基数を元にして乗算と冪乗算を繰り返す。
	# 求める値はその総和となる。
	#
	# 加算処理の回数が多いと繰上げや繰り下げによる演算コストが嵩むため、
	# ペース配分を行いながら遅延実行するように調整してある。
	#
	my $obj = __PACKAGE__->new( $v[0] ) ;
	return undef	unless ( defined $obj ) ;

	my @values = () ;
	foreach ( my $i = 1 ; $i < @v ; $i++ ) {
		if ( $v[ $i ] != 0 ) {
			push( @values , ( $v[ $i ] * ( $radix ** $i ) ) ) ;
		}
		if ( @values >= 20 ) {
			$obj = $obj->add( [ splice( @values , 0 ) ] ) ;
		}
	}
	if ( @values ) {
		$obj = $obj->add( [ @values ] ) ;
	}

	return $obj ;
}

=head2 decimal

This function will create new 'Decimal' object from some strings or numeric values that can be regarded as numerical value, as possible.

If it failed, return "undef".

  print decimal( 10 ) ;                    # 10
  print decimal( '1e+3' ) ;                # 1000
  print decimal( '1e-3' ) ;                # 0.001
  print decimal( '1_000' ) ;               # 1000

=cut

sub decimal { return __PACKAGE__->new( @_ ) ; }

=head2 bin2dec , oct2dec , hex2dec

These fucntions will create 'Decimal' object from binary, octal, or hexadecimal string.

  print bin2dec( '11111' ) ;               # 15
  print bin2dec( '1' x 16 ) ;              # 65535
  print oct2dec( '77' ) ;                  # 63
  print hex2dec( 'FF' ) ;                  # 255

=cut

sub bin2dec { return __PACKAGE__->convert(  2 , [ @_ ] ) ; }
sub oct2dec { return __PACKAGE__->convert(  8 , [ @_ ] ) ; }
sub hex2dec { return __PACKAGE__->convert( 16 , [ @_ ] ) ; }

=head2 fraction( numerator , denominator )

This fucntion will create new 'Fraction' object.

  print fraction( 1 , 2 ) ;                # 1/2
  print fraction( 4 , 6 ) ;                # 2/3

=cut

sub fraction {
	#-----------------------------------------------------------------------
	#
	# 小数 -> 分数への変換
	#
	#   Fraction オブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Fraction->new( @_ ) ;
}

=head2 complex( [ real , imag ] )

This fucntion will create new 'Complex' object.

  print complex( [ 1 , 1 ] ) ;                              # 1 + i
  print complex( { arg => radian(45) } )                    # 0.707106781186548 + 0.707106781186548 i
  print complex( { radius => 2 , arg => radian(90) } ) ;    # 0 + 2 i

=cut

sub complex {
	#-----------------------------------------------------------------------
	#
	# 複素数オブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Complex->new( @_ ) ;
}

=head2 imag

Return 'Complex' object, which means 'imaginary unit'.

  print imag() ;        # 0 + i

=cut

sub imag {
	#-----------------------------------------------------------------------
	#
	# 虚数単位 ( imaginary unit )
	#
	#   Complex オブジェクトで返す。
	#
	#-----------------------------------------------------------------------
	return Complex->new( [ 0 , 1 ] ) ;
}

=head2 vector( @num )

This function will create 'Vector' object.

  print vector( 1 , 2 , 3 ) ;

  -> [              1.00000 ]
     [              2.00000 ]
     [              3.00000 ]

=cut

sub vector {
	#-----------------------------------------------------------------------
	#
	# ベクトルオブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Vector->new( @_ ) ;
}

=head2 complex_vector

This function will create 'Complex Vector' object.

  print complex_vector( [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ) ;

  -> [        1.00 + 1.00 i ]
     [        2.00 + 2.00 i ]
     [        3.00 + 3.00 i ]

=cut

sub complex_vector {
	#-----------------------------------------------------------------------
	#
	# 複素ベクトルオブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Vector->complex_vector( @_ ) ;
}

=head2 matrix

This function will create 'Matrix' object.

  print matrix( [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ) ;

  -> [              1.00000 ,              1.00000 ]
     [              2.00000 ,              2.00000 ]
     [              3.00000 ,              3.00000 ]

=cut

sub matrix {
	#-----------------------------------------------------------------------
	#
	# 行列オブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Vector->matrix( @_ ) ;
}

=head2 complex_matrix

This function will create 'Complex Matrix' object.

  print complex_matrix( [ [ 1 , 1 ]  , [ 2 , 2 ] ] , [ [ 3 , 3 ] , [ 4 , 4 ] ] ) ;

  -> [        1.00 + 1.00 i ,        2.00 + 2.00 i ]
     [        3.00 + 3.00 i ,        4.00 + 4.00 i ]

=cut

sub complex_matrix {
	#-----------------------------------------------------------------------
	#
	# 複素行列オブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Vector->complex_matrix( @_ ) ;
}

=head2 complex_matrix

Return 'imaginary unit' as 'Matrix' object.

  print imag_matrix() ;

  -> [              0.00000 ,             -1.00000 ]
     [              1.00000 ,              0.00000 ]

=cut

sub imag_matrix {
	#-----------------------------------------------------------------------
	#
	# 虚数単位 ( imaginary unit )
	#
	#   Vector オブジェクトで返す。
	#
	#-----------------------------------------------------------------------
	return Vector->imag_unit() ;
}

=head2 polynomial( @coef )

This function will create 'Polynomial' object. ( One variable polynomial object )

  print polynomial( 1 .. 3 ) ;

  ->  2 : 1                                            # == x^2 + 2 * x + 3
      1 : 2
      0 : 3

  print polynomial( 1 .. 3 )->substitute( 5 ) ;        # 38 == 1 x 5^2 + 2 x 5^1 + 3 x 5^0 


  my $c = [ 1 , 2 , 3 ] ;

  print polynomial( $c ) ;

  -> 2 : 3                                             # $c->[2] == 3
     1 : 2                                             # $c->[1] == 2
     0 : 1                                             # $c->[0] == 1
                                                       #
						       # -> sum( $c->[ $k ] * x^( $k ) )         ( k == 0 , 1 , 2 )
                                                       # == 3 * x^2 + 2 * x + 1
						       #

  print polynomial( $c )->substitute( 5 ) ;            # 86 == 3 * 5^2 + 2 * 5^1 + 1 * 5^0

=cut

sub polynomial {
	#-----------------------------------------------------------------------
	#
	# 一変数多項式オブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	return Polynomial->new( @_ ) ;
}

=head1 'Decimal' object - the properties and translations

=cut

#-------------------------------------------------------------------------------
#
# 属性 / 変換
#
#-------------------------------------------------------------------------------

sub value {
	#-----------------------------------------------------------------------
	#
	# オブジェクトが示している値を 10 進数文字列で返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$self->_regulate() ;

	#
	# 値が明らかに 0 であれば小数点の位置をリセットする。
	#
	#   これは本来 _regulate で行うべき処置ではあるが、 _regulate 内で行うと
	#   著しく処理速度が落ちるため、ここで実装している。
	#
	if ( @{ $self->{'val'} } == 1 and $self->{'val'}->[0] == 0 ) {
		$self->{'dlen'} = 0 ;
	}

	#
	# 値はあらかじめ定められた桁数で分割され、逆順に並んでいる。
	# これを反転させながら適切な桁数で 0 埋め込みを施し、文字列として連結していく。
	#
	# 各桁において埋め込まれる 0 の数は基数の桁数を超える事はない。
	# このため、繰り返し演算子や sprintf を用いることができる。
	#
	my $fmt = '%0' . $_DIGLEN . 'd' ;
	my $r = undef ;
	foreach my $v ( reverse( @{ $self->{'val'} } ) ) {
		$r .= sprintf( "$fmt" , $v ) ;
	}

	#
	# 小数点を挿入
	#
	if ( $self->{'dlen'} > 0 ) {

		my $len = $self->{'dlen'} ;

		if ( length( $r ) <= $len ) {
			#
			# 復元された数値の桁数が小数点以下の桁数よりも小さい場合には 0 埋め込みを行う必要がある。
			# この時の桁合わせでは埋め込むべき 0 の数が繰り返し演算子の許容範囲に納まる保証がない。
			#
			while ( length( $r ) <= $len ) { $r = '0000' . $r ; }
			$r = substr( $r , ( $len + 1 ) * ( -1 ) ) ;
		}

		#
		# 小数点を挿入し、小数部を調整。
		#
		# 正規表現の量指定子は 32766 を超える文字数に対応していない。
		# よって、 substr で小数点を挿入する。
		#
		$r = join( '.' ,
			substr( $r , 0 , $len * ( -1 ) ) ,
			substr( $r , $len * ( -1 ) ) ,
		) ;
		foreach ( $r ) {
			#s/^(\d*)(\d{$len})$/$1\.$2/ ;
			s/0+$// ;
			s/\.$// ;
		}
	}

	#
	# 先頭の不要な 0 を落とし、符号を反映して返す。
	#
	foreach ( $r ) {
		s/^0+// ;
		/^\.\d+$/	&& do { $_ = '0' . $_ ; } ;
	}
	$r = 0	if ( length( $r ) == 0 ) ;
	if ( $self->{'sgn'} < 0 ) {
		if ( $r == 0 )	{ $self->{'sgn'} *= ( -1 ) ; }
		else		{ $r = '-' . $r ; }
	}

	return $r ;
}

sub as_string { return $_[0]->value() ; }

=head2 abs

 print decimal( '-2' )->abs() ;                        # 2 ( Decimal object )

=cut 

sub abs {
	#-----------------------------------------------------------------------
	#
	# 絶対値 ( 符号をリセットするだけ )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy() ;
	$obj->{'sgn'} = 1 ;

	return $obj ;
}

sub digits {
	#-----------------------------------------------------------------------
	#
	# オブジェクトの基数に基づく桁数を返す。
	#
	# 桁数はオブジェクトが保持している配列のサイズ。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy()->_regulate() ;

	return scalar( @{ $obj->{'val'} } ) ;
}

=head2 integer_digits

Return a number of digits about integer part.

This method will return native numeric value. ( Not an object. )

  print decimal( 10.2 )->integer_digits() ;

  -> 2

=cut

sub integer_digits {
	#-----------------------------------------------------------------------
	#
	# 10 進数における整数部の桁数を返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy()->_regulate() ;

	my $digits = ( ( @{ $obj->{'val'} } - 1 ) * $_DIGLEN ) + length( $obj->{'val'}->[-1] + 0 ) ;
	$digits = ( $digits > $self->{'dlen'} )
		? $digits - $self->{'dlen'}
		: 1
	;

	return $digits ;
}

=head2 decimal_digits

Return a number of digits about decimal part.

This method will return native numeric value. ( Not an object. )

  print decimal( 10.2 )->decimal_digits() ;

  -> 1

=cut

sub decimal_digits {
	#-----------------------------------------------------------------------
	#
	# 10 進数における小数部の桁数を返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	if ( $self->{'dlen'} == 0 ) ;

	my $obj = $self->copy() ;

	my $fmt = '%0' . $_DIGLEN . 'd' ;
	my $v = sprintf( "$fmt" , $obj->{'val'}->[0] ) ;
	foreach my $i ( 1 .. $#{ $obj->{'val'} } ) {
		last	if ( length( $v ) >= $obj->{'dlen'} ) ;
		$v = sprintf( "$fmt" , $obj->{'val'}->[ $i ] ) . $v ;
	}

	while ( length( $v ) < $obj->{'dlen'} ) {
		$v = '0' x $_DIGLEN . $v ;
	}

	$v = substr( $v , $obj->{'dlen'} * ( -1 ) ) ;
	$v =~ s/0+$// ;

	return length( $v ) ;
}

=head2 bits

Return a length of bits about integer value.

The 'Decimal' object must be an integer value.

This method will return native numeric value or "undef". ( Not an object. )

  print decimal( 10 )->bits() ;

  -> 4    # 10 == b1010

=cut

sub bits {
	#-----------------------------------------------------------------------
	#
	# 自然数を受け取り、 2 進数表記の桁数を返す。
	#
	#   bits( x ) == roundup( ln( x ) / ln( 2 ) )
	#             == length( bin( x ) )
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return undef	unless ( $x->is_integer() ) ;
	return undef	unless ( $x >= 0 ) ;

	return length( $x->bin() ) ;
}

=head2 is_XXXX

  decimal( 10 )->is_zero() ;             # 0
  decimal( 10 )->is_even() ;             # 1
  decimal( 10 )->is_odd() ;              # 0

  decimal( 10 )->is_integer() ;          # 1
  decimal( 10 )->is_decmimal() ;         # 0

  decimal( 0.1 )->is_integer() ;         # 0
  decimal( 0.1 )->is_decmimal() ;        # 1

  decimal( 10 )->is_scalar() ;           # 1
  decimal( 10 )->is_fraction() ;         # 0
  decimal( 10 )->is_vector() ;           # 0
  decimal( 10 )->is_matrix() ;           # 0
  decimal( 10 )->is_polynomial() ;       # 0

=cut

sub is_zero {
	#-----------------------------------------------------------------------
	#
	# オブジェクトが 0 かどうかを返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = ( $self->{'dirty'} )
		? $self->copy()->_regulate()
		: $self
	;

	my $is_zero = 1 ;
	my $v = 0 ;
	#foreach ( @{ $obj->{'val'} } ) {
	foreach ( reverse( @{ $obj->{'val'} } ) ) {
		$v += $_ ;
		if ( $v > 0 ) { $is_zero = 0 ; last ; }
	}
	return $is_zero ;
}

sub is_even {
	#-----------------------------------------------------------------------
	#
	# オブジェクトが偶数かどうかを返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	if ( $self->decimal_digits() > 0 ) ;	# 小数は false とする。 ( Math::BigFloat に倣う。 )
	return 1	if ( ( $self->{'val'}->[0] & 1 ) == 0 ) ;
	return 0 ;
}

sub is_odd {
	#-----------------------------------------------------------------------
	#
	# オブジェクトが奇数かどうかを返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	if ( $self->decimal_digits() > 0 ) ;	# 小数は false とする。 ( Math::BigFloat に倣う。 )
	return 0	if ( $self->is_even() ) ;
	return 1 ;
}

sub is_integer {
	#-----------------------------------------------------------------------
	#
	# オブジェクトが整数かどうかを返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	if ( $self->decimal_digits() > 0 ) ;
	return 1 ;
}

sub is_scalar		{ return 1 ; }
sub is_decimal		{ return 1 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 0 ; }
sub is_vector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 0 ; }

sub is_multiple {
	#-----------------------------------------------------------------------
	#
	# 二つの整数を採り、一方がもう一方の倍数かどうかを返す。
	#
	#   正の整数 x が 2 の倍数であることと bin( x ) の末尾 1 桁が 0 であることは同義。
	#   同様に、 x が 2^p の倍数である時、 bin( x ) の末尾 p 桁が全て 0 となる。
	#
	#   倍数判定と基数変換の関係
	#
	#     正の整数 x が y の倍数であるということは、 x を y を基数とした値に変換した時にその末尾 1 桁が 0 であることと同義。
	#     基数変換そのものが繰り返し商と剰余を採る演算なので、この演算は実質的に剰余を判定していることと同義。
	#
	#   合同算術による倍数判定
	#
	#     x の基数を B とした時、
	#
	#       x == Σ( a[k] * B^k )              ( k == 0 -> n )
	#
	#       -> x % y == Σ( a[k] * B^k ) % y
	#                == Σ( ( ( a[k] % y ) * ( B^k % y ) ) % y ) % y
	#                == Σ( ( ( a[k] % y ) * ( B % y )^k ) ) % y ) % y
	#                == Σ( ( ( a[k] % y ) * modexp( B , k , y ) ) % y ) % y
	#                == 0
	#     で真となる。
	#
	#   以下は、算数的なお遊びかな．．．．。
	#
	#     y ==  2 の時、    10 ==  2 *   5 -> 10 進数末尾 1 桁が  2 の倍数であれば真。
	#     y ==  4 の時、   100 ==  4 *  25 -> 10 進数末尾 2 桁が  4 の倍数であれば真。
	#     y ==  8 の時、  1000 ==  8 * 125 -> 10 進数末尾 3 桁が  8 の倍数であれば真。
	#     y == 16 の時、 10000 == 16 * 625 -> 10 進数末尾 4 桁が 16 の倍数であれば真。
	#
	#     y ==  3 の時、 10 進数の各桁の総和が 3 の倍数であれば真。
	#     y ==  9 の時、 10 進数の各桁の総和が 9 の倍数であれば真。
	#
	#     y ==  5 の時、 10 進数末尾 1 桁が 0 又は 5 であれば真。
	#     y == 10 の時、 10 進数末尾 1 桁が 0 であれば真。
	#
	#     y ==  6 の時、 x が 2 の倍数且つ 3 の倍数であれば真。
	#     y == 12 の時、 x が 3 の倍数且つ 4 の倍数であれば真。
	#     y == 15 の時、 x が 3 の倍数且つ 5 の倍数であれば真。
	#     y == 18 の時、 x が 2 の倍数且つ 9 の倍数であれば真。
	#
	#     y ==  7 又は 13 の時、
	#
	#                   1 == 10^0 ≡  1 ( mod y )
	#               1,000 == 10^3 ≡ -1 ( mod y )
	#           1,000,000 == 10^6 ≡  1 ( mod y )
	#       1,000,000,000 == 10^9 ≡ -1 ( mod y )
	#
	#       x == Σ( a[k] * B^k )        ( k == 0 -> n )
	#
	#       -> ( a[k] * B^k ) % y == ( a[k] % y ) * (-1)       if ( k == 3j )
	#          ( a[k] * B^k ) % y == ( a[k] % y )              if ( k == 6j )
	#
	#       よって、 x == Σ( b[k] * 10^3k )  に変換すると、
	#
	#         x % y == Σ( b[2k] - b[2k+1] ) ) % y               ( k == 0 -> int( n/3 ) )
	#               == 0
	#
	#       で真となる。
	#
	#     y == 11 の時、
	#
	#       10^(2k)   ≡  1 ( mod 11 )
	#       10^(2k+1) ≡ -1 ( mod 11 )
	#
	#       であり、 x == Σ( b[k] * 10^2k ) に変換することで
	#
	#         x % y == Σ( b[2k] - b[2k+1] ) ) % y               ( k == 0 -> int( n/2 ) )
	#               == 0
	#
	#       で真となる。
	#
	#       また、
	#
	#         while ( x >= 11 ) {
	#           l = x % 10              # 10 進数末尾 1 桁                         ( == a[0] * 10^0 )
	#           u = int( x / 10 )       # 10 進数末尾 1 桁を引いて桁下げしたもの。 ( Σ( a[k] * 10^k ) / 10  ( k == 1 -> n ) )
	#           x = u - l
	#         }
	#         return 1 if ( x == 0 )
	#         return 0
	#
	#       としても同じ結果を得る。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $_ ) ;
		return undef			unless ( $_->is_integer() ) ;
		$_ = $_->abs() ;
	}

	return 0	if ( $x < $y ) ;

	#
	# 最下位 1 桁で判定できるもの。
	#
	return 1	if ( $y ==  2 and ( $x->{'val'}->[0] & 1 ) == 0 ) ;
	return 1	if ( $y ==  5 and $x->{'val'}->[0] =~ /[05]$/ ) ;
	return 1	if ( $y == 10 and $x->{'val'}->[0] =~ /0$/ ) ;

	return 0	if ( $y->{'val'}->[0] =~ /[05]$/ and $x->{'val'}->[0] !~ /[05]$/ ) ;	# y が 5 の倍数であれば x も 5 の倍数でなければならない。
	return 0	if ( $y->{'val'}->[0] =~ /0$/ and $x->{'val'}->[0] !~ /0$/ ) ;		# y が 10 の倍数の場合も同じ。

	#
	# y が偶数であれば y == 2^p * d として 2^p の倍数且つ d の倍数であることを検査する。 ( d は奇数 )
	#
	if ( ( $y->{'val'}->[0] & 1 ) == 0 ) {
		my $p = $y->ntz() ;
		my $odd = $y >> $p ;
		if ( $p > 0 and $odd > 1 ) {
			return 0	unless ( $x->is_multiple( $odd ) ) ;
			return 0	unless ( $x->is_multiple( __PACKAGE__->new( 2 )->power( $p ) ) ) ;
			return 1 ;
		}
	}

	#
	# 主処理
	#
	my $r = 0 ;

	if ( $y->bitand( $y - 1 ) == 0 ) {
		#
		# y == 2^p の時、 bin( x ) の末尾の 0 の数が y のそれ以上であれば真。
		#
		#   y ==  2 == 2^1 の時、    10 ==  2 *   5 -> 10 進数下 1 桁が  2 の倍数である時に真。
		#   y ==  4 == 2^2 の時、   100 ==  4 *  25 -> 10 進数下 2 桁が  4 の倍数である時に真。
		#   y ==  8 == 2^3 の時、  1000 ==  8 * 125 -> 10 進数下 3 桁が  8 の倍数である時に真。
		#   y == 16 == 2^4 の時、 10000 == 16 * 625 -> 10 進数下 4 桁が 16 の倍数である時に真。
		#
		#   一般化すると、
		#
		#     y == 2^p
		#     x % ( 10^p ) ≡ 0 ( mod y )
		#
		#   であれば、真となる。
		#
		my $p = length( $y->bin() ) - 1 ;
		my $xu = $x->_decshiftdown( $p )->integer()->_decshiftup( $p ) ;
		my $xmod = $x - $xu ;			# == x % 10^p
		$r = 1	if ( ( $xmod % $y ) == 0 ) 
	}
	elsif ( $y == 3 or $y == 9 ) {
		#
		# 10^k ≡ 1 ( mod 3 )
		# 10^k ≡ 1 ( mod 9 )
		#
		# よって、基数が 10 の冪であれば各項の総和を採るだけで判定できる。
		#
		my $s = __PACKAGE__->new( 0 ) ;
		foreach my $c ( @{ $x->{'val'} } ) {
			$s = $s->modadd( $c , $y ) ;
		}
		$r = 1	if ( ( $s % $y ) == 0 ) ;
	}
	elsif ( $y == 7 or $y == 13 ) {
		#
		# ( 10^3 )^(2k)   ≡  1 ( mod 7 )
		# ( 10^3 )^(2k+1) ≡ -1 ( mod 7 )
		#
		# ( 10^3 )^(2k)   ≡  1 ( mod 13 )
		# ( 10^3 )^(2k+1) ≡ -1 ( mod 13 )
		#
		# x == Σ( a[k] * ( 10^3 )^k )              ( k == 0 -> n )
		# -> x % y == Σ( a[2k] - a[2k+1] ) % y     ( k == 0 -> int( n/3 ) )
		#
		# 基数を 10^3 に採り、偶数項の総和から奇数項の総和を引いた値が y の倍数であれば真となる。
		#
		my $s = __PACKAGE__->new( 0 ) ;
		my @xv = $x->radix_to( 1000 ) ;
		foreach my $k ( 0 .. $#xv ) {
			my $c = $xv[ $k ] % $y ;
			$c *= (-1)	if ( ( $k & 1 ) == 1 ) ;
			$s = $s->modadd( $c , $y ) ;
		}
		$r = 1	if ( ( $s % $y ) == 0 ) ;
	}
	elsif ( $y == 11 ) {
		#
		# 10^(2k)   ≡  1 ( mod 11 )
		# 10^(2k+1) ≡ -1 ( mod 11 )
		#
		# x == Σ( a[k] * ( 10^2 )^k )              ( k == 0 -> n )
		# -> x % y == Σ( a[2k] - a[2k+1] ) % y     ( k == 0 -> int( n/2 ) )
		#
		# 基数を 10 に採り、偶数項の総和から奇数項の総和を引いた値が y の倍数であれば真となる。
		#
		# y == 11 の時は、
		#
		#   11 * 1  ==  11 -> -1 + 1 == 0
		#   11 * 2  ==  22 -> -2 + 2 == 0
		#   .......
		#   11 * 9  ==  99 ->     -9 + 9 == 0
		#   11 * 10 == 110 ->  1 - 1 + 0 == 0
		#   11 * 11 == 121 ->  1 - 2 + 1 == 0
		#   11 * 12 == 132 ->  1 - 3 + 1 == 0
		#
		# であり、 10 進数下位 1 桁を分離しながら上位桁から引くことを繰り返しても同じ結果が得られる。
		#
		#   11 * 1  ==  11 ->                 1 - 1 == 0
		#   11 * 2  ==  22 ->                 2 - 2 == 0
		#   .......
		#   11 * 9  ==  99 ->                 9 - 9 == 0
		#   11 * 10 == 110 -> 11 - 0 == 11 -> 1 - 1 == 0
		#   11 * 11 == 121 -> 12 - 1 == 11 -> 1 - 1 == 0
		#   11 * 12 == 132 -> 13 - 2 == 11 -> 1 - 1 == 0
		#
		my $s = __PACKAGE__->new( 0 ) ;
		my @xv = $x->radix_to( 100 ) ;
		foreach my $k ( 0 .. $#xv ) {
			my $c = $xv[ $k ] % $y ;
			$c *= (-1)	if ( ( $k & 1 ) == 1 ) ;
			$s = $s->modadd( $c , $y ) ;
		}
		$r = 1	if ( ( $s % $y ) == 0 ) ;
	}
	elsif ( $y == 15 ) {
		#
		# 3 の倍数且つ 5 の倍数であれば真。
		#
		$r = 1	if ( $x->is_multiple( 3 ) and $x->is_multiple( 5 ) ) ;
	}
	elsif ( $y == 21 ) {
		#
		# 3 の倍数且つ 7 の倍数であれば真。
		#
		$r = 1	if ( $x->is_multiple( 3 ) and $x->is_multiple( 7 ) ) ;
	}
	else {
		#
		# 合同算術を用いる。
		#
		#   x == Σ( a[k] * B^k )              ( k == 0 -> n )
		#
		#   -> x % y == Σ( a[k] * B^k ) % y
		#            == Σ( ( ( a[k] % y ) * ( B^k % y ) ) % y ) % y
		#            == Σ( ( ( a[k] % y ) * ( B % y )^k ) ) % y ) % y
		#            == Σ( ( ( a[k] % y ) * modexp( B , k , y ) ) % y ) % y
		#
		my $bmy = __PACKAGE__->new( INT_BASE ) % $y ;
		my $s = __PACKAGE__->new( 0 ) ;
		foreach my $k ( 0 .. $#{ $x->{'val'} } ) {
			my $c = $x->{'val'}->[ $k ] ;
			$c = $bmy->modexp( $k , $y )->modmult( $c , $y ) ;	# c == ( ( B^k % y ) * ( a[k] % y ) ) % y
			$s = $s->modadd( $c , $y ) ;				# s == ( s + c ) % y
		}
		$r = 1	if ( ( $s % $y ) == 0 ) ;
	}

	return $r ;
}

sub is_power {
	#-----------------------------------------------------------------------
	#
	# 二つの正の整数を採り、一方がもう一方の冪乗数かどうかを返す。
	#
	#   基数変換を行えば結果は容易に判るが、冪乗数かどうかは
	#
	#     x == y^p
	#
	#   となるかどうかを検査することなので、 y の冪を採りながら比較するだけ。
	#   ( 基数変換は y^p を桁下げしながら繰り返し剰余値を採る処理。 )
	#
	#   自然対数を用いて、
	#
	#     x == y^p
	#     -> ln( x ) == ln( y^p )
	#                == p * ln( y )
	#     -> p == ln( x ) / ln( y )
	#
	#   とし、 p が自然数であれば真とすることもできる。
	#   ただし、演算誤差により p には小数値が返り易いので、
	#
	#     x == y^( int( p ) )
	#
	#   等として検算を行うべき。
	#
	#
	#   y == 2 の時、 x & ( x - 1 ) == 0 ならば真。
	#   y == 3 の時、 x の末尾 1 桁が 9 , 7 , 1 , 3 の何れでもなければ偽。
	#   y == 4 の時、 x の末尾 1 桁が 4 , 6 の何れでもなければ偽。
	#   y == 5 の時、 x の末尾 2 桁が 25 でなければ偽。
	#   y == 6 の時、 x の末尾 2 桁が 36 , 16 , 96 , 76 , 56 の何れでもなければ偽。
	#   y == 7 の時、 x の末尾 2 桁が 49 , 43 , 01 , 07 の何れでもなければ偽。
	#   y == 8 の時、 x の末尾 1 桁が 8 , 4 , 2 , 6 の何れでもなければ偽。
	#   y == 9 の時、 x の末尾 1 桁が 1 , 9 の何れでもなければ偽。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $_ ) ;
		return undef			unless ( $_->is_integer() ) ;
		return undef			if ( $_ < 0 ) ;
	}

	return 0	if ( $x == 0 ) ;
	return 0	if ( $y == 0 ) ;
	return 0	if ( $x < $y ) ;
	return 1	if ( $x == $y ) ;

	if ( $y == 2 ) {
		return 1	if ( $x->bitand( $x - 1 ) == 0 ) ;
		return 0 ;
	}

	if ( $y < 10 ) {
		return 0	if ( $y == 3 and $x->{'val'}->[0] !~ /[1379]$/ ) ;
		return 0	if ( $y == 4 and $x->{'val'}->[0] !~ /[46]$/ ) ;
		return 0	if ( $y == 5 and $x->{'val'}->[0] !~ /25$/ ) ;
		return 0	if ( $y == 6 and $x->{'val'}->[0] !~ /[13579]6$/ ) ;
		return 0	if ( $y == 7 and sprintf( "%02d" , $x->{'val'}->[0] ) !~ /(?:01|07|43|49)$/ ) ;
		return 0	if ( $y == 8 and $x->{'val'}->[0] !~ /[2468]$/ ) ;
		return 0	if ( $y == 9 and $x->{'val'}->[0] !~ /[19]$/ ) ;
	}

	my $ym = $y->copy() ;
	while ( $ym < $x ) {
		$ym *= $y ;
	}

	return 1	if ( $ym == $x ) ;
	return 0 ;
}

sub is_perfect_square_number {
	#-----------------------------------------------------------------------
	#
	# 完全平方数
	#
	#   完全平方数とは整数の平方数のこと。 ( 通常「平方数」と言う時には完全平方数を指すことが多い。 )
	#   完全平方数の判定には平方剰余の概念を利用する。
	#
	#   平方剰余は、任意の整数 x について
	#
	#     x^2 ≡ a ( mod n )
	#
	#   となる a のこと。
	#
	#   法 7 の世界 ( n == 7 ) では、全ての整数は 0 .. 6 の 7 種類の値に変換されるが、
	#   平方剰余 a は 0 , 1 , 2 , 4 の 4 種類しか存在せず、 0 を除く a は巡回群 ( 複素数における共役に酷似した数列 ) を形成する。
	#
	#     0^2 ≡ 0 ( mod 7 )
	#     1^2 ≡ 1 ( mod 7 )
	#     2^2 ≡ 4 ( mod 7 )
	#     3^2 ≡ 2 ( mod 7 )
	#     4^2 ≡ 2 ( mod 7 )
	#     5^2 ≡ 4 ( mod 7 )
	#     6^2 ≡ 1 ( mod 7 )
	#
	#   任意の整数 x は、法 n の下で、
	#
	#     x == ( a * n + b )
	#     -> x ≡ b ( mod n )
	#
	#   と表現できることから、
	#
	#     y == x^2 == ( a * n + b )^2
	#              ≡ ( ( ( a * n ) % n ) + ( b % n ) )^2 % n  ( mod n )
	#              ≡ b^2 % n  ( mod n )
	#
	#   となる。
	#
	#   平方剰余の演算で知ることができるのは b^2 % n の値であり b でも b^2 でもないが、明らかに平方数でないものを排除することはできる。
	#   つまり、法 7 の世界であれば、 0 , 1 , 2 , 4 の何れの値にもならないもの ( 平方非剰余 ) は平方数ではないと判断することができる。
	#
	#   これは任意の n > 1 についても成立する。
	#
	#   y が真に平方数であれば、どのような n においても y % n は、法 n における平方剰余の何れかと合致することになる。
	#   逆に言えば、何れかの法 n の下で平方剰余を採ることができなければ y は平方数ではないということになる。
	#
	#   n == 2^8 == 256 とした時の平方剰余を昇順に並べると、
	#
	#       0 ,   1 ,   4 ,   9 ,  16 ,  17 ,  25 ,  33 ,  36 ,  41 ,
	#      49 ,  57 ,  64 ,  65 ,  68 ,  73 ,  81 ,  89 ,  97 , 100 ,
	#     105 , 113 , 121 , 129 , 132 , 137 , 144 , 145 , 153 , 161 ,
	#     164 , 169 , 177 , 185 , 193 , 196 , 201 , 209 , 217 , 225 ,
	#     228 , 233 , 241 , 249
	#
	#   となり、計 44 種類が存在する。
	#   これを利用して y を篩にかけると、 1 - ( 44 / 256 ) == 82.8% の非平方数を検出できることになる。
	#
	#   これに加えて、 9 , 5 , 7 , 13 , 17 , 97 を法とする平方剰余を併用することで、 99.62% の非平方数を予め篩い落とすことができるとのこと。
	#   ( この 6 種類の法での篩は、 2^24 程度の値を法とする篩に等しい。 )
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			if ( $x < 0 ) ;

	#
	# 2^8 == 256 を法とする平方剰余 ( Quadratic residue ) で篩い落とす。
	#
	#   256 を法とする平方剰余は n == 0 -> 7 として、
	#
	#      1 + 32n == 1^2 + 32n
	#      4 + 32n == 2^2 + 32n
	#      9 + 32n == 3^2 + 32n
	#     17 + 32n
	#     25 + 32n == 5^2 + 32n
	#
	#   の箇所に集中して現れる。 ( 計 44 個の内の 40 個がここに集中している。 )
	#
	#   例外は
	#
	#       0                == 4^2 * 0^2
	#      16 == 16 + 32 * 0 == 4^2 * 1^2
	#      64 ==  0 + 32 * 2 == 4^2 * 2^2
	#     144 == 16 + 32 * 4 == 4^2 * 3^2
	#
	#   の 4 つのみ。
	#
	#   また、
	#
	#      0             == 16 * 0 == 4^2 * 0^2
	#     16 == 16 +   0 == 16 * 1 == 4^2 * 1^2
	#     64 == 16 +  48 == 16 * 4 == 4^2 * 2^2
	#    144 == 16 + 128 == 16 * 9 == 4^2 * 3^2
	#
	#    n == 0 -> 15 として、
	#
	#      1 + 16n == 1 , 17 , 33 ,  49 ,  65 ,  81 ,  97 , 113 , 129 , 145 , 161 , 177 , 193 , 209 , 225 , 241
	#      9 + 16n == 9 , 25 , 41 ,  57 ,  73 ,  89 , 105 , 121 , 137 , 153 , 169 , 185 , 201 , 217 , 233 , 249
	#
	#    n == 0 -> 7 として、
	#
	#      4 + 32n == 4 , 36 , 68 , 100 , 132 , 164 , 196 , 228
	#
	#   と言った規則性らしきものも観察することができる。
	#
	my $is_qr256 = [
		#   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
		    1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		#  32  33          36                  41                              49                              57                      63
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		#  64  65          68                  73                              81                              89                      95
		    1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		#  96  97         100                 105                             113                             121                     127
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		# 128 129         132                 137                         144 145                             153                     159
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		# 160 161         164                 169                             177                             185                     191
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		# 192 193         196                 201                             209                             217                     223
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
		# 224 225         228                 233                             241                             249                     255
		    0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ,
	] ;

	return 0	unless ( $is_qr256->[ $x % 256 ] ) ;

	#
	# 9 , 5 , 7 , 13 , 17 , 97 での平方剰余で篩い落とす。
	# ( 97 の平方剰余は 49 個存在する。 )
	#
	# 結果的に 2^24 に近い値を法とする平方非剰余を篩い落とすことになる。
	#
	return 0	unless ( ( $x % 9 ) =~ /^[0147]$/ ) ;
	return 0	unless ( ( $x % 5 ) =~ /^[014]$/ ) ;
	return 0	unless ( ( $x % 13 ) =~ /^(?:0|1|3|4|9|10|12)$/ ) ;
	return 0	unless ( ( $x % 17 ) =~ /^(?:0|1|2|4|8|9|13|15|16)$/ ) ;

	my $is_qr97 = [
		#   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
		    1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 ,
		#  32  33      35  36                          43  44          47  48  49  50          53  54                          61  62  63
		    1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 ,
		#  64  65  66      68      70      72  73      75              79      81              85  86      88  89      91      93  94  95
		    1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 ,
		#  96
		    1 ,
	] ;

	return 0	unless ( $is_qr97->[ $x % 97 ] ) ;

	#
	# 試し割り
	#
	return 1	if ( $x == $x->sqrt( 0 )->power( 2 ) ) ;
	return 0 ;
}

sub quadratic_residue {
	#-----------------------------------------------------------------------
	#
	# 法 x における平方剰余 ( Quadratic residue ) のリストを返す。
	#
	#   x == 7 の場合、法 7 における剰余値 r は、 r == 0 -> 6 の 7 種類の値を採る。
	#   平方剰余は、この r の 2 乗を法 x で評価した値となる。
	#
	#   法 7 での剰余値 r は、
	#
	#     r == 0 ≡  0 ( mod 7 )
	#     r == 1 ≡ -6 ( mod 7 )
	#     r == 2 ≡ -5 ( mod 7 )
	#     r == 3 ≡ -4 ( mod 7 )
	#     r == 4 ≡ -3 ( mod 7 )
	#     r == 5 ≡ -2 ( mod 7 )
	#     r == 6 ≡ -1 ( mod 7 )
	#
	#   であり、任意の法 x についても同様。
	#   よって、平方剰余は r == 0 -> int( x/2 ) の範囲を求めればよい。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			if ( $x < 0 ) ;

	my $mid = $x->divide( 2 )->integer() ;
	my $r = {} ;
	foreach ( my $i = __PACKAGE__->new( 0 ) ; $i <= $mid ; $i++ ) {
		$r->{ ( $i * $i ) % $x } = 1 ;
	}

	return sort { $a <=> $b } keys %{ $r } ;
}

sub qr { return quadratic_residue( @_ ) ; }

sub non_quadratic_residue {
	#-----------------------------------------------------------------------
	#
	# 法 x における平方非剰余 ( Non-quadratic residue ) のリストを返す。 
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			if ( $x < 0 ) ;

	my $mid = $x->divide( 2 )->integer() ;
	my $r = {} ;
	my $qr = {} ;
	foreach ( my $i = __PACKAGE__->new( 1 ) ; $i < $x ; $i++ ) {
		$r->{ $i } = 1 ;
		if ( $i <= $mid ) {
			$qr->{ ( $i * $i ) % $x } = 1 ;
		}
	}
	foreach my $k ( keys %{ $qr } ) {
		delete $r->{ $k } ;
	}

	return sort { $a <=> $b } keys %{ $r } ;
}

sub nqr { return non_quadratic_residue( @_ ) ; }

=head2 can_XXXX

  decimal( 10 )->can_scalar() ;          # 1

  decimal( 10 )->can_integer() ;         # 1
  decimal( 0.1 )->can_integer() ;        # 0

  decimal( 10 )->can_fraction() ;        # 1
  decimal( 10 )->can_complex() ;         # 1

=cut

sub can_scalar		{ return 1 ; }
sub can_integer		{ return ( $_[0]->is_integer() ) ? 1 : 0 ; }
sub can_decimal		{ return 1 ; }
sub can_fraction	{ return 1 ; }
sub can_complex		{ return 1 ; }

=head2 integer

Return 'Decimal' object contains integer value. ( RZ ; rounding towards zero )

  decimal( 10.5 )->integer() ;            # 10 ( 'Decimal' object )
  decimal( -10.5 )->integer() ;           # -10 ( 'Decimal' object )

=cut

sub integer {
	#-----------------------------------------------------------------------
	#
	# 小数部を切り捨てたオブジェクトを返す。
	#
	# 0 への丸め ( rounding toward zero ; RZ ) 
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $dlen = $self->{'dlen'} ;
	my @val = @{ $self->{'val'} } ;

	#
	# $val[0] が整数部と小数部の境界となるように配列要素を切り落とす。
	#
	if ( $dlen >= $_DIGLEN ) {
		my $pos = CORE::int( $dlen / $_DIGLEN ) ;
		if ( $pos < @val ) {
			@val = @val[ $pos .. $#val ] ;
			$dlen %= $_DIGLEN ;
		}
		else {
			@val = ( 0 ) ;
			$dlen = 0 ;
		}
	}

	#
	# 下位桁から上位桁に向かって 10 進数での桁下げを行う。
	#
	if ( $dlen > 0 ) {
		my $fmt = '%0' . $_DIGLEN . 'd' ;
		my $pos = $dlen * (-1) ;
		foreach my $i ( 0 .. $#val ) {
			#
			# 0 パディングして桁合わせを行った後、上位桁と下位桁に分離。
			#
			my $v = sprintf( "$fmt" , $val[ $i ] ) ;
			my( $upper , $lower ) = (
				substr( $v , 0 , $pos ) ,
				substr( $v , $pos )	,
			) ;

			#
			# 上位桁を現在の要素として格納し直し、下位桁をひとつ前の要素に文字列連結する。
			#
			if ( $i > 0 ) {
				@val[ $i - 1 , $i ] = ( $lower . $val[ $i - 1 ] , $upper ) ;
			}
			else {
				$val[ $i ] = $upper ;
			}
		}
	}

	while ( @val > 1 and $val[-1] == 0 ) {
		pop( @val ) ;
	}

	#
	# 新規オブジェクトとして返す。
	#
	my $r = __PACKAGE__->new( 0 ) ;
	$r->{'val'} = [ @val ] ;
	$r->{'sgn'} = $self->{'sgn'} ;

	return $r ;
}

sub interger_00 {
	#-----------------------------------------------------------------------
	#
	# 小数部を切り捨てたオブジェクトを返す。
	#
	# 0 への丸め ( rounding toward zero ; RZ ) 
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy() ;

	return $obj	if ( $obj->{'dlen'} == 0 ) ;

	#
	# 値を 10 進数文字列に復元し、小数点以下の桁を切り落とす。
	#
	my $r = '' ;
	foreach my $v ( @{ $obj->{'val'} } ) {
		$r = '0' x ( $_DIGLEN - length( $v ) ) . $v . $r ;
	}

	if ( length( $r ) <= $obj->{'dlen'} ) {
		$r = 0 ;
	}
	else {
		$r = substr( $r , 0 , ( length( $r ) - $obj->{'dlen'} ) ) ;
	}

	$r = __PACKAGE__->new( $r ) ;
	$r->{'sgn'} = $obj->{'sgn'} ;

	return $r ;
}

=head2 floor

Return 'Decimal' object contains integer value. ( RM ; rounding towards minus infinity )

  decimal( 10.5 )->floor() ;             # 10 ( 'Decimal' object )
  decimal( -10.5 )->floor() ;            # -11 ( 'Decimal' object )

=cut

sub floor {
	#-----------------------------------------------------------------------
	#
	# 床関数
	#
	# 数値的に小さい整数値への切捨て。
	#
	# -∞ への丸め ( rounding toward minus inifinity ; RM ) 
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self	if ( $self->{'dlen'} == 0 ) ;

	my $i = $self->integer() ;
	if ( $i < 0 ) {
		if ( $self->subtract( $i ) < 0 ) {
			$i-- ;
		}
	}

	return $i ;
}

=head2 ceil

Return 'Decimal' object contains integer value. ( RP ; rounding towards plus infinity )

  decimal( 10.5 )->ceil() ;              # 11 ( 'Decimal' object )
  decimal( -10.5 )->ceil() ;             # -10 ( 'Decimal' object )

=cut

sub ceil {
	#-----------------------------------------------------------------------
	#
	# 天井関数
	#
	# 数値的に大きい整数値への切り上げ。
	#
	# +∞ への丸め ( rounding toward plus inifinity ; RP ) 
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self	if ( $self->{'dlen'} == 0 ) ;

	my $obj = ( $self->decimal_part() > 0 )
		? $self->floor()->add( 1 )
		: $self->floor()
	;

	return $obj ;
}

=head2 integer_part

Same to 'floor'.

  print decimal( 3.33 )->integer_part() ;          #  3 (  3.33 ==  3 + 0.33 )
  print decimal( -3.33 )->integer_part() ;         # -4 ( -3.33 == -4 + 0.67 )

=cut

sub integer_part {
	#-----------------------------------------------------------------------
	#
	# 床関数と同じ。
	#
	# 整数部は床関数の結果であり、正の実数と負の実数では整数部の絶対値が異なる。
	#
	#   3.33 ==  3 + 0.33
	#  -3.33 == -4 + 0.67 
	#
	#-----------------------------------------------------------------------
	return $_[0]->floor() ;
}

=head2 decimal_part

Return 'Decimal' object, which is subtracted 'integer_part'.

  print decimal( 3.33 )->decimal_part() ;          # 0.33 (  3.33 ==  3 + 0.33 )
  print decimal( -3.33 )->decimal_part() ;         # 0.67 ( -3.33 == -4 + 0.67 )

=cut

sub decimal_part {
	#-----------------------------------------------------------------------
	#
	# 小数部を返す。
	#
	# 整数部は床関数の結果となる。 ( 正の実数と負の実数では整数部の絶対値が異なる。 )
	# 小数部は元の値からこれを引いたもの。
	#
	#   3.33 ==  3 + 0.33
	#  -3.33 == -4 + 0.67 
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self->subtract( $self->floor() ) ;
}

=head2 round

  print decimal( 10.55 )->round() ;           # 11

  print decimal( 10.55 )->round( 1 ) ;        # 10.6
  print decimal( 10.54 )->round( 1 ) ;        # 10.5

  print decimal( -10.55 )->round() ;          # -11
  print decimal( -10.55 )->round( 1 ) ;       # -10.5
  print decimal( -10.54 )->round( 1 ) ;       # -10.5

=cut

sub round {
	#-----------------------------------------------------------------------
	#
	# 四捨五入
	#
	# 正の値に関しては JIS X 8401 「規則 B 」と同じ結果となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $digit ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$digit = 0	unless ( defined $digit ) ;
	croak( "invalid argument.\n" )	unless ( $digit =~ /^-{0,1}\d+$/ ) ;

	#
	# 四捨五入する基準位置まで桁上げして小数部を落とし、結果に 5 を加える。
	#
	#   11.16 -> 1116 + 5 == 1121
	#
	my $obj = $self->multiply( _pow10( $digit + 1 ) )->floor()->add( 5 ) ;

	#
	# 10 進数で一桁切り下げた後、小数部を落とし、更に元の桁まで桁下げする。
	#
	#   1121 -> 112.1 -> 112 -> 11.2
	#
	my $dp = __PACKAGE__->new( 0.1 ) ;
	$obj = $obj->multiply( $dp )->floor()->multiply( $dp->power( $digit ) ) ;

	return $obj ;
}

=head2 round_banker

Banker's rounding ( RN ; round to the nearest even )

  print decimal( 10.4 )->round_banker() ;    # 10
  print decimal( 10.5 )->round_banker() ;    # 10
  print decimal( 10.6 )->round_banker() ;    # 11

  print decimal( -10.4 )->round_banker() ;    # -10
  print decimal( -10.5 )->round_banker() ;    # -10
  print decimal( -10.6 )->round_banker() ;    # -11

=cut

sub round_banker {
	#-----------------------------------------------------------------------
	#
	# 銀行家の丸め ( Banker's rounding )
	#
	# 最近接偶数への丸め ( round to the nearest even ; RN ) とも言う。
	#
	# JIS Z 8401 の「規則 A 」に当たる。
	#
	# 端数が 0.5 未満であれば切り捨て。
	# 0.5 超であれば切り上げ。
	# 0.5 に等しければ結果が偶数になるように切り上げ又は切り捨てを行う。
	#
	#-----------------------------------------------------------------------
	my( $self , $digit ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$digit = 0	unless ( defined $digit ) ;
	croak( "invalid argument.\n" )	unless ( $digit =~ /^-{0,1}\d+$/ ) ;

	#
	# 基準となる桁が 1 の位になるように 10 の冪で桁上げし、小数部を落とす。
	#
	my $obj = $self->multiply( _pow10( $digit + 1 ) )->floor() ;

	#
	# 数値の偶奇は下一桁だけで判断できるので、添え字 0 の配列要素 ( 現在の基数における 1 の位の値 ) を取り出して条件判断を行う。
	#
	# 取り出した値 ( 添え字 0 の配列要素 ) を 10 で割り、商と剰余を求める。
	# 剰余が 5 未満であれば切捨て、 5 より大きければ切り上げとなる。
	# 剰余が 5 に等しければ商の偶奇に合わせて切り捨てと切り上げを切り替える。
	#
	my( $i , $m ) = __PACKAGE__->new( $obj->{'val'}->[0] )->multiply( $self->{'sgn'} )->divmod( 10 , 0 ) ;
	my $dp = __PACKAGE__->new( 0.1 ) ;
	if ( $m < 5 ) {
		#
		# 切り捨て
		#
		$obj = $obj->multiply( $dp )->floor()->multiply( $dp->power( $digit ) ) ;
	}
	elsif ( $m == 5 ) {
		if ( ( $i % 2 ) == 0 ) {
			#
			# 切り捨て
			#
			$obj = $obj->multiply( $dp )->floor()->multiply( $dp->power( $digit ) ) ;
		}
		else {
			#
			# 切り上げ
			#
			$obj = $obj->multiply( $dp )->floor()->add( 1 )->multiply( $dp->power( $digit ) ) ;
		}
	}
	else {
		#
		# 切り上げ
		#
		$obj = $obj->multiply( $dp )->floor()->add( 1 )->multiply( $dp->power( $digit ) ) ;
	}

	return $obj ;
}

=head2 round_up

  print decimal( 10.4 )->round_up() ;        # 11
  print decimal( 10.5 )->round_up() ;        # 11
  print decimal( 10.6 )->round_up() ;        # 11

=cut

sub round_up {
	#-----------------------------------------------------------------------
	#
	# 切り上げ
	#
	#-----------------------------------------------------------------------
	my( $self , $digit ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$digit = 0	unless ( defined $digit ) ;
	croak( "invalid argument.\n" )	unless ( $digit =~ /^-{0,1}\d+$/ ) ;

	#
	# 基準となる桁が 1 の位になるように 10 の冪で桁上げし、小数部を落とす。
	# 結果として得られた数値の 10 進数値末尾 1 桁が 0 かどうかで処理を切り分ける。
	#
	my $obj = $self->multiply( _pow10( $digit + 1 ) )->floor() ;
	my( $i , $m ) = __PACKAGE__->new( $obj->{'val'}->[0] )->multiply( $self->{'sgn'} )->divmod( 10 , 0 ) ;
	my $dp = __PACKAGE__->new( 0.1 ) ;
	
	if ( $m == 0 ) {
		$obj = $obj->multiply( $dp )->floor()->multiply( $dp->power( $digit ) ) ;
	}
	else {
		$obj = $obj->multiply( $dp )->floor()->add( 1 )->multiply( $dp->power( $digit ) ) ;
	}

	return $obj ;
}

=head2 round_down

  print decimal( 10.4 )->round_down() ;      # 10
  print decimal( 10.5 )->round_down() ;      # 10
  print decimal( 10.6 )->round_down() ;      # 10

=cut

sub round_down {
	#-----------------------------------------------------------------------
	#
	# 切り捨て
	#
	#-----------------------------------------------------------------------
	my( $self , $digit ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$digit = 0	unless ( defined $digit ) ;
	croak( "invalid argument.\n" )	unless ( $digit =~ /^-{0,1}\d+$/ ) ;

	my $obj = $self->multiply( _pow10( $digit ) )->floor() ;
	$obj = $obj->multiply( __PACKAGE__->new( 0.1 )->power( $digit ) ) ;

	return $obj ;
}

sub dsplit {
	#-----------------------------------------------------------------------
	#
	# 係数列の分割
	#
	#   正の整数を表す Decimal オブジェクトを受け取り、
	#   内部の配列要素を指定された要素数ごとに分割して新規オブジェクトに変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $x , $n ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) ) ;
	return ()			unless ( defined $x ) ;

	if ( $x->{'dlen'} > 0 ) {
		$x = __PACKAGE__->new( $x->as_string() ) ;
	}

	return ()	if ( $x->{'sgn'}  < 0 ) ;
	return ()	if ( $x->{'dlen'} > 0 ) ;

	$x = $x->copy() ;
	my( $class ) = ref( $x ) || $x ;

	#
	# デフォルトでは係数列の要素数を二分割するような桁数で分割することとする。
	#
	unless ( defined $n ) {
		$n = @{ $x->{'val'} } ;
		$n++	unless ( ( $n % 2 ) == 0 ) ;
		$n /= 2 ;
	}

	#
	# Decimal オブジェクトの係数列を取り出し、配列要素数を n の倍数になるように調整する。
	#
	my $xv = [ @{ $x->{'val'} } ] ;
	while ( ( @{ $xv } % $n ) != 0 ) {
		push( @{ $xv } , 0 ) ;
	}

	#
	# 係数列を n 桁で分割。
	#
	my $rv = [] ;
	while ( @{ $xv } ) {
		push( @{ $rv } , [ splice( @{ $xv } , 0 , $n ) ] ) ;
	}

	#
	# 分割した配列を用いて新規オブジェクトを生成。
	#
	my $r = [] ;
	foreach my $i ( 0 .. $#{ $rv } ) {

		my $v = [ @{ $rv->[ $i ] } ] ;

		while ( @{ $v } > 1 and $v->[1] == 0 ) {
			pop( @{ $v } ) ;
		}

		my $conf = {
			'sgn'	=> 1 ,
			'val'	=> [ @{ $v } ] ,
			'dlen'	=> 0 ,
			'dirty'	=> 0 ,
		} ;

		$r->[ $i ] = bless $conf , $class ;
	}

	return @{ $r } ;
}

=head2 complement( $base )

Return b^n - x              ( b^n >= x )

If x == 10 and b == 2 ,

  10 + complement( 10 , 2 ) == 2^n

  -> n == round_up( ln( 10 ) / ln( 2 ) ) == 4

  -> complement( 10 , 2 ) == 2^4 - 10 == 6

  -> 10 + 6         == 16 == 2^4     == 0b10000
     10 + ( 6 - 1 ) == 15 == 2^4 - 1 == 0b01111

If b == 1 , this method will return

  ( b + 1 )^n - x - 1 == complement( x , 2 ) - 1
                      == bitnot( x )


By default, $base == 10.


  print decimal( 10 )->bin() ;                         # 1010  ( == 0b1010 )
  print decimal( 10 )->complement( 2 ) ;               # 6     ( == 0b0110 ; 10 + 6 == 16 == 2^4 )
  print decimal( 10 )->complement( 1 ) ;               # 5     ( == 0b0101 ; 10 + 5 == 15 == 2^4 - 1 )


  52934 - 38917 == 14017

  ->  $x = decimal( 52934 ) ;                          # 52934
      $y = decimal( 38917 ) ;                          # 38917

      $z = $y->complement() ;                          # 61083
      print $x + $z - ( $y + $z ) ;                    # 52934 + 61083 - ( 38917 + 61083 )
                                                       # == 114017 - 10^5
						       # == 14017

      $z = $y->complement( 2 ) - 1 ;                   # == bitnot( y )
      print $x + $z - ( $y + $z ) ;                    # 52934 + 26618 - ( 38917 + 26618 )
                                                       # == 79552 - 65535
                                                       # == 79552 - ( 2^16 - 1 )
                                                       # == ( 79552 - 2^16 ) + 1
						       # == 14017

=cut

sub complement {
	#-----------------------------------------------------------------------
	#
	# 指定された基数における補数 ( complement ) を返す。
	#
	#   補数は、「ある自然数 x に足した時に桁が 1 つ上がる数のうち最小のもの」と定義される。
	#
	#   正の整数 a に対する基数 b における補数 ( b の補数 ) は、
	#
	#     x == b^n - a
	#
	#   となり、減基数の補数 ( b - 1 の補数 ) は、
	#
	#     x == b^n - a - 1
	#
	#   となる。
	#
	#   ここでは、基本的に前者を返すこととする。
	#   基数の省略時値は 10 とする。
	#
	#   b^n は b^n >= a となる最小の値であり、 n は
	#
	#     n == round_up( ln( a ) / ln( b ) )
	#
	#   として求めることができる。
	#
	#
	#   15 についての 2 の補数を求めると、
	#
	#     2^n >= 15
	#     -> n == round_up( ln(15) / ln(2) ) == 4
	#
	#     2^4 - 15 == 1
	#
	#   がその解となる。
	#
	#   定義より、
	#
	#     15 + 1 == 16 == 2^4 == 0b10000
	#
	#
	#   基数が 1 の場合、そのままでは
	#
	#     x == complement( a , 1 ) == 1^n - a
	#
	#   となり演算不能となるが、 2 の減基数の補数として定義しなおすことで、
	#
	#     x == complement( a , 1 ) == 2^n - a - 1         ( 2^n >= a )
	#       == bitnot( a )
	#
	#   となる。
	#
	#     complement( 10 , 1 ) == 2^4 - 10 - 1
	#                          == 5
	#                          == 0b101
	#
	#     bitnot( 10 ) == bitnot( 0b1010 ) == 0b0101 == 5
	#
	#
	#   対数の演算は演算コストが非常に高いので b^n の導出には繰り返し乗算を用いている。
	#
	#-----------------------------------------------------------------------
	my( $x , $rad ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( $x->is_integer() ) ;
	return undef	if ( $x < 0 ) ;

	$rad = 10	unless ( defined $rad ) ;

	my $radix = $rad ;
	return undef	if ( $radix < 1 ) ;
	$radix += 1	if ( $radix == 1 ) ;

	my $rp = __PACKAGE__->new( $radix ) ;
	while ( $rp < $x ) {
		$rp *= $radix ;
	}

	my $r = $rp - $x ;
	$r -= 1		if ( $rad == 1 ) ;
	$r += $x	if ( $r < 0 ) ;

	return $r ;
}

=head2 cf

Return a string, which means a result of the regular continued fraction expansion.

  decimal( 0.4 )->cf() ;

			  #                      1
  -> [ 0 ; 2 , 2 ]        # cf( 0.4 ) == 0 + ---------
                          #                        1
			  #                   2 + ---
			  #                        2

for some examples.

  $d = decmal( 5 )->sqrt() + 1 / 2 ;                   # the golden number
  print $d->cf() ;                                     # [ 1 ; 1 , 1 , 1 , 1 , .... ]
  print $d->inverse()->cf() ;                          # [ 0 ; 1 , 1 , 1 , 1 , .... ]

  $d = decimal( 2 )->sqrt() + 1 ;                      # the silver number
  print $d->cf() ;                                     # [ 2 ; 2 , 2 , 2 , 2 , .... ]
  print $d->inverse()->cf() ;                          # [ 0 ; 2 , 2 , 2 , 2 , .... ]

  print decimal( 2 )->sqrt()->cf() ;                   # [ 1 ; 2 , 2 , 2 , 2 , .... ]

  print decimal( 3 )->sqrt()->cf() ;                   # [ 1 ; 1 , 2 , 1 , 2 , .... ]

  print decimal( 14 )->sqrt()->cf() ;                  # [ 3 ; 1 , 2 , 1 , 6 , 1 , 2 , 1 , 6 , ..... ]

  print decimal( 42 )->sqrt()->cf() ;                  # [ 6 ; 2 , 12 , 2 , 12 , 2 , 12 , ..... ]

=cut

sub cf {
	#-----------------------------------------------------------------------
	#
	# 連分数展開の結果を数学的な表現にフォーマットされた文字列で返す。
	#
	#-----------------------------------------------------------------------
	my( $d , $limit ) = @_ ;
	$d = __PACKAGE__->new( $d )	unless ( ref( $d ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $d ) ;

	my $r = $d->cfraction() ;
	if ( defined $limit and $limit =~ /^\d+$/ ) {
		#
		# $limit が定義されていれば、整数部を除く配列要素の個数として使用する。
		#
		if ( @{ $r } >= $limit ) {
			$r = [ @{ $r }[ 0 .. $limit ] ] ;
		}
	}

	$r = join( ' , ' , @{ $r } ) ;

	$r =~ s/\,/\;/ ;
	$r = '[ ' . $r . ' ]' ;

	return $r ;
}

=head2 cf2frac

Return a 'Fraction' object, which is converted from the string, which means regular continued fraction.

  print cf2frac( '[ 0 ; 2 , 2 ]' ) ;              # 2/5

The argument can be specifed as list or an array reference.

  print cf2frac( 0 , 2 , 2 ) ;                    # 2/5
  print cf2frac( [ 0 , 2 , 2 ] ) ;                # 2/5

In this case, '[ 0 ; 2 , 2 ]' means

                           1
  [ 0 ; 2 , 2 ] == 0 + ---------
                             1
                        2 + ---
                             2

=cut

sub cf2frac	{ return my $r = Fraction::cf2frac( @_ ) ; }


=head2 cf2frac2

Return a 'Fraction' object, which is converted from an array reference, which means non-regular continued fraction.

  $cf = [ [ 0 , 4 ] , [ 1 , 1 ] , [ 3 , 4 ] , [ 5 , 9 ] , [ 7 , 16 ] , [ 9 , 25 ] ] ;

  print cf2frac2( $cf ) ;                         # 1744/555
  print cf2frac2( $cf )->decimal() ;              # 3.1423423423423423423423423423423423423423

In this case, $cf means

                         4
  $cf == 0 + -------------------------------
                            1
              1 + --------------------------
	                        4
	           3 + ---------------------
		                   9
		        5 + ----------------
			             16
			     7 + -----------
                                        25
			          9 + ------
				       ....

then, cf2frac2 will calculate it as follows.

  f[0] == 9                 ( 25 will not be used. )

                    1       79
  f[1] == 7 + 16 * ---- == ----
                    9        9

                     9      476
  f[2] == 5 + 9 * ----- == -----
                    79       79

                    79      1744
  f[3] == 3 + 4 * ----- == ------
                   476       476

                    476      2220
  f[4] == 1 + 1 * ------ == ------
                   1744      1744

                   1744      1744
  f[5] == 0 + 4 * ------ == ------
                   2220       555

and it will return f[5].

=cut

sub cf2frac2	{ return my $r = Fraction::cf2frac2( @_ ) ; }


=head2 random

Return a 'Decimal' object, which contains random integer value.

  decimal( 10 )->random() ;      # == int( rand( 10 ) )

=cut

sub random {
	#-----------------------------------------------------------------------
	#
	# 乱数
	#
	#   速度を重視。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return $n->copy()		if ( $n->is_zero() ) ;
	return undef			if ( $n < 0 ) ;

	#
	# 生成する数値の桁数
	#
	my $dig = $n->integer_digits() ;
	$dig = CORE::int( CORE::rand( $dig ) ) ;

	#
	# 乱数を生成
	#
	my $v = '' ;
	foreach ( 0 .. $dig ) {
		$v .= CORE::int( CORE::rand( 10 ) ) ;		# 0 .. 9 の範囲の乱数を連結
	}

	my $r = __PACKAGE__->new( $v ) ;
	$r %= $n ;

	return $r ;
}

#-------------------------------------------------------------------------------
#
# 比較
#
#-------------------------------------------------------------------------------
sub compare {
	#-----------------------------------------------------------------------
	#
	# 比較
	#
	# return  1	if ( $x >  $y ) ;
	# return  0	if ( $x == $y ) ;
	# return -1	if ( $x <  $y ) ;
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	return undef			unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	if ( substr( ref( $y ) , 0 , 9 ) eq 'Math::Big' ) ;

	unless ( ref( $y ) ) {
		$y = __PACKAGE__->new( $y ) ;
		return undef	unless ( defined $y ) ;
	}

	unless ( ref( $y ) eq __PACKAGE__ ) {
		if ( $y->can_decimal() )	{ $y = $y->decimal() ; }
		else				{ return undef ; }
	}

	#
	# $y == 0 の場合
	#
	if ( $y->is_zero() ) {
		return  0	if ( $x->is_zero() ) ;
		return -1	if ( $x->{'sgn'} < 0 ) ;
		return  1 ;
	}

	#
	# 符号で比較
	#
	if ( $x->{'sgn'} != $y->{'sgn'} ) {
		return  1	if ( $x->{'sgn'} > 0 ) ;
		return -1	if ( $x->{'sgn'} < 0 ) ;
	}

	#
	# 整数部の桁数で比較
	#
	# 正の数と負の数では大小関係が逆になる。
	#
	my $idig = {
		'x'	=> $x->integer_digits() ,
		'y'	=> $y->integer_digits() ,
	} ;
	
	if ( $x->{'sgn'} > 0 ) {
		return  1	if ( $idig->{'x'} > $idig->{'y'} ) ;
		return -1	if ( $idig->{'x'} < $idig->{'y'} ) ;
	}
	else {
		return  1	if ( $idig->{'x'} < $idig->{'y'} ) ;
		return -1	if ( $idig->{'x'} > $idig->{'y'} ) ;
	}

	#
	# 小数点の位置を基準にして桁合わせ。
	#
	#( $x , $y ) = _adjust_DP( $x , $y ) ;
	( $x , $y ) = ( _dec2int( $x , $y ) )[1,2] ;

	#
	# n 進数の桁数で比較
	#
	# 正の数と負の数では大小関係が逆になる。
	#
	my $sz = {
		'x'	=> scalar( @{ $x->{'val'} } ) ,
		'y'	=> scalar( @{ $y->{'val'} } ) ,
	} ;

	if ( $x->{'sgn'} > 0 ) {
		return  1	if ( $sz->{'x'} > $sz->{'y'} ) ;
		return -1	if ( $sz->{'x'} < $sz->{'y'} ) ;
	}
	else {
		return  1	if ( $sz->{'x'} < $sz->{'y'} ) ;
		return -1	if ( $sz->{'x'} > $sz->{'y'} ) ;
	}

	#
	# 各桁を上位から順に比較
	#
	# 絶対値の比較に相当する。
	# これも正の数と負の数では大小関係が逆になる。
	#
	if ( $x->{'sgn'} > 0 ) {
		foreach ( my $i = $sz->{'x'} - 1 ; $i >= 0 ; $i-- ) {
			return  1	if ( $x->{'val'}->[ $i ] > $y->{'val'}->[ $i ] ) ;
			return -1	if ( $x->{'val'}->[ $i ] < $y->{'val'}->[ $i ] ) ;
		}
	}
	else {
		foreach ( my $i = $sz->{'x'} - 1 ; $i >= 0 ; $i-- ) {
			return  1	if ( $x->{'val'}->[ $i ] < $y->{'val'}->[ $i ] ) ;
			return -1	if ( $x->{'val'}->[ $i ] > $y->{'val'}->[ $i ] ) ;
		}
	}

	return  0 ;
}

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	return 1	if ( $x->compare( $y ) == 0 ) ;
	return 0 ;
}

sub not_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( != )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	return 0	if ( $x->compare( $y ) == 0 ) ;
	return 1 ;
}

sub greater_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( > )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	if ( $swapped ) {
		$y = __PACKAGE__->new( $y ) ;
		return undef	unless ( defined $y ) ;
		( $x , $y ) = ( $y , $x ) ;
	}

	return 1	if ( $x->compare( $y ) > 0 ) ;
	return 0 ;
}

sub greater_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( >= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	if ( $swapped ) {
		$y = __PACKAGE__->new( $y ) ;
		return undef	unless ( defined $y ) ;
		( $x , $y ) = ( $y , $x ) ;
	}

	return 1	if ( $x->compare( $y ) >= 0 ) ;
	return 0 ;
}

sub less_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( < )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	if ( $swapped ) {
		$y = __PACKAGE__->new( $y ) ;
		return undef	unless ( defined $y ) ;
		( $x , $y ) = ( $y , $x ) ;
	}

	return 1	if ( $x->compare( $y ) < 0 ) ;
	return 0 ;
}

sub less_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( <= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	if ( $swapped ) {
		$y = __PACKAGE__->new( $y ) ;
		return undef	unless ( defined $y ) ;
		( $x , $y ) = ( $y , $x ) ;
	}

	return 1	if ( $x->compare( $y ) <= 0 ) ;
	return 0 ;
}

=head1 'Decimal' object - calculation methods

=cut

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------
sub ov_add {
	#-----------------------------------------------------------------------
	#
	# 加算 ( オーバーロード用 )
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $swapped ) = @_ ;

	return __PACKAGE__->new( $n )->add( $self )	if ( $swapped ) ;
	return $self->add( $n ) ;
}

sub ov_subtract {
	#-----------------------------------------------------------------------
	#
	# 減算 ( オーバーロード用 )
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $swapped ) = @_ ;

	return __PACKAGE__->new( $n )->subtract( $self )	if ( $swapped ) ;
	return $self->subtract( $n ) ;
}

=head2 add

  my $x = decimal( 10 ) ;
  my $y = decimal( 20 ) ;
  print $x + $y  ;                        # 30
  print $x->add( $y ) ;                   # 30

  $x = decimal( 0 ) ;
  print $x->add( [ 1 .. 10 ] ) ;          # 55

=cut

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	# 繰り返し処理の効率を上げるため、引数に複数値を取れるようにしてある。
	# 複数値を指定するには配列参照を使用する必要がある。
	#
	# 小数の加算は、事前に小数点位置での桁合わせが必要な点を除けば整数の加算と大差はない。
	#
	#-----------------------------------------------------------------------
	my( $self , $arg ) = @_ ;

	#
	# 引数を検査
	#
	my @args ;
	if ( ref( $arg ) eq 'ARRAY' ) {
		@args = @{ $arg } ;
	}
	else {
		@args = ( $arg ) ;
	}

	my $comp = 0 ;
	foreach ( @args ) {

		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;

		unless ( ref( $_ ) ) {
			$_ = __PACKAGE__->new( $_ ) ;
			croak( "unexpected error!!\n" )	unless ( defined $_ ) ;
		}

		unless ( ref( $_ ) eq __PACKAGE__ ) {
			if	( $_->can_decimal() )	{ $_ = $_->decimal() ; }
			elsif	( $_->is_complex() )	{ $comp++ ; }
			else				{ croak( "unexpected error!!\n" ) ; }
		}
	}

	#
	# 複素演算が含まれる場合
	#
	if ( $comp ) {
		my $r = $self->complex() ;
		foreach ( @args ) { $r += $_ ; }
		return $r ;
	}

	#
	# 小数点位置での桁合わせ
	#
	#@args = _adjust_DP( $self , @args ) ;
	my $dlen = 0 ;
	( $dlen , @args ) = _dec2int( $self , @args ) ;

	#
	# 加算
	#
	my $c = 0 ;
	my $y = shift( @args ) ;
	#$y = $y->copy() ;
	foreach my $x ( @args ) {

		next	if ( $x->is_zero() ) ;

		if ( $y->is_zero() ) {
			#$y = $x->copy() ;
			$y = $x ;
			next ;
		}

		#$x = $x->copy() ;

		my $sz = ( sort { $a <=> $b } ( $x->digits() , $y->digits ) )[1] ;

		if ( $x->{'sgn'} == $y->{'sgn'} ) {
			#
			# 符号が同じであれば絶対値を加算するだけ。
			#
			foreach ( my $i = 0 ; $i < $sz ; $i++ ) {
				$y->{'val'}->[ $i ] = 0	unless ( defined $y->{'val'}->[ $i ] ) ;
				$y->{'val'}->[ $i ] += ( defined $x->{'val'}->[ $i ] ) ? $x->{'val'}->[ $i ] : 0 ;
				if ( $y->{'val'}->[ $i ] >= INT_BASE ) {
					$y->{'dirty'}++ ;
					#$y->{'val'}->[ $i + 1 ] += CORE::int( $y->{'val'}->[ $i ] / INT_BASE ) ;
					#$y->{'val'}->[ $i ] %= INT_BASE ;
				}
			}
		}
		else {
			#
			# 符合が異なる場合は、絶対値が大きいほうから小さい方を引く。
			# 符号は絶対値が大きい方に従う。
			#
			if ( $x->abs() > $y->abs() ) {
				( $x , $y ) = ( $y , $x ) ;
			}
			foreach ( my $i = 0 ; $i < $sz ; $i++ ) {
				$y->{'val'}->[ $i ] = 0	unless ( defined $y->{'val'}->[ $i ] ) ;
				$y->{'val'}->[ $i ] -= ( defined $x->{'val'}->[ $i ] ) ? $x->{'val'}->[ $i ] : 0 ;
				if ( $y->{'val'}->[ $i ] < 0 ) {
					$y->{'dirty'}++ ;
					#if ( $i < ( @{ $y->{'val'} } - 1 ) ) {
					#	$y->{'val'}->[ $i + 1 ] += POSIX::floor( $y->{'val'}->[ $i ] / INT_BASE ) ;
					#	$y->{'val'}->[ $i ] %= INT_BASE ;
					#}
				}
			}
		}

		if ( $y->{'dirty'} > 5 ) {
			$y->_regulate() ;
		}
	}

	$y->{'dlen'} += $dlen ;

	return $y->_regulate() ;
}

=head2 subtract

  my $x = decimal( 10 ) ;
  my $y = decimal( 20 ) ;
  print $x - $y  ;                        # -10
  print $x->subtract( $y ) ;              # -10

  $x = decimal( 0 ) ;
  print $x->subtract( [ 1 .. 10 ] ) ;     # -55

=cut

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算
	#
	# 繰り返し処理の効率を上げるため、引数に複数値を取れるようにしてある。
	# 複数値を渡すには、配列参照を使用する必要がある。
	#
	#-----------------------------------------------------------------------
	my( $self , $arg ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @args = ( ref( $arg ) eq 'ARRAY' )
		? @{ $arg }
		: $arg
	;

	foreach ( @args ) {
		my $ref = ref( $_ ) ;
		if ( ! $ref or substr( $ref , 0 , 9 ) eq 'Math::Big' ) {
			$_ = __PACKAGE__->new( $_ ) ;
			croak( "unexpected error!!\n" )	unless ( defined $_ ) ;
		}
	}

	#
	# 符号を反転させて加算。
	#
	my $obj = $self->copy() ;

	foreach ( @args ) {
		#$_->{'sgn'} *= ( -1 ) ;
		$_ *= ( -1 ) ;
	}

	return $obj->add( [ @args ] ) ;
}

sub subtract_c {
	#-----------------------------------------------------------------------
	#
	# 補数を利用した正の整数同士の減算
	#
	#   基数が 10 の場合、以下のような演算が可能。
	#
	#     52934 - 38917
	#     == 52934 + ( 61082 + 1 ) - ( 61082 + 1 + 38917 )
	#     == 52934 + ( 61082 + 1 ) - 10^5
	#     == 14017
	#
	#   この時、 61082 は 38917 の各桁を 9 から減じたものを並べるだけで得られる。
	#   これは 61082 の基数 9 における補数となるため、 +1 することで基数 10 における補数となる。
	#   これによって得られた値 61083 を 52934 に加算した値 114017 から 10^5 ( == 100000 ) を減ずることで解が得られる。
	#
	#   基数が 2 の場合、元の値をビット反転したものが 1 の補数となり、 2 の補数はビット反転した値に +1 した値となる。
	#   2 進数の世界においては 2 の補数は非常に利便性が高く、多くの処理系において負の値の内部表現として用いられている。
	#
	#
	#   このモジュールでは、正の整数は INT_BASE を基数とした多項式の形を採っている。
	#   よって、 INT_BASE - 1 の補数を用いることで正の整数同士の減算を表現することができる。
	#
	#   基数 INT_BASE を B とすると、正の整数 x , y は
	#
	#     x == Σ( a[k] * B^k )            ( k == 0 -> n )
	#     y == Σ( b[k] * B^k )            ( k == 0 -> m )
	#
	#   と表現できる。
	#
	#   y の B - 1 における補数 y' は、
	#
	#     y' == Σ( ( ( B - 1 ) - b[k] ) * B^k )         ( k == 0 -> m )
	#        == Σ( b'[k] * B[k] )
	#
	#   であり、
	#
	#     y + ( y' + 1 ) == B^p
	#
	#     x + y == x + ( y' + 1 ) - ( B^p )
	#           == Σ( ( a[k] + b'[k] ) * B^k ) + 1 - ( INT_BASE )^p        ( k == 0 -> max( n , m ) ) 
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	return undef	if ( $x < 0 ) ;
	return undef	if ( $y < 0 ) ;

	#
	# $y の INT_BASE - 1 における補数を $yc として生成。
	#
	my $yc = $y->copy() ;
	my $base = INT_BASE - 1 ;
	foreach ( @{ $yc->{'val'} } ) {
		$_ = $base - $_ ;
	}

	#
	# $r = $x + ( $yc + 1 ) - ( $y + ( $yc + 1 ) )
	#
	my $r = ( $x + $yc + 1 ) - ( $y + ( $yc + 1 ) ) ;

	return $r ;
}

=head2 multiply

  my $x = decimal( 10 ) ;
  my $y = decimal( 20 ) ;
  print $x * $y  ;                        # 200
  print $x->multiply( $y ) ;              # 200

=cut

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算
	#
	# ここでは非常に小さな整数による乗算のみを処理する。
	# 乗数が小数やオブジェクトである場合には、 bmult へ引き渡す。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	if ( my $ref = ref( $n ) ) {

		$n = __PACKAGE__->new( $n )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;

		if	( $ref eq __PACKAGE__ )		{ return $self->bmult( $n ) ; }
		elsif	( $n->is_fraction() )		{ return $n->multiply( $self ) ; }
		elsif	( $n->is_complex() )		{ return $n->multiply( $self ) ; }
		elsif	( $n->can_decimal() )		{ return $self->bmult( $n->decimal() ) ; }
		elsif	( $n->is_vector() )		{ return $n->multiply( $self ) ; }
		elsif	( $n->is_matrix() )		{ return $n->multiply( $self ) ; }
		elsif	( $n->is_polynomial() )		{ return $n->multiply( $self ) ; }
		else					{ croak( "unexpected error!!\n" ) ; }
	}
	elsif	( $n =~ /^\d+\.\d+$/ )			{ return $self->bmult( __PACKAGE__->new( $n ) ) ; }
	elsif	( $n >= INT_BASE )			{ return $self->bmult( __PACKAGE__->new( $n ) ) ; }

	return __PACKAGE__->new( 0 )	if ( $n == 0 ) ;

	my $obj = $self->copy() ;

	if ( $n == -1 ) {
		$obj->{'sgn'} *= ( -1 ) ;
		return $obj ;
	}

	#
	# 符号
	#
	if ( $n < 0 ) {
		$obj->{'sgn'} *= ( -1 ) ;
		$n *= ( -1 ) ;
	}

	#
	# 全ての桁に乗算を行い、桁上がりを調整。
	#
	my $v = \@{ $obj->{'val'} } ;
	foreach ( my $i = 0 ; $i < @{ $v } ; $i++ ) {
		$v->[ $i ] *= $n ;
		if ( $v->[ $i ] >= INT_BASE ) {
			$obj->{'dirty'}++ ;
		}
	}

	return $obj->_regulate() ;
}

sub bmult {
	#-----------------------------------------------------------------------
	#
	# オブジェクト同士の乗算
	#
	#   乗数が基数に満たないほど小さな値であれば、筆算を模した演算を行う。
	#   乗数が大きな値であれば、多項式の乗算を模した演算を行う。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = __PACKAGE__->new( $y )	if ( substr( ref( $y ) , 0 , 9 ) eq 'Math::Big' ) ;
	return undef	unless ( ref( $y ) eq __PACKAGE__ ) ;

	#
	# 処理を振り分ける
	#
	if ( @{ $x->{'val'} } == 1 and @{ $y->{'val'} } != 1 ) {
		( $x , $y ) = ( $y , $x ) ;
	}
	my $r = ( @{ $y->{'val'} } == 1 )
		? $x->smult( $y )
		: $x->pmult( $y )
	;

	return $r ;
}

=head2 smult

Same to 'multiply'.

'smult' is used by 'multiply', internally.

'smult' is implemented using by 'calculation on paper' method.

  x == 1,234,567 == 1 x 10^6 + 2 x 10^5 + 3 x 10^4 + 4 x 10^3 + 5 x 10^2 + 6 x 10^1 + 7 x 10^0
  y == 2

  x * y == ( 1 x 2 ) x 10^6 + ( 2 x 2 ) x 10^7 + ...... + ( 7 x 2 ) x 10^0
        == 2,469,134

=cut

sub smult {
	#-----------------------------------------------------------------------
	#
	# 筆算 ( calculation on paper ) を模した乗算
	#
	#   筆算は、
	#
	#     ・配列要素ごとの乗算
	#     ・加算位置を特定するシフトアップ
	#     ・加算
	#
	#   の三つの工程を繰り返す処理となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$n = __PACKAGE__->new( $n )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;
	return undef	unless ( ref( $n ) eq __PACKAGE__ ) ;

	if ( $n == -1 ) {
		my $obj = $self->copy() ;
		$obj->{'sgn'} *= ( -1 ) ;
		return $obj ;
	}

	#
	# $n の最下位の桁を掛けた結果を初期値とする。
	#
	my $x = [ @{ $n->{'val'} } ] ;
	my $obj = $self->multiply( $x->[0] ) ;

	return undef	unless ( defined $obj ) ;

	#
	# 桁を上げながら乗算を行い、戻り値をシフトアップしながら加算する。 ( 筆算 )
	#
	foreach ( my $i = 1 ; $i < @{ $x } ; $i++ ) {
		if ( my $m = $self->multiply( $x->[ $i ] ) ) {
			$obj += $m->_shiftup( $i ) ;
		}
	}

	#
	# 小数点の位置を更新
	#
	$obj->{'dlen'} += $n->{'dlen'} ;

	#
	# 符合を反映
	#
	$obj->{'sgn'} *= $n->{'sgn'} ;

	return $obj ;
}

=head2 pmult

Same to 'multiply'.

'pmult' is used by 'multiply', internally.

'pmult' is implemented using by 'Polynomial multiplication' method.  ( aka. 'Linear convolution' method )

  x == 1,234,567 == 1 x 10^6 + 2 x 10^5 + 3 x 10^4 + 4 x 10^3 + 5 x 10^2 + 6 x 10^1 + 7 x 10^0
  y ==   345,678 ==            3 x 10^5 + 4 x 10^4 + 5 x 10^3 + 6 x 10^2 + 7 x 10^1 + 8 x 10^0

  x * y == ( 1 x 3 ) x 10^(6+5) + ( 2 x 3 ) x 10^(5+5) + ......
         + ( 1 x 4 ) x 10^(6+4) + ( 2 x 4 ) x 10^(5+4) + ......
	 + ......
	 + ......
	 + ( 1 x 8 ) x 10^(6+0) + ( 2 x 8 ) x 10^(5+0) + ......
        == 426,762,651,426

  $x = '1234567' ;
  $y = '345678' ;
  -> @xc = reverse( split( '' , $x ) ) ;        # @xc == ( 7, 6, 5, 4, 3, 2, 1 ) ;
     @yc = reverse( split( '' , $y ) ) ;        # @yc == ( 8, 7, 6, 5, 4, 3 ) ;

  -> $x == sum( $xc[$i] * 10**($i) ) ;          # $i == 0 -> 6
     $y == sum( $yc[$j] * 10**($j) ) ;          # $i == 0 -> 5

  -> ( $x * $y ) == sum( ( $xc[$i] * $yc[$j] ) * 10**( $i + $j ) ) ;      # $i == 0 -> 6 , $j == 0 -> 5

=cut

sub pmult {
	#-----------------------------------------------------------------------
	#
	# 多項式の乗算 ( 線形畳み込み ) を用いた乗算
	#
	#   筆算を応用した演算の一種。
	#
	#   符号なし整数は基数 B に関する多項式とみなすことができ、
	#
	#     f(B) == Σ( a[i] * B^i )        ( i == 0 -> n )
	#
	#   と定義できる。
	#
	#   二つの符号なし整数を
	#   
	#     f(B) == Σ( a[i] * B^i )        ( i == 0 -> m )
	#     g(B) == Σ( b[j] * B^j )        ( j == 0 -> n )
	#
	#   と定義すると、その積は
	#
	#     h(B) == f(B) * g(B) == Σ( a[i] * b[j] * B^( i + j ) )
	#                         == Σ( a[i] * b[k-i] * B^k )            ( k == i + j )
	#
	#   と表現できる。
	#   この時の h(B) は、繰り上がりを調整する前の積の結果を示しており、
	#   これに基数 B を代入することで繰り上がりが調整され、 10 進数における二整数の積が得られる。
	#
	#   逆に、 h(B) が基数 B における数値表現となるように h(B) の係数列を調整することもできる。
	#   係数列の調整は繰り上げ処理そのものであり、
	#
	#     h(B) == f(B) * g(B)
	#          == Σ( c[i] * B^i )       ( i == 0 -> n )
	#
	#   とすると、繰り上げ処理は、
	#
	#     c[ i + 1 ] += int( c[i] / B )
	#     c[ i ]      = c[ i ] % B
	#
	#   となる。
	#   これを数列 c 全体に施し、全ての c[i] が c[i] < B となれば、数列 c が基数 B における h(B) の数値表現となる。
	#
	#   係数列の積和演算を行った後、代入によって正規化する手法を採る場合、積和演算によるオーバーフローを解決する必要がある。
	#   係数列を Decimal オブジェクトで管理すればオーバーフローは防げるが、処理効率は大幅に低下する。
	#
	#   もう一つの方法として、積和演算の一環として繰り上がり処理を済ませてしまうこともできる。
	#   f(B) , g(B) の係数列 a[i] , b[j] は全て基数 B 未満の整数値であるため、
	#
	#     a[i] < B
	#     b[j] < B
	#     -> a[i] * b[j] < B^2
	#
	#   となる。
	#
	#   B^2 ( このライブラリでは ( B == INT_BASE ) が言語標準の数値でオーバーフローを起こさない程度の大きさに
	#   調整されていると言う前提の下であれば、一連の積和演算は言語標準の機能だけで実装することができる。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
	}

	if ( $y == -1 ) {
		my $r = $x->copy() ;
		$r->{'sgn'} *= ( -1 ) ;
		return $r ;
	}

	#
	# オブジェクトに格納された配列を多項式の係数列とみなし、
	# 係数列の積和演算を行う。
	#
	$x = $x->copy() ;
	$y = $y->copy() ;

	my $xa = \@{ $x->{'val'} } ;
	my $ya = \@{ $y->{'val'} } ;

	my $xn = $#{ $xa } ;
	my $yn = $#{ $ya } ;

	my $ra = [] ;
	foreach my $i ( 0 .. $xn ) {
		foreach my $j ( 0 .. $yn ) {
			#
			# 係数列の積和演算
			#
			my $k = $i + $j ;
			$ra->[ $k ] = 0	unless ( defined $ra->[ $k ] ) ;
			$ra->[ $k ] += $xa->[ $i ] * $ya->[ $j ] ;

			#
			# 繰り上がり処理
			#
			if ( $ra->[ $k ] >= INT_BASE ) {
				$ra->[ $k + 1 ] = 0	unless ( defined $ra->[ $k + 1 ] ) ;
				$ra->[ $k + 1 ] += CORE::int( $ra->[ $k ] / INT_BASE ) ;
				$ra->[ $k ] = $ra->[ $k ] % INT_BASE ;
			}
		}
	}

	#
	# オブジェクト化
	#
	my $r = __PACKAGE__->new( 0 ) ;
	$r->{'val'}   = [ @{ $ra } ] ;
	$r->{'dlen'}  = $x->{'dlen'} + $y->{'dlen'} ;	# 小数点の位置
	$r->{'sgn'}   = $x->{'sgn'}  * $y->{'sgn'}  ;	# 符合
	$r->{'dirty'} = 1 ;

	$r->_regulate() ;

	return $r ;
}

=head2 fmult

Same to 'multiply'.

'fmult' is implemented using by 'Fast Fourier Transform (FFT)' method. 

'fmult' is very costly calculation, because this module implemented by "Pure Perl".

'fmult' is implemeted like as follows.

  $x = '1234567' ;
  $y = '345678' ;
  -> @xc = reverse( split( '' , $x ) ) ;        # @xc == ( 7, 6, 5, 4, 3, 2, 1 ) ;
     @yc = reverse( split( '' , $y ) ) ;        # @yc == ( 8, 7, 6, 5, 4, 3 ) ;

     @yc = ( @yc , 0 ) ;                        # scalar( @xc ) - scalar( @yc ) == 1

  -> @xc = fft( @xc ) ;
     @yc = fft( @yc ) ;

  -> @zc = map { $xc[$_] * $yc[$_] } ( 0 .. 6 ) ;

  -> @zc == inverse_fft( @zc ) ;

  -> ( x * y ) == sum( $zc[$i] * 10**($i) ) ;    # $i == 0 -> 6

Note:

  FFT is the calculation of the 'complex plane'.

=cut

sub fmult {
	#-----------------------------------------------------------------------
	#
	# 高速フーリエ変換を用いた符号なし整数の乗算
	#
	#   要素数 n の多項式形式の数列で表される二つの符号なし整数 x , y について、
	#   高速フーリエ変換を用いた乗算は、
	#
	#     x * y == ifft( fft( x )[i] * fft( y )[i] )         ( i == 0 -> n - 1 )
	#
	#   で表される。
	#   ( x と y をそれぞれフーリエ変換に掛け、結果をその要素ごとに乗じた後、フーリエ逆変換に掛ける。 )
	#
	#   通常の乗算のオーダーが O(n^2) であるのに対して、 FFT を使用した乗算は O( n * log(n) ) となるとのことだが、
	#   複素数の積和演算に伴うオーバーヘッドが非常に大きく、 10^100 程度の数値同士の乗算では演算コストの削減効果は得られていない。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
		return undef			unless ( $_ > 0 ) ;
	}

	( $x , $y ) = ( $y , $x )	if ( $x < $y ) ;

	#
	# x , y に格納されている配列要素を多項式の係数とみなし、
	# その最大次数の二倍以上で且つ次数が 8 の倍数となるように配列要素数を調整する。
	# ( 要素数を 8 の倍数に採るのは、フーリエ変換の処理効率を上げるため。)
	#
	my $xa = [] ;
	my $ya = [] ;
	foreach my $i ( 0 .. ( @{ $x->{'val'} } * 2 - 1 ) ) {
		$xa->[ $i ] = ( defined $x->{'val'}->[ $i ] ) ? complex( $x->{'val'}->[ $i ] ) : complex( 0 ) ;
		$ya->[ $i ] = ( defined $y->{'val'}->[ $i ] ) ? complex( $y->{'val'}->[ $i ] ) : complex( 0 ) ;
	}
	while ( ( @{ $xa } % 8 ) != 0 ) {
		push( @{ $xa } , complex( 0 ) ) ;
		push( @{ $ya } , complex( 0 ) ) ;
	}

	#
	# FFT で使用する回転因子を生成し、正変換用に調整する。
	#
	my $n = @{ $xa } ;
	my $w = [ complex( [ 1 , 0 ] )->circle_group( $n ) ] ;
	$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;	# w = conj( w )

	#
	# x , y を FFT 正変換に掛け、要素ごとの積を採る。
	#
	my $ra = [] ;
	foreach ( my $k = 0 ; $k < $n ; $k++ ) {

		my $xf = complex( 0 ) ;
		my $yf = complex( 0 ) ;

		foreach ( my $j = 0 ; $j < $n ; $j++ ) {
			my $ix = ( $j * $k ) % $n ;
			$xf += ( $xa->[ $j ] * $w->[ $ix ] ) ;
			$yf += ( $ya->[ $j ] * $w->[ $ix ] ) ;
		}

		$ra->[ $k ] = $xf * $yf ;
	}
	undef $xa ;
	undef $ya ;

	#
	# 結果を FFT の逆変換に掛ける。
	#
	$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;	# w = conj( w )
	my $rb = [] ;
	foreach ( my $k = 0 ; $k < $n ; $k++ ) {

		$rb->[ $k ] = complex( 0 ) ;

		foreach ( my $j = 0 ; $j < $n ; $j++ ) {
			my $ix = ( $j * $k ) % $n ;
			$rb->[ $k ] += ( $ra->[ $j ] * $w->[ $ix ] ) ;
		}

		$rb->[ $k ] = $rb->[ $k ]->divide( $n ) ;

		#
		# 結果は複素数から整数に戻るが、多くの場合、演算誤差による端数が存在する。
		# 演算誤差を修正するために小数点以下 15 桁で切り詰める。
		#
		$rb->[ $k ] = $rb->[ $k ]->round( 15 ) ;
	}
	undef $ra ;

	#
	# ホーナー法を用いて戻り値を得る。
	#
	my $hd = $#{ $rb } ;	# 添え字の最大値 == 最高位次数
	my $r = $rb->[ $hd ] ;
	foreach my $i ( reverse ( 0 .. ( $hd - 1 ) ) ) {
		$r = $r * INT_BASE + $rb->[ $i ] ;
	}

	return $r ;
}

=head2 rfmult

Same to 'fmult'.

'rfmult' is implemented using by 'Real Fast Fourier Transform (Real FFT)' method. 

'rfmult' is also very costly calculation, because this module implemented by "Pure Perl".


Note:

  'Real FFT' is also the calculation of the 'complex plane'.

  'fmult' use coefficient arrays, which has the rational numerical elements.
  'rfmult' use a half size of the coefficient arrays, which has translated to the complex numerical elements.

  'Real FFT' is implemented by 'Complex' class method 'rft' and 'irft'.

=cut

sub rfmult {
	#-----------------------------------------------------------------------
	#
	# 実数列フーリエ変換 ( Real FFT ) を用いた符号なし整数の乗算
	#
	#   サイズ n の実数列をサイズ n/2 の複素数列に変換してフーリエ変換を行う。
	#   FFT による乗算 ( fmult メソッド ) に比べて 3 ～ 4 倍処理効率が向上している。
	#
	#   実数列フーリエ変換に関しての詳細は Complex クラスの rft , irft 関数を参照のこと。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
		return undef			unless ( $_ > 0 ) ;
	}

	#
	# 定数
	#
	my $one       = complex( [ 1 , 0 ] ) ;
	my $imag_unit = complex( [ 0 , 1 ] ) ;

	#
	# x , y を数列に変換し、要素数を 4 の倍数に揃える。
	#
	$x = __PACKAGE__->new( $x->as_string() ) ;
	$y = __PACKAGE__->new( $y->as_string() ) ;

	$x = [ @{ $x->{'val'} } ] ;
	$y = [ @{ $y->{'val'} } ] ;

	my $n = @{ $x } + @{ $y } ;
	while ( ( $n % 4 ) != 0 ) { $n++ ; }

	while ( @{ $x } < $n ) { push( @{ $x } , 0 ) ; }
	while ( @{ $x } > $n ) { push( @{ $y } , 0 ) ; }

	#
	# n/2 , n/4 を抑える。
	#
	my $n2 = $n / 2 ;
	my $n4 = $n / 4 ;

	#-----------------------------------------------------------------------
	#
	# 正変換して要素ごとの積を採る。 ( rft )
	#
	#-----------------------------------------------------------------------
	my $w = [ complex( [ 1 , 0 ] )->root( $n ) ] ;
	$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;

	#-------------------------------
	#
	# x , y を n/2 のサイズの複素数列に変換
	#
	#-------------------------------
	my $xa = [] ;
	my $ya = [] ;
	foreach my $j ( 0 .. ( $n2 - 1 ) ) {
		$xa->[ $j ] = complex( [ $x->[ $j * 2 ] , $x->[ $j * 2 + 1 ] ] ) ;
		$ya->[ $j ] = complex( [ $y->[ $j * 2 ] , $y->[ $j * 2 + 1 ] ] ) ;
	}

	#-------------------------------
	#
	# サイズ n/2 の複素数列をフーリエ正変換に掛ける。
	#
	#-------------------------------
	my $xb = [] ;
	my $yb = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		$xb->[ $i ] = complex( 0 ) ;
		$yb->[ $i ] = complex( 0 ) ;
		foreach my $j ( 0 .. ( $n2 - 1 ) ) {
			my $k = ( $i * $j * 2 ) % $n ;
			$xb->[ $i ] += ( $xa->[ $j ] * $w->[ $k ] ) ;
			$yb->[ $i ] += ( $ya->[ $j ] * $w->[ $k ] ) ;
		}
	}
	undef $xa ;
	undef $ya ;

	#-------------------------------
	#
	# fft( x ) , fft( y ) に戻す。 ( 要素数 n の複素数列となる。 )
	#
	#-------------------------------
	my $xc = [] ;
	my $yc = [] ;
	
	#
	# 0 , n/2 次の項
	#
	#   X[ 0 ]   == real( x[ 0 ] ) + imag( x[ 0 ] )
	#   X[ n/2 ] == real( x[ 0 ] ) - imag( x[ 0 ] )
	#
	$xc->[ 0 ]   = $xb->[ 0 ]->real() + $xb->[ 0 ]->imag() ;
	$xc->[ $n2 ] = $xb->[ 0 ]->real() - $xb->[ 0 ]->imag() ;

	$yc->[ 0 ]   = $yb->[ 0 ]->real() + $yb->[ 0 ]->imag() ;
	$yc->[ $n2 ] = $yb->[ 0 ]->real() - $yb->[ 0 ]->imag() ;

	#
	# n - n/4 , n/4 の項
	#
	#   X[ n - n/4 ] == x[ n/4 ]
	#   X[ n/4 ]     == conj( x[ n/4 ] )
	#
	$xc->[ $n - $n4 ] = $xb->[ $n4 ] ;
	$xc->[ $n4 ]      = $xb->[ $n4 ]->conj() ;

	$yc->[ $n - $n4 ] = $yb->[ $n4 ] ;
	$yc->[ $n4 ]      = $yb->[ $n4 ]->conj() ;

	#
	# 1 <= k < n/4 の範囲の項及びそれと対称となる項
	#
	#   d = 1/2 * ( 1 + i * w^k ) * ( x[ k ] - conj( x[ n/2 - k ] ) ) 
	#
	#   X[ k ]       ==       x[ k ]         - d
	#   X[ n/2 + k ] == conj( x[ n/2 - k ] ) + d
	#
	#   X[ n   - k ] == conj( X[ k ] )
	#   X[ n/2 - k ] == conj( X[ n/2 + k ] )
	#
	foreach my $k ( 1 .. ( $n4 - 1 ) ) {
		my $d = {
			'x'	=> ( $one + ( $imag_unit * $w->[ $k ] ) ) * ( $xb->[ $k ] - $xb->[ $n2 - $k ]->conj() ) * 0.5 ,
			'y'	=> ( $one + ( $imag_unit * $w->[ $k ] ) ) * ( $yb->[ $k ] - $yb->[ $n2 - $k ]->conj() ) * 0.5 ,
		} ;

		$xc->[ $k ]       = $xb->[ $k ]               - $d->{'x'} ;
		$xc->[ $n2 + $k ] = $xb->[ $n2 - $k ]->conj() + $d->{'x'} ;

		$xc->[ $n  - $k ] = $xc->[ $k ]->conj() ;
		$xc->[ $n2 - $k ] = $xc->[ $n2 + $k ]->conj() ;

		$yc->[ $k ]       = $yb->[ $k ]               - $d->{'y'} ;
		$yc->[ $n2 + $k ] = $yb->[ $n2 - $k ]->conj() + $d->{'y'} ;

		$yc->[ $n  - $k ] = $yc->[ $k ]->conj() ;
		$yc->[ $n2 - $k ] = $yc->[ $n2 + $k ]->conj() ;
	}
	undef $xb ;
	undef $yb ;

	#-------------------------------
	#
	# 要素ごとの積を採る。
	#
	#-------------------------------
	my $z = [] ;
	foreach my $i ( 0 .. ( $n - 1 ) ) {
		$z->[ $i ] = ( $xc->[ $i ] * $yc->[ $i ] ) ;
	}
	undef $xc ;
	undef $yc ;

	#-----------------------------------------------------------------------
	#
	# 逆変換 ( irft ) 
	#
	#-----------------------------------------------------------------------
	$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;

	#-------------------------------
	#
	# 要素数 n/2 の複素数列に変換
	#
	#-------------------------------
	my $za = [] ;

	#
	# 0 , n/4 次の項
	#
	#   z[ 0 ] == 1/2 * ( ( Z[ 0 ] + Z[ n/2 ] ) + i * ( Z[ 0 ] - Z[ n/2 ] ) )
	#   z[ 4 ] == conj( Z[ n/4 ] )
	#
	$za->[ 0 ]   = ( ( $z->[ 0 ] + $z->[ $n2 ] ) + $imag_unit * ( $z->[ 0 ] - $z->[ $n2 ] ) ) * 0.5 ;
	$za->[ $n4 ] = $z->[ $n4 ]->conj() ;

	#
	# 1 <= k < n/4 の範囲の項及びそれと対称となる項
	#
	foreach my $k ( 1 .. ( $n4 - 1 ) ) {
		#
		# d == 1/2 * ( 1 - i * w^(-k) ) * ( Z[ k ] - Z[ n/2 + k ] ) )
		#
		my $d = ( $one - ( $imag_unit * $w->[ $k ] ) ) * ( $z->[ $k ] - $z->[ $n2 + $k ] ) * 0.5 ;

		#
		# z[ k ]       ==     ( Z[ k ]       - d )
		# z[ n/2 - k ] == conj( Z[ n/2 + k ] + d )
		#
		$za->[ $k ]       = ( $z->[ $k ]       - $d ) ;
		$za->[ $n2 - $k ] = ( $z->[ $n2 + $k ] + $d )->conj() ;
	}

	#-------------------------------
	# 
	# 複素数列をフーリエ逆変換
	#
	#-------------------------------
	my $zb = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		$zb->[ $i ] = complex( 0 ) ;
		foreach my $j ( 0 .. ( $n2 - 1 ) ) {
			my $k = ( $i * $j * 2 ) % $n ;
			$zb->[ $i ] += ( $za->[ $j ] * $w->[ $k ] ) ;
		}
		$zb->[ $i ] /= $n2 ;
	}
	undef $za ;

	#-------------------------------
	#
	# 実数列に戻す。
	#
	#-------------------------------
	$z = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		my( $re , $im ) = $zb->[ $i ]->as_array() ;
		push( @{ $z } , $re->round( 0 ) , $im->round( 0 ) ) ;
	}
	undef $zb ;

	#-----------------------------------------------------------------------
	#
	# ホーナー法を用いて戻り値を得る。
	#
	#-----------------------------------------------------------------------
	my $hd = $#{ $z } ;	# 添え字の最大値 == 最高位次数
	my $r = $z->[ $hd ] ;
	foreach my $i ( reverse ( 0 .. ( $hd - 1 ) ) ) {
		$r = $r * INT_BASE + $z->[ $i ] ;
	}

	return $r ;
}

=head2 nmult

'nmult' is the one of a kind of 'multiplication' mehtod.

This method is implemented using by 'Number Theoretic Transform' method. 

It supports unsigned integer multiplication, only.

'nmult' is also costly calculation, but it is faster than 'fmult'.

In some cases, this method return a incorrect value.

Note:

  The 'Number Theoretic Transform' is derived from the FFT.

  The FFT is the calculation of the 'complex plane'.
  The 'Number Theroetic Transform' is based on the 'Modular arithmetic'.	

  The values of the complex plane has a periodicity based on PI.
  The values on the modular arithmetic also has a periodicity, but it based on 'modulus n'.
  The 'Number Theoretic Transform' is implemented using by this periodicity, and it need not complex values.
  It only uses integer values.

=cut

sub nmult {
	#-----------------------------------------------------------------------
	#
	# 数論変換 ( Number Theoretic Transform ) を用いた符号なし整数の乗算
	#
	#   FFT を用いた乗算に比べて数倍から十数倍高速。
	#   実数列フーリエ変換を用いた乗算と同等かその数倍速い。
	#   しかし、10 進数 100 x 100 桁程度の演算ではカラツバ法にも遥かに及ばない。
	#
	#   100 x 100 桁程度の演算では、通常の筆算に基づく乗算が圧倒的に速い。
	#   これは、筆算に基づく乗算が言語標準の演算機能のみで実装できているためと考えられる。
	#
	# 
	#   8 つの要素からなる数列を数論変換に掛ける場合、パラメーターの組み合わせの一つとして、
	#
	#     n0 == 2^17 , w == 20 , p == 164 * n + 1
	#
	#   を選択することができる。
	#
	#   要素数 n は、
	#
	#     n == 8 == 2^3
	#
	#   であり、ここから w^1 及び法 p の下でのモジュラー逆数 w^(-1) は、
	#
	#     w^1    == modexp( w , n0 / n , p )
	#            == modexp( 20 ,  2^14 , 21495809 )
	#            == modexp( 20 , 16384 , 21495809 )
	#            == 11038676
	#
	#     w^(-1) == modexp( w , p - 2 , p )
	#            == modexp( 11038676 , 21495807 , 21495809 )
	#            == 86864
	#
	#   を用いることができる。
	#
	#   この時、 w^k , ( w^(-1) )^k  ( k == 0 -> n ) を一覧表示すると以下のようになる。
	#
	#      k        w^k     w^(-k)   ( w^k * w^(-k) ) % p
	#     --+----------+----------+----------------------
	#      0          1          1                      1
	#      1   11038676      86864                      1
	#      2   21170272     325537                      1
	#      3   21408945   10457133                      1
	#      4   21495808   21495808                      1
	#      5   10457133   21408945                      1
	#      6     325537   21170272                      1
	#      7      86864   11038676                      1
	#      8          1          1                      1
	#
	#   これをフーリエ変換における回転因子の変わりに用いるのが数論変換の骨子。
	#
	#
	#   bits == int( ln( p ) / ln( 2 ) ) とした時、数列の要素 x[i] が
	#
	#     ( max( x[i] ) )^2 < 2^(bits)
	#
	#   である必要がある。
	#
	#
	#   数論変換による乗算は、フーリエ変換と酷似しており、
	#
	#     x * y == intt( ntt( x ) * ntt( y ) )
	#
	#   となる。 ( intt 内の乗算は数列の要素ごとの乗算。 )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	my $debug = 0 ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
		return undef			unless ( $_ > 0 ) ;
	}

	#
	# 定数
	#
	#   Decimal オブジェクトは基数を INT_BASE == 10^7 に設定しているため、
	#   int( ln( p ) / ln( 2 ) ) == 48 に設定している。
	#   
	#   -> 2^48 == 281,474,976,710,656 > 10^14 == ( 10^7 )^2
	#
	my( $n0 , $w , $p ) = ( 
		__PACKAGE__->new( '34359738368' )	, # 2^35
		__PACKAGE__->new( '360' )		, # 360
		__PACKAGE__->new( '285838663483393' )	, # 2^35 * 8319 + 1
	) ;

	#
	# x , y を数列に変換
	#
	if ( ref( $x ) ne 'ARRAY' or ref( $y ) ne 'ARRAY' ) {
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
			return undef			unless ( defined $_ ) ;
			return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
			return undef			unless ( $_->is_integer() ) ;
		}

		$x = __PACKAGE__->new( $x->as_string() ) ;
		$y = __PACKAGE__->new( $y->as_string() ) ;
		$x = [ @{ $x->{'val'} } ] ;
		$y = [ @{ $y->{'val'} } ] ;
	}

	#
	# 配列要素をオブジェクト化
	#
	while ( @{ $x } < @{ $y } ) { push( @{ $x } , 0 ) ; }
	while ( @{ $y } < @{ $x } ) { push( @{ $y } , 0 ) ; }

	foreach my $i ( 0 .. $#{ $x } ) {
		foreach ( $x , $y ) {
			$_->[ $i ] = __PACKAGE__->new( $_->[ $i ] ) ;
			return undef	unless ( defined $_->[ $i ] ) ;
			return undef	if ( $_->[ $i ] < 0 ) ;
			if ( $_->[ $i ] >= INT_BASE ) {
				my( $d , $m ) = $_->[ $i ]->divmod( INT_BASE , 0 ) ;
				if ( defined $_->[ $i + 1 ] )	{ $_->[ $i + 1 ] += $d ; }
				else				{ $_->[ $i + 1 ]  = $d ; }
				$_->[ $i ] = $m ;
			}
		}
	}

	#
	# 数列の要素数を調整
	#
	my $n = @{ $x } + @{ $y } ;
	$n = __PACKAGE__->new( $n ) ;
	return undef			unless ( defined $n ) ;

	unless ( $n->bin() =~ /^10+$/ ) {
		$n = __PACKAGE__->new( 2 )->power( $n->bits() ) ;	# n を 2 の冪に合わせる。
	}

	while ( @{ $x } < $n ) { push( @{ $x } , __PACKAGE__->new( 0 ) ) ; }
	while ( @{ $y } < $n ) { push( @{ $y } , __PACKAGE__->new( 0 ) ) ; }

	#
	# n の大きさに合わせて w を調整。
	#
	$w = $w->modexp( $n0 / $n , $p ) ;

	#
	# w^k のリストを作成。
	#
	my $wn = [] ;
	foreach my $i ( 0 .. ( $n - 1 ) ) {
		$wn->[ $i ] = $w->modexp( $i , $p ) ;
	}

	if ( $debug ) {
		print join( ' ' , @{ $x } ) , "\n" ;
		print join( ' ' , @{ $y } ) , "\n" ;
		print join( ' ' , $w , $n , $p ) , "\n" ; 
		my $w1 = $w->modexp( $p - 2 , $p ) ;
		foreach my $i ( 0 .. $n ) {
			printf( "%3s %15s %15s %3s\n" , 
				$i ,
				$w->modexp( $i , $p ) ,
				$w1->modexp( $i , $p ) ,
				( $w->modexp( $i , $p ) * $w1->modexp( $i , $p ) ) % $p ,
			) ;
		}
	}

	#-----------------------------------------------------------------------
	#
	# 正変換して要素同士の積を採る。
	#
	#   変換因子を
	#
	#     wn[k] == w^k 
	#
	#   で管理する。
	#
	#   wn[1] == w^1
	#   wn[k] == ( wn[1] )^k   % p
	#
	#   X == ntt( x )
	#   -> X[i] == Σ( x[j] * w^( ij ) ) ( mod p )              ( i == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#   Y == ntt( y )
	#   -> Y[i] == Σ( y[j] * w^( ij ) ) ( mod p )              ( i == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#   Z == X * Y
	#   -> Z[i] == X[i] * Y[i] ( mod p )                        ( i == 0 -> n - 1 )
	#
	#-----------------------------------------------------------------------
	my $zt = [] ;
	foreach my $i ( 0 .. ( $n - 1 ) ) {

		my $xt = __PACKAGE__->new( 0 ) ;
		my $yt = __PACKAGE__->new( 0 ) ;

		foreach my $j ( 0 .. ( $n - 1 ) ) {

			my $k = ( $i * $j ) % $n ;

			$xt += ( $x->[ $j ] * $wn->[ $k ] ) ;
			$yt += ( $y->[ $j ] * $wn->[ $k ] ) ;

			foreach ( $xt , $yt ) {
				$_ %= $p	if ( $_ >= $p ) ;
			}
		}

		$zt->[ $i ] = ( $xt * $yt ) % $p ;
	}

	#-----------------------------------------------------------------------
	#
	# 逆変換
	#
	#   wn[1] == w^(-1) == modexp( w^1 , totient( p ) - 1 , p )
	#                   == modexp( w^1 , p - 2 , p )
	#   wn[k] == ( wn[1] )^k   % p
	#
	#   z == intt( Z )
	#   -> z[i] == n^(-1) * Σ( Z[j] * w^( ij ) ) ( mod p )              ( i == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#-----------------------------------------------------------------------
	my $z = [] ;
	my $ni = $n->modexp( $p - 2 , $p ) ;	# n のモジュラー逆数 n^(-1) ( mod p )

	#
	# w^(-k) のリストを作成。
	#
	if ( $debug ) {
		print join( ' ' , @{ $wn } ) , "\n" ;
	}

	$wn = [ $wn->[0] , reverse( @{ $wn }[ 1 .. $#{ $wn } ] ) ] ;

	#
	# 変換
	#
	foreach my $i ( 0 .. ( $n - 1 ) ) {

		$z->[ $i ] = __PACKAGE__->new( 0 ) ;

		foreach my $j ( 0 .. ( $n - 1 ) ) {

			my $k = ( $i * $j ) % $n ;

			$z->[ $i ] += ( $zt->[ $j ] * $wn->[ $k ] ) ;
			$z->[ $i ] %= $p	if ( $z->[ $i ] >= $p ) ;
		}

		$z->[ $i ] *= $ni ;
		$z->[ $i ] %= $p	if ( $z->[ $i ] >= $p ) ;
	}

	if ( $debug ) {
		print join( ' ' , @{ $wn } ) , "\n" ;
		print join( ' '  , @{ $z } ) , "\n" ;
	}

	#
	# ホーナー法で復元
	#
	my $hd = $#{ $z } ;
	my $r = $z->[ $hd ] ;
	foreach my $i ( reverse( 0 .. ( $hd - 1 ) ) ) {
		$r = $r * INT_BASE + $z->[ $i ] ;
	}

	return $r ;
}

sub karatsuba {
	#-----------------------------------------------------------------------
	#
	# カラツバ法 ( Karatsuba algorithm ) による乗算
	#
	# 乗算によるコストが加減算のそれよりも遥かに大きい処理系において有効な方法。
	# 現在では、乗算と加減算のコストに大きな差はないとされており、カラツバ法の出番はなさそう。
	# ( Perl V5.8.9 の Benchmark の結果では、単純な乗算の方が概ね 10 倍速いと言う結果となった。 )
	#
	# カラツバ法では、乗算回数を 3/4 程度に減ずる効果がある一方、加減算の回数は飛躍的に増加する。
	# 加減算の増加によるトータルコストが乗算の削減効果を下回るケースでコスト削減の効果が出る。
	#
	# カラツバ法では乗数と被乗数を共に二分割して演算を行うが、三つ以上に分割して更に効果を挙げる方法も存在する。 ( Toom-Cook 法 )
	# ただし、分割数が増えるほど加減算に伴うコストが増えることもあり、最適な分割数を予め見積もる事はできないとされている。
	# Toom-Cook 法での現実的な分割数は 3 ～ 4 とのこと。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;
	croak( "invalid method call!!" ) 	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) ;
	if	( @args == 2 )	{ ( $x , $y ) = @args ; }
	elsif	( @args == 1 )	{ ( $x , $y ) = ( $self->copy() , $args[0] ) }
	else {
		croak( "invalid method call!!" ) ;
	}

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;

	croak( "unexpected error!!" )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	croak( "unexpected error!!" )	unless ( ref( $y ) eq __PACKAGE__ ) ;

	#
	# 桁数が小さければ通常の演算を行う。
	#
	my( $xdig , $ydig ) = ( $x->digits() , $y->digits() ) ;
	if ( $xdig == 1 or $ydig == 1 ) {
		return $x->multiply( $y ) ;
	}

	#
	# 符合と小数点の位置を抑えて整数化する。
	#
	my $sgn = $x->{'sgn'} * $y->{'sgn'} ;
	my $dlen = $x->{'dlen'} + $y->{'dlen'} ;

	foreach ( $x , $y ) {
		$_->{'sgn'} = 1 ;
		$_->{'dlen'} = 0 ;
	}

	#
	# 桁数が多い方を基準として偶数桁になるよう桁数を設定する。
	#
	my $digits = ( sort { $a <=> $b } ( $xdig , $ydig ) )[1] ;
	$digits += 1	if ( ( $digits & 1 ) == 1 ) ;

	#
	# 上位桁と下位桁に分離
	#
	my $hdig = ( $digits >> 1 ) ;

	my $flg = 1 ;
	if ( $flg == 0 ) {
		my @xv = @{ $x->{'val'} } ;
		my @yv = @{ $y->{'val'} } ;

		$x = [ __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) ] ;
		$x->[1]->{'val'} = [ @xv[ $hdig .. $#xv ] ] ;
		$x->[0]->{'val'} = [ @xv[ 0 .. ( $hdig - 1 ) ] ] ;
		
		$y = [ __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) ] ;
		$y->[1]->{'val'} = [ @yv[ $hdig .. $#yv ] ] ;
		$y->[0]->{'val'} = [ @yv[ 0 .. ( $hdig - 1 ) ] ] ;
		
		foreach ( @{ $x } , @{ $y } ) {
			my $v = \@{ $_->{'val'} } ;
			if ( @{ $v } < 1 ) {
				$v->[0] = 0 ;
			}
			else {
				foreach ( @{ $v } ) {
					$_ = 0	unless ( defined $_ ) ;
				}
				while ( @{ $v } > 1 and $v->[-1] == 0 ) {
					pop( @{ $v } ) ;
				}
			}
		}
	}
	else {
		$x = [ $x->dsplit( $hdig ) ] ;
		$y = [ $y->dsplit( $hdig ) ] ;
		if ( @{ $x } < 2 ) { push( @{ $x } , __PACKAGE__->new( 0 ) ) ; }
		if ( @{ $y } < 2 ) { push( @{ $y } , __PACKAGE__->new( 0 ) ) ; }
	}

	#
	# カラツバ法による再帰処理
	#
	# 二つの整数 x , y が基数 r の下で
	#
	#   x == ar + b
	#   y == cr + d
	#
	# と分解できることから、 x , y の乗算は、
	#
	#   x * y == ( ar + b ) * ( cr + d )
	#         == ac * r^2 + ( ad + bc ) * r + bd
	#
	# ( ad + bc ) は、
	#
	#   ad + bc  == ( ad + bc ) + ( ac + bd ) - ( ac + bd )
	#            == ( ac + bd ) - ( a - b ) * ( c - d )
	#
	# と変換できるので、
	#
	#   x * y == ( ar + b ) * ( cr + d )
	#         == ac * r^2 + ( ad + bc ) * r + bd                          .... [1] 
	#         == ac * r^2 + ( ac + bd - ( a - b ) * ( c - d ) ) * r + bd  .... [2]
	#
	# [1] は、通常の乗算処理であり、基数 r の下での 2 桁の筆算を意味している。
	# [2] は、基数 r の下での 2 桁の乗算をカラツバ法で表現したものとなる。
	# 基数 r の冪での乗算によるコストはどちらも同じであり、実装によってシフト演算で置き換えることができる。
	# 残る乗算は、
	# [1] のケースで ac , ad , bc , bd の 4 種類。
	# [2] のケースでは ac , bd , ( a - b ) * ( c - d ) の 3 種類
	# となる。
	#
	# [2] のケースでは ac と bd が 2 回現われるが、予め計算した結果を使い回すことができる。
	# [2] の演算で現われる 3 種類の乗算は、再帰処理によって、より桁数の小さい演算に落とし込むことができる。
	# 結果、カラツバ法による乗算では、乗算の回数を 3/4 程度に減ずる効果があるとされている。
	#
	# 加減算の回数は
	# [1] のケースで 3 回。
	# [2] のケースで 6 回。
	# 乗算、加減算共に桁数が大きくなるにつれて回数が増加するため、桁数が大きくなるにつれて加減算によるコストの増加が全体のコストを引き上げる結果となる可能性がある。
	# 乗算と加減算のコストに大きな差が無い場合や、乗数と被乗数のどちらかが非常に小さい値である場合には、カラツバ法は逆効果となる可能性がある。
	#
	my $z = [] ;
	$z->[2] = karatsuba( $x->[1] , $y->[1] ) ;
	$z->[0] = karatsuba( $x->[0] , $y->[0] ) ;
	$z->[1] = $z->[2] + $z->[0] - ( karatsuba( ( $x->[1] - $x->[0] ) , ( $y->[1] - $y->[0] ) ) ) ;

	#my $r = $z->[2]->_shiftup( $hdig * 2 ) + $z->[1]->_shiftup( $hdig ) + $z->[0] ;
	my $r = $z->[2] ;
	foreach my $i ( 1 , 0 ) {
		$r = $r->_shiftup( $hdig ) + $z->[ $i ] ;
	}

	#
	# 符号と小数点の位置を復元
	#
	$r->{'sgn'} *= $sgn ;
	$r->{'dlen'} = $dlen ;
	$r->{'dirty'} = 1 ;
	$r->_regulate() ;

	return $r ;
}

=head2 power( $p [ , $max_prec ] ) ;

 Return $x ** $p                 if ( $p->is_integer() ) ;
 Return exp( ln( $x ) * $p )     if ( $p->is_decimal() ) ;

  my $x = decimal( 10 ) ;
  my $y = decimal( 2 ) ;
  print $x ** $y ;                     # 100
  print $x ** 3 ;                      # 1000
  print $x->power( $y ) ;              # 100

  print $x->power( 0.1 ) ;             # 1.2589254117941672104239541063958006060936
  print $x->power( 0.1 , 3 ) ;         # 1.258

=cut

sub power {
	#-----------------------------------------------------------------------
	#
	# 冪乗
	#
	#-----------------------------------------------------------------------
	my( $n , $p , $dlen ) = @_ ;
	return undef	unless ( ref( $n ) eq __PACKAGE__ ) ;

	unless ( ref( $p ) eq __PACKAGE__ ) {
		$p = __PACKAGE__->new( $p ) ;
		return undef	unless ( defined $p ) ;
	}

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# 指数が整数や小数でない場合
	#
	if ( $p->is_complex() ) {
		#
		# 指数が複素数の場合
		#
		return $n->complex()->power( $p ) ;
	}
	elsif ( $p->is_fraction() ) {
		#
		# 指数が分数の場合
		#
		#   分子で冪を採り、分母で根を採ればよい。
		#   ただし、通分した状態で分子分母の桁数が大きいと演算コストが大きくなる。
		#   この場合は小数に変換して指数関数を使用するのが無難。 ( ただし、演算誤差は大きくなる。 )
		#
		my( $numer , $denom ) = ( $p->numerator() , $p->denominator() ) ;
		if ( $numer < 10000 and $denom < 100 ) {
			return $n->power( $numer )->root( $denom ) ;
		}
		else {
			$p = $p->decimal() ;
		}
	}

	unless ( $p->is_decimal() ) {
		return undef	unless ( $p->can_decimal() ) ;
		$p = $p->decimal() ;
	}

	#
	# 指数が負の場合
	#
	if ( $p->{'sgn'} < 0 ) {
		my $d = $n->power( $p->abs() , $dlen ) ;
		return fraction( 1 , $d )	if ( defined $d and ! $d->is_zero() ) ;
		return undef ;
	}

	#
	# 主処理
	#
	my $obj = undef ;

	if ( $p->is_zero() ) {
		return __PACKAGE__->new( 1 ) ;
	}
	elsif ( $p->is_integer() ) {
		#
		# $p は正の整数。
		#

		#
		# $n == 0 , 1 or -1 の場合。
		#
		return __PACKAGE__->new( 0 )	if ( $n->is_zero() ) ;
		return __PACKAGE__->new( 1 )	if ( $n == 1 ) ;

		if ( $n == -1 ) {
			my $obj = ( $p->is_even() )
				? __PACKAGE__->new( 1 )
				: __PACKAGE__->new( '-1' )
			;
			return $obj ;
		}

		#
		# $n == 10 の場合
		#
		return $n->_decshiftup( $p - 1 )	if ( $n == 10 ) ;

		#
		# 冪乗算
		#
		# 指数を 2 進数に変換し、下位の桁から評価していく。
		# 指数の各ビットにおける $n の冪を求めながら処理を進め、
		# ビットが立っている位置で 1 ステップ前の $n の冪を戻り値に反映する。
		#
		$obj = __PACKAGE__->new( 1 ) ;
		my $npow = $n->copy() ;
		foreach my $bit ( $p->radix_to( 2 ) ) {
			if ( $bit == 1 ) {
				$obj = $obj->bmult( $npow ) ;
			}
			$npow = $npow->bmult( $npow ) ;
		}
	}
	else {
		#
		# p が小数の場合
		#
		#   自然対数を用いて演算
		#
		#     n^p == e^( ln( n^p ) )                e はネイピア数
		#         == exp( ln( n^p ) )
		#         == exp( ln( n ) * p )
		#
		$obj = $n->ln()->multiply( $p )->exp( $dlen ) ;
	}

	return $obj ;
}

=head2 root( $p [ , $max_prec ] ) ;

Return $x ** ( 1 / $p ) ;

  $x = decimal( 2 ) ;
  print $x->root( 2 ) ;                  # 1.4142135623730950488016887242096980785696
  print $x->root( 2 , 3 ) ;              # 1.414

=cut

sub root {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	#-----------------------------------------------------------------------
	my( $x , $p , $dlen ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return __PACKAGE__->new( 0 )				if ( $x->is_zero() ) ;		# root( 0 ,  n ) == 0
	return __PACKAGE__->new( 1 )				if ( $p == 0 ) ;		# root( x ,  0 ) == 1
	return $x->copy()					if ( $x == 1 or $p == 1 ) ;	# root( 1 ,  n ) == 1 or root( x , 1 ) == x
	return fraction( 1 , $x )->root( $p * ( -1 ) )		if ( $p < 0 ) ;			# root( x , -n ) == root( 1 / x , n )

	return undef	if ( $x < 0 and __PACKAGE__->new( $p )->is_even() ) ;			# root( -x , n ) == undef		if ( n & 1 == 0 )
												# root( -x , n ) == -1 * root( x , n )	if ( n & 1 == 1 )

	#$dlen = ( defined $dlen ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$p = __PACKAGE__->new( $p )	unless ( ref( $p ) eq __PACKAGE__ ) ;

	my $r = undef ;

	if ( $p->is_integer() and $p < 5 ) {
		$r = $x->root_n( $p , $dlen ) ;			# ニュートン法
	}
	else {
		$r = $x->power( $p->inverse() , $dlen ) ;	# 指数の逆数の冪
	}

	return $r->round_down( $dlen ) ;
}

sub root_n {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	# ニュートン法で近似する。
	#
	# 不定 ( NaN ) や発散 ( +∞ or -∞ ) には対応していない。
	#
	#-----------------------------------------------------------------------
	my( $x0 , $p , $dlen ) = @_ ;

	return undef	unless ( ref( $x0 ) eq __PACKAGE__ ) ;

	#$x0 = __PACKAGE__->new( $x0->value() ) ;

	return __PACKAGE__->new( 0 )				if ( $x0->is_zero() ) ;		# root( 0 ,  n ) == 0
	return __PACKAGE__->new( 1 )				if ( $p == 0 ) ;		# root( x ,  0 ) == 1
	return $x0->copy()					if ( $x0 == 1 or $p == 1 ) ;	# root( 1 ,  n ) == 1 or root( x , 1 ) == x
	return fraction( 1 , $x0 )->root_n( $p * ( -1 ) )	if ( $p < 0 ) ;			# root( x , -n ) == root( 1 / x , n )

	return undef	if ( $x0 < 0 and __PACKAGE__->new( $p )->is_even() ) ;			# root( -x , n ) == undef		if ( n & 1 == 0 )
												# root( -x , n ) == -1 * root( x , n )	if ( n & 1 == 1 )
	$p = __PACKAGE__->new( $p )	unless ( ref( $p ) eq __PACKAGE__ ) ;

	#
	# $p が小数の場合
	#
	#   $p の逆数を取って冪を採る。
	#
	if ( $p->{'dlen'} > 0 ) {
		return $x0->power( $p->inverse() , $dlen ) ;
	}

	#
	# ニュートン法による近似計算
	#
	#   負の数の奇数冪根も正しく算出される。
	#
	#my $f	= sub { my $r = ( $_[0] ** $p ) - $x0 ;		return $r ; } ;		# $y == f( $x ) == $x ** $p - $x0
	#my $df	= sub { my $r = $p * ( $_[0] ** ( $p - 1 ) ) ;	return $r ; } ;		# $y == df( $x ) == $p * ( $x ** ( $p - 1 ) ) 

	my $try_count = 1000 ;
	#my $diff_stop = __PACKAGE__->new( 0.1 )->power( $DECIMAL_PART_LENGTH_LIMIT ) ;

	my $x = undef ;
	my $y = $x0->copy() ;
	#$dlen = ( defined $dlen ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	my $diff_stop = __PACKAGE__->new( 0.1 )->power( $dlen ) ;

	foreach ( 1 .. $try_count ) {
		$x = $y->copy() ;
		my $xpow = $x->power( $p - 1 ) ;			# $xpow == $x ** ( $p - 1 )
		my $df = $xpow->multiply( $p ) ;			# $y == df( $x ) == $p * ( $x ** ( $p - 1 ) ) == $xpow * $p
		my $f  = $xpow->multiply( $x )->subtract( $x0 ) ;	# $y ==  f( $x ) == $x ** $p - $x0 == ( $xpow * $x ) - $x0

		$y = $x - ( $f->divide( $df , $dlen + 5 ) ) ;		# $y == $x - ( f( $x ) / df( $x ) )

		last	if ( ( $x->subtract( $y )->abs() < $diff_stop ) ) ;
	}

	$y = $y->round_down( $dlen ) ;
	$y = __PACKAGE__->new( $y->value() ) ;

	return $y ;
}

sub root_m {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	# 冪根の逆数を用いた乗算。
	#
	#-----------------------------------------------------------------------
	my( $x , $n , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )		unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = 2					unless ( defined $n ) ;
	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $inv = $x->inverse_root( $n , $dlen * 4 ) ;
	my $r = $x->copy()->multiply( $inv->power( $n - 1 ) ) ;

	return $r->round_down( $dlen ) ;
}

=head2 sqrt( [ $max_prec ] ) 

Return $x ** ( 1/2 ) ;

  $x = decimal( 2 ) ;
  print $x->sqrt() ;                     # 1.4142135623730950488016887242096980785696
  print $x->sqrt( 3 ) ;                  # 1.414

=cut

sub sqrt {
	#-----------------------------------------------------------------------
	#
	# 平方根
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )		unless ( ref( $x ) eq __PACKAGE__ ) ;

	return $x->root( 2 , $dlen ) ;
}

sub ov_divide {
	#-----------------------------------------------------------------------
	#
	# 除算 ( オーバーロード用 )
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $swapped ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return __PACKAGE__->new( $n )->divide( $self )	if ( $swapped ) ;
	return $self->divide( $n ) ;
}

=head2 divide( $divisor [ , $max_prec ] )

Return $x / $divisor

Same to

  return ( $x->divmod( $divisor , $max_prec ) )[0] ;


  $x = decimal( 1 ) ;
  print $x / 3 ;                         # 0.3333333333333333333333333333333333333333
  print $x->divide( 3 ) ;                # 0.3333333333333333333333333333333333333333
  print $x->divide( 3 , 3 ) ;            # 0.333

=cut

sub divide {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	# 商を返す。
	#
	# 第一引数は除数。
	# 第二引数には小数点以下の有効桁数を指定することができる。
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$n = __PACKAGE__->new( $n )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $n ) and $n->is_complex() ) {
		return $self->complex()->divide( $n , $dlen ) ;
	}

	my @r = $self->divmod( $n , $dlen ) ;
	return $r[0] ;
}

=head2 modulus( $divisor )

Return $x % $divisor

Same to

  return ( $x->divmod( $divisor , 0 ) )[1] ;


  $x = decimal( 1 ) ;
  print $x % 3 ;                         # 1
  print $x->modulus( 3 ) ;               # 1

  $x = decimal( 10 ) ;
  print $x->modulus( 1.3 ) ;             # 0.9    ( 10 == 1.3 * 7 + 0.9 )

=cut

sub modulus {
	#-----------------------------------------------------------------------
	#
	# 剰余算
	#
	# 被除数から除数の整数倍を引いた残りを返す。
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = __PACKAGE__->new( $y )	if ( substr( ref( $y ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y ) and $y->is_complex() ) {
		croak( "unexpected error!!\n" ) ;
	}

	if ( $swapped ) {
		( $x , $y ) = ( __PACKAGE__->new( $y ) , $x ) ;
	}

	return $x->copy()		if ( $x->{'sgn'} > 0 and $x <  $y ) ;
	return __PACKAGE__->new( 0 )	if ( $x == $y ) ;

	my @r = $x->divmod( $y , 0 ) ;

	return $r[1] ;
	#return $x->subtract( $y * $r[0] ) ;
}

=head2 divmod( $divisor [ , $max_prec ] )

Return the quotient and the remainder.

The $max_prec will effect to the quotient, at first.
Then, it will reflect to the remainder. ( remainder == $x - ( quotient * $divisor ) )

  $x = decimal( 1 ) ;
  print join( ' ' , $x->divmod( 3 ) ) ;      # 0.3333333333333333333333333333333333333333 0.0000000000000000000000000000000000000001
  print join( ' ' , $x->divmod( 3 , 3 ) ) ;  # 0.333 0.001

=cut

sub divmod {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	#   商と剰余を返す。
	#
	#   除算は正の整数同士の演算に変換して実装する。
	#
	#   商を小数に採る必要がある場合には、予め必要な有効桁数の分だけ非除数 x と除数 y を桁上げして整数化する。
	#   整数同士の除算が完了した後、桁数の調整を行う。
	#
	#   非除数 x と除数 y の符号が異なる場合には、正の整数同士の除算が完了した後、商 q を負の数に採る。
	#
	#   いずれの場合も剰余 r は、定義通り
	#
	#     r = x - q * y
	#
	#   とする。
	#
	#   二つの整数 x , y について x >= y > 0 , x と y の基数を B , 商を q 剰余を r とする。
	#
	#   ・基数 B の下で除数 y の最高次数が 0 の場合、
	#
	#     x == Σ( a[k] * B^k )              ( k == 0 -> n )
	#     y == b[0] * B^0
	#
	#     x の上位桁から順に除算、剰余算を繰り返す。
	#
	#       q[0] = int( a[n] / b[0] )
	#       r[0] = a[n] % b[0]
	#
	#       r[1] = r[0] * B + a[n-1]
	#       q[1] = q[0] * B + int( r[1] / b[0] )
	#       r[1] = r[1] % b[0]
	#       ......
	#       ......
	#       r[n] = r[n-1] * B + a[0]
	#       q[n] = q[n-1] * B + int( r[n] / b[0] )
	#       r[n] = r[n] % b[0]
	#
	#       q = q[n]
	#       r = r[n]
	#
	#   ・ x と y の桁数が同じ場合、
	#
	#     x == Σ( a[k] * B^k )              ( k == 0 -> n )
	#     y == Σ( b[k] * B^k )              ( k == 0 -> n )
	#
	#     商 q の近似値 ( 仮商 ) q[0] を以下のように採る。
	# 
	#       q[0] = int( a[n] / b[n] )
	#
	#     x と y は桁数が同じで x >= y の関係にあるため、
	#
	#       0 < q[0] < B
	#
	#     となり、実際の商である q が採りうる範囲は、
	#
	#                     B
	#       q[0] - int( ------ ) - 1 < q <= q[0]
	#                    b[n]
	#
	#     となる。
	#
	#     q の範囲が定まった後、 q と r を求める処理は以下のようになる。
	#
	#       q = q[0]
	#       r = 0
	#       qmin = q[0] - int( B / b[n] ) - 1
	#
	#       while ( q > qmin ) {
	#          r = x - q * y
	#          last if ( r >= 0 and r < y ) ;
	#          q -= 1
	#       }
	#
	#
	#   ・ x の桁数が y より 1 だけ大きい場合、
	#
	#     x == Σ( a[k] * B^k )              ( k == 0 -> n )
	#     y == Σ( b[j] * B^j )              ( j == 0 -> n - 1 )
	#
	#     仮商 q[0] と実際の商 q が採りうる範囲は以下のようになる。
	# 
	#                                                a[n] * B + a[n-1]
	#       a[n] >= b[n-1] の時、 B <= q[0] == int( ------------------- ) < B^2
	#                                                     b[n-1]
	#
	#                        B^2
	#         q[0] - int( -------- ) - 1 < q < q[0]
	#                      b[n-1]
	#
	#                                               a[n] * B + a[n-1]
	#       a[n] <  b[n-1] の時、 0 < q[0] == int( ------------------- ) < B
	#                                                    b[n-1]
	#
	#                        B 
	#         q[0] - int( -------- ) - 1 < q < q[0]
	#                      b[n-1]
	#
	#     この後の処理は前述のとおり。
	#
	#
	#   ・ x の桁数が y より 2 桁以上大きい場合、
	#
	#     x == Σ( a[k] * B^k )              ( k == 0 -> n )
	#     y == Σ( b[j] * B^j )              ( j == 0 -> m ; m < n - 1 )
	#
	#     剰余 r の初期値を以下のように設定する。
	#
	#       r = 0
	#       k = n
	#       while ( r < y ) {
	#         r = r * B + a[k]
	#         k -= 1
	#       }
	#
	#     この時、 r の桁数は y と同数か又は 1 だけ大きい桁数を持つ数値となる。
	#     この r を前述の処理の何れかにかけて仮の q' と r' を求め、これを取りまとめながら順次繰り返す。
	#
	#     桁数の差が 1 以内の除算を行う関数を _divmod( x , y ) と定義すると、全体の処理は以下のようになる。
	#
	#       q = 0
	#       r = 0
	#       k = n
	#
	#       while ( k >= 0 ) {
	#         q = q * B
	#         r = r * B + a[k]
	#         if ( r >= y ) {
	#           ( q' , r' ) = _divmod( r , y )
	#           q += q'
	#           r = r'
	#         }
	#         k -= 1
	#       }
	#
	#-----------------------------------------------------------------------
	my( $x0 , $y0 , $dlen ) = @_ ;
	return ()	unless ( ref( $x0 ) eq __PACKAGE__ ) ;

	$y0 = __PACKAGE__->new( $y0 )	if ( substr( ref( $y0 ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y0 ) and $y0->is_complex() ) {
		croak( "unexpected error!!\n" ) ;
	}

	$x0 = $x0->copy() ;

	if ( ref( $y0 ) eq __PACKAGE__ )	{ $y0 = $y0->copy() ; }
	else					{ $y0 = __PACKAGE__->new( $y0 ) ; }

	croak( "Division by zero.\n" )					if ( $y0->is_zero() ) ;
	return ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) )	if ( $x0->is_zero() ) ;

	#
	# 絶対値を採る。
	#
	my $x = $x0->abs() ;
	my $y = $y0->abs() ;

	#
	# 被除数を 10 の冪で桁上げ。
	#
	my $x_dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$x = $x->_decshiftup( $x_dlen ) ;

	#
	# 除数が小数であれば被除数と除数を 10 の冪で桁上げ。
	#
	my $y_dlen = $y0->decimal_digits() ;
	if ( $y_dlen > 0 ) {
		$x = $x->_decshiftup( $y_dlen ) ;
		$y = $y->_decshiftup( $y_dlen ) ;
	}

	#
	# 非除数 x の小数部を切り捨てる。
	#
	#   桁上げによって必要な桁数は確保されているので小数部は切り捨てる。
	#
	$x = $x->integer() ;

	#
	# x , y を検査
	#
	foreach ( $x , $y ) {
		$_->_regulate()	if ( $_->{'val'}->[-1] == 0 ) ;
	}

	#
	# 正の整数同士の除算
	#
	my @r = (
		__PACKAGE__->new( 0 ) ,		# 商
		__PACKAGE__->new( 0 ) ,		# 剰余
	) ;

	if ( $x < $y ) {
		#
		# 非除数 x が除数 y よりも小さければ、商は 0 剰余は x となる。
		#
		$r[1] = $x->copy() ;
	}
	elsif ( $y == 1 ) {
		#
		# y が 1 であれば商は x , 剰余は 0。
		#
		$r[0] = $x->copy() ;
	}
	elsif ( @{ $y->{'val'} } < 2 ) {
		#
		# 除数が十分に小さければ、係数列の除算を行う。
		#
		#   多倍長整数オブジェクトの内部データは、基数を INT_BASE とする一変数 n 次多項式の係数列で構成されている。
		#   基数 INT_BASE は、これを二乗した値が言語標準の数値において桁あふれなく表現できる値に設定されている。
		#
		#   よって、除数 $y が言語標準の数値として桁あふれなく表現できる整数値であれば、係数列の除算を用いることができ、
		#   係数列の除算は言語標準の除算と剰余算のみを用いて実装することができる。
		#
		#     x == Σ( a[k] * B^k )        ( k == 0 -> n )
		#     y == b[0] * B^0
		#
		#     q == int( x / y ) == Σ( c[k] * B^k )        ( k == 0 -> n )
		#     r == 0
		#
		#     -> c[k] == int( r * B + a[k] / b[0] )        ( k == n -> 0 )
		#        r    == ( r * B + a[k] )  % b[0]
		#
		#     -> divmod( x , y ) == ( q , r )
		#
		my $m = 0 ;
		my $divisor = $y->value() ;
		my $dig = $#{ $x->{'val'} } ;
		foreach my $i ( reverse( 0 .. $dig ) ) {
			my $v = $m * INT_BASE + $x->{'val'}->[ $i ] ;
			$r[0]->{'val'}->[ $i ] = CORE::int( $v / $divisor ) ;
			$m = $v % $divisor ;
		}
		$r[0]->_regulate() ;
		$r[1] = __PACKAGE__->new( $m ) ;
	}
	elsif ( ( @{ $x->{'val'} } - @{ $y->{'val'} } ) < 2 ) {
		#
		# 正の整数同士の除算
		#
		#   x と y の桁数の差が 1 以下の場合、 _divmod メソッドに直接引き渡すことができる。
		#
		@r = $x->_divmod( $y ) ;
	}
	else {
		#
		# 正の整数同士の除算
		#
		#   上位桁から順に割っていく。
		#   ( ホーナー法による代入処理を行いながらモジュロ演算による引き戻しを行うようなイメージ。 )
		#
		#     x == Σ( a[k] * B^k )        ( k == 0 -> n )
		#
		#     q == 0
		#     r == a[n]
		#
		#     foreach ( k = n - 1 ; k >= 0 ; k -= 1 ) {
		#       r = r * B + a[k]
		#       q = q * B + int( r / y )
		#       r %= y
		#     }
		#
		#   同様の処理は _divmod にも組み込んであるが x の分解をここで行うことによって、
		#   無駄な再帰処理が抑制されることを期待している。
		#
		my @xv = @{ $x->{'val'} } ;

		@r = (
			__PACKAGE__->new( 0 ) ,
			__PACKAGE__->new( pop( @xv ) ) ,
		) ;

		while ( $r[1] < $y ) {
			last	if ( @xv < 1 ) ;
			$r[1] = $r[1]->_shiftup() + pop( @xv ) ;
		}

		@r = $r[1]->_divmod( $y ) ;

		while ( @xv ) {
			my( $qc , $rc ) ;
			$r[0] = $r[0]->_shiftup() ;
			$r[1] = $r[1]->_shiftup() + pop( @xv ) ;
			if ( $r[1] >= $y ) {
				( $qc , $rc ) = $r[1]->_divmod( $y ) ;
				$r[0] += $qc ;
				$r[1] = $rc ;
			}
		}
	}

	#
	# 符号に合わせて調整
	#
	if ( $x0->{'sgn'} ne $y0->{'sgn'} ) {
		$r[0]->{'sgn'} = -1 ;
		unless ( $r[1] == 0 )	{ $r[0] -= 1 ; }
	}

	#
	# 桁上げした分を再調整
	#
	$r[0] = $r[0]->_decshiftdown( $x_dlen ) ;
	$r[1] = $x0 - ( $r[0] * $y0 ) ;

	return @r ;
}

sub divmod_30 {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	#   商と剰余を返す。
	#
	#-----------------------------------------------------------------------
	my( $x0 , $y0 , $dlen ) = @_ ;
	return ()	unless ( ref( $x0 ) eq __PACKAGE__ ) ;

	$y0 = __PACKAGE__->new( $y0 )	if ( substr( ref( $y0 ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y0 ) and $y0->is_complex() ) {
		croak( "unexpected error!!\n" ) ;
	}

	$x0 = $x0->copy() ;

	if ( ref( $y0 ) eq __PACKAGE__ )	{ $y0 = $y0->copy() ; }
	else					{ $y0 = __PACKAGE__->new( $y0 ) ; }

	croak( "Division by zero.\n" )					if ( $y0->is_zero() ) ;
	return ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) )	if ( $x0->is_zero() ) ;

	#
	# 絶対値を採る。
	#
	my $x = $x0->abs() ;
	my $y = $y0->abs() ;

	#
	# 被除数を 10 の冪で桁上げ。
	#
	my $x_dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$x = $x->_decshiftup( $x_dlen ) ;

	#
	# 除数が小数であれば被除数と除数を 10 の冪で桁上げ。
	#
	my $y_dlen = $y0->decimal_digits() ;
	if ( $y_dlen > 0 ) {
		$x = $x->_decshiftup( $y_dlen ) ;
		$y = $y->_decshiftup( $y_dlen ) ;
	}

	#
	# 非除数 $x の小数部を切り捨てる。
	#
	#   桁上げによって必要な桁数は確保されているので小数部は切り捨てる。
	#
	$x = $x->integer() ;

	#
	# 正の整数同士の除算
	#
	my @r = (
		__PACKAGE__->new( 0 ) ,		# 商
		0 ,				# 剰余
	) ;

	if ( $x < $y ) {
		#
		# 非除数 x が除数 y よりも小さければ、商は 0 剰余は x となる。
		#
		$r[1] = $x->copy() ;
	}
	elsif ( @{ $y->{'val'} } < 2 ) {
		#
		# 除数が十分に小さければ、係数列の除算を行う。
		#
		#   多倍長整数オブジェクトの内部データは、基数を INT_BASE とする一変数 n 次多項式の係数列で構成されている。
		#   基数 INT_BASE は、これを二乗した値が言語標準の数値において桁あふれなく表現できる値に設定されている。
		#
		#   よって、除数 $y が言語標準の数値として桁あふれなく表現できる整数値であれば、係数列の除算を用いることができ、
		#   係数列の除算は言語標準の除算と剰余算のみを用いて実装することができる。
		#
		#     x == Σ( a[k] * B^k )        ( k == 0 -> n )
		#     y == b[0] * B^0
		#
		#     q == int( x / y ) == Σ( c[k] * B^k )        ( k == 0 -> n )
		#     r == 0
		#
		#     -> c[k] == int( r * B + a[k] / b[0] )        ( k == n -> 0 )
		#        r    == ( r * B + a[k] )  % b[0]
		#
		#     -> divmod( x , y ) == ( q , r )
		#
		my $m = 0 ;
		my $divisor = $y->value() ;
		my $dig = $#{ $x->{'val'} } ;
		foreach my $i ( reverse( 0 .. $dig ) ) {
			my $v = $m * INT_BASE + $x->{'val'}->[ $i ] ;
			$r[0]->{'val'}->[ $i ] = CORE::int( $v / $divisor ) ;
			$m = $v % $divisor ;
		}
		$r[0]->_regulate() ;
		$r[1] = __PACKAGE__->new( $m ) ;
	}
	else {
		#
		# $x の整数部の上位桁を取り出して $d とする。
		#
		#   桁上げによって必要な桁数は確保されているので、小数部は切り捨てることができる。
		#
		#   Decimal オブジェクトの内部表現は INT_BASE を基数とした一変数 n 次多項式の係数列を配列として格納したものとなっている。
		#   非除数 $x の係数列を上位桁から順に取り出しながら $d >= $y となる $x の上位桁 $d を生成する。
		#
		#   $d は $y と同じか 1 桁だけ大きな値であり、除算はこの $d に対してのみ行われる。
		#   除算の結果得られた剰余値 $m は、次の除算における非除数 $d の生成元となる。
		#
		my @xv = @{ $x->{'val'} } ;

		my( $d , $m ) = ( __PACKAGE__->new( pop( @xv ) ) , undef ) ;
		while ( $d < $y ) {
			last	if ( @xv < 1 ) ;
			$d = $d->_shiftup() + pop( @xv ) ;
		}

		#
		# $d を $y で除算し、商を戻り値 @r の初期値とする。
		#
		( $d , $m ) = $d->_divmod20( $y ) ;
		@r = ( $d , undef ) ;

		#
		# 同様の処理を $x の下位桁に対して繰り返す。
		#
		while ( @xv ) {
			#
			# 前回の剰余を桁上げしたものに $x の次の桁を加算して非除数とする。
			# 前回の処理までに導出された商 ( $r[0] ) も桁上げしておく。
			#
			$d = $m->_shiftup() + pop( @xv ) ;
			$r[0] = $r[0]->_shiftup() ;

			#
			# $d が十分に大きければ除算を行い、結果を $r[0] と $m に反映する。
			#
			if ( $d >= $y ) {
				( $d , $m ) = $d->_divmod20( $y ) ;
				$r[0] += $d ;
			}
		}

		#
		# 最終的に残った剰余値を $r[1] に格納。
		#
		$r[1] = $m ;

	}

	#
	# 符号に合わせて調整
	#
	if ( $x0->{'sgn'} ne $y0->{'sgn'} ) {
		$r[0]->{'sgn'} = -1 ;
		unless ( $r[1] == 0 )	{ $r[0] -= 1 ; }
	}

	#
	# 桁上げした分を再調整
	#
	$r[0] = $r[0]->_decshiftdown( $x_dlen ) ;
	$r[1] = $x0 - ( $r[0] * $y0 ) ;

	return @r ;
}

sub divmod_20 {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	# 商と剰余を返す。
	# 被除数の桁を一定の長さで区切りながら除算を行う。
	#
	#-----------------------------------------------------------------------
	my( $x0 , $y0 , $dlen ) = @_ ;
	return ()	unless ( ref( $x0 ) eq __PACKAGE__ ) ;

	$y0 = __PACKAGE__->new( $y0 )	if ( substr( ref( $y0 ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y0 ) and $y0->is_complex() ) {
		croak( "unexpected error!!\n" ) ;
	}

	$x0 = $x0->copy() ;

	if ( ref( $y0 ) eq __PACKAGE__ ) {
		$y0 = $y0->copy() ;
	}
	else {
		$y0 = __PACKAGE__->new( $y0 ) ;
	}

	croak( "Division by zero.\n" )					if ( $y0->is_zero() ) ;
	return ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) )	if ( $x0->is_zero() ) ;

	#
	# 絶対値を採る。
	#
	my $x = $x0->abs() ;
	my $y = $y0->abs() ;

	#
	# 被除数を 10 の冪で桁上げ。
	#
	my $x_dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$x = $x->_decshiftup( $x_dlen ) ;

	#
	# 除数が小数であれば被除数と除数を 10 の冪で桁上げ。
	#
	my $y_dlen = $y0->decimal_digits() ;
	if ( $y_dlen > 0 ) {
		$x = $x->_decshiftup( $y_dlen ) ;
		$y = $y->_decshiftup( $y_dlen ) ;
	}

	#
	# $x の整数部を分割 
	#
	# 桁上げによって必要な桁数は確保されているので小数部は不要。
	#
	$x = $x->integer() ;
	my $z = $x->_separate( $y ) ;		# $x を $y の桁数に合わせて分割した数列
	my $zdig = @{ $x->{'val'} } ;		# $x 全体の桁数

	#
	# 分割した非除数の上位桁を取り出し、残りの桁数を抑える。
	#
	my( $d , $m ) = ( pop( @{ $z } ) , undef ) ;
	$zdig -= @{ $d->{'val'} } ;		# $z に残っている桁数

	#
	# 取り出した上位桁を除算し、その結果で戻り値を初期化。
	#
	( $d , $m ) = $d->_divmod20( $y ) ;

	my @r = (
		$d->_shiftup( $zdig ) ,
		undef ,
	) ;

	#
	# 下位桁に対して同様の処理を繰り返す。
	#
	while ( @{ $z } ) {
		#
		# 残っている上位桁を取り出し、前回の剰余値を反映して非除数とする。
		#
		$d = pop( @{ $z } ) ;
		my $dig = @{ $d->{'val'} } ;
		$zdig -= $dig ;			# $z に残っている桁数

		$d += $m->_shiftup( $dig ) ;	# 今回の非除数

		#
		# 商と剰余を求めて $r に反映。
		#
		( $d , $m ) = $d->_divmod20( $y ) ;
		$r[0] += $d->_shiftup( $zdig ) ;
	}
	$r[1] = $m ;

	#
	# 符号に合わせて調整
	#
	if ( $x0->{'sgn'} ne $y0->{'sgn'} ) {
		$r[0]->{'sgn'} = -1 ;
		unless ( $r[1] == 0 )	{ $r[0] -= 1 ; }
	}

	#
	# 桁上げした分を再調整
	#
	$r[0] = $r[0]->_decshiftdown( $x_dlen ) ;
	$r[1] = $x0 - ( $r[0] * $y0 ) ;

	return @r ;
}

sub divmod_10 {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	# 商と剰余を返す。
	# 被除数の桁を一定の長さで区切りながら除算を行う。
	#
	#-----------------------------------------------------------------------
	my( $x0 , $y0 , $dlen ) = @_ ;
	return ()	unless ( ref( $x0 ) eq __PACKAGE__ ) ;

	$y0 = __PACKAGE__->new( $y0 )	if ( substr( ref( $y0 ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y0 ) and $y0->is_complex() ) {
		croak( "unexpected error!!\n" ) ;
	}

	$x0 = $x0->copy() ;

	if ( ref( $y0 ) eq __PACKAGE__ ) {
		$y0 = $y0->copy() ;
	}
	else {
		$y0 = __PACKAGE__->new( $y0 ) ;
	}

	croak( "Division by zero.\n" )					if ( $y0->is_zero() ) ;
	return ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 0 ) )	if ( $x0->is_zero() ) ;

	#
	# 絶対値を採る。
	#
	my $x = $x0->abs() ;
	my $y = $y0->abs() ;

	#
	# 被除数を 10 の冪で桁上げ。
	#
	my $x_dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$x = $x->_decshiftup( $x_dlen ) ;

	#
	# 除数が小数であれば被除数と除数を 10 の冪で桁上げ。
	#
	my $y_dlen = $y0->decimal_digits() ;
	if ( $y_dlen > 0 ) {
		$x = $x->_decshiftup( $y_dlen ) ;
		$y = $y->_decshiftup( $y_dlen ) ;
	}

	#
	# $x を分割
	#
	# 桁上げによって必要な桁数は確保されているので、整数部のみを処理する。
	#
	my $z = $x->integer()->_separate( $y ) ;

	#
	# 除算
	#
	my @r = (
		__PACKAGE__->new( 0 ) ,
		undef ,
	) ;

	while ( @{ $z } ) {
		#
		# 分割した被除数の上位桁を取り出して除算を行う。
		#
		my $dig = pop( @{ $z } ) ;
		my( $d , $m ) = $dig->_divmod20( $y ) ;

		#
		# 商を抑える。
		#
		my $p = 0 ;
		foreach ( @{ $z } ) {
			$p += @{ $_->{'val'} } ;
		}
		$r[0] += $d->_shiftup( $p ) ;

		#
		# 剰余値を抑えた後、次の桁に反映。
		#
		$r[1] = $m->copy() ;
		if ( @{ $z } > 0 ) {
			my $p = @{ $z->[-1]->{'val'} } ;
			$z->[-1] += $m->_shiftup( $p ) ;
		}
	}

	#
	# 符号に合わせて調整
	#
	if ( $x0->{'sgn'} ne $y0->{'sgn'} ) {
		$r[0]->{'sgn'} = -1 ;
		unless ( $r[1] == 0 )	{ $r[0] -= 1 ; }
	}

	#
	# 桁上げした分を再調整
	#
	$r[0] = $r[0]->_decshiftdown( $x_dlen ) ;
	$r[1] = $x0 - ( $r[0] * $y0 ) ;

	return @r ;
}

sub divmod_00 {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	# 商と剰余を返す。
	# 除数を桁上げし、漸次桁下げしながら演算を行う。
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $dlen ) = @_ ;
	return ()	unless ( ref( $x ) eq __PACKAGE__ ) ;

	$x = $x->copy() ;

	$y = __PACKAGE__->new( $y )	if ( substr( ref( $y ) , 0 , 9 ) eq 'Math::Big' ) ;

	if ( ref( $y ) eq __PACKAGE__ ) {
		$y = $y->copy() ;
	}
	else {
		$y = __PACKAGE__->new( $y ) ;
	}

	croak( "Division by zero.\n" )		if ( $y->is_zero() ) ;

	#
	# 被除数を 10 の冪で桁上げ。
	#
	my $x_dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	$x *= _pow10( $x_dlen ) ;

	#
	# 除数が小数であれば被除数と除数を 10 の冪で桁上げ。
	#
	if ( $y->{'dlen'} > 0 ) {
		$x *= _pow10( $y->{'dlen'} ) ;
		$y *= _pow10( $y->{'dlen'} ) ;
	}

	#
	# 被除数と除数の絶対値を用いて演算を行い、その後符合を反映する。
	#
	my @r = (
		__PACKAGE__->new( 0 ) ,		# 最終的にここに商が格納される。
		$x->abs() ,			# 被除数 ( 最終的に剰余が残る。 )
	) ;
	my $amod = $y->abs() ;			# 除数

	if ( $r[1] >= $amod ) {
		my $p = 0 ;
		my $m = $amod->copy() ;

		#
		# 除数を桁上げし、桁上げした回数を抑えておく。
		#
		while ( $r[1] >= $m ) { $m = $m->_shiftup( 1 ) ; $p++ ; }

		#
		# 減算
		#
		while ( $m > $amod ) {
			#
			# 除数を被除数以下の最大値になるように桁下げする。 ( 小数点以下切捨て )
			#
			while ( $r[1] < $m ) { $m = $m->_shiftdown_integer( 1 ) ; $p-- ; }

			#
			# $m == $y * $d となる $d を抑える。
			# $d の総和が最終的な商となる。
			#
			my $d = __PACKAGE__->new( 1 )->_shiftup( $p ) ;

			#
			# $m を $r[1] から引けるだけ引き、それを @r に反映する。
			# これは同じ桁の中での商を求めてそれを戻り値に反映する処理となる。
			# オブジェクトの基数を $n とした場合、最大で ( $n - 1 ) 回のループが発生する。
			#
			#   while ( $r[1] >= $m ) { $r[0] += $d ; $r[1] -= $m ; }
			#
			# 基数が大きくなると単純な減算では性能が劣悪になるため、二分木法で絞り込んでから減算を行う。
			# 基数が 10^7 程度の大きさで除数が 2 の時、単純な減算では 5,000,000 回の減算が必要になることもある。
			# 二分木法で絞り込むと、20 ～ 30 回程度の試行で収束させることができる。
			#
			# 2 進数での桁上げ、桁下げを利用することで更に効率化できる余地はある。
			# ただし、冪乗算や基数変換でこのメソッドを利用しているため、ここでは採用していない。
			# ( 安易に実装すると Deep Recursion を誘発する可能性がある。 )
			#
			my @i = ( 1 , undef , INT_BASE ) ;
			while ( ( $i[2] - $i[0] ) > 1 ) {
				$i[1] = CORE::int( ( $i[0] + $i[2] ) / 2 ) ;
				my $div = $m * $i[1] ;
				if	( $r[1] > $div )	{ $i[0] = $i[1] ; }
				elsif	( $r[1] < $div )	{ $i[2] = $i[1] ; }
				else				{ last ; }
			}

			while ( $r[1] >= $m ) {
				if ( $r[1] >= ( $m * $i[1] ) ) {
					$r[0] += ( $d * $i[1] ) ;
					$r[1] -= ( $m * $i[1] ) ;
				}
				$i[1]-- ;
			}

			last	if ( $r[1] < $amod ) ;
		}
	}

	#
	# 符号に合わせて調整
	#
	if ( $x->{'sgn'} ne $y->{'sgn'} ) {
		$r[0]->{'sgn'} = -1 ;
		unless ( $r[1] == 0 )	{ $r[0] -= 1 ; }

		if ( $x->{'sgn'} > 0 )	{ $r[1] = $x + ( $r[0] * $y ) ; }	# $x > 0 and $y < 0
		else			{ $r[1] = $x - ( $r[0] * $y ) ; }	# $x < 0 and $y > 0
	}
	elsif ( $x->{'sgn'} < 0 )	{ $r[1] = $x + ( $r[0] * $y ) ; }	# $x < 0 and $y < 0

	#
	# 小数点の位置を反映
	#
	# 被除数を桁上げした分を戻す。
	#
	$r[0]->{'dlen'} += $x_dlen ;
	$r[1]->{'dlen'} += ( $x_dlen + $y->{'dlen'} ) ;

	return @r ;
}

=head1 'Decimal' object - Modular arithmetic operations

=cut

#-------------------------------------------------------------------------------
#
# 合同算術
#
#-------------------------------------------------------------------------------

=head2 modadd( $num , $modulus )

Return ( $x + $num ) % $modulus

  $x->modadd( $y , $m ) == ( $x + $y ) % $m
                        == ( ( $x % $m ) + ( $y % $m ) ) % $m

  print decimal( 10 )->modadd( 2 , 3 ) ;         # ( ( 10 % 3 ) + (   2 % 3 ) ) % 3 == ( 1 + 2 ) % 3 == 0
  print decimal( 1 )->modadd( -11 , 3 ) ;        # ( (  1 % 3 ) + ( -11 % 3 ) ) % 3 == ( 1 + 1 ) % 3 == 2

=cut

sub modadd {
	#-----------------------------------------------------------------------
	#
	# 合同式の加法
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $m ) = @_ ;

	foreach ( $x , $y , $m ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
	}

	my $r = ( ( $x % $m ) + ( $y % $m ) ) % $m ;

	return $r ;
}

=head2 modsubtract( $num , $modulus )

Return ( $x - $num ) % $modulus 

  $x->modsubtract( $y , $m ) == ( $x - $y ) % $m
                             == ( ( $x % $m ) - ( $y % $m ) ) % $m

  print decimal( 10 )->modsubtract( 2 , 3 ) ;         # ( ( 10 % 3 ) - (   2 % 3 ) ) % 3 == ( 1 - 2 ) % 3 == 2
  print decimal( 1 )->modsubtract( -11 , 3 ) ;        # ( (  1 % 3 ) - ( -11 % 3 ) ) % 3 == ( 1 - 1 ) % 3 == 0

=cut

sub modsubtract {
	#-----------------------------------------------------------------------
	#
	# 合同式の減法
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $m ) = @_ ;

	foreach ( $x , $y , $m ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
	}

	return $x->modadd( $y * ( -1 ) , $m ) ;
}

=head2 modmult( $num , $modulus )

Return ( $x * $num ) % $modulus 

  $x->modmult( $y , $m ) == ( $x * $y ) % $m
			 == ( ( $x % $m ) * ( $y % $m ) ) % $m

  print decimal( 10 )->modmult( 2 , 3 ) ;             # ( ( 10 % 3 ) * (   2 % 3 ) ) % 3 == ( 1 * 2 ) % 3 == 2
  print decimal( 1 )->modmult( -11 , 3 ) ;            # ( (  1 % 3 ) * ( -11 % 3 ) ) % 3 == ( 1 * 1 ) % 3 == 1

=cut

sub modmult {
	#-----------------------------------------------------------------------
	#
	# 合同式の乗法
	#
	#-----------------------------------------------------------------------
	my( $x , $n , $m ) = @_ ;

	foreach ( $x , $n , $m ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
	}

	my $r = ( ( $x % $m ) * ( $n % $m ) ) % $m ;

	return $r ;
}

=head2 moddivide( $num , $modulus )

Return ( $x / $num ) % $modulus 

  $x->moddivide( $y , $m ) == $x->modmult($y->modinverse($m), $m)

  print decimal( 10 )->moddivide( 2 , 3 ) ;           # 2
  print decimal( 1 )->moddivide( -11 , 3 ) ;          # 1

=cut

sub moddivide {
	#-----------------------------------------------------------------------
	#
	# 合同式の除法
	#
	#   moddiv(x, y, m) == modmult(x, modinverse(y, m), m)
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $m ) = @_ ;

	foreach ( $x , $y , $m ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
	}

	my $y_inv = $y->modinverse() ;
	my $r = (defined $y_inv) ? $x->modmult($y, $m) : undef ;

	return $r ;
}

=head2 modexp( $power , $modulus )

Return ( $x ** $power ) % $modulus  ( Modular exponentiation )

  $x = decimal( 10 ) ;
  print $x->modexp( 2 , 7 ) ;           # ( ( 10 % 7 ) * ( 10 % 7 ) ) % 7 == ( 3 * 3 ) % 7 == 2

The "modexp" can be defined as follows, using by binary method.

  10^2 % 7

  ->  $base = 10 % 7 ;   # == 3
      $p = 2 ;
      $m = 7 ;
      $r = 1 ;

      while ( $p > 0 ) {
          if ( ( $p & 1 ) == 1 ) { $r = ( $r * $base ) % $m ; }
          $base = ( $base * $base ) % $m ;
	  $p >>= 1 ;
      }
      return $r ;

In this method, "modexp" is implemented using by the left-to-right binary method.

  10^2 % 7

  ->  $base = 10 % 7 ;           # == 3
      @p == ( 1 , 0 ) ;          # 2 == 0b10 -> ( 1 , 0 )
      $m = 7 ;
      $r = 1

      foreach my $bit ( @p ) {
          $r = ( $r * $r ) % $m ;
          if ( $bit == 1 ) { $r = ( $r * $base ) % $m ; }
      }
      return $r ;


=cut

sub modexp {
	#-----------------------------------------------------------------------
	#
	# 冪剰余
	#
	#   合同式の乗法により、
	#
	#     10^2 % 7 == ( ( 10 % 7 ) * ( 10 % 7 ) ) % 7
	#              == ( 3 * 3 ) % 7
	#              == 2
	#
	#   右向きバイナリー法で上記の処理を行う場合、
	#
	#     p == 2 == 0b10
	#     m == 10 % 7 == 3 
	#     r == 1
	#
	#   というパラメーターを用いて、
	#
	#     1. p の各ビット毎に r = ( r * r ) % 7
	#     2. ビット == 1 の時、更に r = ( r * m ) % 7
	#
	#   と言う処理を繰り返す。
	#   これを処理すると、最初のビット ( == 1 ) で
	#
	#     r = ( r * r ) % 7 == ( 1 * 1 ) % 7 == 1
	#     r = ( r * m ) % 7 == ( 1 * 3 ) % 7 == 3
	#
	#   次のビット ( == 0 ) で
	#   
	#     r = ( r * r ) % 7 == ( 3 * 3 ) % 7 == 2
	#
	#   となる。
	#
	#   冪剰余演算では整数値のみをサポートすることとする。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $base , $pow , $mod ) ;
	if	( @args == 3 )	{ ( $base , $pow , $mod ) = @args ; }
	elsif	( @args == 2 )	{ ( $base , $pow , $mod ) = ( $self->copy() , @args ) ; }
	else			{ return undef ; }

	foreach ( $base , $pow , $mod ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $_ ) ;

		if ( $_->decimal_digits() > 0 ) {
			croak( $_ , " is not an integer value.\n" ) ;
		}
	}

	my $pow_bin = [ reverse( $pow->radix_to( 2 ) ) ] ;
	my $r = __PACKAGE__->new( 1 ) ;
	my $m = $base % $mod ;

	foreach my $bit ( @{ $pow_bin } ) {
		$r = ( $r ** 2 ) % $mod ;
		if ( $bit == 1 ) {
			$r = ( $r * $m ) % $mod ;
		}
		last	if ( $r->is_zero() ) ;
	}

	return $r ;
}

=head2 modinverse( $modulus )

Return Modular Multiplicative Inverse.

When $x , $y and $z are defined as follows,

  $z = $x->modinverse( $y ) ;

then

  ( $x * $z ) % $y == 1

This method will return this $z.

According to Euler's theorem,

  $x ** ( totient( $y ) ) % y == 1

  -> $x ** ( totient( $y ) - 1 ) % $y == -1

  -> $z == $x ** ( totient( $y ) - 1 )

totient() is called "Euler's totient function", and if $y is a prime number,

  totient( $y ) == $y - 1

then

  $z == $x ** ( totient( $y ) - 1 ) == $x ** ( $y - 2 ) ;         ( $y is prime )

If $y is not a prime number, 

  ( $x * $z ) % $y == 1
  -> ( $x * $z ) + ( $y * $w ) == 1

These $z and $w are unknown variables, but these are able to calculate through gcd( $x , $y ).

=cut

sub modinverse {
	#-----------------------------------------------------------------------
	#
	# モジュラー逆数 ( Modular Multiplicative Inverse )
	#
	#   オイラーの定理より、正の整数 x , y が互いに素である場合、
	#
	#     x^( totient( y ) ) ≡ 1 mod ( y )
	#
	#   が成立するとされる。
	#
	#   totient( y ) は、オイラーのトーシェント関数 ( Euler's totient function ) と呼ばれるものであり、
	#   オイラーの φ 関数 ( Euler's phi function ) やオイラーの関数とも呼ばれる。
	#   ( 数学上の表現としては φ( $n ) で表される。 )
	#
	#   この関数は、
	#
	#    「任意の正の整数 $n が与えられた時、 ( 1 .. n ) の範囲内に n と互いに素となる自然数が表れる数を返す関数」
	#
	#   と定義される。
	#
	#   n が合成数である場合、 totient( n ) を解くには効率的な素因数分解の手法が必須となる。
	#   このため、全ての正の整数に対してこの解を求めることは現実的には不可能である。
	#
	#   しかし、n が素数であれば ( 1 .. n - 1 ) の範囲の全ての整数が n と素になるため、
	#
	#     totient( n ) == n - 1
	#
	#   となる。
	#
	#
	#   オイラーの定理より、互いに素となる正の整数 x , y に対して、
	#
	#     x^( totient( y ) ) ≡ 1 ( mod y )
	#
	#  ここから、 y を法とする x の逆数 X は、以下のような合同式で表される。
	#
	#    x^( totient( y ) - 1 ) ≡ X ( mod y )
	#
	#
	#  y が素数の場合
	#
	#    y が素数であれば
	#
	#      totient( y ) == y - 1
	#
	#    よって、
	#
	#      x^( totient( y ) - 1 ) == x^( y - 2 ) ≡ X ( mod y )
	#
	#    合同式の対象律より、
	#
	#      X ≡ x^( y - 2 ) ( mod y )
	#      -> X == ( y * b + ( x^( y - 2 ) ) )
	#
	#      X は法 y における剰余でもあるので、
	#
	#        y * b ≡ 0 ( mod y )
	#
	#        -> X == ( y * b + ( x^( y - 2 ) ) ) % y
	#             == x^( y - 2 ) % y
	#
	#    となる。
	#    これは、単純な冪剰余演算であり、この解を求めることは容易い。
	#
	#
	#  y が合成数である場合
	#
	#    y が合成数である場合、 totient( y ) を求めるのは現実的ではない。
	#    x のモジュラー逆数を a とすると、
	#
	#      x * a ≡ 1 ( mod y )
	#      -> a * x + b * y == 1
	#
	#    拡張ユークリッドの互除法により、
	#
	#      a * x + b * y == 1
	#
	#      -> ( a , b ) == exgcd( x , y , 1 )
	#
	#    ここでは、 exgcd の第三引数を 1 とすることにより、 gcd( x , y ) == 1 を仮定している。
	#    この結果として、 非零の整数 a を求めることができれば、これがモジュラー逆数となる。
	#
	#    拡張ユークリッドの互除法を用いる場合、戻り値が負値となることもある。
	#
	#-----------------------------------------------------------------------
	croak( "Invalid arguments\n")   unless ( @_ == 2 ) ;

	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( defined $_ ) ;
	}

	my $r = undef ;

	if ( $y->integer_digits() <= 50 and $y->is_prime() ) {
		#
		# y が素数である場合
		#
		$r = modexp( $x , $y - 2 , $y ) ;
	}
	else {
		#
		# 拡張ユークリッドの互除法を用いる。
		#
		$r = ( exgcd( $x , $y , 1 ) )[0] ;
	}

	#
	# モジュラー逆数は絶対値非零の整数でなければらない。 ( 負値もあり得る。 )
	#
	return undef	unless ( defined $r ) ;
	return undef	unless ( $r->is_integer() ) ;
	return undef	if ( $r == 0 ) ;

	return $r ;
}

=head2 modfactorial( $modulus )

Return factorial( $x ) % $modulus

  n! % m == ( 1 * 2 * 3 * .... * ( n - 1 ) * n ) % m
         == ( ( 1 % m ) * ( 2 % m ) * ( 3 % m ) * .... * ( ( n - 1 ) % m ) * ( n % m ) ) %m

  If you define median and PI as follows,

    median = int( n / 2 ) + 1
    PI( a,b,c,d,e,.... ) == a * b * c * d * e * ......

  factorial( n ) is defined as follows.

    n! == median * PI( ( median + i ) * ( median - i ) )     ( i == 1 -> ( n - median ) )
       == median * PI( median^2 - i^2 )                      ( i == 1 -> ( n - median ) )

  then

    n! % m == ( median * PI( median^2 - i^2 ) ) % m                                 ( i == 1 -> ( n - median ) )
           == ( ( median % m ) * PI( ( ( median^2 % m ) - ( i^2 % m ) ) % m ) % m   ( i == 1 -> ( n - median ) )

=cut

sub modfactorial {
	#-----------------------------------------------------------------------
	#
	# 法 m の下での階乗
	#
	#   x' = int( x / 2 ) + 1
	#
	#   x! ≡ x' * Π( ( x' )^2 - i^2 ) ( mod m )       ( i == 1 -> ( x - x' ) ) )
	#
	#-----------------------------------------------------------------------
	my( $x , $m ) = @_ ;

	foreach ( $x , $m ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( $_->is_integer() ) ;
		return undef			if ( $_ < 1 ) ;
	}

	#
	# 言語標準の演算で実装する。
	#
	$x = $x->value() ;
	$m = $m->value() ;

	#
	# $m <= $x であれば $m は factorial( $x ) の因数であり、 factorial( $x ) % $m == 0
	#
	return __PACKAGE__->new( 0 )	if ( $m <= $x ) ;

	#
	# 階乗演算を行いながらモジュロを採る。
	#
	my $med  = int( $x / 2 ) + 1 ;
	my $med2 = $med * $med ;

	my $r = __PACKAGE__->new( 1 ) ;
	my $p2 = 0 ;
	foreach my $i ( 0 .. ( $x - $med ) ) {
		my $j = ( $i > 0 )
			? ( $med2 - ( $i * $i ) )
			: $med
		;

		#
		# j == 2^p * d に分解し、 j = d とする。 ( j は奇数値となる。 )
		#
		my $p = 0 ;
		if ( ( $j &  1 ) == 0 ) { $p = ntz( $j ) ; $j >>= $p->value() ; }

		$r *= $j ;
		$p2 += $p ;

		$r %= $m	if ( $r >= $m ) ;
	}

	#
	# 2 の冪の掛け戻しには modexp を使用する。
	#
	$r *= __PACKAGE__->new( 2 )->modexp( $p2 , $m ) ;
	$r %= $m	if ( $r >= $m ) ;

	return $r ;
}

=head2 crt( [ $x[0] , $m[0] ] , [ $x[1] , $m[1] ) , ... ] )

Return the answer of simultaneous congruences based on 'Chinese Remainder Theorem'.

  The arguments are recognized as follows.

    The all $m[n] has no common divisor within all other $m[n].
    ( gcd( @{ $m } ) == 1 )

    $y % $m[0] == $x[0] ;
    $y % $m[1] == $x[1] ;
    $y % $m[2] == $x[2] ;
    $y % $m[3] == $x[3] ;
    .......
    $y % $m[n] == $x[n] ;

  This method will return this $y. ( The all $y is a same value. )

  When @_ is ( [ 2 , 3 ] , [ 3 , 5 ] , [ 2 , 7 ] ) ,

    $y % 3 == 2
    $y % 5 == 3
    $y % 7 == 2

  At first, define $g and $a,$b,$c as follws.

    $g = 3 * 5 * 7 == 105

    ( ( $m / 3 ) * $a ) % 3 == ( 35 * $a ) % 3 == 1
    ( ( $m / 5 ) * $b ) % 5 == ( 21 * $b ) % 5 == 1
    ( ( $m / 7 ) * $c ) % 7 == ( 15 * $c ) % 7 == 1

    -> $a == modinverse( 35 , 3 ) == 2
       $b == modinverse( 21 , 5 ) == 1
       $c == modinverse( 15 , 7 ) == 1

  Then $y > 0 and the smallest $y is 

    $y == ( ( 2 * 35 * $a ) + ( 3 * 21 * $b ) + ( 2 * 15 * $c ) ) % $g
       == ( ( 2 * 35 * 2 ) + ( 3 * 21 * 1 ) + ( 2 * 15 * 1 ) ) % 105
       == ( 140 + 63 + 30 ) % 105
       == ( 35 + 63 + 30 ) % 105
       == 128 % 105
       == 23

  The $y can be a many other values, because we are in "Modular arithmetic" plane.     
  In general, the all this $y ( including 23 ) are defined as follows.

    $y == 105 * $k + 23     ( $k == 0 -> inf )
  
  This method will return the smallest one, only.

=cut

sub crt {
	#-----------------------------------------------------------------------
	#
	# 中国の剰余定理 ( Chinese Remainder Theorem )
	#
	#   「孫子算経」 ( 3 ～ 5 世紀に成立したとされる ) に記載された
	#   「 3 で割ると 2 余り、 5 で割ると 3 余り、 7 で割ると 2 余る数」の解法。
	#
	#   この解は、全ての除数が互いに素である場合に連立合同式の解として得られる。
	#
	#
	#   ここではガウスの方法 ( Gauss's algorithm ) に基づいた演算を行う。
	#
	#   「孫子算経」に示された問題を一般化して合同式で表すと、
	#
	#     x ≡ n[i] mod( m[i] )
	#
	#   となる。
	#
	#   この解法をガウスの方法で表すと、
	#
	#     M == Π( m[i] )
	#     M[i] == M / m[i]
	#     d[i] == M[i]^(-1) ( mod m[i] )
	#
	#     x ≡ Σ( n[i] * M[i] * d[i] ) ( mod M )
	#
	#   となる。
	#
	#
	#   「孫子算経」に示された問題を合同式で表すと、
	#
	#     x ≡ 2 ( mod 3 )
	#     x ≡ 3 ( mod 5 )
	#     x ≡ 2 ( mod 7 )
	#
	#   となる。
	#
	#   m = 3 * 5 * 7 == 105 とおき、以下の合同式を考える。
	#
	#     ( m / 3 ) * a == 35 * a ≡ 1 ( mod 3 )
	#     ( m / 5 ) * b == 21 * b ≡ 1 ( mod 5 )
	#     ( m / 7 ) * c == 15 * c ≡ 1 ( mod 7 )
	#
	#   a , b , c が採りうる解の内、最小のものを考えると、
	#
	#     35 * a ( mod 3 ) ≡ 2 * a ( mod 3 ) ≡ 1 ( mod 3 )   -> a == 2
	#     21 * b ( mod 5 ) ≡ 1 * b ( mod 5 ) ≡ 1 ( mod 5 )   -> b == 1
	#     15 * c ( mod 7 ) ≡ 1 * c ( mod 7 ) ≡ 1 ( mod 7 )   -> c == 1
	#
	#   が得られる。
	#
	#   この時、
	#
	#     a == 2 は、法 3 における 35 のモジュラー逆数 ( 35 * 2 ≡ 2 * 2 ( mod 3 ) ≡ 1 ( mod 3 ) )
	#     b == 1 は、法 5 における 21 のモジュラー逆数 ( 21 * 1 ≡ 1 * 1 ( mod 5 ) ≡ 1 ( mod 5 ) )
	#     c == 1 は、法 7 における 15 のモジュラー逆数 ( 15 * 1 ≡ 1 * 1 ( mod 7 ) ≡ 1 ( mod 7 ) )
	#
	#   であることを示しており、
	#
	#     x == ( 2 * 35 * a ) + ( 3 * 21 * b ) + ( 2 * 15 * c )
	#       == ( 2 * 35 * 2 ) + ( 3 * 21 * 1 ) + ( 2 * 15 * 1 )
	#       ≡ 140 + 63 + 30 ( mod 105 )
	#       ≡  35 + 63 + 30 ( mod 105 )
	#       ≡ 128           ( mod 105 )
	#       ≡  23           ( mod 105 )
	#
	#   として、条件を満たす x の x >= 0 における最小値 23 を得る。
	#
	#   この時、全ての解を示す x の一般化された式は、
	#
	#     x == 105 * k + 23       ( k は任意の整数 )
	#     
	#   となる。
	#
	#
	#   入力としての合同式のリストは、 n[k] を法 m[k] における合同数とし、
	#
	#     @_ = ( [ n[0] , m[0] ] , [ n[1] , m[1] ] , .... [ n[k] , m[k] ] )
	#
	#   で与えられるものとする。
	#
	#-----------------------------------------------------------------------
	my ( @args ) = @_ ;

	shift( @args )	if ( ref( $args[0] ) ne 'ARRAY' ) ;

	my $ma = [] ;
	foreach my $i ( 0 .. $#args ) {
		return undef	unless ( ref( $args[ $i ] ) eq 'ARRAY' ) ;
	
		$ma->[ $i ] = {
			'n'	=> __PACKAGE__->new( $args[ $i ]->[0] )	, # 合同数 ( residue ; remainder )
			'm'	=> __PACKAGE__->new( $args[ $i ]->[1] )	, # 法 ( modulus ; modulo )
		} ;
	}

	#
	# 法 m[i] の総積を採りながら、 m[i] が互いに素であることを確認する。
	#
	my $mx = __PACKAGE__->new( $ma->[0]->{'m'} ) ;
	foreach my $i ( 1 .. $#{ $ma } ) {
		return undef	unless ( $mx->gcd( $ma->[ $i ]->{'m'} ) == 1 ) ;
		$mx *= $ma->[ $i ]->{'m'} ;
	}

	#
	# 連立合同式を解く。
	#
	my $x = __PACKAGE__->new( 0 ) ;
	foreach my $i ( 0 .. $#{ $ma } ) {
		my $ref = \%{ $ma->[ $i ] } ;
		my $c = $mx / $ref->{'m'} ;			# 法の総積 / 法
		my $inv = $c->modinverse( $ref->{'m'} ) ;	# c のモジュラー逆数

		return undef	unless ( defined $inv ) ;

		$x += ( $ref->{'n'} * $c * $inv ) % $mx ;
		$x %= $mx	if ( $x >= $mx ) ;
	}

	return $x ;
}

=head1 'Decimal' object - shift operation and bitwise operation

=cut

#-------------------------------------------------------------------------------
#
# シフト演算
#
#-------------------------------------------------------------------------------

sub shiftup {
	#-----------------------------------------------------------------------
	#
	# 左シフト
	#
	#   基数の冪での乗算を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _shiftup( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer_part()	if ( $r->{'dlen'} > 0 ) ;
	return $r ;
}

sub shiftdown {
	#-----------------------------------------------------------------------
	#
	# 右シフト
	#
	#   基数の冪での除算を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _shiftdown( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer_part()	if ( $r->{'dlen'} > 0 ) ;
}

=head2 bitshiftup

Return $x << $n 

Same to $x->multiply( 2 ** $n )->integer()

  $x = decimal( 2 ) ;
  print $x << 1 ;                  # 4
  print $x->bitshiftup() ;         # 4

  print $x << 2 ;                  # 8
  print $x->bitshiftup( 2 ) ;      # 8

=cut

sub bitshiftup {
	#-----------------------------------------------------------------------
	#
	# 左ビットシフト
	#
	#   2 の冪での乗算を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _bitshiftup( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer() ;
}

=head2 bitshiftdown

Return $x >> $n 

Same to $x->divide( 2 ** $n )->integer()

  $x = decimal( 8 ) ;
  print $x >> 1 ;                  # 4
  print $x->bitshiftdown() ;       # 4

  print $x >> 2 ;                  # 2
  print $x->bitshiftdown( 2 ) ;    # 2

=cut

sub bitshiftdown {
	#-----------------------------------------------------------------------
	#
	# 右ビットシフト
	#
	#   2 の冪での除算を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _bitshiftdown( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer() ;
}

=head2 decshiftup( $n )

Return $x * ( 10 ** $n )

Same to $x->multiply( 10 ** $n )->integer()

=cut

sub decshiftup {
	#-----------------------------------------------------------------------
	#
	# 10 進数での左シフト
	#
	#   10 の冪での乗算に相当する処理を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _decshiftup( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer_part() ;
}

=head2 decshiftdown( $n )

Return $x / ( 10 ** $n )

Same to $x->divide( 10 ** $n )->integer()

=cut

sub decshiftdown {
	#-----------------------------------------------------------------------
	#
	# 10 進数での右シフト
	#
	#   10 の冪での除算に相当する処理を行い、整数部を返す。
	#
	#-----------------------------------------------------------------------
	my $r = _decshiftdown( @_ ) ;
	return undef	unless ( defined $r ) ;
	return $r->integer_part() ;
}

#-------------------------------------------------------------------------------
#
# ビット演算
#
#-------------------------------------------------------------------------------

=head2 bitnot

Return a bitwise NOT.

  $x = decimal( 20 ) ;

  print $x->bitnot() ;                                 # 11

  printf( "%5s" , $x->bin() ) ;                        # 10100
  printf( "%5s" ,  $x->bitnot()->bin() ) ;             #  1011

This operation sames to

  $x->complement(2) - 1

=cut

sub bitnot {
	#-----------------------------------------------------------------------
	#
	# BIT NOT
	#
	#   ビット反転操作であり、 1 を基数とする補数 ( 2 を基数とする補数 - 1 ) に等しい。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;

	my $r = $x->complement(1) ;

	return $r ;
}

=head2 bitor

Return a bitwise OR.

  $x = decimal( 20 ) ;
  $y = decimal( 10 ) ;

  print $x->bitor( $y ) ;                              # 30

  printf( "%5s" , $x->bin() ) ;                        # 10100
  printf( "%5s" , $y->bin() ) ;                        #  1010
  printf( "%5s" , $x->bitor( $y )->bin() ) ;           # 11110

=cut

sub bitor {
	#-----------------------------------------------------------------------
	#
	# BIT OR
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;
	#return undef			if ( $x < 0 or $y < 0 ) ;

	my( $xbin , $ybin ) = _adjust_bin( $x , $y ) ;

	my $r = '' ;
	foreach my $i ( 0 .. ( length( $xbin ) - 1 ) ) {
		my( $xbit , $ybit ) = ( substr( $xbin , $i , 1 ) , substr( $ybin , $i , 1 ) ) ;
		$r .= ( $xbit == 1 or $ybit == 1 ) ? 1 : 0 ;
	}

	$r = ( length( $r ) > 0 )
		? __PACKAGE__->convert( 2 , $r )
		: undef
	;

	return $r ;
}

=head2 bitxor

Return a bitwise XOR.

  $x = decimal( 20 ) ;
  $y = decimal( 4 ) ;

  print $x->bitxor( $y ) ;                             # 16

  printf( "%5s" , $x->bin() ) ;                        # 10100
  printf( "%5s" , $y->bin() ) ;                        #  1010
  printf( "%5s" , $x->bitxor( $y )->bin() ) ;          # 10000

=cut

sub bitxor {
	#-----------------------------------------------------------------------
	#
	# BIT XOR
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;
	#return undef			if ( $x < 0 or $y < 0 ) ;

	my( $xbin , $ybin ) = _adjust_bin( $x , $y ) ;

	my $r = '' ;
	foreach my $i ( 0 .. ( length( $xbin ) - 1 ) ) {
		my( $xbit , $ybit ) = ( substr( $xbin , $i , 1 ) , substr( $ybin , $i , 1 ) ) ;
		$r .= ( $xbit == $ybit ) ? 0 : 1 ;
	}

	$r = ( length( $r ) > 0 )
		? __PACKAGE__->convert( 2 , $r )
		: undef
	;

	return $r ;
}

=head2 bitand

Return a bitwise AND.

  $x = decimal( 20 ) ;
  $y = decimal( 4 ) ;

  print $x->bitand( $y ) ;                             # 4

  printf( "%5s" , $x->bin() ) ;                        # 10100
  printf( "%5s" , $y->bin() ) ;                        #   100
  printf( "%5s" , $x->bitand( $y )->bin() ) ;          #   100

=cut

sub bitand {
	#-----------------------------------------------------------------------
	#
	# BIT AND
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;
	#return undef			if ( $x < 0 or $y < 0 ) ;

	my( $xbin , $ybin ) = _adjust_bin( $x , $y ) ;

	my $r = '' ;
	foreach my $i ( 0 .. ( length( $xbin ) - 1 ) ) {
		my( $xbit , $ybit ) = ( substr( $xbin , $i , 1 ) , substr( $ybin , $i , 1 ) ) ;
		$r .= ( $xbit == 1 and $ybit == 1 ) ? 1 : 0 ;
	}

	$r = ( length( $r ) > 0 )
		? __PACKAGE__->convert( 2 , $r )
		: undef
	;

	return $r ;
}

=head2 bitcount

Return a number of bits, which bit is '1'.

  $x = decimal( 20 ) ;
  print $x->bitcount() ;                               # 2
  printf( "%5s" , $x->bin() ) ;                        # 10100

  $x = decimal( 25 ) ;
  print $x->bitcount() ;                               # 3
  printf( "%5s" , $x->bin() ) ;                        # 11001


If the integer value x is a 32 bits numeric value and x >= 0 ,

  c = x                                                         #                 1------8-------16------24------32
  c = ( c & 0x55555555 ) + ( ( c >>  1 ) &  0x55555555 ) ;	# 0x55555555 == 0b01010101010101010101010101010101
  c = ( c & 0x33333333 ) + ( ( c >>  2 ) &  0x33333333 ) ;	# 0x33333333 == 0b00110011001100110011001100110011
  c = ( c & 0x0f0f0f0f ) + ( ( c >>  4 ) &  0x0f0f0f0f ) ;	# 0x0f0f0f0f == 0b00001111000011110000111100001111
  c = ( c & 0x00ff00ff ) + ( ( c >>  8 ) &  0x00ff00ff ) ;	# 0x00ff00ff == 0b00000000111111110000000011111111
  c = ( c & 0x0000ffff ) + ( ( c >> 16 ) &  0x0000ffff ) ;	# 0x0000ffff == 0b00000000000000001111111111111111

Then, 

  c == bitcount( x ) 

This method supports an over 32 bits integer value.

=cut

sub bitcount {
	#-----------------------------------------------------------------------
	#
	# 正の整数を受け取り、 2 進数表記でビットが立っている個所の数を返す。
	#
	#   ここでは、多倍長整数をビット配列に変換し、 32 ビットずつに区切って変換を行う。
	#   これにより、負荷の高い処理を言語標準のビット演算に落とし込むことができる。
	#   結果は逐次 Decimal オブジェクトとして加算処理する。
	#
	#   ビット配列のビット長が 32 の倍数になっていない場合には、 0 パディングして桁を合わせる。
	#   ビットの数え上げ処理なのでパディングによる演算誤差は発生しない。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			unless ( $x >= 0 ) ;

	my $bin = $x->bin() ;
	my $r = __PACKAGE__->new( 0 ) ;

	while ( length( $bin ) > 0 ) {

		my $bits = '' ;
		if ( length( $bin ) >= 32 ) {
			( $bits , $bin ) = ( substr( $bin , 0 , 32 ) , substr( $bin , 32 ) ) ;
		}
		else {
			( $bits , $bin ) = ( $bin , '' ) ;
		}

		if ( length( $bits ) < 32 ) {
			my $pad = '0' x ( 32 - length( $bits ) ) ;
			$bits .= $pad ;
		}

		my $c = bin2dec( $bits )->value() ;				#                 1------8-------16------24------32
		$c = ( $c & 0x55555555 ) + ( ( $c >>  1 ) &  0x55555555 ) ;	# 0x55555555 == 0b01010101010101010101010101010101
	        $c = ( $c & 0x33333333 ) + ( ( $c >>  2 ) &  0x33333333 ) ;	# 0x33333333 == 0b00110011001100110011001100110011
	        $c = ( $c & 0x0f0f0f0f ) + ( ( $c >>  4 ) &  0x0f0f0f0f ) ;	# 0x0f0f0f0f == 0b00001111000011110000111100001111
	        $c = ( $c & 0x00ff00ff ) + ( ( $c >>  8 ) &  0x00ff00ff ) ;	# 0x00ff00ff == 0b00000000111111110000000011111111
	        $c = ( $c & 0x0000ffff ) + ( ( $c >> 16 ) &  0x0000ffff ) ;	# 0x0000ffff == 0b00000000000000001111111111111111

		$r += $c ;
	}

	return $r ;
}

=head2 msb

Return a MSB ( Most Significant Bit ).

  $x = decimal( 20 ) ;
  print $x->msb() ;                                    # 5  ( == length( '10100' ) )


If the integer value x is a 32 bits numeric value and x >= 0 ,

  c = x 
  c |= ( $c >>  1 )
  c |= ( $c >>  2 )
  c |= ( $c >>  4 )
  c |= ( $c >>  8 )
  c |= ( $c >> 16 )
  c |= ( $c >> 32 )
  c = bitcount( c ) - 1

Then,

  c == msb( x )

This method supports an over 32 bits integer value.

In this module,

  $x->msb() == length( $x->bin() ) - 1

=cut

sub msb {
	#-----------------------------------------------------------------------
	#
	# MSB ( Most Significant Bit )
	#
	#   正の整数を受け取り、最大ビットの位置を返す。
	#
	#   このモジュールでは、 bin メソッドが常に最短ビット長で結果を返すため、
	#
	#     $x->msb() == length( $x->bin() ) - 1 ;
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			unless ( $x >= 0 ) ;

	my $bin = $x->bin() ;
	my $r = __PACKAGE__->new( 0 ) ;

	while ( length( $bin ) > 0 ) {

		my $bits = '' ;
		if ( length( $bin ) >= 32 ) {
			( $bits , $bin ) = ( substr( $bin , 0 , 32 ) , substr( $bin , 32 ) ) ;
		}
		else {
			( $bits , $bin ) = ( $bin , '' ) ;
		}

		if ( length( $bits ) < 32 ) {
			my $pad = '0' x ( 32 - length( $bits ) ) ;
			$bits = $pad . $bits ;
		}

		my $c = bin2dec( $bits )->value() ;
		$c |= ( $c >>  1 ) ;
		$c |= ( $c >>  2 ) ;
		$c |= ( $c >>  4 ) ;
		$c |= ( $c >>  8 ) ;
		$c |= ( $c >> 16 ) ;
		$c |= ( $c >> 32 ) ;

		$r += bitcount( $c ) ;
	}

	return $r - 1 ;
}

=head2 lsb

Return a LSB ( Least Significant Bit ).

  $x = decimal( 20 ) ;
  print $x->msb() ;                                    # 2    ( 20 == 0x10100 )
                                                                          ~

If the integer value x is a 32 bits numeric value and x >= 0 ,

  c = x 
  c |= ( $c <<  1 )
  c |= ( $c <<  2 )
  c |= ( $c <<  4 )
  c |= ( $c <<  8 )
  c |= ( $c << 16 )
  c |= ( $c << 32 )

  c = 32 - bitcount( c ) ;

In this module,

  $x->lsb() == $x->ntz() 

=cut

sub lsb {
	#-----------------------------------------------------------------------
	#
	# LSB ( Least Significant Bit )
	#
	#   正の整数を受け取り、ビットが立っている最下端の位置を返す。
	#
	#   このモジュールでは、
	#
	#     $x->lsb() == $x->ntz()
	#
	#   となる。
	#   ( 両者の意味合いは異なるが、結果は同じ。)
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			unless ( $x >= 0 ) ;

	my $bin = $x->bin() ;
	my $r = __PACKAGE__->new( 0 ) ;

	while ( length( $bin ) > 0 ) {

		my $bits = '' ;
		if ( length( $bin ) >= 32 ) {
			( $bits , $bin ) = ( substr( $bin , 0 , 32 ) , substr( $bin , 32 ) ) ;
		}
		else {
			( $bits , $bin ) = ( $bin , '' ) ;
		}

		if ( length( $bits ) < 32 ) {
			my $pad = '0' x ( 32 - length( $bits ) ) ;
			$bits = $pad . $bits ;
		}

		my $c = bin2dec( $bits )->value() ;
		$c |= ( $c <<  1 ) ;
		$c |= ( $c <<  2 ) ;
		$c |= ( $c <<  4 ) ;
		$c |= ( $c <<  8 ) ;
		$c |= ( $c << 16 ) ;
		$c |= ( $c << 32 ) ;

		$r += 32 - bitcount( $c ) ;
	}

	$r += 32 ;

	return $r ;
}

=head2 ntz

Return a NTZ ( Number of Trailing Zero ).

  $x = decimal( 20 ) ;
  print $x->ntz() ;                                    # 2    ( 20 == 0x10100 )
                                                                           ~~

  x == 10 == 0b1010

    -> ~x == bitnot( x ) == 0b0101
       x - 1             == 0b1001
  
    -> ~x & ( x - 1 )    == 0b0001
                                 ~
    -> NTZ( x ) == 1

  x == 160 == 0b10100000

    -> ~x == bitnot( x ) == 0b01011111
       x - 1             == 0b10011111

    -> ~x & x - 1        == 0b00011111
                                 ~~~~~
    -> NTZ( x ) == 5

In this module,

  $x->ntz() == $x->bitnot()->bitand( $x - 1 )->bitcount() ;

            == $x->bin() =~ /(0+)$/ && length( $1 ) || 0 ;


=cut

sub ntz {
	#-----------------------------------------------------------------------
	#
	# NTZ ( Number of Trailing Zero )
	#
	#   正の整数を受け取り、 2 進数表記した時の末尾の連続した 0 の数を返す。
	#
	#   x == 10 == 0b1010
	#
	#     ~x == bitnot( x ) == 0b0101
	#     x - 1             == 0b1001
	#
	#     -> ~x & ( x - 1 ) == 0b0001
	#                               ~
	#     -> NTZ( x ) == 1
	#
	#   x == 160 == 0b10100000
	#
	#     ~x == bitnot( x ) == 0b01011111
	#     x - 1             == 0b10011111
	#
	#     -> ~x & x - 1     == 0b00011111
	#                               ~~~~~
	#
	#     -> NTZ( x ) == 5
	#
	#  これは以下の処理と等価。
	#
	#    $x->ntz() == $x->bin() =~ /(0+)$/ && length( $1 ) || 0
	#
	#  2 進数表記した時の先頭の連続した 0 の数を返す NLZ ( Number of Leading Zero ) という概念もあるが、
	#  このモジュールではビット長が不定であるため、これは実装していない。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( $x->is_integer() ) ;
	return undef			unless ( $x >= 0 ) ;

	my $r = $x->bitnot()->bitand( $x - 1 )->bitcount() ;

	return $r ;
}


=head1 'Decimal' object - inverse operation

=cut

#-------------------------------------------------------------------------------
#
# 逆数
#
#-------------------------------------------------------------------------------

=head2 inverse( [ $max_prec ] )

Return 1 / $x

Same to $x->inverse_root( 1 )

  print decimal( 3 )->inverse() ;           # 0.3333333333333333333333333333333333333333
  print decimal( 3 )->inverse( 3 ) ;        # 0.333

=cut

sub inverse {
	#-----------------------------------------------------------------------
	#
	# 逆数 ( == 1 乗根の逆数 )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )		unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	return $x->inverse_root( 1 , $dlen ) ;
}

=head2 inverse_root( $p [ , $max_prec ] )

Return 1 / $x->root( $p )

  print decimal( 9 )->inverse_root( 2 ) ;           # 0.3333333333333333333333333333333333333333 ( == 1/3 )
  print decimal( 9 )->inverse_root( 2 , 3 ) ;       # 0.333

=cut

sub inverse_root {
	#-----------------------------------------------------------------------
	#
	# n 乗根の逆数
	#
	#-----------------------------------------------------------------------
	my( $x , $n , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )		unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = 1					unless ( defined $n ) ;
	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	return undef	unless ( $n =~ /^\d+$/ ) ;

	return $x->copy()					if ( $n == 0 ) ;
	return __PACKAGE__->new( 1 )->divide( $x , $dlen )	if ( $n == 1 ) ;
	return __PACKAGE__->new( 1 )->divide( $x->root( $n , $dlen ) , $dlen ) ;
}

sub inverse_root_0 {
	#-----------------------------------------------------------------------
	#
	# n 乗根の逆数
	#
	# ニュートン・ラフソン法に基づき、漸化式を用いて近似する。
	#
	#   n == 1 の時、逆数となる。
	#   n  > 1 の時、n 乗根の逆数となる。
	#
	# x の n 乗根 root( x , n ) は、その逆数 inverse_root( x , n ) を用いて、
	#
	#   root( x , n ) == x * ( inverse_root( x , n ) ** ( n - 1 ) )
	#
	# で求められる。
	#
	#-----------------------------------------------------------------------
	my( $x , $n , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )		unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = 1					unless ( defined $n ) ;
	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $inv = __PACKAGE__->new( 0.1 ) ;		# 求める逆数の初期値
	my $one = __PACKAGE__->new( 1 ) ;		# 1
	my $inv_n = $one->divide( $n , $dlen ) ;	# $n の逆数

	my $diff_stop = __PACKAGE__->new( 0.1 )->power( $dlen + 1 ) ;

	#
	# abs( 1 - $x * $inv ) < 1 となる $inv を初期値とする。
	#
	while ( $x->multiply( $inv )->abs() >= 1 ) {
		$inv *= 0.1 ;
	}

	#
	# 以下の漸化式を用いて演算を行う。
	#
	#   $delta = 1 - ( $inv * $x )
	#   $inv = $inv + ( ( $inv ** $n ) * $delta ) / $n 
	#
	my $delta = $one->subtract( $inv * $x ) ;
	foreach ( 1 .. 100 ) {
		my $next = $inv + $inv->power( $n )->multiply( $delta )->multiply( $inv_n )->round_up( $dlen + 1 ) ;
		if ( $inv->subtract( $next )->abs() <= $diff_stop ) {
			last ;
		}
		$inv = $next ;
		$delta = $one->subtract( $inv->power( $n )->multiply( $x ) ) ;
	}

	return $inv->round_down( $dlen ) ;
}

=head1 'Decimal' object - factorial operation

=cut

#-------------------------------------------------------------------------------
#
# 階乗
#
#-------------------------------------------------------------------------------

=head2 factorial

Return n!

  print decimal( 10 )->factorial() ;           # 3628800

factorial is defined as follows.

  n! == 1 * 2 * 3 * .... * ( n - 1 ) * n

This operation can be defined as follows with List::Util::reduce.

  use List::Util qw( reduce ) ;

  sub factorial {
      return reduce { $a * $b } @_ ; 
  }
     
If you define m and total_product as follows,

  m = int( n / 2 ) + 1

  total_product( a,b,c,d,e,.... ) == a * b * c * d * e * ......

factorial( n ) is defined as follows.

  n! == m * total_product( ( m + i ) * ( m - i ) )     ( i == 1 -> n - m )
     == m * total_product( m^2 - i^2 )                 ( i == 1 -> n - m )

This method is implemented using by the last one.

In the other hand, the all of the integer value can be decomposed as follow.

  x == 2^p * d             ( p is integer and p >=0 , d is a odd number and d > 0 )

  p == bitcount( ~x & ( x - 1 ) )            # ~x == bitnot( x ) 
  d == x >> p

then, the numeric array can be defined as follows.

  x[0] == m
  x[k] == ( m^2 - k^2 )                     ( k == 1 -> n - m )
  
  -> x[k] == 2^(p[k]) * d[k]                ( k == 0 -> n - m )

     p[k] == ntz( x[k] )
          == bitcount( bitnot( x[k] ) & ( x[k] - 1 ) )

     d[k] == x[k] >> p[k]

And the factorial( n ) can be redefined as follows.

  n! == total_product( x[k] )                              ( k == 0 -> n - m )
     == total_product( 2^(p[k]) * d[k] )                   ( k == 0 -> n - m )
     == total_product( d[k] ) * 2^( sum( p[k] ) )          ( k == 0 -> n - m )
     == total_product( d[k] ) << sum( p[k] )               ( k == 0 -> n - m )


=cut

sub factorial {
	#-----------------------------------------------------------------------
	#
	# 階乗
	#
	#   n! == 1 * 2 * 3 * ..... * n
	#
	#   List::Util::reduce を用いると、
	#
	#     use List::Util qw( reduce ) ;
	#     sub factorial { return reduce { $a * $b } @_ ; }
	#
	#   と表現できる。
	#
	#   ここでは、数列 ( 1 .. n ) を中央値 m と中央値との差 i に変換し、
	#
	#     n! == m * Π( ( m + i ) * ( m - i ) ) == m * Π( m^2 - i^2 )      ( m == int( n/2 ) + 1 , i == 1 -> ( n - m ) )
	#
	#   として演算を行っている。
	#   ( ここで言う「中央値」は所謂「メディアン」とは異なる。 )
	#
	#   これを reduce を使って表現すると、
	#
	#     sub factorial {
	#         my( $n ) = @_ ;
	#         $m = int( $n / 2 ) + 1 ;
	#         $m2 = $m * $m ;
	#         return reduce { $a * ( $m2 - ( $b ** 2 ) ) } $m , 1 .. ( $n - $m ) ;
	#     }
	#
	#   となる。
	#
	#  
	#  奇数列への落とし込み
	#
	#    階乗数は 2 の冪と奇数の積で表すことができる。
	#
	#      0! == 2^0 * 1
	#      1! == 2^0 * 1
	#      2! == 1 * 2 == 2^1 * 1
	#      3! == 1 * 2 * 3 == 2^1 * 3
	#      4! == 1 * 2 * 3 * 4 == 2^3 * 3
	#      5! == 1 * 2 * 3 * 4 * 5 == 2^3 * 15
	#      6! == 1 * 2 * 3 * 4 * 5 * 6 == 2^4 * 45
	#
	#    任意の階乗数 n! は n が大きくなるにつれてビット配列に直した時の末尾 0 が伸びていく形になる。
	#    この時の末尾の 0 の数を 2 の冪乗数 p として抑えながらビットシフトして桁を落とすことができる。
	#    こうすることで、途中の演算を実質的に奇数列の乗算に落とし込むことができる。
	#
	#    階乗演算に使用する数列を
	#
	#      m == int( n / 2 ) + 1
	#      x[0] == m
	#      x[k] == m^2 - k^2               ( k == 1 -> n - m )
	#
	#    とした時、
	#
	#       n! == m * Π( m^2 - k^2 )
	#          == 2^p[k] * d[k]              ( d[k] は奇数 )
	#
	#    となる p[k], d[k] が存在し、ここから、
	#
	#       n! == Π( d[k] ) * 2^( Σ(p[k]) )  ( k == 0 -> n - m )
	#          == Π( d[k] ) << Σ(p[k])       ( k == 0 -> n - m )
	#
	#    と定義できるということ。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return __PACKAGE__->new( 1 )	if ( $n->is_zero() ) ;

	#
	# これ以降は基本的に Perl 標準の数値演算で実装する。
	#
	$n = $n->integer()->value() ;	# 整数部のみを取り出す。

	#
	# n! を求める場合、 n と 1 .. n の間の中央値、及び中央値と n との間の距離を利用して演算を行う。
	#
	# 中央値は、一般的な定義とは異なり、 n の偶奇に関わらず int( n / 2 ) + 1 を採る。
	#
	#   4! == 1 * 2 * 3 * 4
	#   -> 3 を採る。
	#
	#   5! == 1 * 2 * 3 * 4 * 5
	#   -> 3 を採る。
	#
	# 階乗の演算では 1 の有無が結果に影響しないため、このような方法が採れる。
	#
	# 中央値 m が決定したら、 m から n へ向かう距離 i を取りながら奇数の総積 r = m を初期値として
	#
	#   j == r * ( m + i ) * ( m - i )
	#     == r * ( m^2 - i^2 )
	#     == 2^p * d
	#
	#   r *= d
	#   pow += p
	#
	# を繰り返す。 ( i == 0 の時は j == m とする。 )
	#
	# 数列をすべて処理したら、
	#
	#   r <<= pow
	#
	# として結果を得る。
	#
	my $m  = int( $n / 2 ) + 1 ;
	my $m2 = $m * $m ;

	my $r = __PACKAGE__->new( 1 ) ;
	my $p2 = 0 ;
	foreach my $i ( 0 .. ( $n - $m ) ) {
		my $j = ( $i > 0 )
			? ( $m2 - ( $i * $i ) )
			: $m
		;

		my $p = 0 ;
		$r *= $j ;
		if ( $r->is_even ) { $p = ntz($r) ; $r >>= $p->value() ; }
		$p2 += $p ;
	}

	$r <<= $p2 ;

	return $r ;
}

=head2 double_factorial

Return n!!

  print decimal( 10 )->double_factorial() ;           # 3840

The double factorial is defined as follows.

  if n is odd

    double_factorial( n ) == 1 * 3 * 5 * 7 * ..... * n

                           ( 2k )!
    -> ( 2k - 1 )!! == --------------
                        ( 2^k ) * k! 

  if n is even

    double_factorial( n ) == 2 * 4 * 6 * 8 * ..... * n

    -> ( 2k )!!     == 2^k * k!

  if n < 0

    ( -n )!! * n! == ( -1 )^( ( n - 1 ) / 2 ) * n
    -> ( -n )!!   == ( -1 )^( ( n - 1 ) / 2 ) * n / n!!


=cut

sub double_factorial {
	#-----------------------------------------------------------------------
	#
	# 二重階乗 ( double factorial )
	#
	#   n!! で表現される数値。
	#
	#   n が奇数であれば 1 から n までの奇数の総乗となり、
	#   n が偶数であれば 1 から n までの偶数の総乗となる。
	#
	#                          ( 2k )!
	#   ( 2k - 1 )!!   == ------------------
	#                       ( 2^k ) * k!
	#
	#   ( 2k )!!       == 2^k * k!
	#
	#
	#   ( -n )!! * n!! == ( -1 )^( ( n - 1 )/2 ) * n
	#   -> ( -n )!!    == ( -1 )^( ( n - 1 )/2 ) * n / n!!
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	if ( $self->is_zero() ) ;

	my $n = $self->integer() ;	# 整数部のみを取り出す。

	my $r = undef ;
	if ( $n->{'sgn'} < 0 ) {
		$n->{'sgn'} *= ( -1 ) ;
		$r = ( -1 ) ** ( ( $n - 1 ) * 0.5 ) * $n ;
		$r /= $n->double_factorial() ;
	}
	else {
		if ( $n->is_even() ) {
			my $k = $n->multiply( 0.5 ) ;
			$r = __PACKAGE__->new( 2 )->power( $k )->multiply( $k->factorial() ) ;
		}
		else {
			my $k = $n->multiply( 0.5 )->integer()->add( 1 ) ;
			my $numer = $k->multiply( 2 )->factorial() ;
			my $denom = __PACKAGE__->new( 2 )->power( $k )->multiply( $k->factorial() ) ;

			$r = $numer->divide( $denom ) ;
		}
	}

	return $r ;
}

=head2 alternating_factorial

  print decimal( 10 )->alternating_factorial() ;         # 3301819

The alternating_factorial is defined as follows.

  alternating_factorial( n ) == n! - alternating_factorial( n - 1 )
                             == sum( ( -1 )^(n-1) * i! )              ( i == 1 -> n )

if $n <= 3, 4, 5, 6, 7, 8, 10, 15, 19, 41, 59, 61, 105, 160, 661, 2653, 3069, 3943, 4053, 4998, 8275, 9158, 11164,

  $n->alternating_factorial()->is_prime() == True

if $n >= 3612702,

  $n->alternating_factorial() % 3612703 == 0

=cut

sub alternating_factorial {
	#-----------------------------------------------------------------------
	#
	# 交互階乗
	#
	#   交互階乗の定義は以下のとおり。
	#
	#     af( n ) = Σ( ( ( -1 ) ** ( n - 1 ) ) * i! )        ( i = 1 -> n )
	#
	#   交互階乗は、以下の漸化式によっても得られる。
	#
	#     af( n ) == n! - af( n - 1 )
	#
	#   n が以下の値を採る時に af( n ) は素数となる。 ( ただし、2653 以降は確率的素数 )
	#
	#     3, 4, 5, 6, 7, 8, 10, 15, 19, 41, 59, 61, 105, 160, 661, 2653, 3069, 3943, 4053, 4998, 8275, 9158, 11164
	#
	#   n >= 3612702 の時、 af( n ) は全て 3612703 の倍数となるとのこと。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	$n = __PACKAGE__->new( $n )	unless( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $af = __PACKAGE__->new( 1 ) ;
	my $f  = __PACKAGE__->new( 1 ) ;
	foreach ( my $i = __PACKAGE__->new( 2 ) ; $i <= $n ; $i++ ) {
		$f *= $i ;
		$af = $f - $af ;
	}

	return $af ;
}

=head2 primorial

Return p#

  print decimal( 10 )->primorial() ;                    # 210 ( == 2 * 3 * 5 * 7 )

The primorial is defined as follows.

  primorial( n ) == p#
                 == 2 * 3 * 5 * 7 * 11 * .... * p       # p <= n and all p is prime.

=cut

sub primorial {
	#-----------------------------------------------------------------------
	#
	# 素数階乗
	#
	#   任意の素数 p 以下の全ての素数を掛け合わせた数。
	#   数学では p# で表される。
	#
	#   ここでは任意の整数 $n 以下の素数リストを取得し、それを全て掛け合わせた数を返す。
	#
	#   ちなみに、 2 つの素数の積で現される合成数は半素数 ( semiprime ; biprime ) と呼ばれる。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $r = __PACKAGE__->new( 1 ) ;
	foreach my $p ( $n->primes() ) {
		#$r *= $p ;
		$r = $r * $p ;
	}

	return $r ;
}

=head2 primorial_numbers

Return primorial numbers as array.

  print decimal( 10 )->primorial_numbers() ;           # ( 2 , 6 , 30 , 210 )

=cut

sub primorial_numbers {
	#-----------------------------------------------------------------------
	#
	# 素数階乗を配列で返す。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $r = [] ;
	foreach my $p ( $n->primes() ) {
		if ( defined $r->[0] )	{ push( @{ $r } , $r->[-1] * $p ) ; }
		else			{ $r->[0] = $p ; }
	}

	return @{ $r } ;
}

=head2 primorial_primes

Retun prime numbers, which is p#+1 or p#-1.

  print decimal( 10 )->primorial_primes() ;         # ( 3 , 5 , 7 , 29 , 31 , 211 )
                                                    #
                                                    #   3 == 2# + 1 ==   2 + 1
						    #   5 == 3# - 1 ==   6 - 1
						    #   7 == 3# + 1 ==   6 + 1
						    #  29 == 5# - 1 ==  30 - 1
						    #  31 == 5# + 1 ==  30 + 1
						    # 211 == 7# + 1 == 210 + 1
						    #

=cut

sub primorial_primes {
	#-----------------------------------------------------------------------
	#
	# 素数階乗素数
	#
	#   任意の素数 p について p#+1 または p#-1 の形を採る数値の内、素数となるもの。
	#
	#   p#+1 型の数はユークリッド数 ( Euclid number )、 p#-1 型の数はクンマー数 ( Kummer number ) とも呼ばれる。
	#
	#   p#+1 や p#-1 は p 以下の素数で割り切る事はできない。
	#   それ自体が素数となる確立は非常に小さいが、その素因数は全て p より大きい値であり、桁数の大きな素因数を含むことが多い。
	#
	#   ここでは、 p#+1 や p#-1 型の数の内、それ自体が素数となる数を返す。
	#
	#   100 以下の素数で生成される素数階乗素数は 12 個しかなく、
	#   12 番目の素数階乗素数は 10 進数 21 桁に及ぶ数値となる。
	#
	#   2013 年現在、 p#+1 型の素数は 22 個、 p#-1 型の素数は 20 個存在することが知られているとのこと。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $r = {} ;
	my $pr = __PACKAGE__->new( 1 ) ;
	foreach my $p ( $n->primes() ) {
		$pr *= $p ;
		if ( $p->value() =~ /^(?:2|3|5|7|11|31|379|1019|1021|2657|3229|4547|4787|11549|13649|18523|23801|24029|42209|145823|366439|392113)$/ ) {
			#
			# p#+1 型の素数
			#
			my $d = $pr + 1 ;
			$r->{ $d } = $d ;
		}
		if ( $p->value() =~ /^(?:3|5|11|13|41|89|317|337|991|1873|2053|2377|4093|4297|4583|6569|13033|15877|843301|1098133)$/ ) {
			#
			# p#-1 型の素数
			#
			my $d = $pr - 1 ;
			$r->{ $d } = $d ;
		}
	}

	return sort { $a <=> $b } values %{ $r } ;
}

sub primorial_series {
	#-----------------------------------------------------------------------
	#
	# 素数階乗と、これを求める過程で現れる素数階乗の途中経過、素数階乗素数をハッシュ参照で返す。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $r = {
		'primorial'	=> undef ,	# 素数階乗
		'members'	=> [] ,		# 素数階乗を求める過程で表れる個々の素数階乗
		'primes_p'	=> [] ,		# p#+1 型の素数階乗素数
		'primes_m'	=> [] ,		# p#-1 型の素数階乗素数
	} ;

	my $pr = __PACKAGE__->new( 1 ) ;
	foreach my $p ( $n->primes() ) {
		$pr *= $p ;
		$r->{'primorial'} = $pr ;
		push( @{ $r->{'members'} } , $pr ) ;
		if ( $p->value() =~ /^(?:2|3|5|7|11|31|379|1019|1021|2657|3229|4547|4787|11549|13649|18523|23801|24029|42209|145823|366439|392113)$/ ) {
			push( @{ $r->{'primes_p'} } , $pr + 1 ) ;
		}
		if ( $p->value() =~ /^(?:3|5|11|13|41|89|317|337|991|1873|2053|2377|4093|4297|4583|6569|13033|15877|843301|1098133)$/ ) {
			push( @{ $r->{'primes_m'} } , $pr - 1 ) ;
		}
	}

	return ( defined $r->{'primorial'} ) ? $r : undef ;
}

=head2 euclid_number

Return p#+1

  print decimal( 10 )->euclid_number() ;                    # 211 ( == 7#+1 )

=cut

sub euclid_number {
	#-----------------------------------------------------------------------
	#
	# ユークリッド数
	#
	#   素数階乗に 1 を加えた数。 ( p#+1 型の整数 )
	#
	#   p#+1 型の整数はユークリッドの原論において素数が無限に存在することの証明に使用された数。
	#   ここから p#+1 型の数値はユークリッド数 ( Euclid number ) とも呼ばれる。
	#   ユークリッド数は 3 ( mod 4 ) の形を採る有理整数でもある。
	#
	#   p#+1 型の整数は p 以下のどの素数でも割り切れない整数であり、それ自体が素数でなければ、
	#   その素因数は全て p より大きな素数となる。
	#
	#-----------------------------------------------------------------------
	return $_[0]->primorial() + 1 ;
}

=head2 kummer_number

Return p#-1

  print decimal( 10 )->kummer_number() ;                    # 209 ( == 7#-1 )

=cut

sub kummer_number {
	#-----------------------------------------------------------------------
	#
	# クンマー数
	#
	#   素数階乗から 1 を減じた数。 ( p#-1 型の整数 )
	#
	#   p#-1 型の整数は p 以下のどの素数でも割り切れない整数であり、それ自体が素数でなければ、
	#   その素因数は全て p より大きな素数となる。
	#
	#-----------------------------------------------------------------------
	return $_[0]->primorial() - 1 ;
}

=head1 'Decimal' object - statistical operation.

These methods can be imported as functions.

=cut

#-------------------------------------------------------------------------------
#
# 集計 / 統計
#
#-------------------------------------------------------------------------------

=head2 min

Return minimum number.

  print decimal( 10 )->min( 20 .. 100 ) ;         # 10 ( not a 20 )

If you imported this method,

  print min( 10 .. 100 ) ;                        # 10

=cut

sub min {
	#-----------------------------------------------------------------------
	#
	# 最小値
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;
	foreach ( @n ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
	}
	return ( sort { $a <=> $b } @n )[0] ;
}

=head2 max

Return maximum number.

  print decimal( 10 )->max( 1 .. 9 ) ;            # 10 ( not a 9 )

If you imported this method,

  print max( 10 , 1 .. 9 ) ;                      # 10

=cut

sub max {
	#-----------------------------------------------------------------------
	#
	# 最大値
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;
	foreach ( @n ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
	}
	return ( sort { $a <=> $b } @n )[-1] ;
}

=head2 mean

Return mean.

  print decimal( 10 )->mean( 1 .. 9 ) ;            # 5.5 ( not a 5 )

If you imported this method,

  print mean( 1 .. 10 ) ;                          # 5.5

=cut

sub mean {
	#-----------------------------------------------------------------------
	#
	# 平均値
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;
	my $r = undef ;
	if ( @n > 0 ) {
		$r = __PACKAGE__->new( 0 ) ;
		foreach ( @n ) { $r += $_ ; }
		$r /= @n ;
	}
	return $r ;
}

=head2 median

Return median.

  print decimal( 10 )->median( 1 .. 9 ) ;            # 4.5 ( not a 5 )

If you imported this method,

  print median( 1 .. 10 ) ;                        # 4.5


In this module,

  median( @n ) == ( quantile( @n ) )[2]
               == ( percentile( @n , { perc => 50 } ) )[1] 

=cut

sub median {
	#-----------------------------------------------------------------------
	#
	# 中央値
	#
	#   $median == ( quantile( @n ) )[2]
	#   $median == ( percentile( @n , { perc => 50 } ) )[1]
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;

	@n = sort { $a <=> $b } @n ;
	my @ix = (
		CORE::int( $#n / 2 )	,
		POSIX::ceil( $#n / 2 )	,
	) ;

	my $r = ( $n[ $ix[0] ] + $n[ $ix[1] ] ) / 2 ;
	return $r ;
}

=head2 percentile( @n , { perc => $percent } )

Return percentile.
By default, return 25 percentile.

  print join ' ' , decimal( 1 )->mean( 2 .. 10 ) ;                           # 1 3.5 5.5 7.5 10
  print join ' ' , decimal( 1 )->mean( 2 .. 10 , { perc => 50 } ) ;          # 1 5.5 10

If you imported this method,

  print join ' ' , percentile( 1 .. 10 ) ;                                   # 1 3.5 5.5 7.5 10
  print join ' ' , percentile( 1 .. 10 , { perc => 50 } ) ;                  # 1 5.5 10

=cut

sub percentile {
	#-----------------------------------------------------------------------
	#
	# パーセンタイル ( 百分位数 ; パーセント点 )
	#
	#   percentile( @array , { perc => <nn> } ) ;
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;

	my $perc = 25 ;
	if ( ref( $n[-1] ) ) {
		my $o = pop( @n ) ;
		$perc = $o->{'perc'}    if ( defined $o->{'perc'} ) ;
	}

	@n = sort { $a <=> $b } @n ;
	my @r = ( $n[0] ) ;
	foreach ( my $p = $perc ; $p < 100 ; $p += $perc ) {
		my @ix = (
			CORE::int( $#n * $p / 100 )	,
			POSIX::ceil( $#n * $p / 100 )	,
		) ;
		my $v = ( $n[ $ix[0] ] + $n[ $ix[1] ] ) / 2 ;
		push( @r , $v ) ;
	}
	push( @r , $n[-1] ) ;

	return @r ;
}

=head2 quantile( @n )

Return quantile.

Same to

  decimal( $x )->percentile( @n , { perc => 25 } ) ;

If you imported this method,

  print join ' ' , quantile( 1 .. 10 ) ;                                     # 1 3.5 5.5 7.5 10

It is same to

  print join ' ' , percentile( 1 .. 10 , { perc => 25 } ) ;                  # 1 3.5 5.5 7.5 10

=cut

sub quantile {
	#-----------------------------------------------------------------------
	#
	# 四分位数
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;
	return percentile( @n , { 'perc' => 25 } ) ;
}

sub hinge {
	#-----------------------------------------------------------------------
	#
	# ヒンジ
	#
	#   配列要素を中央値を境にして二分割し、それぞれの中央値を用いることで分位数を近似する。
	#   四分位数を簡便に求める方法とされているが、処理コストの面から言ってコストメリットがあるかどうかは微妙なところ。
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;

	@n = sort { $a <=> $b } @n ;

	my $med = median( @n ) ;
	my $m = [] ;
	foreach my $i ( @n ) {
		if      ( $i < $med )   { push( @{ $m->[0] } , $i ) ; }
		elsif   ( $i > $med )   { push( @{ $m->[1] } , $i ) ; }
	}

	my @r = () ;
	push( @r ,
		$n[0] ,
		median( @{ $m->[0] } ) ,
		$med ,
		median( @{ $m->[1] } ) ,
		$n[-1]
	) ;

	return @r ;
}

=head2 tertile( @n )

Return tertile.

This method likes to

  decimal( $x )->percentile( @n , { perc => 100/3 } ) ;

If you imported this method,

  print join ' ' , tertile( 1 .. 10 ) ;                                      # 1 4 7 10

=cut

sub tertile {
	#-----------------------------------------------------------------------
	#
	# 三分位数
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;
	return undef    unless( @n ) ;

	@n = sort { $a <=> $b } @n ;

	my @r = () ;
	foreach my $i ( 0 .. 3 ) {
		my @ix = (
			CORE::int( $#n * $i / 3 )	,
			POSIX::ceil( $#n * $i / 3 )	,
		) ;
		my $v = mean( $n[ $ix[0] ] , $n[ $ix[1] ] ) ;
		push( @r , $v ) ;
	}

	return @r ;
}

=head2 quintile

Return quintile.

If you imported this method,

  print join ' ' , quintile( 1 .. 10 ) ;                                # 1 2.5 4.5 6.5 8.5 10

=cut

sub quintile	{ return percentile( @_ , { 'perc' => 20 } ) ; }	# 五分位数

=head2 decil

Return decil.

If you imported this method,

  print join ' ' , decil( 1 .. 10 ) ;                                   # 1 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10

=cut

sub decil	{ return percentile( @_ , { 'perc' => 10 } ) ; }	# 十分位数

=head2 variance

Return the sampled variance.

By default, this method will be exported as a function. ( you need not import it. )

 print variance( 1 .. 10 ) ;                                            # 8.25

=cut

sub variance {
	#-----------------------------------------------------------------------
	#
	# 標本分散 ( sampled variance )
	#
	#   分散は、平均値からの隔たり度合いを示す指標であり、平均値からの隔たり ( 偏差 ) の平均値として定義される。
	#
	#   数値配列の各要素とそれらの平均値との差 ( 偏差 ) の総和 ( 偏差平方和 ) を求めてその平均を採るというのが基本的な考え方。
	#   偏差は、正負のベクトル ( 方向性 ) を持っているが、これを量 ( または長さ ) の概念に補正するために、偏差を 2 乗するという方法論が採られる。
	#   ( 絶対値でもいいような気がするのだが．．．．。)
	#
	#   このため、分散は、確率論において「確率変数の 2 次の中心化モーメント ( 積率 ) 」とも表現される。
	#
	#   扱う数値配列が母集団そのものである場合には、得られた分散は「母分散」と呼ばれる。
	#   数値配列が母集団から抽出された標本である場合には、「標本分散」 ( sampled variance ) と呼ばれる。
	#
	#   標本分散では、平均値を取る際の分母 ( 自由度 ) には要素数を用いる。
	#   しかし、標本分散は母分散よりもやや小さい値を返すことが一般に知られている。
	#
	#   これを補正するために考案された手法として「不偏分散」 ( unbiased variance ) がある。
	#   不偏分散は、「母分散の不偏推定量」を表す値であり、平均値を取る際の分母として ( 要素数 - 1 ) を用いる。
	#   標本数が十分に大きければ、不偏分散は標本分散とほぼ等しい値を返す。
	#   ( 「標本数が十分に大きい」のであれば、 不偏分散 ≒ 母分散 ≒ 標本分散 だよな。 (^^) )
	#
	#   分散を求める演算では、平均値からの距離を求めるために偏差の 2 乗が用いられているが、
	#   その副作用として、必要以上に大きな結果が返るという弊害がある。
	#   これを補正する概念が「標準偏差」。
	#
	#-----------------------------------------------------------------------
	return undef    unless( @_ ) ;
	my @n = @_ ;
	my $m = mean( @n ) ;
	my $r = __PACKAGE__->new( 0 ) ;
	foreach my $i ( @n ) {
		$r += ( $i - $m ) ** 2 ;
	}
	return $r / scalar( @n ) ;
}

sub variance_u {
	#-----------------------------------------------------------------------
	#
	# 不偏分散 ( unbiased variance )
	#
	#-----------------------------------------------------------------------
	return undef    unless( @_ ) ;
	my @n = @_ ;
	my $m = mean( @n ) ;
	my $r = __PACKAGE__->new( 0 ) ;
	foreach my $i ( @n ) {
		$r += ( $i - $m ) ** 2 ;
	}
	return $r / ( scalar( @n ) - 1 ) ;
}

=head2 sd

Return the standard deviation.

  sd( @n ) == sqrt( variance( @n ) ) >= 0 

By default, this method will be exported as a function. ( you need not import it. )

 print sd( 1 .. 10 ) ;                                            # 2.8722813232690143299253057341094646591101

=cut

sub sd {
	#------------------------------------------------------------------------
	#
	# 標準偏差 ( Standard Deviation )
	#
	#   標準偏差は「分散の正の平方根」として定義される。
	#
	#------------------------------------------------------------------------
	return undef    unless( @_ ) ;

	my $v = variance( @_ ) ;
	return undef    unless( defined $v ) ;

	$v = __PACKAGE__->new( $v )	unless ( ref( $v ) ) ;

	return $v->sqrt() ;
}

sub std_score {
	#------------------------------------------------------------------------
	#
	# 偏差値 ( Standard Score )
	#
	#------------------------------------------------------------------------
	my( $pop , $n ) = @_ ;
	croak( "The first argument must be an array ref ( population ).\n" )    unless( ref( $pop ) eq 'ARRAY' ) ;
	croak( "The second argument must be a numeric value.\n" )               unless( $n =~ /^\d+$/ ) ;

	my $m = mean( @{ $pop } ) ;
	my $sd = sd( @{ $pop } ) ;

	my $r = ( ( $n - $m ) * 10 / $sd ) + 50 ;

	return $r ;
}

=head2 covariance( $array1 , $array2 [ , $flg ] ) 

Return the covariance.

if $flg == 1, return the corelation coefficient. ( default )
else return the mean value.

By default, this method will be exported as a function. ( you need not import it. )

  print covariance( [ 1 .. 10 ] , [ 1 , 10 ] , 0 ) ;            # 8.25 
  print covariance( [ 1 .. 10 ] , [ 1 , 10 ] , 1 ) ;            # 1

=cut

sub covariance {
	#-----------------------------------------------------------------------
	#
	# 共分散
	#
	#   二組のデータ @x と @y について、 @x と @y との相関関係を調べるためのもの。
	#
	#   配列要素 $x[ $n ] と $y[ $n ] について、それぞれの平均値からの偏差 $sx[ $n ] , $sy[ $n ] の積を採り、
	#   その平均値を求めることで @x と @y の相関関係を数値化する。
	#
	#   分散や標準偏差が一組のデータの量的な偏りを表現するのに対して、
	#   共分散は二組のデータによって作り出されるデータの偏りとベクトル ( 方向性 ) を表現するものと言える。
	#
	#   @x と @y が異なる単位や広がりを持つデータである場合には、要素数で平均を採ると相関関係が見えづらくなる。
	#   このため、偏差の積を @x , @y の標準偏差の積で割った値 ( 相関係数 ) に変換して用いるのが一般的とされる。
	#
	#   相関係数を $c とすると、 $c は -1 <= $c <= 1 となる。
	#   $c ==  1 ならば、 @x と @y は完全に同期している ( 完全な正の相関関係がある ) ことになる。
	#   $c == -1 ならば、 @x と @y は完全に反発している ( 完全な負の相関関係がある ) ことになる。
	#   「相関関係が見出せない」状態は $c == 0 によって示される。
	#
	#   共分散は二組のデータの間の相関関係を示すのみであり、因果関係を示すものではない。
	#   得られた結果から因果関係の有無を見出すのは人間 ( 観察者 ) の役割。
	#
	#
	#   ここでは、第三引数に明示的に 0 が設定されていれば要素数で平均した結果を返し、
	#   それ以外の場合は標準偏差の積で割った結果 ( 相関係数 ; correlation coefficient ) を返す事とする。
	#
	#-----------------------------------------------------------------------
	return undef    unless ( @_ ) ;
	my( $x , $y , $coef ) = @_ ;

	return undef	unless ( defined $y ) ;
	$coef = 1	unless ( defined $coef ) ;      # デフォルトでは相関係数を返す。

	#
	# 平均値
	#
	my $m = {
		'x'     => mean( @{ $x } ) ,
		'y'     => mean( @{ $y } ) ,
	} ;
	foreach ( 'x' , 'y' ) {
		$m->{ $_ } = __PACKAGE__->new( $m->{ $_ } )	if ( substr( ref( $m->{ $_ } ) , 0 , 9 ) eq 'Math::Big' ) ;
		$m->{ $_ } = __PACKAGE__->new( $m->{ $_ } )	unless ( ref( $m->{ $_ } ) ) ;
	}

	#
	# 共分散を求める。
	#
	my $lim = ( sort { $a <=> $b } ( $#{ $x } , $#{ $y } ) )[1] ;
	my $r = __PACKAGE__->new( 0 ) ;
	my $div = __PACKAGE__->new( 0 ) ;
	foreach my $i ( 0 .. $lim ) {
		my( $xi , $yi ) = (
			$x->[ $i ] || __PACKAGE__->new( 0 ) ,
			$y->[ $i ] || __PACKAGE__->new( 0 ) ,
		) ;
		$xi = __PACKAGE__->new( $xi )	if ( substr( ref( $xi ) , 0 , 9 ) eq 'Math::Big' ) ;
		$yi = __PACKAGE__->new( $yi )	if ( substr( ref( $yi ) , 0 , 9 ) eq 'Math::Big' ) ;

		$xi = __PACKAGE__->new( $xi )	unless ( ref( $xi ) ) ;
		$yi = __PACKAGE__->new( $yi )	unless ( ref( $yi ) ) ;

		$r += ( $xi - $m->{'x'} ) * ( $yi - $m->{'y'} ) ;
		$div += ( ( $xi - $m->{'x'} ) ** 2 )->sqrt() * ( ( $yi - $m->{'y'} ) ** 2 )->sqrt() ;
	}

	if ( $coef )	{ $r /= $div ; }
	else		{ $r /= ( $lim + 1 ) ; }

	return $r ;
}

=head1 'Decimal' object - gcd, lcm, exgcd.

=cut

#-------------------------------------------------------------------------------
#
# 公約数、公倍数
#
#-------------------------------------------------------------------------------

=head2 gcd( $x , $y )

Return the greatest common divisor.

This method will be exported as a function by default.

  print gcd( 21 , 69 ) ;                           # 3

=cut

sub gcd {
	#-----------------------------------------------------------------------
	#
	# 最大公約数 ( greatest common divisor )
	#
	#-----------------------------------------------------------------------
	my( @v ) = @_ ;

	my $m = shift( @v ) ;
	$m = __PACKAGE__->new( $m )	unless ( ref( $m ) eq __PACKAGE__ ) ;
	$m = $m->abs() ;
	foreach my $n ( @v ) {
		$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
		$n = $n->abs() ;
		if ( $n > $m ) {
			( $n , $m ) = ( $m , $n ) ;
		}
		while ( $n > 0 ) { ( $m , $n ) = ( $n , $m->modulus( $n ) ) } ;		# ユークリッドの互除法
	}
	return $m ;
}

=head2 lcm( $x , $y )

Return the least common multiple.

This method will be exported as a function by default.

  print lcm( 21 , 69 ) ;                           # 483


  21 == 3 x 7
  69 == 3 x 23
  lcm( 21 , 69 ) == 3 x 7 x 23
                 == ( 21 * 69 ) / gcd( 21 , 69 ) == ( 21 * 69 ) / 3
                 == 489

=cut

sub lcm {
	#-----------------------------------------------------------------------
	#
	# 最小公倍数 ( least common multiple )
	#
	#-----------------------------------------------------------------------
	my( @v ) = @_ ;

	my $m = shift( @v ) ;
	$m = __PACKAGE__->new( $m )	unless ( ref( $m ) eq __PACKAGE__ ) ;
	foreach my $n ( @v ) {
		$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
		$m = ( $n * $m ) / gcd( $m , $n ) ;
	}
	return $m ;
}

=head2 exgcd( $x , $y [ , $c ] )

The extended greatest common devisor.

This method will be exported as a function by default.

This function ( or method ) accept x and y and calculate

  a * x + b * y == c

Then return ( a , b , c ).

If defined c as argument, return ( a , b ).

  print join ' ' , exgcd( 21 , 69 ) ;                           # 10 -3 3  ( == 10 * 21 + ( -3 ) * 69 == 3 )
  print join ' ' , exgcd( 20 ,  7 , 1 ) ;                       # -1 3     ( == (-1) * 20 + 3 * 7 == 1 )

In the last case,

  (-1) * 20 + 3 * 7 == 1

this means

  ( (-1) * 20 ) % 7 == 1

  modinverse( 20 , 7 ) == -1  ( == 6 mod 7 )

=cut

sub exgcd {
	#-----------------------------------------------------------------------
	#
	# 拡張ユークリッドの互除法
	#
	#   引数で与えられた x , y に対して、
	#
	#     a * x + b * y == c
	#
	#   となる a , b , c を返す。
	#
	#   c は x と y の最大公約数であり、 x と y が互いに素であれば c == 1 となる。
	#
	#   この時、
	#
	#     x * a + y * b == 1
	#
	#   から得られた a の値は、
	#
	#     x * a ≡ 1 ( mod y )
	#
	#   における a に等しく、 a が「法 y の下での x のモジュラー逆数」であることを示す。
	#
	#   第三引数として $c が与えられた場合には、
	#
	#     a * x + b * y == c
	#
	#   となる a , b を返す。
	#
	#-----------------------------------------------------------------------
	croak( "Invalid arguments\n")   if ( @_ < 2 ) ;

	my( $x , $y , $c ) = @_ ;
	foreach ( $x , $y , $c ) { $_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ; }

	my @a = ( __PACKAGE__->new( 1 ) , __PACKAGE__->new( 0 ) ) ;
	my @b = ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 1 ) ) ;

	while ( $y > 0 ) {
		my( $d , $m ) = $x->divmod( $y , 0 ) ;
		@a = ( $a[1] , $a[0] - $d * $a[1] ) ;
		@b = ( $b[1] , $b[0] - $d * $b[1] ) ;
		( $x , $y ) = ( $y , $m ) ;
	}

	my @r = ( $a[0] , $b[0] , $x ) ;

	if ( defined $c ) {
		$r[0] *= ( $c / $r[2] ) ;
		$r[1] *= ( $c / $r[2] ) ;
		return @r[ 0 , 1 ] ;
	}

	return @r ;
}

=head1 'Decimal' object - trigonometric functions.

=cut

#-------------------------------------------------------------------------------
#
# 三角関数
#
#-------------------------------------------------------------------------------

=head2 sine

  print radian( 30 )->sine() ;              # 0.5
  print radian( 45 )->sine() ;              # 0.7071067811865475244008443621048490392848
  print radian( 60 )->sine() ;              # 0.8660254037844386467637231707529361834714

=cut

sub sine {
	#-----------------------------------------------------------------------
	#
	# 正弦 ( sine )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $pi = pi( $dlen ) ;
	my $pi2 = $pi * 2 ;

	#
	# $x を 0 <= $x < 2PI の範囲に変換。
	#
	$x = ( $x >= 0 ) ? ( $x % $pi2 ) : ( $pi2 - ( $x->abs() % $pi2 ) ) ;

	return __PACKAGE__->new( 0 )		if ( $x->is_zero() ) ;

	#
	# x == ( n * PI / 12 + m )
	# -> sin( x ) == sin( ( n * PI / 12 ) + m )
	#
	# dpi == PI * n/12 とおくと、正弦の加法定理より、
	#
	#   sin( x ) == sin( dpi + m )
	#            == sin( dpi ) * cos( m ) + cos( dpi ) * sin( m )
	#
	# 剰余値の小数点以下 37 桁目以降は誤差の範囲とする。
	#
	my $dpi = $pi->divide( 12 ) ;		# $dpi = PI / 12
	my( $n , $m ) = $x->divmod( $dpi , 0 ) ;

	if ( $m->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
		$m = __PACKAGE__->new( 0 ) ;
	}
	elsif ( $m->abs()->subtract( $dpi )->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
		$n += 1 ;
		$m = __PACKAGE__->new( 0 ) ;
	}

	return sine_dpi_add( $n , $m )	if ( $n > 0 ) ;
	return $x->_sine_tayler_expansion( $dlen ) ;
}

=head2 cosine

  print radian( 30 )->cosine() ;            # 0.8660254037844386467637231707529361834714 
  print radian( 45 )->cosine() ;            # 0.7071067811865475244008443621048490392848
  print radian( 60 )->cosine() ;            # 0.5

=cut

sub cosine {
	#-----------------------------------------------------------------------
	#
	# 余弦
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $pi = pi( $dlen ) ;
	my $pi2 = $pi * 2 ;

	#
	# $x を 0 <= $x < 2PI の範囲に変換。
	#
	$x = ( $x >= 0 ) ? ( $x % $pi2 ) : ( $pi2 - ( $x->abs() % $pi2 ) ) ;

	return __PACKAGE__->new( 1 )		if ( $x->is_zero() ) ;

	#
	# x == ( n * PI / 12 + m )
	# -> cos( x ) == cos( ( n * PI / 12 ) + m )
	#
	# dpi == PI * n/12 とおくと、余弦の加法定理より、
	#
	#   cos( x ) == cos( dpi + m )
	#            == cos( dpi ) * cos( m ) - sin( dpi ) * sin( m )
	#
	# 剰余値の小数点以下 37 桁目以降は誤差の範囲とする。
	#
	my $dpi = $pi->divide( 12 ) ;		# $dpi = PI / 12
	my( $n , $m ) = $x->divmod( $dpi , 0 ) ;

	if ( $m->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
		$m = __PACKAGE__->new( 0 ) ;
	}
	elsif ( $m->abs()->subtract( $dpi )->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
		$n += 1 ;
		$m = __PACKAGE__->new( 0 ) ;
	}

	return cosine_dpi_add( $n , $m )	if ( $n > 0 ) ;
	return $x->_cosine_tayler_expansion( $dlen ) ;
}

=head2 tangent

  print radian( 30 )->tangent() ;           # 0.5773502691896257645091487805019574556476
  print radian( 45 )->tangent() ;           # 1
  print radian( 60 )->tangent() ;           # 1.7320508075688772935274463415058723669428

=cut

sub tangent {
	#-----------------------------------------------------------------------
	#
	# 正接 ( tangent )
	#
	#                  sine( x )
	#   tan( x ) == --------------
	#                 cosine( x )
	#
	#
	#                        sqrt( 1 - ( cosine( x ) ** 2 ) )
	#   abs( tan( x ) ) == ------------------------------------
	#                                 cosine( x )
	#
	#                              1 - ( cosine( x ) ** 2 ) 
	#                   == sqrt( ---------------------------- )
	#                                 cosine( x ) ** 2
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my( $cos , $sin ) = $x->_cosine_sine( $dlen ) ;
	return undef	if ( $cos->is_zero() ) ;

	my $tan = $sin->divide( $cos , $dlen ) ;

	return $tan ;
}

=head2 trigonometric

Alias : trig

  print join "\n" , radian( 30 )->trigometric() ;         # 0.5                                         ( sine )
                                                          # 0.8660254037844386467637231707529361834714  ( cosine )
                                                          # 0.5773502691896257645091487805019574556476  ( tangent )

  print join "\n" , radian( 30 )->trig() ;                # 0.5                                         ( sine )
                                                          # 0.8660254037844386467637231707529361834714  ( cosine )
                                                          # 0.5773502691896257645091487805019574556476  ( tangent )
=cut

sub trigonometric {
	#-----------------------------------------------------------------------
	#
	# 正弦、余弦、正接を返す。
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my( $c , $s ) = $x->_cosine_sine( $dlen ) ;
	my $t = undef ;

	if	( $c->is_zero() )	{ $t = undef ; } # +∞ or -∞
	elsif	( $s->is_zero() )	{ $t = ( $c < 0 ) ? __PACKAGE__->new( -1 ) : __PACKAGE__->new( 1 ) ; }
	else				{ $t = $s->divide( $c , $dlen ) ; }

	return ( $s , $c , $t ) ;
}

sub trig { return $_[0]->trigonometric( $_[1] ) ; }

=head2 arcsine

  print radian( 30 )->sine()->arcsine()->degree() ;           # 30

=cut

sub arcsine {
	#-----------------------------------------------------------------------
	#
	# 逆正弦 ( arcsine ; inverse sine )
	#
	#   y == sin( theta )
	#   x == cos( theta ) == 1 - y^2         ( 0 <= y <= 1 )
	#
	#   theta == atan2( y , x ) ;
	#
	#-----------------------------------------------------------------------
	my( $sin , $dlen ) = @_ ;

	$sin = __PACKAGE__->new( $sin )	unless ( ref( $sin ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $sin ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# 0 <= $sin <= 1 に変換
	#
	$sin -= $sin->floor() ;

	my $cos = __PACKAGE__->new( 1 )->subtract( $sin->power( 2 ) )->sqrt() ;
	my $theta = arctan2( $sin , $cos ) ;

	return $theta ;
}

=head2 arccosine

  print radian( 30 )->cosine()->arccosine()->degree() ;       # 30

=cut

sub arccosine {
	#-----------------------------------------------------------------------
	#
	# 逆余接 ( arccosine ; inverse cosine )
	#
	#   x == cos( theta )
	#   y == sin( theta ) == 1 - x^2         ( 0 <= x <= 1 )
	#
	#   theta == atan2( y , x ) ;
	#
	#-----------------------------------------------------------------------
	my( $cos , $dlen ) = @_ ;

	$cos = __PACKAGE__->new( $cos )	unless ( ref( $cos ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $cos ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# 0 <= $cos <= 1 に変換
	#
	$cos -= $cos->floor() ;

	my $sin = __PACKAGE__->new( 1 )->subtract( $cos->power( 2 ) )->sqrt() ;
	my $theta = arctan2( $sin , $cos ) ;

	return $theta ;
}

=head2 arctan 

  print radian( 30 )->tangent()->arctan()->degree() ;       # 30

  print radian( 120 )->tangent()->arctan()->degree() ;      # -60
  print radian( 210 )->tangent()->arctan()->degree() ;      # 30
  print radian( 300 )->tangent()->arctan()->degree() ;      # -60

=cut

sub arctan {
	#-----------------------------------------------------------------------
	#
	# 逆正接 ( arctangent ; inverse tangent )
	#
	#   arctan2 を介する事で結果を 0 <= arctan( x ) <= 2 * PI に拡張する。
	#
	#
	#   逆正接は、
	#
	#                         (-1)^(n-1)
	#     arctan( x ) == Σ( ------------ * x^(2n-1) )
	#                           2n - 1
	#
	#                         x^3     x^5     x^7
	#                 == x - ----- + ----- - ----- + ......
	#                          3       5       7
	#
	#   と定義される。 ( グレゴリー級数 ; ライプニッツの公式 )
	#   ただし、この式は収束が非常に遅く、実用的ではない。
	#
	#-----------------------------------------------------------------------
	return arctan2( $_[0] , 1 ) ;
}

=head2 arctan2( y , x )

  print decimal( 1 )->arctan2( sqrt(3) )->degree() ;        # 30

This method will be exported as a function by default.

  print arctan2(  1 , sqrt(3) )->degree() ;                 # 30
  print arctan2( -1 , sqrt(3) )->degree() ;                 # -30
  print arctan2( -1 , sqrt(3) * (-1) )->degree() ;          # -150
  print arctan2(  1 , sqrt(3) * (-1) )->degree() ;          # 150

=cut

sub arctan2 {
	#-----------------------------------------------------------------------
	#
	# 逆正接 ( arctangent )
	#
	#   単位円上の座標 [ a , b ] において、 a == 0 の時、 arctan は演算不能となる。
	#   また、マクローリン展開では abs( x ) < 1 の時しか収束しないため、
	#
	#     -1 * PI / 4 < arctan(x) < PI / 4
	#
	#   の範囲の値しか返すことができないと言う制限がある。
	#   更に、
	#
	#     arctan( -1 / -1 ) == arctan( 1 / 1 ) == PI / 4
	#
	#   となってしまう。
	#
	#   arctan2 では、
	#
	#     arctan2(  1 ,  1 ) == PI / 4
	#     arctan2( -1 , -1 ) == -1 * ( 3/4 * PI )
	#
	#   となるように演算を行う。
	#
	#   座標 [ x , y ] を半径 r の円上の偏角 t の点と考えると、
	#
	#     x == r * cos( t )
	#     y == r * sin( t )
	#     r == sqrt( x^2 + y^2 )
	#
	#   余弦の二倍角は以下のように定義される。
	#
	#     cos( 2t ) == cos( t + t )
	#               == cos( t ) * cos( t ) - sin( t ) * sin( t )
	#               == ( cos( t ) )^2 - ( sin( t ) )^2
	#               == 1 - 2 * ( sin( t ) )^2
	#               == 2 * ( cos( t ) )^2 - 1 
	#
	#   ここから、
	#
	#     2 * ( sin( t ) )^2 == 1 - cos( 2t )
	#     2 * ( cos( t ) )^2 == 1 + cos( 2t )
	#
	#                             sin( t )          1 - cos( 2t )
	#     -> ( tan( t ) )^2 == ( ---------- )^2 == ---------------
	#                             cos( t )          1 + cos( 2t )
	#
	#                             1 - cos( t )      1 - ( cos( t ) )^2          sin( t )
	#     -> ( tan( t/2 ) )^2 == -------------- == -------------------- == ( -------------- )^2
	#                             1 + cos( t )      ( 1 + cos( t ) )^2        1 + cos( t )
	#
	#                         sin( t )
	#     -> tan( t/2 ) == --------------
	#                       1 + cos( t )
	#
	#   として正接の半角の公式が得られる。
	#
	#   x == r * cos( t ) , y == r * sin( t ) より、
	#
	#                      y/r         y
	#     tan( t/2 ) == --------- = -------
	#                    1 + x/r     r + x
	#                                               y
	#     t/2 == arctan( tan( t/2 ) ) == arctan( ------- )
	#                                             r + x
	#                            y
	#     -> t == 2 * arctan( ------- )
	#                          r + x
	#
	#   となる。
	#
	#   また、
	#
	#                          1 - cos( t )      ( 1 - cos( t ) )^2        1 - cos( t )
	#     ( tan( t/2 ) )^2 == -------------- == -------------------- == ( -------------- )^2
	#                          1 + cos( t )      1 - ( cos( t ) )^2          sin( t )
	#   
	#   と変換すると、正接の半角の公式は
	#
	#                    1 - cos( t )      1 - x/r      r - x
	#     tan( t/2 ) == -------------- == --------- == -------
	#                      sin( t )         y/r           y
	#
	#   と表現することもでき、これを用いて
	#
	#                       r - x
	#     t == 2 * arctan( ------- )
	#                         y
	#
	#   とすることもできる。
	#
	#   座標 [ x , y ] == [ r * a , r * b ] と表現できることから、
	# 
	#                          y                          r * b                          b
	#     t == 2 * arctan( --------- ) == 2 * arctan( ------------- ) == 2 * arctan( --------- )
	#                        r + x                      r + r * a                      1 + a 
	#
	#                        r - x                      r - r * a                      1 - a
	#       == 2 * arctan( --------- ) == 2 * arctan( ------------- ) == 2 * arctan( --------- )
	#                          y                          r * b                          b
	#
	#   と言う関係となる。
	#
	#   これは、
	#
	#                      y         r - x
	#     tan( t/2 ) == -------- == -------
	#                    r + x         y
	#
	#   が複素平面における単位円上の偏角 1/2 の座標 [ a , b ] についての正接を求めていることを意味している。
	#   偏角 1/2 の正接であるため、 x >= 0 且つ y >= 0 であれば、座標 [ a , b ] の偏角 t/2 は、 0 <= t/2 <= PI/4 となる。
	#
	#   逆正接の演算では級数展開に大きなコストがかかるが、 0 <= t/2 <= PI/4 の範囲の tan(t/2) は、 abs( tan(t/2) ) <= 1 であり、
	#   級数展開による演算コストを最適化することができる。
	#
	#
	#   複素平面上でのアークタンジェント
	#     
	#     座標 [ x , y ] を複素平面上の点として捕らえると、この点は複素数 z として表現され、
	#
	#       z == x + iy
	#
	#     で表される。 ( x は複素数 z の実部、y は虚部であり、i は虚数単位。 )
	#
	#     この時、複素平面上の原点と [ x , y ] を結ぶ直線の長さ ( == 原点を中心として [ x , y ] を通る円の半径 ) を r とし、
	#     この直線と X 軸 ( 実軸 ) がなす角 ( 偏角 ) を t とすると、
	#
	#       r == abs( z )
	#         == sqrt( x^2 + y^2 )
	#
	#       x == r * cos( t )
	#       y == r * sin( t )
	#
	#       t == arg( z )
	#         == atan2( y , x )                                           ( -PI <= t <= PI )
	#
	#                        r - x                      y
	#         == 2 * atan( --------- ) == 2 * atan( --------- )           ( -PI/2 <= t <= PI/2 )
	#                          y                      r + x
	#
	#       z == x + iy
	#         == r * exp( i * t )
	#         == sqrt( x^2 + y^2 ) * exp( i * atan2( y , x ) )                   ( -PI   <= t <= PI   )
	#         == sqrt( x^2 + y^2 ) * exp( i * ( 2 * atan( ( r - x ) / y ) ) )    ( -PI/2 <= t <= PI/2 )
	#         == sqrt( x^2 + y^2 ) * exp( i * ( 2 * atan( y / ( r + x ) ) ) )    ( -PI/2 <= t <= PI/2 )
	#
	#     という関係になる。
	#
	#-----------------------------------------------------------------------
	my( $y0 , $x0 , $dlen ) = @_ ;

	foreach ( $x0 , $y0 ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $_ ) ;
	}

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# $x0 == 0 or $y0 == 0 の場合
	#
	if ( $y0->is_zero() ) {
		#
		# y == 0 の時、複素平面上の x 座標の値は +-∞ へ発散する。
		# x >= 0 ならば theta ==  0
		# x <  0 ならば theta == PI
		#
		return __PACKAGE__->new( 0 )	if ( $x0 >= 0 ) ;
		return pi( $dlen ) ;
	}
	elsif ( $x0->is_zero() ) {
		#
		# x == 0 の時、複素平面上の y 座標の値は +-∞ へ発散する。
		# y > 0 ならば theta = PI/2
		# y < 0 ならば theta = PI/2 * ( -1 )
		#
		my $r = pi( $dlen )->multiply( 0.5 )->round_down( $dlen ) ;
		return $r		if ( $y0->{'sgn'} > 0 ) ;
		return $r * ( -1 ) ;
	}

	#
	# 複素平面における象限の位置
	#
	my $quadrant = 1 ;
	if	( $y0 > 0 )	{ $quadrant = 2	if ( $x0 < 0 ) ; }
	elsif	( $x0 < 0 )	{ $quadrant = 3 ; }
	else			{ $quadrant = 4 ; }

	#
	# x , y を複素平面の第一象限上の座標に変換する。
	#
	# 座標 [ x , y ] が第二象限にある場合、 虚軸で折り返した位置へ変換される。
	# 座標 [ x , y ] が第三象限にある場合、 原点を中心に PI だけ回転した位置へ変換される。
	# 座標 [ x , y ] が第四象限にある場合、 実軸で折り返した位置へ変換される。
	#
	my( $x , $y ) = ( $x0->abs() , $y0->abs() ) ;

	#
	# 0 <= t' <= PI/4 となる tan( t' ) を採る。
	#
	#   y <= x であれば、 tan( t' ) == y / x
	#   y >  x であれば   tan( t' ) == y / ( r + x )
	#
	# とする。
	#
	# 後者の場合、最終的に求める偏角 t は
	#
	#   t = t' * 2
	#
	# となる。
	#  
	my $radius = $x->power( 2 )->add( $y->power( 2 ) )->sqrt() ;
	my $tan = undef ;
	if ( $y > $x )	{ $tan = $y->divide( $radius->add( $x ) , $dlen + 2 ) ;	}	# $tan = $y / ( $radius + $x )
	else		{ $tan = $y / $x ; }						# $tan = $y / $x 

	#
	# t' == atan( tan( t' ) ) を求める。 ( 0 <= t' <= PI/4 )
	#
	# 第一象限上の偏角を 6 分割する位置の座標における正接は比較的容易に求めることができる。
	# その位置の座標を [ x' , y' ] とすると、
	#
	#   tan( n/12 * PI ) == y' / x'
	#
	#                         sin( n/12 * PI ) 
	#                    == --------------------            ( n == 0 -> 5 )
	#                         cos( n/12 * PI )
	#
	#   n == 0 -> tan( 0/12 * PI ) == tan( 0 )        == 0
	#   n == 1 -> tan( 1/12 * PI )                    == ( sqrt(6) - sqrt(2) )^2 / 4
	#   n == 2 -> tan( 2/12 * PI ) == tan( 1/6 * PI ) == 1 / sqrt(3)                 == sqrt(3) / 3
	#   n == 3 -> tan( 3/12 * PI ) == tan( 1/4 * PI ) == 1
	#   n == 4 -> tan( 4/12 * PI ) == tan( 1/3 * PI ) == sqrt(3)
	#   n == 5 -> tan( 5/12 * PI )                    == ( sqrt(6) + sqrt(2) )^2 / 4
	#
	# 求める偏角 t' は、 0 <= t' <= PI/4 の範囲に存在することから、
	#
	#   tan( t' ) == y/x
	#             == tan( n/12 * PI + m )    ( n == 0 -> 3 )
	#
	#   -> t' == n/12 * PI + m               ( n == 0 -> 3 )
	#
	# となる。
	#
	# 正接の加法定理より、
	#
	#                                    tan(a) + tan(b)
	#   tan( x ) == tan( a + b ) == ---------------------------
	#                                 1 - ( tan(a) * tan(b) )
	#
	#   -> tan(x) - tan(x) * tan(a) * tan(b) == tan(a) + tan(b)
	# 
	#      tan(b) * ( 1 + tan(x) * tan(a) ) == tan(x) - tan(a)
	#
	#                    tan(x) - tan(a)
	#      tan(b) == ------------------------
	#                  1 + tan(x) * tan(a)
	#
	#
	# t' == n/12 * PI + m より、
	#
	#   x == t'
	#   a == n/12 * PI
	#   b == m
	#                   tan( t' ) - tan( n/12 * PI )
	#      tan(m) == ----------------------------------
	#                 1 + tan( t' ) * tan( n/12 * PI )
	# 
	# これにより、逆正接の近似計算は、
	#
	#   m == atan( tan(m) )
	#
	# を求めることに還元される。
	#
	# マクローリン展開や連分数展開等を用いて m を確定すると、求める偏角 t は、
	#
	#   y <= x  ->  t == t'     == m + n/12 * PI
	#   y >  x  ->  t == t' * 2 == ( m + n/12 * PI ) * 2
	#
	# で表す事ができる。
	#
	#
	# atan2 は「 -PI < t <= PI の範囲の値を返す」と定義されている。
	# これに合わせると、絶対値を採る前の x , y の正負によって、偏角 t は、
	#
	#   t == t		if ( x >= 0 and y >= 0 )      # 第一象限
	#   t == PI - t		if ( x <  0 and y >= 0 )      # 第二象限
	#   t == t - PI		if ( x <  0 and y <  0 )      # 第三象限
	#   t == t * ( -1 )	if ( x >= 0 and y <  0 )      # 第四象限
	#
	# となる。
	#
	my $theta = undef ;
	my $pi = pi( $dlen ) ;

	#
	# 近似値としての tan( n/12 * PI ) を求める。
	#
	#   第一象限の前半に着目するので、探索範囲は 0 <= n < 4 ( n == 3 == PI/4 も範囲に含める。 )
	#
	my $tan_dpi = [ _dpi2tan( [ 0 .. 3 ] ) ] ;
	my $dpi = undef ;
	my @pos = ( 0 , 4 , undef ) ;
	while () {
		$pos[2] = CORE::int( ( $pos[0] + $pos[1] ) / 2 ) ;
		$dpi = $pos[2] ;
		
		if	( $tan == $tan_dpi->[ $dpi ] )	{ last ; }
		elsif	( $tan <  $tan_dpi->[ $dpi ] )	{ $pos[1] = $pos[2] ; }
		else					{ $pos[0] = $pos[2] ; }

		if ( ( $pos[1] - $pos[0] ) <= 1 ) {
			$dpi = $pos[0] ;
			last ;
		}
	}

	#
	# 正接の加法定理を用いて tan( n/12 * PI + m ) と tan( n/12 * PI ) との差分を取り出す。
	# この結果を連分数展開に掛けることで偏角の差分を取り出す。
	#
	#                tan( t' ) - tan( n/12 * PI )
	#   tan(m) == ----------------------------------
	#              1 + tan( t' ) * tan( n/12 * PI )
	#
	# これに n/12 * PI を加算し、必要に応じて 2 倍することで、第一象限に写像された偏角が得られる。
	#
	#   t' == arctan( tan(m) ) + ( n/12 * PI ) 
	#
	#   y >  x  ->  t == t' * 2 == ( arctan( tan(m) ) + ( n/12 * PI ) ) * 2
	#   y <= x  ->  t == t'     == arctan( tan(m) ) + ( n/12 * PI )
	#
	my $t = ( $tan - $tan_dpi->[ $dpi ] )->divide( $tan * $tan_dpi->[ $dpi ] + 1 , $dlen + 2 ) ;
	if	( $t->is_zero() )	{ $theta = 0 ; }
	else				{ $theta = _atan_cf( $t , $dlen + 2 ) ; }	# 連分数展開

	$theta += $pi->multiply( $dpi )->divide( 12 , $dlen + 2 ) ;
	$theta *= 2	if ( $y > $x ) ;

	#
	# 象限に合わせて調整。 ( 一般角に戻す。 )
	#
	foreach ( $quadrant ) {
		/^1$/	&& do { last ; } ;
		/^2$/	&& do { $theta = $pi - $theta ;		last ; } ;
		/^3$/	&& do { $theta = $theta - $pi ;		last ; } ;
		/^4$/	&& do { $theta = $theta * ( -1 ) ;	last ; } ;
	}

	return $theta->round_down( $dlen ) ; 
}

sub sine_add {
	#-----------------------------------------------------------------------
	#
	# 正弦の加法
	#
	#   sin( a + b ) == sin( a ) * cos( b ) + cos( a ) * sin( b )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $y ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
	my $yt = { 'cos' => $y->cosine( $dlen ) , 'sin' => $y->sine( $dlen ) } ;

	my $r = ( $xt->{'sin'} * $yt->{'cos'} ) + ( $xt->{'cos'} * $yt->{'sin'} ) ;

	return $r ;
}

sub cosine_add {
	#-----------------------------------------------------------------------
	#
	# 余弦の加法
	#
	#   cos( a + b ) == cos( a ) * cos( b ) - sin( a ) * sin( b )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $y ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
	my $yt = { 'cos' => $y->cosine( $dlen ) , 'sin' => $y->sine( $dlen ) } ;

	my $r = ( $xt->{'cos'} * $yt->{'cos'} ) - ( $xt->{'sin'} * $yt->{'sin'} ) ;

	return $r ;
}

sub tan_add {
	#-----------------------------------------------------------------------
	#
	# 正接の加法
	#
	#                     sin( a + b )
	#   tan( a + b ) == ----------------
	#                     cos( a + b )
	#
	#                     sin( a ) * cos( b ) + cos( a ) * sin( b )
	#                == ---------------------------------------------
	#                     cos( a ) * cos( b ) - sin( a ) * sin( b )
	#
	#                         tan( a ) + tan( b )
	#                == -------------------------------
	#                     1 - ( tan( a ) * tan( b ) )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $y ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $xt = $x->tangent( $dlen ) ;
	my $yt = $y->tangent( $dlen ) ;

	my $f = fraction( $xt + $yt , __PACKAGE__->new( 1 ) - ( $xt * $yt ) ) ;

	return ( defined $f ) ? $f->decimal( $dlen ) : undef ;
}

sub sine_qpi_add {
	#-----------------------------------------------------------------------
	#
	# 正弦の加法
	#
	#   sin( n / 4 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $qpi , $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _qpi2cs( $qpi ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'sin'} * $xt->{'cos'} ) + ( $p->{'cos'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub cosine_qpi_add {
	#-----------------------------------------------------------------------
	#
	# 余弦の加法
	#
	#   cos( n / 4 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $qpi , $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _qpi2cs( $qpi ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'cos'} * $xt->{'cos'} ) - ( $p->{'sin'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub tangent_qpi_add {
	#-----------------------------------------------------------------------
	#
	# 正接の加法
	#
	#   tan( n / 4 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $qpi , $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $f = undef ;

	my $p = _qpi2tan( $qpi ) ;
	if ( defined $p ) {
		my $xt = $x->tangent( $dlen ) ;
		$f = fraction( $p + $xt , __PACKAGE__->new( 1 ) - ( $p * $xt ) ) ;
	}

	return ( defined $f ) ? $f->decimal( $dlen ) : undef ;
}

sub sine_dpi_add {
	#-----------------------------------------------------------------------
	#
	# 正弦の加法
	#
	#   sin( n / 12 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $dpi , $x , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _dpi2cs( $dpi ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'sin'} * $xt->{'cos'} ) + ( $p->{'cos'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub cosine_dpi_add {
	#-----------------------------------------------------------------------
	#
	# 余弦の加法
	#
	#   cos( n / 12 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $dpi , $x , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _dpi2cs( $dpi ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'cos'} * $xt->{'cos'} ) - ( $p->{'sin'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub tangent_dpi_add {
	#-----------------------------------------------------------------------
	#
	# 正接の加法
	#
	#   tan( n / 12 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $dpi , $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $f = undef ;

	my( $p ) = _dpi2tan( $dpi ) ;
	if ( defined $p ) {
		my $xt = $x->tangent( $dlen ) ;
		$f = fraction( $p + $xt , __PACKAGE__->new( 1 ) - ( $p * $xt ) ) ;
	}

	return ( defined $f ) ? $f->decimal( $dlen ) : undef ;
}

sub sine_deg_add {
	#-----------------------------------------------------------------------
	#
	# 正弦の加法
	#
	#   sin( n / 180 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $deg , $x , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _deg2cs( $deg ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'sin'} * $xt->{'cos'} ) + ( $p->{'cos'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub cosine_deg_add {
	#-----------------------------------------------------------------------
	#
	# 余弦の加法
	#
	#   cos( n / 180 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $deg , $x , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = undef ;

	my $p = _deg2cs( $deg ) ;
	if ( defined $p ) {
		my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
		$r = ( $p->{'cos'} * $xt->{'cos'} ) - ( $p->{'sin'} * $xt->{'sin'} ) ;
	}

	return $r->round( $dlen ) ;
}

sub tangent_deg_add {
	#-----------------------------------------------------------------------
	#
	# 正接の加法
	#
	#   tan( n / 180 * PI + diff )
	#
	#-----------------------------------------------------------------------
	my( $deg , $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $f = undef ;

	my $p = _deg2tan( $deg ) ;
	if ( defined $p ) {
		my $xt = $x->tangent( $dlen ) ;
		$f = fraction( $p + $xt , __PACKAGE__->new( 1 ) - ( $p * $xt ) ) ;
	}

	return ( defined $f ) ? $f->decimal( $dlen ) : undef ;
}

sub sine_w {
	#-----------------------------------------------------------------------
	#
	# 正弦の二倍角
	#
	#   sin( 2 * a ) == 2 * sin( a ) * cos( a )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->sine( $dlen ) * $x->cosine( $dlen ) * 2 ;

	return $r->round( $dlen ) ;
}

sub cosine_w {
	#-----------------------------------------------------------------------
	#
	# 余弦の二倍角
	#
	#   cos( 2 * a ) == cos( a )^2 - sin( a )^2
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->cosine( $dlen )->power( 2 ) - $x->sine( $dlen )->power( 2 ) ;

	return $r->round( $dlen ) ;
}

sub tangent_w {
	#-----------------------------------------------------------------------
	#
	# 正接の二倍角
	# 
	#
	#                     sin( 2 * a )
	#   tan( 2 * a ) == ----------------
	#                     cos( 2 * a ) 
	#
	#                        2 * cos( a ) * sin( a )
	#                == ---------------------------------
	#                     cos( a ) ** 2 - sin( a ) ** 2
	#
	#                        2 * tan( a )
	#                == ---------------------
	#                     1 - tan( a ) ** 2
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $xt = { 'cos' => $x->cosine() , 'sin' => $x->sine() } ;
	my $f = fraction(
		$xt->{'cos'} * $xt->{'sin'} * 2 ,
		$xt->{'cos'}->power( 2 ) - $xt->{'sin'}->power( 2 ) ,
	) ;

	return ( defined $f ) ? $f->decimal( $dlen ) : undef ;
}

=head2 csc

Return cosecant.

                   1
  csc( x ) == -----------
               sine( x )


  print radian( 30 )->csc() ;                   # 2
  print radian( 45 )->csc() ;                   # 1.4142135623730950488016887242096980785697
  print radian( 60 )->csc() ;                   # 1.1547005383792515290182975610039149112952

=cut

sub csc {
	#-----------------------------------------------------------------------
	#
	# 余割 ( cosecant )
	#
	#                    1
	#   csc( x ) == -------------
	#                 sine( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->sine( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 sec

Return secant.

                    1
  sec( x ) == -------------
               cosine( x )


  print radian( 30 )->sec() ;                   # 1.1547005383792515290182975610039149112952
  print radian( 45 )->sec() ;                   # 1.4142135623730950488016887242096980785697
  print radian( 60 )->sec() ;                   # 2

=cut

sub sec {
	#-----------------------------------------------------------------------
	#
	# 正割 ( secant )
	#
	#                     1
	#   sec( x ) == ---------------
	#                 cosine( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->cosine( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 cot

Return cotangent.

                     1
  cot( x ) == --------------
               tangent( x )


  print radian( 30 )->cot() ;                   # 1.7320508075688772935274463415058723669428
  print radian( 45 )->cot() ;                   # 1
  print radian( 60 )->cot() ;                   # 0.5773502691896257645091487805019574556476

=cut

sub cot {
	#-----------------------------------------------------------------------
	#
	# 余接 ( cotangent )
	#
	#                    1
	#   cot( x ) == ------------
	#                 tan( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->tangent( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 thas

Tangent half-angle substitution ( Weierstrass substitution )

In any x, which is -PI < x < PI,

  exp( ix ) == cos( x ) * i * sin( x )

                1 + i * tan( x/2 )      exp(  i * tan( x/2 ) )
            == -------------------- == ------------------------
                1 - i * tan( x/2 )      exp( -i * tan( x/2 ) )

                    exp( i * tan( x/2 ) )
            == -----------------------------
	        conj( exp( i * tan( x/2 ) )


This method will return cos( x ) and sin( x ) as array.

  print join "\n" , radian( 60 )->thas() ;              # 0.5
                                                        # 0.8660254037844386467637231707529361834714


=cut

sub thas {
	#-----------------------------------------------------------------------
	#
	# ワイエルシュトラスの置換 ( Weierstrass substitution )
	#
	#   正式には Tangent half-angle substitution ( 正接半角置換 ) と呼ばれる。
	#
	#   任意のラジアン x に対して、
	#
	#     t == tan( x / 2 )
	#   
	#   を定義すると、二倍角の公式より、
	#
	#     sin( x ) == 2 * sin( x/2 ) * cos( x/2 )
	#
	#              == 2 * t * ( cos( x/2 ) )^2
	#
	#                        2 * t                     2 * t
	#              == -------------------- == ------------------------
	#                   ( sec( x/2 ) )^2        1 + ( tan( x/2 ) )^2
	#
	#                    2 * t
	#              == -----------
	#                   1 + t^2
	#
	#     cos( x ) == 1 - 2 * ( sin( x/2 ) )^2
	#
	#              == 1 - 2 * t^2 * ( cos( x/2 ) )^2
	#
	#                           2 * t^2                     2 * t^2
	#              == 1 - ------------------ == 1 - ------------------------
	#                      ( sec( x/2 ) )^2           1 + ( tan( x/2 ) )^2
	#
	#                       2 * t^2
	#              == 1 - -----------
	#                       1 + t^2
	#
	#                   1 - t^2
	#              == -----------
	#                   1 + t^2
	#
	#  となり、更に、
	#
	#     dt / dx  == 1/2 * ( sec( x/2 ) )^2
	#
	#              == 1/2 * ( 1 + ( tan( x/2 ) )^2 )
	#
	#                   1 + t^2
	#              == -----------
	#                      2
	#
	#                   2 * dt
	#     -> dx    == -----------
	#                   1 + t^2
	#
	#
	#    exp( ix ) == cos( x ) + i * sin( x )
	#
	#                   1 - t^2             2t
	#              == ----------- + i * -----------
	#                   1 + t^2           1 + t^2
	#
	#                   1 + 2it - t^2             ( 1 + it )^2
	#              == ----------------- == ---------------------------
	#                      1 + t^2           ( 1 + it ) * ( 1 - it )
	#
	#                   1 + it       1 + i * tan( x/2 )
	#              == ---------- == --------------------
	#                   1 - it       1 - i * tan( x/2 )
	#
	#                      exp( i * t )          exp(  i * t )      exp(  i * tan( x/2 ) )
	#              == ---------------------- == --------------- == ------------------------
	#                  conj( exp( i * t ) )      exp( -i * t )      exp( -i * tan( x/2 ) )
	#
	#  となる。
	#
	#  この変換は、
	#
	#    x == PI or -PI ( mod 2PI )
	#
	#  では機能しない ( tan( PI / 2 ) == ∞ ) が、
	#
	#    x == PI or -PI
	#    -> cos( x ) == -1 , sin( x ) == 0
	#
	#  である事は自明。
	#
	#
	#  ここでは、
	#
	#    t == tan( x / 2 )
	#
	#    z == 1 + i * t
	#    z' == z / conj( z )
	#
	#    cos( x ) == real( z' )
	#    sin( x ) == imag( z' )
	#
	#  として、 @r == ( cos( x ) , sin( x ) ) となる配列を返す。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;
	return ()	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $pi = pi() ;
	$x %= ( $pi * 2 ) ;

	return ( __PACKAGE__->new( '-1' ) , __PACKAGE__->new( 0 ) )	if ( $x->abs() == $pi ) ;

	my $t = $x->divide( 2 )->tangent() ;
	my $z = complex( [ 1 , $t ] ) ;
	$z = $z / $z->conj() ;

	my @r = $z->as_array() ;

	return @r ;
}

sub tan2warg_cs {
	#-----------------------------------------------------------------------
	#
	# ワイエルシュトラスの置換の応用
	#
	#   正接を受け取り、二倍角の余弦と正弦を返す。
	#
	#-----------------------------------------------------------------------
	my( $tan ) = @_ ;
	return ()	unless ( ref( $tan ) eq __PACKAGE__ ) ;

	my $z = complex( [ 1 , $tan ] ) ;
	$z = $z / $z->conj() ;

	my @r = $z->as_array() ;

	return @r ;
}

sub cs2warg_cs {
	#-----------------------------------------------------------------------
	#
	# ワイエルシュトラスの置換の応用
	#
	#   余接と正接を受け取り、二倍角の余弦と正弦を返す。
	#
	#-----------------------------------------------------------------------
	my( $c , $s ) = @_ ;

	foreach ( $c , $s ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return ()			unless ( ref( $_ ) eq __PACKAGE__ ) ;
	}

	return ( __PACKAGE__->new( '-1' ) , __PACKAGE__->new( 0 ) )	if ( $c->is_zero() ) ;
	return $s->divide( $c )->tan2warg_cs() ;
}

sub arg2warg_cs {
	#-----------------------------------------------------------------------
	#
	# ワイエルシュトラスの置換の応用
	#
	#   偏角を受け取り、二倍角の余弦と正弦を返す。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;
	return ()	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $pi = pi() ;
	$x %= ( $pi * 2 ) ;

	return ( __PACKAGE__->new( '-1' ) , __PACKAGE__->new( 0 ) )	if ( $x->abs() == ( $pi / 2 ) ) ;
	return $x->tangent()->tan2warg_cs() ;
}

=head1 'Decimal' object - hyperbolic functions

=cut

#-------------------------------------------------------------------------------
#
# 双曲線関数
#
#-------------------------------------------------------------------------------

=head2 sinh

Return hyperbolic sine.

                exp( x ) - exp( -x )
  sinh( x ) == ----------------------
                         2


  print radian( 30 )->sinh() ;                 # 0.5478534738880398084757156477174314033528
  print radian( 45 )->sinh() ;                 # 0.8686709614860096098969241822753544020225
  print radian( 60 )->sinh() ;                 # 1.2493670505239752649541953019279756678007

=cut

sub sinh {
	#-----------------------------------------------------------------------
	#
	# 双曲線正弦 ( hyperbolic sine )
	#
	#                  e^( x ) - e^( -x )
	#   sinh( x ) == ----------------------
	#                         2
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = ( $x->exp() - $x->multiply( -1 )->exp() ) / 2 ;

	return $r->round_down( $dlen ) ;
}

=head2 cosh

Return hyperbolic cosine.

                exp( x ) + exp( -x )
  sinh( x ) == ----------------------
                         2


  print radian( 30 )->cosh() ;                 # 1.1402383210764287921411319803793508907668
  print radian( 45 )->cosh() ;                 # 1.3246090892520058466628454770033838214391
  print radian( 60 )->cosh() ;                 # 1.6002868577023862325199320179249287261632

=cut

sub cosh {
	#-----------------------------------------------------------------------
	#
	# 双曲線余弦 ( hyperbolic cosine )
	#
	#                  e^( x ) + e^( -x )
	#   cosh( x ) == ----------------------
	#                         2
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = ( $x->exp() + $x->multiply( -1 )->exp() ) / 2 ;

	return $r->round_down( $dlen ) ;
}

=head2 tanh

Return hyperbolic tangent.

                sinh( x )      exp( x ) - exp( -x )
  tanh( x ) == ----------- == ----------------------
                cosh( x )      exp( x ) + exp( -x )


  print radian( 30 )->tanh() ;                 # 0.480472778156451605860845287075243225991
  print radian( 45 )->tanh() ;                 # 0.6557942026326724356531211426917828879854
  print radian( 60 )->tanh() ;                 # 0.7807144353592677128562290348274513189461

=cut

sub tanh {
	#-----------------------------------------------------------------------
	#
	# 双曲線正接 ( hyperbolic tangent )
	#
	#                  sinh( x )
	#   tanh( x ) == -------------
	#                  cosh( x )
	#
	#                  ( e^( x ) - e^( -x ) ) / 2
	#             == ------------------------------
	#                  ( e^( x ) + e^( -x ) ) / 2
	#
	#                  e^( x ) - e^( -x )
	#             == ----------------------
	#                  e^( x ) + e^( -x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $ex1 = $x->exp() ;
	my $ex2 = $x->multiply( -1 )->exp() ;

	my $r = ( $ex1 - $ex2 ) / ( $ex1 + $ex2 ) ;

	return $r->round_down( $dlen ) ;
}

=head2 csch

Return hyperbolic cosecant.

                    1
  csch( x ) == -----------
                sinh( x )


  print radian( 30 )->csch() ;                 # 1.8253055746879530816526448518311373007351
  print radian( 45 )->csch() ;                 # 1.1511838709208486779082364329517304306061
  print radian( 60 )->csch() ;                 # 0.8004052928885930076257087027612777755953

=cut

sub csch {
	#-----------------------------------------------------------------------
	#
	# 双曲線余割 ( hyperbolic cosecant )
	#
	#                      1
	#   csch( x ) == -------------
	#                  sinh( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->sinh( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 sech

Return hyperbolic secant.

                    1
  sech( x ) == -----------
                cosh( x )


  print radian( 30 )->sech() ;                 # 0.8770096404547792886219904382382500512242
  print radian( 45 )->sech() ;                 # 0.7549397087141312673916684913178157958022
  print radian( 60 )->sech() ;                 # 0.6248879662960871868275607935005243123022

=cut

sub sech {
	#-----------------------------------------------------------------------
	#
	# 双曲線正割 ( hyperbolic secant )
	#
	#                      1
	#   sech( x ) == -------------
	#                  cosh( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->cosh( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 coth

Return hyperbolic cotangent.

                    1
  coth( x ) == -----------
                tanh( x )


  print radian( 30 )->coth() ;                 # 2.0812833639336376211122626925977987771813
  print radian( 45 )->coth() ;                 # 1.5248686188220640244069037792021796311286
  print radian( 60 )->coth() ;                 # 1.2808780710450446134865539898365210015863

=cut

sub coth {
	#-----------------------------------------------------------------------
	#
	# 双曲線余接 ( hyperbolic cotangent )
	#
	#                      1
	#   coth( x ) == -------------
	#                  tanh( x )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->tanh( $dlen )->inverse() ;

	return $r->round_down( $dlen ) ;
}

=head2 pi

  print pi() ;               # 3.1415926535897932384626433832795028841971
  print pi(2) ;              # 3.14
  print pi(50) ;             # 3.14159265358979323846264338327950288419716939937508

=cut

#-------------------------------------------------------------------------------
#
# 円周率
#
#-------------------------------------------------------------------------------
sub pi {
	#-----------------------------------------------------------------------
	#
	# 円周率
	#
	#   任意の桁数が要求されている場合には、その都度計算して返す。
	#   デフォルトでは小数点以下 40 桁の固定値を返す。
	#
	#-----------------------------------------------------------------------
	my( $dlen ) = ( ref( $_[0] ) ) ? $_[1] : $_[0] ;

	return qpi( $dlen ) * 4	if ( defined $dlen and $dlen > 40 ) ;

	my $pi = __PACKAGE__->new( '3.1415926535897932384626433832795028841971' ) ;

	return ( defined $dlen ) ? $pi->round( $dlen ) : $pi ;
}

sub qpi {
	#-----------------------------------------------------------------------
	#
	# 円周率の 1/4 を返す。
	#
	# Math::BigFloat では、以下の方法で円周率を求めている。
	#
	#   pi/4 == 183 * atan(    1/239 ) + 32 * atan(    1/1023 ) -  68 * atan(    1/5832 )
	#          + 12 * atan( 1/110443 ) - 12 * atan( 1/4841182 ) - 100 * atan( 1/6826318 )
	#
	# atan( 1/x ) は 1 以上の奇数値 k を伴って、
	#
	#   atan( 1/x ) == Σ( 1 / ( ( x^k ) * k ) )
	#
	# で求められる。
	#
	# このメソッドは、この手法を踏襲したもの。
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) ) ? $_[1] : $_[0] ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;
	my $n = $dlen + 5 ;

	#
	# atan( 1/x ) の結果を示す分数を受け取る。
	#
	#   $x->[ $i ]->[0] が分子
	#   $x->[ $i ]->[1] が分母
	#
	my $x = [] ;
	$x->[0] = _atan_inv(     239 , $n ) ;
	$x->[1] = _atan_inv(    1023 , $n ) ;
	$x->[2] = _atan_inv(    5832 , $n ) ;
	$x->[3] = _atan_inv(  110443 , $n ) ;
	$x->[4] = _atan_inv( 4841182 , $n ) ;
	$x->[5] = _atan_inv( 6826318 , $n ) ;

	#
	# 分子に係数を掛ける。
	#
	$x->[0]->[0] *= 183 ;
	$x->[1]->[0] *=  32 ;
	$x->[2]->[0] *=  68 ;
	$x->[3]->[0] *=  12 ;
	$x->[4]->[0] *=  12 ;
	$x->[5]->[0] *= 100 ;

	#
	# 分子を分母で除算した小数値を取得。
	#
	my $y = [] ;
	foreach ( my $i = 0 ; $i < @{ $x } ; $i++ ) {
		my( $numer , $denom ) = @{ $x->[ $i ] }[ 0 , 1 ] ;
		$y->[ $i ] = $numer->divide( $denom , $dlen + 1 ) ;
	}

	#
	# 円周率の 1/4 を算出。
	#
	my $pi = $y->[0] + $y->[1] - $y->[2] + $y->[3] - $y->[4] - $y->[5] ;

	return $pi->round_down( $dlen ) ;
}

sub pi_machin {
	#-----------------------------------------------------------------------
	#
	# マチンの公式 ( Machin's formula ) による円周率
	#
	# マチンの公式は以下の通り。
	#
	#   pi/4 == 4 * arctan( 1/5 ) - arctan( 1/239 )
	#
	# arctan( x ) をグレゴリー級数で置き換えると、
	#
	#   pi(m) == 16 * arctan( 1/5 ) - 4 * arctan( 1/239 )
	#
	#                      (-1)^n       1                        (-1)^k        1
	#         == 16 * Σ( -------- * ( --- )^(2n+1) ) - 4 * Σ( -------- * ( ----- )^(2k+1) )
	#                      2n + 1       5                        2k + 1       239
	#
	#         ( n == 0 -> 3m + 2 , k == 0 -> m )
	#
	# が得られる。
	#
	# m が 1 増える度に項数は 4 増えるが、 m == 10 辺りで有効桁数 47 桁程度の精度が得られるとのこと。
	# ただし、演算途中の有効桁数をかなり大きくとらないと精度が上がらない。
	# 実用上は有効桁数 40 桁位が限度かもしれない。
	#
	#-----------------------------------------------------------------------
	my $m = shift || 10 ;

	my $lp0 = __PACKAGE__->new( 1 )->divide( 5 , 200 ) ;
	my $rp0 = __PACKAGE__->new( 1 )->divide( 239 , 200 ) ;

	my $lp = $lp0->copy() ;
	my $rp = $rp0->copy() ;

	my $lim = $m * 3 + 2 ;
	foreach my $i ( 1 .. $lim ) {
		my $sgn = ( ( $i & 1 ) == 1 ) ? (-1) : 1 ;	# (-1)^n
		my $p = ( $i * 2 + 1 ) ;			# 2n + 1
		my $c = __PACKAGE__->new( $sgn )->divide( $p , 200 ) ;		# (-1)^n / ( 2n + 1 )
		
								#        (-1)^n       1
		$lp += $c * ( $lp0 ** $p ) ;			# lp += -------- * ( --- )^(2n+1) ;
								#        2n + 1       5
		if ( $i <= $m ) {
								#        (-1)^k        1
			$rp += $c * ( $rp0 ** $p ) ;		# rp += -------- * ( ----- )^(2k+1)
								#        2k + 1       239
		}
	}

	my $r = $lp * 16 - $rp * 4 ;

	return $r ;
}

sub pi_gauss {
	#-----------------------------------------------------------------------
	#
	# ガウス・ルジャンドルの円周率
	#
	# 4 回のループで小数点以下 38 桁までの精度が得られている。
	# ただし、ループ 1 回のコストは小さくない。
	#
	#-----------------------------------------------------------------------
	my @c = (
		__PACKAGE__->new( 1 ) ,				# 1
		__PACKAGE__->new( 2 )->inverse_root( 2 ) ,	# 1/sqrt(2)
		__PACKAGE__->new( 0.25 ) ,			# 1/4
		__PACKAGE__->new( 1 ) ,				# 1
	) ;

	foreach ( 1 .. 4 ) {
		my @d = () ;
		foreach my $i ( 0 .. 3 ) {
			$d[ $i ] = $c[ $i ]->copy() ;
		}
		$c[0] = ( $d[0] + $d[1] ) * 0.5 ;
		$c[1] = ( $d[0] * $d[1] )->sqrt() ;
		$c[2] = $d[2] - ( $d[3] * ( ( $d[0] - $c[0] ) ** 2 ) ) ;
		$c[3] = $d[3] * 2 ;
	}

	my $pi = ( ( $c[0] + $c[1] ) ** 2 ) / ( $c[2] * 4 ) ;

	return $pi ;
}

sub pi_chudnovsky {
	#-----------------------------------------------------------------------
	#
	# チュドノフスキー ( Chudnovsky ) アルゴリズムによる円周率
	#
	#   チュドノフスキーのアルゴリズムは、
	#
	#      1                ( -1 )^n * ( 6n )! * ( A + B * n )
	#     ---- == 12 * Σ( ------------------------------------- )   ( n == 0 -> ∞ , A == 13591409 , B = 545140134 , C == 640320 )
	#      PI               ( 3n )! * ( n! )^3 * C^( 3n + 3/2 )
	#
	#   で表される。
	#
	#   n が 1 進むごとに 14 桁ずつ精度が上がるとのこと。
	#
	#   収束は非常に速く、 n == 0 -> 2 で小数点以下 40 桁の精度が得られている。
	#   しかし、 n == 4 程度で小数点以下 48 桁の精度に達した後、値が動かなくなる。
	#   ループ回数をいくら延ばしても効果がないため、除算の実装に問題があるのかもしれない。
	#
	#
	#   積和演算の中身を整理し、
	#
	#      ( 6n )!       Π( 6k * ( 6k - 1 ) * ( 6k - 2 ) * ( 6k - 3 ) * ( 6k - 4 ) * ( 6k - 5 ) )
	#     --------- == -----------------------------------------------------------------------------        ( k == 1 -> n )
	#      ( 3n )!       Π( 3k * ( 3k - 1 ) * ( 3k - 2 ) )
	#
	#               == Π( 2 * ( 6k - 1 ) * 2 ( 6k - 3 ) * 2 * ( 6k - 5 ) )                                 ( k == 1 -> n )
	#
	#               == Π( 24 * ( 6k - 1 ) * ( 2k - 1 ) * ( 6k - 5 ) )                                      ( k == 1 -> n )
	#
	#               == 24^n * Π( ( 2k - 1 ) * ( 6k - 1 ) * ( 6k - 5 ) )                                    ( k == 1 -> n )
	#
	#               == 24^n * Π( p(k) )
	#
	#     -> p(k) == ( 2k - 1 ) * ( 6k - 1 ) * ( 6k - 5 )
	#
	#     a(k) == ( -1 )^k * ( A + B * k )
	#     q(k) == k^3 * C^3 / 24
	#
	#   とおくと、
	#
	#      1         12            a(n) * Π( p(k) )
	#     ---- == --------- * Σ( ------------------- )         ( n == 0 -> ∞ , k == 1 -> n )
	#      PI      C^(3/2)             Π( q(k) )
	#
	#                12                       p(k)
	#          == --------- * Σ( a(n) * Π( ------ ) + a(0) )  ( n == 1 -> ∞ , k == 1 -> n )
	#              C^(3/2)                    q(k)
	#
	#    となる。
	#
	#    ここで、
	#                                      p(k)
	#      S( n1 , n2 ) == Σ( a(n) * Π( ------ ) )            ( n == n1 + 1 -> n2 , k == n1 + 1 -> n )
	#                                      q(k)
	#
	#      P( n1 , n2 ) == Π( p(k) )                           ( k == n1 + 1 -> n2 )
	#      Q( n1 , n2 ) == Π( q(k) )                           ( k == n1 + 1 -> n2 )
	#
	#    とおき、
	#
	#      T( n1 , n2 ) == S( n1 , n2 ) * Q( n1 , n2 )
	#
	#                                        p(k)
	#                   == ( Σ( a(n) * Π( ------ ) ) * ( Π( q(k) ) )
	#                                        q(k)
	#
	#                   == Σ( a(n) * Π( p(k) ) * Π( q(r) ) )    ( n == n1 + 1 -> n2 , k == n1 + 1 -> n , r == n + 1 -> n2 )
	#
	#    を定義すると、
	#
	#       1         12        T( 0 , N ) + A * Q( 0 , N )
	#      ---- == --------- * -----------------------------
	#       PI      C^(3/2)             Q( 0 , N )
	#    
	#                C^(3/2)             Q( 0 , N )
	#      -> PI == --------- * -----------------------------
	#                  12        T( 0 , N ) + A * Q( 0 , N )
	#
	#    となる。
	#
	#    この時、 P , Q , T の漸化式は、
	#
	#      P( 0 , 0 ) == 1
	#      Q( 0 , 0 ) == 1
	#      T( 0 , 0 ) == 0
	#
	#      P( 0 , N ) == P( 0 , N - 1 ) * p(N)
	#      Q( 0 , N ) == Q( 0 , N - 1 ) * q(N)
	#      T( 0 , N ) == T( 0 , N - 1 ) * q(N) + a(N) * P( 0 , N )
	#
	#    となる。
	#
	#    演算効率を考えると、
	#
	#      P( n1 , n2 ) == P( n1 , m ) * P( m , n2 )
	#      Q( n1 , n2 ) == Q( n1 , m ) * Q( m , n2 )
	#      T( n1 , n2 ) == T( n1 , m ) * Q( m , n2 ) + P( n1 , m ) * T( m , n2 )
	#
	#      m == floor( ( n1 + n2 ) / 2 )
	#
	#    とするのが良いらしい ( Binary Splitting 法 ) のだが、再帰呼び出しで実装すると、すぐに Deep recursing を引き起こしてしまう。
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) ) ? $_[1] : $_[0] ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $limit = CORE::int( $dlen / 14 ) ;

	my @c = ( 13591409 , 545140134 , 640320 ) ;
	my $c1 = __PACKAGE__->new( $c[2] )->power( 3 )->divide( 24 ) ;

	my $pqt = [ 1 , 1 , 0 ] ;

	foreach ( my $k = __PACKAGE__->new( 1 ) ; $k <= $limit ; $k++ ) {
		#
		# p(k) == ( 2k - 1 ) * ( 6k - 1 ) * ( 6k - 5 )
		# q(k) == k^3 * C^3 / 24
		# a(k) == ( -1 )^k * ( A + B * k )
		#
		# P( 0 , N ) == P( 0 , N - 1 ) * p(N)
		# Q( 0 , N ) == Q( 0 , N - 1 ) * q(N)
		# T( 0 , N ) == T( 0 , N - 1 ) * q(N) + a(N) * P( 0 , N )
		#
		my $pk = ( $k * 2 - 1 ) * ( $k * 6 - 1 ) * ( $k * 6 - 5 ) ;
		my $qk = ( $k ** 3 ) * $c1 ;
		my $ak = ( $k * $c[1] ) + $c[0] ;
		$ak *= ( -1 )	if ( $k->is_odd() ) ;

		$pqt->[0] *= $pk ;
		$pqt->[1] *= $qk ;
		$pqt->[2] = ( $pqt->[2] * $qk ) + $ak * $pqt->[0] ;

		my $numer = ( __PACKAGE__->new( $c[2] )->power( 3 )->sqrt() ) * $pqt->[1] ;
		my $denom =( $pqt->[2] + $pqt->[1] * $c[0] ) * 12 ;
		warn $numer->divide( $denom , $dlen ) , "\n" ;
	}

	#
	#        C^(3/2)             Q( 0 , N )
	# PI == --------- * -----------------------------
	#          12        T( 0 , N ) + A * Q( 0 , N )
	#
	my $numer = ( __PACKAGE__->new( $c[2] )->power( 3 )->sqrt() ) * $pqt->[1] ;
	my $denom =( $pqt->[2] + $pqt->[1] * $c[0] ) * 12 ;

	return $numer->divide( $denom , $dlen ) ;
}

sub pi_cf10 {
	#-----------------------------------------------------------------------
	#
	# 連分数展開による円周率
	#
	#                                  1
	#   PI / 4 == 0 + ------------------------------------
	#                                     1
	#                  1 + -------------------------------
	#                                     2 + 2
	#                       1 + --------------------------
	#                                         3
	#                            1 + ---------------------
	#                                          4 + 4
	#                                 1 + ----------------
	#                                              5
	#                                      1 + -----------
	#                                           ........
	#
	#
	#   有効桁数 40 桁を得るには 300 回程度の連分数展開が必要。
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) ) ? $_[1] : $_[0] ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $cf = [ [ 0 , 1 ] ] ;
	my $lim = $dlen * 10 ;

	foreach my $i ( 1 .. $lim ) {
		if ( ( $i & 1 ) == 1 )	{ push( @{ $cf } , [ 1 , $i ] ) ; }
		else			{ push( @{ $cf } , [ 1 , $i * 2 ] ) ; }
	}

	my $r = cf2frac2( $cf ) * 4 ;

	return $r->decimal( $dlen + 3 )->round_down( $dlen ) ;
}

sub pi_cf20 {
	#-----------------------------------------------------------------------
	#
	# 連分数展開による円周率
	#
	#                             4
	#   PI == 0 + ------------------------------------
	#                              1^2
	#              1 + -------------------------------
	#                                2^2
	#                   3 + --------------------------
	#                                   3^2
	#                        5 + ---------------------
	#                                      4^2
	#                             7 + ----------------
	#                                         5^2
	#                                  9 + -----------
	#                                       .........
	#
	#
	#   この連分数展開は、有効桁数の 2 倍程度の回数の連分数展開で収束する。
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) ) ? $_[1] : $_[0] ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $cf = [ [ 0 , 4 ] ] ;
	my $lim = $dlen * 2 ;

	foreach my $i ( 1 .. $lim ) {
		if ( $i == 1 )	{ push( @{ $cf } , [ 1 , $i ] ) ; }
		else		{ push( @{ $cf } , [ $i * 2 - 1 , $i ** 2 ] ) ; }
	}

	my $r = cf2frac2( $cf ) ;

	return $r->decimal( $dlen + 3 )->round_down( $dlen ) ;
}

#-------------------------------------------------------------------------------
#
# ラジアン
#
#-------------------------------------------------------------------------------
sub rad2deg {
	#-----------------------------------------------------------------------
	#
	# radian -> degree
	#
	#                         180
	#   degree( x ) == ( x * ----- ) % 360
	#                          PI
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $pi = pi( $dlen ) ;
	my $r = $x->multiply( 180 )->divide( $pi , $dlen + 2 )->round( $dlen ) ;

	my $sgn = ( $r < 0 ) ? -1 : 1 ;
	$r = $r->abs()->modulus( 360 ) * $sgn ;

	return ( defined $_[1] and $_[1] =~ /^\d+$/ ) ? $r : $r->round( 3 ) ;
}

=head2 degree

  print pi()->divide(2)->degree() ;            # 90
  print pi()->divide(3)->degree() ;            # 60
  print pi()->divide(4)->degree() ;            # 45
  print pi()->divide(6)->degree() ;            # 30

=cut

sub degree { return rad2deg( @_ ) ; }

sub deg2rad {
	#-----------------------------------------------------------------------
	#
	# degree -> radian
	#
	#                          PI
	#   radian( x ) == ( x * ----- ) % ( 2 * PI )
	#                         180
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $pi = pi( $dlen ) ;
	my $r = $x->multiply( $pi )->divide( 180 , $dlen + 2 )->round( $dlen ) ;
	
	my $sgn = ( $r < 0 ) ? -1 : 1 ;
	$r = $r->abs()->modulus( $pi * 2 ) * $sgn ;

	return $r ;
}

=head2 radian

  print radian( 30 ) ;                         # 0.5235987755982988730771072305465838140329
  print radian( 45 ) ;                         # 0.7853981633974483096156608458198757210493
  print radian( 60 ) ;                         # 1.0471975511965977461542144610931676280657
  print radian( 90 ) ;                         # 1.5707963267948966192313216916397514420986

=cut

sub radian { return deg2rad( @_ ) ; }

=head2 npi

  print radian( 30 )->npi() ;                  # 0.1666666666666666666666666666666666666667
  print radian( 45 )->npi() ;                  # 0.25
  print radian( 60 )->npi() ;                  # 0.3333333333333333333333333333333333333333
  print radian( 90 )->npi() ;                  # 0.5

  print radian( 30 )->npi()->fraction() ;      # 1/6
  print radian( 45 )->npi()->fraction() ;      # 1/4
  print radian( 60 )->npi()->fraction() ;      # 1/3
  print radian( 90 )->npi()->fraction() ;      # 1/2

=cut

sub npi {
	#-----------------------------------------------------------------------
	#
	# ラジアンを円周率の倍数で返す。
	#
	#                 x
	#   npi( x ) == ----- % 2
	#                PI
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $pi = pi( $dlen ) ;
	my $r = $x->divide( $pi , $dlen + 2 )->round( $dlen ) ;

	my $sgn = ( $r < 0 ) ? -1 : 1 ;
	$r = $r->abs()->modulus( 2 ) * $sgn ;

	return $r ;
}

=head1 'Decimal' object - logarithm and exponential operation

=cut

#-------------------------------------------------------------------------------
#
# 対数
#
#-------------------------------------------------------------------------------

sub ln2 {
	#-----------------------------------------------------------------------
	#
	# ln(2) を返す。
	#
	#   デフォルトでは定数を返す。
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) eq __PACKAGE__ ) ? $_[1] : $_[0] ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# 小数点以下 256 桁までは定数として扱う。
	#
	#my $r = __PACKAGE__->new( '0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156058633269964186875' ) ;
	my $r = __PACKAGE__->new(
		#1--------------16--------------32--------------48--------------64
		'0.' .
		'6931471805599453094172321214581765680755001343602552541206800094' .
		'9339362196969471560586332699641868754200148102057068573368552023' .
		'5758130557032670751635075961930727570828371435190307038623891673' .
		'4711233501153644979552391204751726815749320651555247341395258829'
	) ;

	#
	# より細かい値が要求された場合には級数展開を行う。
	#
	if ( $dlen > 256 ) {
		#
		# 級数展開よる演算
		#
		#                        t^( 2n + 1 )
		#   ln( x ) == 2 * Σ( ---------------- )          ( n == 0 -> ∞ )
		#                           2n + 1 
		#          x - 1
		#   t == ---------
		#          x + 1
		#
		#                        ( 1/3 )^( 2n + 1 )
		#   ln( 2 ) == 2 * Σ( ---------------------- )                 ( n == 0 -> ∞ )
		#                             2n + 1
		#
		#                                    1
		#           == 2 * Σ( ----------------------------- )          ( n == 0 -> ∞ )
		#                        3^( 2n + 1 ) * ( 2n + 1 )
		#
		#                     1        1             1
		#           == 2 * ( --- + ---------- + ----------- + ..... )
		#                     3     3^3 * 3       3^5 * 5
		#
		#                     1       1         1
		#           == 2 * ( --- + ------ + -------- + ..... ) 
		#                     3      81       1215
		#
		my $t = fraction( 1 , 3 ) ;
		$r = $t->copy() ;

		my $f = [] ;
		my $n = __PACKAGE__->new( 0 ) ;
		while ( ++$n ) {
			my $odd = $n->multiply( 2 )->add( 1 ) ;
			push( @{ $f } , $t->power( $odd )->divide( $odd ) ) ;
			if ( @{ $f } >= 10 ) {
				$r = $r->add( $f ) ;
				last	if ( $f->[-1]->decimal( $dlen + 1 )->is_zero() ) ;
				$f = [] ;
			}
		}
		$r = $r->multiply( 2 )->decimal( $dlen ) ;
	}

	return $r->round_down( $dlen ) ;
}

sub ln2_base {
	#-----------------------------------------------------------------------
	#
	# 自然対数 ln(2) を返す。
	#
	#   ln(2) の算出方法を示すためのもの。
	#   演算コストが高いため、実用性は乏しい。
	#
	#
	#   ln(2) は超越数であり、連分数表記では以下のようになる。
	#
	#     ln(2) == [ 0 ; 1 , 2 , 3 , 1 , 6 , 3 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 3 , 10 , ..... ]
	#
	#   超越数は無理数でもあるので、正則連分数に規則性はない。
	#
	#
	#   対数関数のテイラー展開は以下の通り。
	#
	#                          ( -1 ) ** ( n + 1 )
	#     ln( 1 + x ) == Σ( ----------------------- * ( x ** n ) )            ( n == 1 -> ∞ )
	#                                  n
	#
	#                          x^2       x^3       x^4
	#                 == x - ------- + ------- - ------- + ......
	#                           2         3         4
	#
	#   上記テイラー展開には abs( x ) < 1 という条件があるが、 x == 1 つまり ln(2) に関してはうまく収束するらしい。
	#   要するに正しい条件は ( x == 1 or abs( x ) < 1 ) と言うことになる。
	#
	#   テイラー展開による ln(2) の定義は以下のようになる。
	#
	#                      ( -1 ) ** ( n + 1 )             1     1     1
	#     ln( 2 ) == Σ( ----------------------- ) == 1 - --- + --- - --- + ......
	#                              n                       2     3     4
	#
	#   また、
	#
	#     ln( 1/2 ) == ln( 1 ) - ln( 2 )
	#               == 0 - ln( 2 )
	#               == ( -1 ) * ln( 2 )
	#
	#   であることから、
	#
	#     ln( 2 ) == ln( 0.5 ) * ( -1 )
	#
	#   として求めることもできる。
	#
	#
	#   級数展開の効率化
	#
	#     ln( 1 + x ) の展開式に x == -x を適用すると、
	#
	#                            ( -1 ) ** ( n + 1 ) 
	#       ln( 1 - x ) == Σ( ----------------------- * ( -x ** n ) )           ( n == 1 -> ∞ )
	#                                    n
	#
	#                             x^2       x^3       x^4
	#                   == -x + ------- + ------- + ------- + ......
	#                              2         3         4
	#
	#     となる。
	#
	#                     1 + y
	#     ここで、 x == --------- となる y を定義すると、
	#                     1 - y
	#
	#                        1 + y
	#       ln( x ) == ln( --------- ) == ln( 1 + y ) - ln( 1 - y )
	#                        1 - y
	#
	#                              y^3       y^5
	#               == 2 * ( x + ------- + ------- + .... )
	#                               3         5
	#
	#                             y^( 2n + 1 )
	#               == 2 * Σ( ----------------- )                ( n == 0 -> ∞ )
	#                                2n + 1
	#
	#     が得られ、級数展開の項数が削減される。
	#
	#            1 + y                 x - 1
	#     x == --------- より、 y == --------- であり、
	#            1 - y                 x + 1
	#
	#                            y^( 2n + 1 )
	#       ln( x ) == 2 * Σ( ----------------- )                            ( n == 0 -> ∞ )
	#                               2n + 1
	#
	#                                    ( x - 1 )^( 2n + 1 )
	#               == 2 * Σ( ------------------------------------- )        ( n == 0 -> ∞ )
	#                            ( x + 1 )^( 2n + 1 ) * ( 2n + 1 )
	#
	#     となる。
	#
	#     この場合、 ln( 2 ) は、
	#
	#             2 - 1      1
	#       y == ------- == ---
	#             2 + 1      3
	#
	#                            ( 1/3 )^( 2n + 1 )
	#       ln( 2 ) == 2 * Σ( ---------------------- )            ( n == 0 -> ∞ )
	#                                 2n + 1
	#
	#                                        1
	#               == 2 * Σ( ----------------------------- )     ( n == 0 -> ∞ )
	#                            3^( 2n + 1 ) * ( 2n + 1 )
	#
	#     となる。
	#
	#            1 + y
	#     x == --------- として演算を行うことの妥当性は、対数の公式に則って展開することで確認できる。
	#            1 - y
	#
	#     x == 2 の場合、 y == 1/3
	#
	#       ln( 2 ) == ln( ( 1 + 1/3 ) / ( 1 - 1/3 ) )
	#               == ln( ( 4/3 ) / ( 2/3 ) )
	#               == ln( 4/3 ) - ln( 2/3 )
	#               == ( ln( 4 ) - ln( 3 ) ) - ( ln( 2 ) - ln( 3 ) )
	#               == ln( 4 ) - ln( 2 )
	#               == ln( 2 * 2 ) - ln( 2 )
	#               == ln( 2 ) + ln( 2 ) - ln( 2 )
	#               == ln( 2 )
	#
	#     となる。
	#
	#   これ以外にも、以下のような級数展開も存在する。
	#
	#                            1
	#     ln( 2 ) == Σ( ------------------ )       ( n == 1 -> ∞ )
	#                      n * ( 2 ** n )
	#
	#-----------------------------------------------------------------------

	my $flg = $_[0] || 2 ;
	my $r = undef ;

	if ( $flg == 0 ) {
		#
		# テイラー展開
		#
		#   収束が遅く精度も悪い。
		#
		my $f = [] ;
		my $sgn = ( -1 ) ;
		foreach ( my $i = 1 ; $i <= 100 ; $i++ ) {
			$sgn *= ( -1 ) ;
			push( @{ $f } , fraction( $sgn , $i ) ) ;
		}

		my $f0 = shift( @{ $f } ) ;
		$r = $f0->add( $f ) ;
	}
	elsif ( $flg == 1 ) {
		#
		#          1
		# Σ( ----------- ) による級数展開
		#       n * 2^n
		#
		#   比較的収束が速い。
		#   小数点以下 40 桁の値を Perl の bignum と同程度の精度で得るには、
		#   n == 140 程度の繰り返し演算が必要。
		#
		my $f = [] ;
		my $two = __PACKAGE__->new( 2 ) ;
		foreach ( my $n = __PACKAGE__->new( 1 ) ; $n <= 140 ; $n++ ) {
			push( @{ $f } , fraction( 1 , $n * $two->power( $n ) ) ) ;
		}
		my $f0 = shift( @{ $f } ) ;
		$r = $f0->add( $f ) ;
	}
	elsif ( $flg == 2 ) {
		#
		#        x - 1        1
		# t == --------- == -----
		#        x + 1        3
		#
		#                      ( 1/3 )^( 2n + 1 )
		# ln( 2 ) == 2 * Σ( ---------------------- )
		#                           2n + 1 
		#
		#   かなり収束が速い。
		#   小数点以下 40 桁の値を Perl の bignum と同程度の精度で得るには、
		#   n == 42 程度の繰り返し演算で求めることができる。
		#
		my $f = [] ;
		my $t = fraction( 1 , 3 ) ;
		foreach ( my $n = __PACKAGE__->new( 0 ) ; $n <= 42 ; $n++ ) {
			my $odd = $n->multiply( 2 )->add( 1 ) ;
			push( @{ $f } , $t->power( $odd )->divide( $odd ) ) ;
		}
		my $f0 = shift( @{ $f } ) ;
		$r = $f0->add( $f )->multiply( 2 ) ;
	}
	elsif ( $flg == 3 ) {
		#
		# 連分数を復元
		#
		#   整数部を含めて 100 の要素を持つ配列から、小数点以下 40 桁程度の ln(2) を復元する。
		#
		my @cf = (
			 0 ,  1 ,  2 ,  3 ,  1 ,  6 ,  3 ,  1 ,  1 ,  2 ,
			 1 ,  1 ,  1 ,  1 ,  3 , 10 ,  1 ,  1 ,  1 ,  2 ,
			 1 ,  1 ,  1 ,  1 ,  3 ,  2 ,  3 ,  1 , 13 ,  7 ,
			 4 ,  1 ,  1 ,  1 ,  7 ,  2 ,  4 ,  1 ,  1 ,  2 ,
			 5 , 14 ,  1 , 10 ,  1 ,  4 ,  2 , 18 ,  7 ,  1 ,
			24 ,  1 , 39 ,  1 ,  4 ,  1 , 12 ,  1 , 14 ,  2 ,
			 1 ,  1 ,  1 , 42 , 16 ,  4 ,  3 ,  2 , 11 ,  1 ,
			 3 ,  1 ,  1 ,  1 ,  3 ,  2 ,  3 ,  9 ,  1 , 33 ,
			 3 ,  2 , 11 ,  1 ,  5 , 10 ,  5 ,  5 ,  2 , 10 ,
			 1 ,  1 , 12 ,  2 ,  1 ,  4 ,  5 ,  7 , 38 ,  1 ,
		) ;
		$r = cf2frac( @cf ) ;
	}

	return $r ;
}

sub ln10 {
	#-----------------------------------------------------------------------
	#
	# ln(10) を返す。
	#
	#   デフォルトでは定数を返す。
	#
	#   ln(10) とネイピア数との間には以下のような関係がある。
	#
	#     ln(10) == 2.3025850929940456840179914546843642076010.....
	#            == log(10) / log(e)
	#            == 1 / log(e)
	#
	#     -> log(e)     == 1 / ln(10) == 0.4342944819032518276511289189166050822944.....
	#        1 / log(e) == ln(10)     == 2.3025850929940456840179914546843642076010.....
	#
	#   これにより、 ln(10) を定数として用いることで自然対数と常用対数の相互変換が容易になる。
	#
	#     ln(x)  == log(x) / log(e) == log(x) * ln(10) == log(x) * 2.3025850929940456840179914546843642076010.....
	#     log(x) == ln(x)  * log(e) == ln(x)  / ln(10) == ln(x)  * 0.4342944819032518276511289189166050822944.....
	#
	#-----------------------------------------------------------------------
	my $dlen = ( ref( $_[0] ) eq __PACKAGE__ ) ? $_[1] : $_[0] ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# 小数点以下 128 桁までは定数として扱う。
	#
	my $r = __PACKAGE__->new(
		#1--------------16--------------32--------------48--------------64
		'2.' . 
		'3025850929940456840179914546843642076011014886287729760333279009' .
		'6757260967735248023599720508959829834196778404228624863340952546' 
	) ;

	#
	# より細かい値が要求された場合には再計算する。
	#
	if ( $dlen > 128 ) {
		$r = __PACKAGE__->new( 10 )->ln( $dlen ) ;
	}

	return $r->round_down( $dlen ) ;
}

=head2 ln

Return the natural logarithm.

  print decimal( 2 )->ln() ;             # 0.6931471805599453094172321214581765680755
  print decimal( 10 )->ln() ;            # 2.3025850929940456840179914546843642076011
  print napier()->ln() ;                 # 0.9999999999999999999999999999999999999999

=cut

sub ln {
	#-----------------------------------------------------------------------
	#
	# 自然対数 ( natural logarithm )
	#
	#
	#   対数の基本公式
	#
	#     log( x * y ) == log( x ) + log( y )
	#     log( x / y ) == log( x ) - log( y )
	#     log( x^p )   == p * log( x )
	#     log( 1/x )   == log( x ** -1 ) == -1 * log( x )
	#
	#   この基本公式により、全ての有理数は素数の対数の倍数の総和として表現できることが判る。
	#
	#     log( 6 ) == log( 2 * 3 )
	#              == log( 2 ) + log( 3 )
	#
	#     log( 147 ) == log( 3 * 7^2 )
	#                == log( 3 ) + 2 * log( 7 )
	#
	#
	#   無理数を含む実数 x の対数は以下のように分解される。
	#
	#     x == d * ( 2^p )   ( 0 < d < 1 )
	#
	#     log( x ) == log( d * ( 2^p ) )
	#              == log( d ) + p * log( 2 )
	#
	#   自然対数 ( natural logarithm ) ln( x ) も同様に
	#
	#     ln( x ) == ln( d * ( 2^p ) )
	#             == ln( d ) + p * ln( 2 )
	#
	#   として求められる。
	#
	#   これにより、 ln( 2 ) を定数として持っておけば、任意の ln( x ) を容易に求めることができる。
	#
	#   ln( d ) の級数展開は以下の二つの演算を基本とする。
	#
	#      ln( d ) == ln( 1 + y )
	#
	#              == y - y^2/2 + y^3/3 - y^4/4 + ......
	#
	#                       ( -1 )^( n + 1 ) * y^2
	#              == Σ( -------------------------- )             ( n == 1 -> ∞ )
	#                                 n
	#
	#      ln( d ) == ln( 1 - y )
	#
	#              == ( -1 ) * ( y + y^2/2 + y^3/3 + y^4/4 + ...... )
	#
	#                                y^n
	#              == ( -1 ) * Σ( ------- )                       ( n == 1 -> ∞ )
	#                                 n
	#
	#   前者の式では y == d - 1 であり、後者では y == 1 - d となる。
	#   何れも、 d が 1 の近傍にある時に収束が速くなる。
	#
	#
	#   d が 1 の近傍にある時、
	#
	#             1 + y                                     1 + y
	#      d == --------- と定義しなおし、 ln( d ) == ln( --------- ) で近似する事を考える。
	#             1 - y                                     1 - y
	#
	#   これを展開して整理すると、
	#
	#             1 + y
	#      d == ---------
	#             1 - y
	#
	#                d - 1
	#      -> y == ---------
	#                d + 1
	#
	#                       1 + y
	#      ln( d ) == ln( --------- )
	#                       1 - y
	#
	#              == ln( 1 + y ) - ln( 1 - y )
	#
	#              ==   (  y - y^2/2 + y^3/3 - y^4/4 + ........ )
	#                 - ( -y - y^2/2 - y^3/3 - y^4/4 - ........ )
	#
	#              == 2 * ( y + y^3/3 + y^5/5 + ....... )
	#
	#                           y^( 2n + 1 )
	#              == 2 * Σ( ---------------- )                           ( n == 0 -> ∞ )
	#                              2n + 1
	#
	#                                 ( d - 1 )^( 2n + 1 )
	#              == 2 * Σ( ------------------------------------- )      ( n == 0 -> ∞ )
	#                           ( d + 1 )^( 2n + 1 ) * ( 2n + 1 )
	#
	#   となり、級数展開の項数を削減することができる。
	#
	#   d が 0 の近傍にある場合、上記の式では十分な精度が出ない。
	#   また、 y が 1 に近い値となるため、収束も遅くなる。
	#   この場合には、
	#
	#     ln( d ) == ln( 1 - y )
	#
	#   の方がまだましと言える。
	#
	#   d が 0 の近傍にある場合、 d == w^( 2^p ) に分解することで収束を速める事はできる。
	#   この場合、 w は 1 に近い値となり、
	#
	#     ln( d ) == ln( w^( 2^p ) )
	#
	#             == ln( w ) * 2^p
	#
	#                              w - 1
	#                          ( --------- )^( 2n + 1 )
	#                              w + 1
	#             == 2 * Σ( ---------------------------- ) * 2^p             ( n == 0 -> ∞ )
	#                                   2n + 1 
	#
	#   として演算を行うことができるが、演算誤差が大きくなるため、演算過程で使用する小数点以下の有効桁数を十分に長く採る必要がある。
	#   結果的に処理効率と演算誤差の双方において不利な結果を招くことになる。
	#
	#   もう一つのアプローチとして、 x == d * ( 2^p ) の分解方法を工夫することもできる。
	#   x == d * ( 2^p ) という分解は、 x >= 1 となる x を d < 1 となる小数 d と 2 の冪の積に分解する演算だが、
	#   これを 0.5 < d < 1 となるように調整することができる。
	#
	#     x >= 1 の場合、
	#
	#       1. x == d * ( 2^p ) に分解
	#       2. d と 2 * d を比較し、 2 * d の方が 1 に近ければ d *=2 , p -= 1 とする。
	#
	#     x < 0.5 の場合、
	#
	#       1.  初期値を d = x , p = 0 とする。
	#       2.  d >= 0.5 になるまで d *= 2 , p -= 1 を繰り返す。
	#
	#   この状態から ln( d ) を求めれば、
	#
	#     ln( x ) == ln( d * 2^p )
	#             == ln( d ) + p * ln( 2 )
	#
	#   で ln( x ) を求めることができる。 ( x が 0 の近傍にある場合、 p が p < 0 となるだけ。 )
	#
	#
	#   自然対数は、逆双曲線関数 ( inverse hyperbolic function ) とも関連しており、
	#
	#                              1
	#     artanh( y ) == Σ( ------------- * ( y ** ( 2 * n + 1 ) ) )       ( n == 0 -> ∞ )
	#                          2 * n + 1
	#
	#                                1 + y
	#                 == 1/2 * ln( --------- )
	#                                1 - y 
	#
	#                 == 1/2 * ln( d )
	#
	#     -> ln( d )  == 2 * artanh( y )
	#
	#                                  d - 1
	#                 == 2 * artanh( --------- )
	#                                  d + 1
	#
	#   でもある。
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return undef	if ( $x < 0 ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	return undef			if ( $x->is_zero() ) ;
	return __PACKAGE__->new( 0 )	if ( $x == 1 ) ;
	return ln2( $dlen )		if ( $x == 2 ) ;
	return ln2( $dlen ) * ( -1 )	if ( $x == 0.5 ) ;

	return ln10( $dlen )		if ( $x == 10 and $dlen <= 128 ) ;

	#
	# $x が小数値である場合、簡潔な分数で表現できるどうかを試す。
	#
	unless ( $x->is_integer() ) {
		my $f = $x->fraction() ;
		my( $numer , $denom ) = ( $f->numerator() , $f->denominator() ) ;
		if ( $numer == 1 ) {
			#
			# $x == 1 / $y
			# -> ln( $x ) == ( -1 ) * ln( $y )
			#
			return $denom->ln( $dlen ) * ( -1 ) ;
		}
		elsif ( $numer->integer_digits() < 4 and $denom->integer_digits() < 4 ) {
			#
			# $x == $y / $z
			# -> ln( $x ) == ln( $y ) - ln( $z )
			#
			return $numer->ln( $dlen + 2 )->subtract( $denom->ln( $dlen + 2 ) )->round_down( $dlen ) ;
		}
	}

	#
	# $x == $d * ( 2 ** $p ) に分解する。
	# $p は int( $x ) を 2 進数で表現した時の桁の長さに等しいものとする。
	# ( これは、 $x の二進対数の整数部のビット数に等しい。 )
	#
	# 2 ** $p は 2 進数表記で $x よりも一桁大きい 2 の冪となる。
	#
	# これより、
	#
	#   $d = $x / ( 2 ** $p )
	#
	# によって 0 < $d < 1 となる。
	#
	# 対数の級数展開では、 $d が 1 の近傍にある時に速度と精度が向上する。
	# よって、 $d が 1 の近傍になるように $d と $p を調整する。
	#
	my $p = 0 ;
	my $d = $x->copy() ;
	if ( $d >= 1 ) {
		$p = length( $d->integer()->bin() ) ;
		$d = $d->divide( __PACKAGE__->new( 2 )->power( $p ) , $dlen + 10 ) ;

		my $one = __PACKAGE__->new( 1 ) ;
		my $df1 = $one->subtract( $d )->abs() ;
		my $df2 = $one->subtract( $d->multiply( 2 ) )->abs() ;

		if ( $df2->is_zero() ) {
			#
			# ln( $x ) == ln( 2 ** ( $p - 1 ) )
			#          == ln( 2 ) * ( $p - 1 )
			#
			return ln2( $dlen + 10 )->multiply( $p - 1 )->round_down( $dlen ) ;
		}

		if ( $df1 > $df2 )	{ $d *= 2 ; $p = $p - 1 ; }	# $d = $x / ( 2 ** ( $p - 1 ) )
	}
	elsif ( $d < 0.5 ) {
		my $c = $d->multiply( 2 )->inverse()->integer() ;	# c == int( 0.5 / d ) == int( 1/( 2 * d ) )
		$d *= $c * 2 ;
		$p -= $c ;
		while ( $d < 0.5 ) { $d *= 2 ; $p -= 1 ; }
	}

	#
	# ln( $d ) の近似計算
	#
	my $lnd = undef ;

	#
	# d == ( 1 + y ) / ( 1 - y )
	# -> d - yd == 1 + y
	# -> y + yd == d - 1
	# -> y == ( d - 1 ) / ( d + 1 )
	#
	# ln( d ) == ln( ( 1 + y ) / ( 1 - y ) )
	#
	#         == ln( 1 + y ) - ln( 1 - y )
	#
	#                      y^( 2n + 1 )
	#         == 2 * Σ( ---------------- )                            ( n == 0 -> ∞ )
	#                         2n + 1
	#
	#                             ( d - 1 )^( 2n + 1 )
	#         == 2 * Σ( ------------------------------------- )       ( n == 0 -> ∞ )
	#                      ( d + 1 )^( 2n + 1 ) * ( 2n + 1 )
	#
	$lnd = __PACKAGE__->new( 0 ) ;
	#my $y = fraction( $d - 1 , $d + 1 )->decimal( $dlen + 11 ) ;
	my $y = ( $d - 1 )->divide( $d + 1 , $dlen + 11 ) ;
	my $n = __PACKAGE__->new( -1 ) ;
	my $f = [] ;
	while () {
		$n += 1 ;
		my $odd = $n->multiply( 2 )->add( 1 ) ;
		push( @{ $f } , $y->power( $odd )->divide( $odd , $dlen + 2 ) ) ;

		if ( sprintf( "%0d" , $n->{'val'}->[0] ) =~ /0$/ ) {
			$lnd = $lnd->add( $f ) ;
			last	if ( $f->[-1]->round( $dlen )->is_zero() ) ;
			#last	if ( $n > 300 ) ;
			$f = [] ;
		}
	}
	$lnd *= 2 ;

	#
	# ln( x ) への変換
	#
	#   ln( $x ) == ln( $d * ( 2 ** $p ) )
	#            == ln( $d ) + ln( 2 ** $p )
	#            == ln( $d ) + $p * ln( 2 )
	#
	my $r = $lnd ;
	$r += ln2( $dlen + 10 ) * $p			if ( $p != 0 ) ;
	$r = $r->round_down( $dlen ) ;

	return $r ;
}

=head2 log10

Return the common logarithm.

  print decimal( 2 )->log10() ;          # 0.3010299956639811952137388947244930267682
  print decimal( 10 )->log10() ;         # 1
  print napier()->log10() ;              # 0.4342944819032518276511289189166050822944

=cut

sub log10 {
	#-----------------------------------------------------------------------
	#
	# 常用対数
	#
	#   log(x) == ln(x) / ln(10)
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return undef	if ( $x < 0 ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $r = $x->ln( $dlen )->divide( ln10( $dlen ) , $dlen + 10 ) ;

	return $r->round( $dlen ) ;
}

sub log { return log10( @_ ) ; } 

sub lb {
	#-----------------------------------------------------------------------
	#
	# 二進対数 ( Binary logarithm )
	#
	#   底を 2 とする対数。
	#
	#-----------------------------------------------------------------------
	return $_[0]->ln() / ln2() ;
}

sub lb_base {
	#-----------------------------------------------------------------------
	#
	# 二進対数 ( Binary logarithm )
	#
	#   2 を底とする対数 lb( x ) の整数部 n は以下のように定義される。
	#
	#     2^n <= x < 2^(n+1)
	#
	#     n == length( bin( x ) ) - 1
	#
	#   小数部の展開は、連分数展開に酷似したロジックとなる。
	#
	#     lb( x ) == n + lb( y )
	#             == n + lb( 2^(-n) * x )
	#                           x
	#             == n + lb( ------- )
	#                          2^n
	#
	#     y[ 0 ] = 2^(-n) * x
	#     y[ i ] = y[ i - 1 ]^2
	#     if ( y[ i ] >= 2 ) { lb( y[ i ] ) == 1/( 2^i ) ; y[ i ] /= 2 ; }
	#     else               { lb( y[ i ] ) == 0 ; }
	#
	#     ( i == 0 -> ∞ )
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return undef	if ( $x < 0 ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	return $x->abs()->lb() * ( -1 )	if ( $x < 0 ) ;

	return undef			if ( $x->is_zero() ) ;
	return __PACKAGE__->new( 0 )	if ( $x == 1 ) ;
	return __PACKAGE__->new( 1 )	if ( $x == 2 ) ;

	#
	# 整数部分
	#
	#   2^n <= x < 2^(n+1) となる n を求める。
	#
	my $n = ( $x >= 2 )
		? length( $x->integer()->bin() ) - 1
		: 0
	;

	#
	# 小数部分
	#
	my $dlen2 = $dlen * 2 ;
	#my $limit = length( __PACKAGE__->new( 10 )->power( $dlen )->bin() ) ;

	my $two = __PACKAGE__->new( 2 ) ;
	my $y = $x->divide( $two->power( $n ) , $dlen2 ) ;
	my @bits = () ;
	my $d = __PACKAGE__->new( 0 ) ;
	my $i = 0 ;
	#while ( ++$i <= $limit ) {
	while ( ++$i ) {
		my $diff = fraction( 1 , $two->power( $i ) ) ;
		last	if ( $diff->decimal( $dlen2 )->is_zero() ) ;
		$y = $y * $y ;
		$y = $y->round_down( $dlen2 ) ;
		if ( $y >= $two ) {
			$y = $y->divide( $two , $dlen2 ) ;
			$d += $diff ;
		}
		last	if ( $y->is_zero() ) ;
	}

	my $r = __PACKAGE__->new( $n ) + $d ;

	return $r->decimal()->round( $dlen ) ;
}

#-------------------------------------------------------------------------------
#
# 指数関数
#
#-------------------------------------------------------------------------------

=head2 exp

                    1
  exp( x ) == sum( ---- * x^n )            ( n == 0 -> +INF )
                    n!


  print decimal(1)->exp() ;       # 2.7182818284590452353602874713526624977572  ( Napier's constant )
  print decimal(2)->exp() ;       # 7.3890560989306502272304274605750078131803
  print decimal(3)->exp() ;       # 20.0855369231876677409285296545817178969879

=cut

sub exp {
	#-----------------------------------------------------------------------
	#
	# 指数関数 ( exponential function )
	#
	#   指数関数のマクローリン展開は、
	#
	#                       1
	#     exp( x ) == Σ( ------ * x^n )          ( n == 0 -> ∞ )
	#                       n!
	#
	#   ネイピア数 e は、
	#                            1
	#     e == exp( 1 ) == Σ( ------ * 1^n )
	#                            n!
	#
	#                            1
	#                   == Σ( ------ )
	#                            n!
	#
	#   と定義される。
	#
	#   x > 0 とした場合、
	#                                       1
	#     exp( -x ) == exp( x )^(-1) == ----------
	#                                    exp( x )
	#
	#   は自明。
	#
	#
	#   x が非常に大きい数になるとマクローリン展開では効率が悪い。
	#
	#   exp( x ) -> 2^n * exp( p ) に変換することを考えると、
	#
	#     n == ceil( x / ln(2) )
	#     p == x - n * ln(2)
	#     exp( x ) == 2^n * exp( x - n * ln(2) )
	#
	#   となるとのこと。
	#
	#-----------------------------------------------------------------------
	my( $x , $dlen ) = @_ ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;

	#$dlen = 40	if ( ! defined $dlen or $dlen > 40 ) ;
	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	#
	# $n == 0 の時
	#               1
	#   exp(x) == ------ * x^0 == 1
	#               0!
	#
	my $f = __PACKAGE__->new( 1 ) ;
	my $r = __PACKAGE__->new( 1 ) ;

	#
	# $n == 1 から展開
	#
	my $n = __PACKAGE__->new( 1 ) ;
	if ( $x == 1 ) {
		#
		# ネイピア数
		#
		while () {
			$f *= $n ;
			my $diff = $x->divide( $f , $dlen + 3 ) ;
			last	if ( $diff->is_zero() ) ;
			#warn( $diff , "\n" ) ;
			$r += $diff ;
			$n++ ;
			#last	if ( $n > 100 ) ;
		}
	}
	else {
		#
		# x が大きい場合には、
		#
		#   p == ceil( x / ln(2) )
		#   exp( x ) == 2^p * exp( x - p * ln(2) )
		#
		# として演算を行う。
		#
		# x と p の関係はおおよそ以下のようになる。
		#
		#   x >=  22 -> p >=  32
		#   x >=  44 -> p >=  64
		#   x >=  89 -> p >  128
		#   x >= 133 -> p >= 192
		#   x >= 177 -> p >= 256
		#
		# このモジュールでは ln(2) を小数点以下 256 桁まで定数として保持している。
		#
		my $ln2 = ln2( 128 ) ;
		my $p = $x->divide( $ln2 )->ceil() ;
		if ( $p >= 64 )	{ $x -= $p * $ln2 ; }
		else		{ $p = 0 ; }

		my $inverse = 0 ;
		if ( $x < 0 ) { $inverse = 1 ; $x *= (-1) ; }

		#
		# マクローリン展開
		#
		#                     1
		#   exp( x ) == Σ( ------ * x^n )          ( n == 0 -> ∞ )
		#                     n!
		#
		while () {
			$f *= $n ;
			my $diff = $x->power( $n )->divide( $f , $dlen + 3 ) ;
			last	if ( $diff->is_zero() ) ;
			#warn( $diff , "\n" ) ;
			$r += $diff ;
			$n++ ;
			#last	if ( $n > 100 ) ;
		}

		if ( $inverse ) {
			$r = $r->inverse( $dlen ) ;
		}

		#
		# 2^p を反映
		#
		if ( $p > 0 ) {
			$r *= __PACKAGE__->new( 2 )->power( $p ) ;
		}
	}

	return $r->round_down( $dlen ) ;
}

=head2 napier

Return Napier's constant.

  napier() == decimal( 1 )->exp()
  napier()->ln() == 1

                 log10( 10 )              1
  ln( 10 ) == ----------------- == -----------------
               log10( napier )      log10( napier )

=cut

sub napier {
	#-----------------------------------------------------------------------
	#
	# ネイピア数 ( Napier's constant ; ネイピア定数 )
	#
	#   e == ( 1 / n! )         ( n == 1 -> ∞ )
	#     == exp( 1 )
	#     -> ln( e ) == 1
	#
	#   ln(10) == log(10) / log(e)
	#          == 1 / log(e)
	#   -> log(e)     == 1 / ln(10) == 0.4342944819032518276511289189166050822944.....
	#      1 / log(e) == ln(10)     == 2.3025850929940456840179914546843642076010.....
	#
	#   ln(x)  == log(x) / log(e)
	#          == log(x) * ln(10)  == log(x) * 2.302585.......
	#
	#   log(x) == ln(x) * log(e)
	#          == ln(x) / ln(10)   == ln(x)  * 0.434294.......
	#
	#-----------------------------------------------------------------------
	return __PACKAGE__->new( 1 )->exp() ;
}

=head1 'Decimal' object - prime numbers.

=cut

#-------------------------------------------------------------------------------
#
# 素数
#
#-------------------------------------------------------------------------------

=head2 primes

Return a list of prime numbers.

  print join ' ' , decimal( 100 )->primes() ;      # 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

=cut

sub primes {
	#-----------------------------------------------------------------------
	#
	# 素数リストを返す。
	#
	#   乗算のみを使用して合成数を篩い落とす。
	#
	#   エラトステネスの篩を応用し、既知の素数の倍数を篩い落とすことによって素数リストを得る。
	#   エラトステネスの篩とは逆に、最初に $n を最大値とする正の整数列を用意して処理を行う。
	#   これにより、作業用の変数によるメモリ負担が大きくなるため、ビットベクターを利用してこれを実装する。
	#
	#   ビットベクターは Perl の vec 標準関数で実装しており、 2^31 程度の数値まではサポートできるはず。
	#   しかし、実用上は 2^20 程度 ( 10 進数 100 万程度 ) までが探索範囲の限度と考えられる。
	#   ( 32 ビット環境では 10^9 でも 'out of memory' となった。 )
	#
	#
	#   2014/12
	#
	#     ・処理効率を上げるために内部の演算を言語標準の機能のみで実装しなおした。
	#
	#     ・$bitmap を 6n-1 型と 6n+1 型の自然数のみを管理するものとして再定義した。
	#
	#     ・戻り値をオブジェクト化するかどうかを選択できるようにした。
	#       オブジェクト化しないことでメモリーへの負担が軽減され、より大きな数値範囲が扱えるようになる。 ( 理論上の上限は 10^16 程度 )
	#       デフォルトではオブジェクト化された数値配列を返す。
	#
	#-----------------------------------------------------------------------
	my( $n , $objectify ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return ()			unless ( defined $n ) ;
	return ()			unless ( $n->is_integer() ) ;
	return ()			if ( $n < 0 ) ;

	$objectify = 1	unless ( defined $objectify ) ;

	$n = $n->value() ;

	my $bitmap = [] ;
	$bitmap->[0] = '' ;	# for 6n-1
	$bitmap->[1] = '' ;	# for 6n+1

	{
		my $blen = int( $n / 6 ) ;
		foreach my $i ( 0 .. $blen ) {
			vec( $bitmap->[0] , $i , 1 ) = 1 ;
			vec( $bitmap->[1] , $i , 1 ) = 1 ;
		}
	}

	#
	# 合成数のフラグを落とす。
	#
	#   6 の倍数の前後にフラグを立てているので篩に使う数値 $i は 5 以上の奇数値のみ。
	#   5 以上の奇数値を昇順に処理することにより、 $i が素数か合成数かはそれを取り出した時点で既に確定している。
	#   $i が素数であれば、 $i 以上の 6n+1 及び 6n-1 型の奇数値を順次取り出して積を採り、その数値に合致するフラグを落とす。
	#
	#   6n+1 及び 6n-1 型の奇数の積には以下のようなパターンがある。
	#  
	#     ( 6n+1 ) * ( 6m+1 ) == 36mn + 6n + 6m + 1 == 6( 6mn + n + m ) + 1 ≡  1 ( mod 6 )
	#     ( 6n+1 ) * ( 6m-1 ) == 36mn - 6n + 6m - 1 == 6( 6mn - n + m ) - 1 ≡ -1 ( mod 6 )
	#     ( 6n-1 ) * ( 6m-1 ) == 36mn - 6n - 6m + 1 == 6( 6mn - n - m ) + 1 ≡  1 ( mod 6 )
	#     ( 6n+1 )^m ≡ (  1 )^m ( mod 6 )
	#     ( 6n-1 )^m ≡ ( -1 )^m ( mod 6 )
	#   
	#  いずれの場合も結果は 6n+1 又は 6n-1 型になる。
	#  合同式の乗法により、 6n+1 及び 6n-1 型の奇数を三つ以上掛け合わせた場合も同じ結果となる。
	#  よって、篩を完成させるにはこの二種類の奇数値だけを意識すればよいことが判る。
	#  特に奇素数の冪乗数に対して特別な考慮をする必要がないという点が非常に都合がよい。
	#
	my @p = ( 2 , 3 ) ;

	my $i = 5 ;
	my $t1 = 0 ;
	while () {
		#
		# $bitmap を走査するためのポインター
		#
		my $pos = ( $t1 == 1 )
			? int( $i / 6 )
			: int( $i / 6 ) + 1
		;

		#
		# $i 以下の数値については素数か合成数かは既に確定している。
		# $i より小さな素数での判定は既に終わっているので、 $i が合成数である場合にはこれをスキップすることができる。
		#
		if ( vec( $bitmap->[ $t1 ] , $pos , 1 ) == 1 ) {
			push( @p , $i ) ;	# 確定している奇素数を抑える。
			my $j = $i ;		# $j の初期値は $i
			my $t2 = $t1 ;		# $t2 == $t1 == 0 ならば $j == $i は 6n-1 型、 1 なら 6n+1 型。
			while () {
				#
				# ( $i * $j ) となる数値のフラグを落とす。 ( 合成数として認定 )
				#
				# $i は素数として確定したもののみを使用すればよいが、
				# $j は合成数として確定していたとしてもスキップする事はできない。
				# $j を不用意にスキップすると、素数の冪や三つ以上の素因数を持つ合成数が篩い落とされずに残ることになる。
				#
				my $k = $i * $j ;
				last	if ( $k > $n ) ;

				my $mod = $k % 6 ;
				if	( $mod == 1 )	{ vec( $bitmap->[1] , int( $k / 6 )     , 1 ) = 0 ; }
				elsif	( $mod == 5 )	{ vec( $bitmap->[0] , int( $k / 6 ) + 1 , 1 ) = 0 ; }

				#
				# $j に次の奇素数候補をセットする。
				#
				$j += ( $t2 == 0 ) ? 2 : 4 ;
				$t2 = ( $t2 == 0 ) ? 1 : 0 ;
			}
		}

		#
		# $i に次の奇素数候補をセットする。
		#
		$i += ( $t1 == 0 ) ? 2 : 4 ;
		$t1 = ( $t1 == 0 ) ? 1 : 0 ;

		last	if ( ( $i * $i ) > $n ) ;
	}

	#
	# フラグが立っている奇数値を拾い上げる。
	# 既知の素数の次の 6n+1 or 6n-1 型の奇数から検索を開始する。
	#
	$i = $p[-1] ;				# 確定している最後の奇素数 ( $i == $p[-1] >= 5 )
	$t1 = ( ( $i % 6 ) == 5 ) ? 0 : 1 ;     # $i が 6n-1 型ならば 0 , 6n+1 型ならば 1
	$i += ( $t1 == 0 ) ? 2 : 4 ;            # 次の奇素数候補 ( $i が 6n-1 型なら $i += 2 , 6n+1 型なら $i += 4 )
	$t1 = ( $t1 == 0 ) ? 1 : 0 ;

	while ( $i <= $n ) {
		my $pos = ( $t1 == 1 )
			? int( $i / 6 )
			: int( $i / 6 ) + 1
		;
		push( @p , $i )	if ( vec( $bitmap->[ $t1 ] , $pos , 1 ) == 1 ) ;
		$i += ( $t1 == 0 ) ? 2 : 4 ;
		$t1 = ( $t1 == 0 ) ? 1 : 0 ;
	}

	if ( $objectify ) {
		foreach ( @p ) {
			$_ = __PACKAGE__->new( $_ ) ;
		}
	}

	return ( $p[0] )	if ( $n < 3 ) ;
	return @p[0,1]		if ( $n < 5 ) ;
	return @p ;
}

sub nth_prime {
	#-----------------------------------------------------------------------
	#
	# 2014/12 追加
	# 2015/02 Primes クラスを使用する形で再定義。
	#
	# n 番目の素数を返す。
	#
	#   エラトステネスの篩がベースとなっているのであまり巨大な数値を扱うことはできない。
	#
	# ガウスの素数定理より、任意の正の整数 x を超えない素数の個数は、
	#
	#   PI(x) ≒ x / ln(x)        ( x -> ∞ )
	#
	# で近似される。
	#
	# ここから、 n 番目の素数 P[n] は、
	#
	#   P[n] ≒ n * ln( n )
	#
	# で近似される。
	#
	#-----------------------------------------------------------------------
	my( $nth , $objectify ) = @_ ;

	$nth = __PACKAGE__->new( $nth )	unless ( ref( $nth ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $nth ) ;
	return undef			unless ( $nth->is_integer() ) ;
	return undef			if ( $nth == 0 ) ;

	$objectify = 0	unless ( defined $objectify ) ;

	my $limit = $nth->multiply( $nth->ln() )->integer() * 2 ;

	my $iter = Primes->new( $limit , { 'objectify' => $objectify } ) ;
	while ( $iter->count() < $nth ) {
		$limit *= 2 ;
		$iter = Primes->new( $limit , { 'objectify' => $objectify } ) ;
	}

	my $r = $iter->nth_prime( $nth ) ;

	return $r
}

sub factorial_primes {
	#-----------------------------------------------------------------------
	#
	# 階乗素数と交互階乗素数の一覧を返す。
	#
	#   階乗素数 ( factorial prime numbers ) は、以下の演算で得られる f(n) の内で素数となるもの。
	#
	#     f(n)  == n! == 1 * 2 * ..... * (n-1) * n
	#
	#     階乗素数には n!+1 型と n!-1 型の二種類がある。
	#
	#     n!+1 型の素数の存在は、素数が無限に存在することの根拠となっている。
	#     n!+1 なる正の整数は、 1 < k <= n となる如何なる正の整数 k をもってこれを割り切ることはできない。
	#     このことはつまり、
	#       ・ n!+1 の素因数全てが n よりも大きい
	#       ・ n!+1 自身が素数 ( n!+1 型の階乗素数 )
	#     の何れかを意味している。
	#     素数が有限個しか存在しないと仮定した場合、その最大の素数 p に対して p!+1 が p よりも大きな素因数で分解できると言うことは、
	#     「p が最大の素数である」という前提と完全に矛盾する。
	#     よって、素数には最大値は存在しない ( == 素数は無限に存在する ) と言うことになる。
	#
	#
	#  交互階乗素数 ( alternating factorial prime numbers ) は、以下の漸化式で得られる af(n) の内で素数となるもの。
	#
	#    af(n) = f(n) - af(n-1)
	#
	#-----------------------------------------------------------------------
	my $m = shift ;
	return undef	unless ( defined $m ) ;

	$m = __PACKAGE__->new( $m )	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $m ) ;

	my $regex1 = join( '|' , 0 , 1 , 2 , 3 , 11 , 27 , 37 , 41 , 73 , 77 , 116 , 154 , 320 , 340 , 399 , 427 , 872 , 1477 , 6380 , 26951 , 110059 , 150209 ) ;
	my $regex2 = join( '|' , 3 , 4 , 6 , 7 , 12 , 14 , 30 , 32 , 33 , 38 , 94 , 166 , 324 , 379 , 469 , 546 , 974 , 1963 , 3507 , 3610 , 6917 , 21480 , 34790 , 94550 , 103040 ) ;
	my $regex3 = join( '|' , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 15 , 19 , 41 , 59 , 61 , 105 , 160 , 661 , 2653 , 3069 , 3943 , 4053 , 4998 , 8275 , 9158 , 11164 ) ;

	$regex1 = qr/(?:$regex1)/ ;
	$regex2 = qr/(?:$regex2)/ ;
	$regex3 = qr/(?:$regex3)/ ;

	my $f	= __PACKAGE__->new( 1 ) ;
	my $af	= __PACKAGE__->new( 1 ) ;
	my $p = {} ;

	foreach ( my $n = 2 ; $n <= 150209 ; $n++ ) {

		$f *= $n ;
		$af = $f - $af ;

		last	if ( $af > $m ) ;

		if ( $n =~ /^(?:$regex1)$/ )	{ $p->{ $f + 1 } = $f + 1 ; }		# n!+1 系の階乗素数
		if ( $n =~ /^(?:$regex2)$/ )	{ $p->{ $f - 1 } = $f - 1 ; }		# n!-1 系の階乗素数
		if ( $n =~ /^(?:$regex3)$/ )	{ $p->{ $af } = $af->copy() ; }		# 交互階乗素数
	}

	my @primes = sort { $a <=> $b } values %{ $p } ;

	return @primes ;
}

sub euler_primes {
	#-----------------------------------------------------------------------
	#
	# オイラーの素数生成式
	#
	#   f(x) = x^2 + x + 41
	#
	#   この式は 0 <= x <= 39 で常に素数を返す。
	#   また、 0 <= x <= 10,000,000 の範囲で 47.5% の確率で素数を返すとされている。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my @p ;
	foreach ( my $x = __PACKAGE__->new( 0 ) ; $x < $n ; $x++ ) {
		my $prp = __PACKAGE__->new( $x ) * ( $x + 1 ) + 41 ;
		push( @p , $prp )	if ( $prp->is_prime() ) ;
	}

	return @p ;
}

sub prime_ln {
	#-----------------------------------------------------------------------
	#
	# 素数の自然対数
	#
	#   10,000 以下の素数の自然対数をテーブル化したもの。 ( 小数点以下 40 桁で定義してある。 )
	#
	#   任意の正の整数の自然対数は、その素因数の対数の積和で表現することができる。
	#   ( 底が同じであれば任意の対数について成り立つ。 )
	#
	#     ln( 6 )   == ln( 2 * 3 )
	#               == ln( 2 ) + ln( 3 )
	#
	#     ln( 147 ) == ln( 3 * 7^2 )
	#               == ln( 3 ) + 2 * ln( 7 )
	#
	#   合成数の素因数分解自体が非常にコストの高い処理なので通常はこのテーブルが役立つことはないが、
	#   ゼータ関数のオイラー積展開などを行う際には役立つものと考えられる。
	#
	#   ゼータ関数のオイラー積展開は、以下のようなもの。
	#
	#                           1                     1                    1                  p^s
	#     zeta( s ) == Π( ------------ ) == Π( ----------- ) == Π( ----------- ) == Π( --------- )
	#                       1 - p^(-s)                  1               p^s - 1             p^s - 1 
	#                                             1 - -----            ---------
	#                                                  p^s                p^s
	#
	#     p^s == exp( s * ln( p ) ) 
	#
	#     p : 全ての素数
	#     s : 任意の複素数
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			unless ( $n->is_integer() ) ;
	return undef			unless ( $n > 0 ) ;

	my $pln = {
		'2'	=>	'0.6931471805599453094172321214581765680755'	,	'3'	=>	'1.0986122886681096913952452369225257046474'	,
		'5'	=>	'1.6094379124341003746007593332261876395255'	,	'7'	=>	'1.945910149055313305105352743443179729637'	,
		'11'	=>	'2.3978952727983705440619435779651292998216'	,	'13'	=>	'2.5649493574615367360534874415653186048052'	,
		'17'	=>	'2.8332133440562160802495346178731265355881'	,	'19'	=>	'2.9444389791664404600090274318878535372373'	,
		'23'	=>	'3.1354942159291496908067528318101961184423'	,	'29'	=>	'3.3672958299864740271832720323619116054945'	,
		'31'	=>	'3.4339872044851462459291643245423572104499'	,	'37'	=>	'3.6109179126442244443680956710314471639'	,
		'41'	=>	'3.7135720667043078038667633730374075883763'	,	'43'	=>	'3.7612001156935624234728425133458470355591'	,
		'47'	=>	'3.850147601710058586820950669772173708896'	,	'53'	=>	'3.9702919135521218341444691390290577703599'	,
		'59'	=>	'4.0775374439057194506160503737196976240633'	,	'61'	=>	'4.1108830833583608487513891034256147463156'	,
		'67'	=>	'4.2046926193909660596700719963637227505669'	,	'71'	=>	'4.2626798770413154213294545325130340967595'	,
		'73'	=>	'4.2904594411483911290921088574385425709047'	,	'79'	=>	'4.3694478524670214941729455414814109221735'	,
		'83'	=>	'4.4188406077965979234754722232913704530292'	,	'89'	=>	'4.4886363697321398383178155406698492194046'	,
		'97'	=>	'4.5747109785033828221167216217039617138088'	,	'101'	=>	'4.6151205168412594508841982669129891568908'	,
		'103'	=>	'4.6347289882296357707686023150534408206282'	,	'107'	=>	'4.6728288344619061733043988170232770015631'	,
		'109'	=>	'4.6913478822291437003773164522092016510603'	,	'113'	=>	'4.7273878187123405685821314936160216720293'	,
		'127'	=>	'4.8441870864585912730474408077162923948739'	,	'131'	=>	'4.8751973232011515441494240111695258931078'	,
		'137'	=>	'4.9199809258281249153151901279798653905631'	,	'139'	=>	'4.9344739331306917571887849188755437824425'	,
		'149'	=>	'5.003946305945459140992428275104120487856'	,	'151'	=>	'5.0172798368149243287962362994844762902577'	,
		'157'	=>	'5.0562458053483080574244452364034752487422'	,	'163'	=>	'5.0937502008067623340649323661207498766318'	,
		'167'	=>	'5.1179938124167551072597507767447793657972'	,	'173'	=>	'5.1532915944977789469335003884409914691858'	,
		'179'	=>	'5.1873858058407549961778044300214021756029'	,	'181'	=>	'5.1984970312658257468390870386330089272403'	,
		'191'	=>	'5.2522734280466298728499499522023671466084'	,	'193'	=>	'5.26269018890488555185493105338305876419'	,
		'197'	=>	'5.2832037287379885067797973291628309750086'	,	'199'	=>	'5.293304824724492395410121291868537201891'	,
		'211'	=>	'5.3518581334760664957419562654542801180411'	,	'223'	=>	'5.4071717714601187586361052097231400266986'	,
		'227'	=>	'5.4249500174814026750133815768334970451548'	,	'229'	=>	'5.4337220035542396484412356039326083172384'	,
		'233'	=>	'5.4510384535657005653022248746688874785889'	,	'239'	=>	'5.4764635519315106669631635942619090964377'	,
		'241'	=>	'5.4847969334906549954664113187108157350172'	,	'251'	=>	'5.5254529391317838862185852390082532412793'	,
		'257'	=>	'5.5490760848952197983517943147612554516147'	,	'263'	=>	'5.5721540321777645510859262642050720903854'	,
		'269'	=>	'5.594711379601839106219953180495237117871'	,	'271'	=>	'5.6021188208797009000968700732058620389055'	,
		'277'	=>	'5.624017506187338499869397549524610839163'	,	'281'	=>	'5.6383546693337457651066383246931719408198'	,
		'283'	=>	'5.6454468976432376246459871467951402048004'	,	'293'	=>	'5.6801726090170673059398402628124981902297'	,
		'307'	=>	'5.7268477475871971535984625672824922838456'	,	'311'	=>	'5.7397929121792341341959955654326822761199'	,
		'313'	=>	'5.746203190540153216678765309257210353573'	,	'317'	=>	'5.7589017738772806141997621692986113093775'	,
		'331'	=>	'5.802118375377062900784616839576636806697'	,	'337'	=>	'5.8200829303523617245048665546484312128973'	,
		'347'	=>	'5.8493247799468591923536768463858595345941'	,	'349'	=>	'5.8550719222024271631994815224986397091488'	,
		'353'	=>	'5.8664680569332967673957201171879700024912'	,	'359'	=>	'5.8833223884882788730480928856046799777149'	,
		'367'	=>	'5.9053618480545702716194319391584291655296'	,	'373'	=>	'5.9215784196438155413357346051016641379187'	,
		'379'	=>	'5.9375362050824263478172365836536279080887'	,	'383'	=>	'5.9480349891806459899930545371524702521813'	,
		'389'	=>	'5.9635793436184462928486202336321726511187'	,	'397'	=>	'5.9839362806871904130834320301768592834822'	,
		'401'	=>	'5.9939614273065691858506790873493497308779'	,	'409'	=>	'6.0137151560428017457135222091283860873127'	,
		'419'	=>	'6.0378709199221377310329339216854903899321'	,	'421'	=>	'6.0426328336823814175887162283970974735215'	,
		'431'	=>	'6.0661080901037477877476668063250502537924'	,	'433'	=>	'6.0707377280024898467202845739725439695269'	,
		'439'	=>	'6.0844994130751713499932121297427537003561'	,	'443'	=>	'6.0935697700451356380860072578452757031697'	,
		'449'	=>	'6.1070228877422542932535217908261100014185'	,	'457'	=>	'6.1246833908942046991931313811534835344183'	,
		'461'	=>	'6.1333980429966485183727251932745265396546'	,	'463'	=>	'6.1377270540862340740798471812587099415648'	,
		'467'	=>	'6.1463292576688973115295312887342689861508'	,	'479'	=>	'6.1717005974109152351166778313996166138872'	,
		'487'	=>	'6.1882641230825897907299108312505455050804'	,	'491'	=>	'6.1964441277945205787341903250150846530035'	,
		'499'	=>	'6.2126060957515186652850911379843930230084'	,	'503'	=>	'6.2205901700997392064187611156356100318257'	,
		'509'	=>	'6.2324480165505227428348638560597586485265'	,	'521'	=>	'6.2557500417533669180888957065178364635211'	,
		'523'	=>	'6.2595814640649229008101431769130952937183'	,	'541'	=>	'6.2934192788464815215701856125846501368066'	,
		'547'	=>	'6.3044488024219812056327326215976607527898'	,	'557'	=>	'6.3225652399272840219114269368447817642507'	,
		'563'	=>	'6.3332796281396903820008369886177409825319'	,	'569'	=>	'6.3438804341263309209821848093841384780934'	,
		'571'	=>	'6.3473892096560102167299661959396291641779'	,	'577'	=>	'6.357842266508099561476575307270688407002'	,
		'587'	=>	'6.3750248198280964483003004975696726777665'	,	'593'	=>	'6.3851943989977254525466197436501486392638'	,
		'599'	=>	'6.3952615981154493488101991728814566869234'	,	'601'	=>	'6.3985949345352075792730805065791461321158'	,
		'607'	=>	'6.408528791059498262149972234846691766525'	,	'613'	=>	'6.418364935936211399439732593576050936687'	,
		'617'	=>	'6.4248690239053878139975716786101908247144'	,	'619'	=>	'6.4281052726845961022280353901497237298769'	,
		'631'	=>	'6.4473058625412131572787380336655940837796'	,	'641'	=>	'6.4630294569206700398334065380016001858682'	,
		'643'	=>	'6.4661447242376193872645685035480330868749'	,	'647'	=>	'6.4723462945009005646550692156575404118134'	,
		'653'	=>	'6.4815771292764310614129510711982250818042'	,	'659'	=>	'6.4907235345025072192038738508198241010429'	,
		'661'	=>	'6.4937538398516862858406895884787072764172'	,	'673'	=>	'6.5117453296447278045789111643563382054688'	,
		'677'	=>	'6.5176712729122749932406919353205120274909'	,	'683'	=>	'6.5264948595707900633828451488100619540333'	,
		'691'	=>	'6.538139823767669896607758069822955176013'	,	'701'	=>	'6.5525078870345900905003484240280005729843'	,
		'709'	=>	'6.5638555265321274991651970567992231036525'	,	'719'	=>	'6.5778613577210466885264860618866935014078'	,
		'727'	=>	'6.5889264775335193659124529688432678890285'	,	'733'	=>	'6.5971457018866514922691486987850983063783'	,
		'739'	=>	'6.6052979209482017742171588750805383352347'	,	'743'	=>	'6.610696044717759164858618839634512883789'	,
		'751'	=>	'6.6214056517641347442555134028669339282763'	,	'757'	=>	'6.6293632534374487762823257718929415518654'	,
		'761'	=>	'6.6346333578616858363553787478567696191599'	,	'769'	=>	'6.6450909695056439745323568459210776451513'	,
		'773'	=>	'6.650279048587421961616151561786842491402'	,	'787'	=>	'6.6682282484174032271365774484844157923608'	,
		'797'	=>	'6.6808546787902150393150938033599385743268'	,	'809'	=>	'6.6957989170584916894352524626865851783879'	,
		'811'	=>	'6.6982680541154129212003806737289004821126'	,	'821'	=>	'6.7105231094524282216149482298417612974082'	,
		'823'	=>	'6.7129562006770698119098729654453781441285'	,	'827'	=>	'6.717804695023691314484337846883340437823'	,
		'829'	=>	'6.7202201551352949745894387398425819843479'	,	'839'	=>	'6.7322107064672061772058288083996250294879'	,
		'853'	=>	'6.7487595474916791179497999135389741190346'	,	'857'	=>	'6.75343791859777978940204190829274858468'	,
		'859'	=>	'6.755768921984255371316976437171629568832'	,	'863'	=>	'6.7604146910834279454336019052135730299021'	,
		'877'	=>	'6.7765069923721830401920276096052107340297'	,	'881'	=>	'6.7810576259361795083642528306843184319897'	,
		'883'	=>	'6.7833252006039600135245968809533075552277'	,	'887'	=>	'6.7878449823095794904030486528127287568082'	,
		'907'	=>	'6.8101424501151366029359689546356148898593'	,	'911'	=>	'6.8145428972599583209433513865849838020923'	,
		'919'	=>	'6.8232861223556870495726180340555503540905'	,	'929'	=>	'6.8341087388138385172907967471519004253531'	,
		'937'	=>	'6.8426832822384221877963405971653287417155'	,	'941'	=>	'6.8469431395853796348115339014819102913889'	,
		'947'	=>	'6.8532990931860782439691286833017620051565'	,	'953'	=>	'6.859614903654202112286016310594368674089'	,
		'967'	=>	'6.8741984954532943257523857263095057186076'	,	'971'	=>	'6.8783264682913249112596133473231774271594'	,
		'977'	=>	'6.8844866520427827403529856683212911082098'	,	'983'	=>	'6.8906091201471665520593372694557144360547'	,
		'991'	=>	'6.8987145343299879898484502487707067720339'	,	'997'	=>	'6.9047507699618383302407234747034725117717'	,
		'1009'	=>	'6.9167150203536089564971208253804207152206'	,	'1013'	=>	'6.9206715042486833804928109126884201585386'	,
		'1019'	=>	'6.9265770332227248134894659671586754868917'	,	'1021'	=>	'6.9285378181646655556761467289830845235427'	,
		'1031'	=>	'6.9382844840169599253044051054442024088077'	,	'1033'	=>	'6.9402224691196385466069643896391202924774'	,
		'1039'	=>	'6.946013991099227392786995927158175434665'	,	'1049'	=>	'6.9555926083962971750878922749594637352322'	,
		'1051'	=>	'6.9574973708769511256147840645306872485989'	,	'1061'	=>	'6.96696713861398313506187102203982055058'	,
		'1063'	=>	'6.9688503783419479284307287445993657298293'	,	'1069'	=>	'6.9744789110250452254596305216711524237853'	,
		'1087'	=>	'6.9911768871212094431420940113459618549738'	,	'1091'	=>	'6.9948499858330708185118958171103840806981'	,
		'1093'	=>	'6.9966814881765385606661129105681841354993'	,	'1097'	=>	'7.0003344602752302459093473695666497862224'	,
		'1103'	=>	'7.005789019253502470556455334984090277391'	,	'1109'	=>	'7.0112139873503670348963709832515702099893'	,
		'1117'	=>	'7.0184017990692007085780818437453898580706'	,	'1123'	=>	'7.0237589547384431805353694669597543440403'	,
		'1129'	=>	'7.0290875641496620172483832533140045183403'	,	'1151'	=>	'7.0483864087218826439094122544218125780788'	,
		'1153'	=>	'7.0501225202690590259735826638463748819716'	,	'1163'	=>	'7.0587581525186644247976683307882597526142'	,
		'1171'	=>	'7.0656133635977173418332331799398876353575'	,	'1181'	=>	'7.0741168161973623050388108787696204021466'	,
		'1187'	=>	'7.079184394609668037105270638792446182281'	,	'1193'	=>	'7.0842264220979161131218318721741987813784'	,
		'1201'	=>	'7.0909098220799835409928377102177257360547'	,	'1213'	=>	'7.1008519089440501307424011623287824408746'	,
		'1217'	=>	'7.104144092987527172786132029498701026145'	,	'1223'	=>	'7.1090621356871723552615330775265205799235'	,
		'1229'	=>	'7.1139561095660348210728181333466610515895'	,	'1231'	=>	'7.1155821261844535103502782236721800380322'	,
		'1237'	=>	'7.120444372392487899433225094507777381971'	,	'1249'	=>	'7.1300985101255776755738821407288642524369'	,
		'1259'	=>	'7.1380730340443471664701422112826139228278'	,	'1277'	=>	'7.1522688560325392911129898741907607171418'	,
		'1279'	=>	'7.1538338015788426900345311704465247076289'	,	'1283'	=>	'7.1569563646156364278034412195190729719391'	,
		'1289'	=>	'7.1616220029391873876128480412611940860557'	,	'1291'	=>	'7.1631723908466424996653809900424933858879'	,
		'1297'	=>	'7.1678091843164438820204355188296662788801'	,	'1301'	=>	'7.1708884785125052747350824898984433244593'	,
		'1303'	=>	'7.1724245771248451178018101975386627780939'	,	'1307'	=>	'7.175489713624221947608353702491875853506'	,
		'1319'	=>	'7.1846291527173145985742026156412104304176'	,	'1321'	=>	'7.1861443045223253188256027061646435722407'	,
		'1327'	=>	'7.190676034332207509383150061486964196904'	,	'1361'	=>	'7.2159750026514660717988417785312629788801'	,
		'1367'	=>	'7.2203738367239495604485761817409771478916'	,	'1373'	=>	'7.224753405767971049407640093415687643246'	,
		'1381'	=>	'7.2305631534092921183556931281513061831279'	,	'1399'	=>	'7.24351297466548117539257036912245164453'	,
		'1409'	=>	'7.2506355118986802169619004595927052651067'	,	'1423'	=>	'7.2605225980898523691441633374276934687031'	,
		'1427'	=>	'7.2633296174768364169024075855929458385201'	,	'1429'	=>	'7.2647301779298674064524916065289351800341'	,
		'1433'	=>	'7.2675254278281718500766404021695455846774'	,	'1439'	=>	'7.2717037068873678169333005658002799741008'	,
		'1447'	=>	'7.2772477266314838612728992197161114391723'	,	'1451'	=>	'7.2800082528841878465500466326789762435123'	,
		'1453'	=>	'7.2813856635702829037327357823478666222295'	,	'1459'	=>	'7.2855065485227856459948593273503139629121'	,
		'1471'	=>	'7.2936977206014375180434188101858988430416'	,	'1481'	=>	'7.3004728142677987825018266688389687395451'	,
		'1483'	=>	'7.3018223421379320952532347693978809197167'	,	'1487'	=>	'7.3045159464601550733286773249640011433901'	,
		'1489'	=>	'7.3058600326840089849280371081906863463027'	,	'1493'	=>	'7.3085427975391903855231537524043411973393'	,
		'1499'	=>	'7.3125534981025977039761949343014942680633'	,	'1511'	=>	'7.3205269622727395692460493230346684281028'	,
		'1523'	=>	'7.3284373528951618107719279536860698056223'	,	'1531'	=>	'7.3336763956576837541864517282475243759665'	,
		'1543'	=>	'7.3414838523631608394071278531635887831178'	,	'1549'	=>	'7.3453648404168686311036364793340676185305'	,
		'1553'	=>	'7.3479438231486870694704489568804627473905'	,	'1559'	=>	'7.3517998690577765193985134785531613977114'	,
		'1567'	=>	'7.3569182423560208279887799997255625975873'	,	'1571'	=>	'7.3594676382556211570429956210051041899'	,
		'1579'	=>	'7.3645470142556420906063400021443348895829'	,	'1583'	=>	'7.3670770598810121482800340378011323937606'	,
		'1597'	=>	'7.3758821482150124338089550724534243071997'	,	'1601'	=>	'7.3783837129967146861291460181317193585091'	,
		'1607'	=>	'7.3821243657375125864035504072598721285692'	,	'1609'	=>	'7.3833681469923832093389928433709503552792'	,
		'1613'	=>	'7.3858510781252088615037163396456871470574'	,	'1619'	=>	'7.3895639536776351302220144968120675103707'	,
		'1621'	=>	'7.3907985217356761025694854356646016061392'	,	'1627'	=>	'7.3944931072190377985394128226843128148196'	,
		'1637'	=>	'7.4006205773711349033003091805993107980915'	,	'1657'	=>	'7.412764017426562911904525016886528264665'	,
		'1663'	=>	'7.4163784791929276757298020469933931444843'	,	'1667'	=>	'7.4187808827507940019901444621850060431314'	,
		'1669'	=>	'7.419979923661835076320736525113217552725'	,	'1693'	=>	'7.4342573821331353155703759951304368425071'	,
		'1697'	=>	'7.4366172652342263153560139082678181375471'	,	'1699'	=>	'7.437795121671932023617299389358043967892'	,
		'1709'	=>	'7.4436636831155908897363531902326028530564'	,	'1721'	=>	'7.4506607962115394185103213743451604566519'	,
		'1723'	=>	'7.4518222365279296215890181436758676247208'	,	'1733'	=>	'7.4576092897156060799352235122785856917757'	,
		'1741'	=>	'7.4622149397681890420167394109109201943374'	,	'1747'	=>	'7.4656553101340565647900571292666213879574'	,
		'1753'	=>	'7.4690838849212344985681812622250608403524'	,	'1759'	=>	'7.4725007447375581696030606711557057589018'	,
		'1777'	=>	'7.4826818281546513331790942536610606932504'	,	'1783'	=>	'7.4860526178631404082318534091606164871946'	,
		'1787'	=>	'7.488293515159428040768056114445482774773'	,	'1789'	=>	'7.4894120835087191598903875253126331675468'	,
		'1801'	=>	'7.4960973451759560784440270320102302423428'	,	'1811'	=>	'7.5016344578834133819821741692071794517916'	,
		'1823'	=>	'7.5082387746786630378275126214554977194428'	,	'1831'	=>	'7.5126175446745107113929082718245615825835'	,
		'1847'	=>	'7.5213179801992399614105315315679154393655'	,	'1861'	=>	'7.5288692566422507571879860926622690579434'	,
		'1867'	=>	'7.5320881435417226140387215048989499722142'	,	'1871'	=>	'7.5342283262740896156896784966946609381432'	,
		'1873'	=>	'7.5352967024440885133844104966814626284067'	,	'1877'	=>	'7.5374300365865088188076083511301434800581'	,
		'1879'	=>	'7.538494999413465315201028710022254924522'	,	'1889'	=>	'7.5438028675015095522054962178293367933296'	,
		'1901'	=>	'7.5501353424884291614410358470819855482236'	,	'1907'	=>	'7.5532866056004190662261431868719619040922'	,
		'1913'	=>	'7.5564279694402528754418161625851553045042'	,	'1931'	=>	'7.5657932824285144417543225786757186071635'	,
		'1933'	=>	'7.5668284792083308973963539324291387169691'	,	'1949'	=>	'7.5750716995075608110788961523770971176571'	,
		'1951'	=>	'7.5760973406231112110331283915944998412138'	,	'1973'	=>	'7.5873105060226153461161622660359902665219'	,
		'1979'	=>	'7.5903469456025657271621006045867251181395'	,	'1987'	=>	'7.5943812425518168483069877607146476968424'	,
		'1993'	=>	'7.5973963202127947187549792104729408327864'	,	'1997'	=>	'7.5994013334158152158203249294064434734452'	,
		'1999'	=>	'7.6004023345004000635519345356180089245273'	,	'2003'	=>	'7.6024013356658182533252066343779993788754'	,
		'2011'	=>	'7.6063873897726520467593521936481973271114'	,	'2017'	=>	'7.6093665379542117723886129137943003683956'	,
		'2027'	=>	'7.614312146452000035929062265202194351424'	,	'2029'	=>	'7.6152983398258147429302886313972137328925'	,
		'2039'	=>	'7.6202147705744551758460026878410291507089'	,	'2053'	=>	'7.62705741701893357133233763302946770009'	,
		'2063'	=>	'7.6319165130712518230670564373397700130345'	,	'2069'	=>	'7.6348206777455430306695355994851855916454'	,
		'2081'	=>	'7.6406038263936344250548270083691318208882'	,	'2083'	=>	'7.641564441260971993831475900747056143471'	,
		'2087'	=>	'7.6434829070772007487905355798321900912952'	,	'2089'	=>	'7.6444407615565657862753708032532194422647'	,
		'2099'	=>	'7.6492163198206329881925728084754688426542'	,	'2111'	=>	'7.6549170478483206097373338747863732403871'	,
		'2113'	=>	'7.6558640176160566993525024129136322519521'	,	'2129'	=>	'7.6634076648934794707048225039631349918607'	,
		'2131'	=>	'7.6643466320986171388870334161582392796767'	,	'2137'	=>	'7.6671582553191476198343895137356454293944'	,
		'2141'	=>	'7.6690282885896827965663268239439341613489'	,	'2143'	=>	'7.6699619954735770178831611555514147443206'	,
		'2153'	=>	'7.6746174973643630304387165386812862230712'	,	'2161'	=>	'7.678326356506885974481873424336381220415'	,
		'2179'	=>	'7.6866213349446198753864170371804819887589'	,	'2203'	=>	'7.6975753468023431235127634378174483708726'	,
		'2207'	=>	'7.6993894062567363999425368892477199166401'	,	'2213'	=>	'7.7021043400510496583158489571408608075631'	,
		'2221'	=>	'7.7057128238944274427325710169584181261605'	,	'2237'	=>	'7.712890961490129607925312704898827672376'	,
		'2239'	=>	'7.713784616598754827060110780832271449841'	,	'2243'	=>	'7.7155695345202083176381986833164201937775'	,
		'2251'	=>	'7.7191298409067322422784247348124203228557'	,	'2267'	=>	'7.7262126505075289942780395701608526358072'	,
		'2269'	=>	'7.7270944847798417275045835636600914655584'	,	'2273'	=>	'7.7288558238525432053585255949275215249776'	,
		'2281'	=>	'7.7323692222843880308104660648122168095619'	,	'2287'	=>	'7.7349961940227811395212164348770837715299'	,
		'2293'	=>	'7.7376162828579044405033703370418902250418'	,	'2297'	=>	'7.7393592026890982508400358437077254024098'	,
		'2309'	=>	'7.7445698093544953571066193957937679806829'	,	'2311'	=>	'7.7454356102743807267681683944463870713696'	,
		'2333'	=>	'7.7549102720214299688203466920307015338548'	,	'2339'	=>	'7.7574787665841790256472513124264508438404'	,
		'2341'	=>	'7.758333467490910765752229176833327006574'	,	'2347'	=>	'7.7608931958510235136279762214628177489722'	,
		'2351'	=>	'7.7625960485400695105703375872911261743307'	,	'2357'	=>	'7.7651449029361311139857493320166704790924'	,
		'2371'	=>	'7.771067086065405480131496299732159304459'	,	'2377'	=>	'7.7735944673601939235204490969236714029994'	,
		'2381'	=>	'7.7752758464868627807987944782539392184993'	,	'2383'	=>	'7.7761154770987421228168191523428703925664'	,
		'2389'	=>	'7.7786301473258095336385236662883906026773'	,	'2393'	=>	'7.7803030879083733231604394567461603030014'	,
		'2399'	=>	'7.7828072628396945734226320586414594099354'	,	'2411'	=>	'7.7877968781811710497246950005695504449047'	,
		'2417'	=>	'7.7902823807034830116858047111246508647229'	,	'2423'	=>	'7.792761720816525732007401326502927556362'	,
		'2437'	=>	'7.7985230536252062249186855175280125087544'	,	'2441'	=>	'7.8001630703929600691093429889569046376753'	,
		'2447'	=>	'7.802618063442671662546740809791685507862'	,	'2459'	=>	'7.8075100422161925656617664680119811254804'	,
		'2467'	=>	'7.8107581165293566985079200422847261801574'	,	'2473'	=>	'7.8131872675214162049663740176447513493784'	,
		'2477'	=>	'7.8148034294893595575480918500328606583155'	,	'2503'	=>	'7.8252452914317742144043489218881026947596'	,
		'2521'	=>	'7.8324109271879198248957163835136369566222'	,	'2531'	=>	'7.8363697605451240530559009878394588043822'	,
		'2539'	=>	'7.8395255817046784351715509480100901149356'	,	'2543'	=>	'7.8410997654221196359994550432552416383783'	,
		'2549'	=>	'7.843456404376115442248877127814448800545'	,	'2551'	=>	'7.8442407181418113949778562036249857244729'	,
		'2557'	=>	'7.8465899752911866193774199149376610931139'	,	'2579'	=>	'7.855157005881344777689624452933873420849'	,
		'2591'	=>	'7.8597991805621099718302924802948121517901'	,	'2593'	=>	'7.8605707855386643850206020988887223855172'	,
		'2609'	=>	'7.8667222851367284318651917254904464777845'	,	'2617'	=>	'7.8697839025301458573789225194586670526228'	,
		'2621'	=>	'7.871311203323406341330390766924692457941'	,	'2633'	=>	'7.8758791594963094022028676267067499941352'	,
		'2647'	=>	'7.8811822022271012686866197298640993804668'	,	'2657'	=>	'7.884952945759813504753751267221991835917'	,
		'2659'	=>	'7.8857053912430198127456637672503945935909'	,	'2663'	=>	'7.8872085858139322307494837786356071310123'	,
		'2671'	=>	'7.8902082131099608686075286802335868089856'	,	'2677'	=>	'7.8924520435203525081205660843513222519503'	,
		'2683'	=>	'7.8946908504256241387884932117543850891782'	,	'2687'	=>	'7.8961806086154912253411904023851740715027'	,
		'2689'	=>	'7.8969246562688646693753247402863364185436'	,	'2693'	=>	'7.8984110928115989087177447338862727825222'	,
		'2699'	=>	'7.9006366130180046543149341661167041031674'	,	'2707'	=>	'7.9035962896143011830601527395828899899217'	,
		'2711'	=>	'7.9050728494986655257315850285321920878828'	,	'2713'	=>	'7.9058103126589317442554454424285961822776'	,
		'2719'	=>	'7.9080194446324707132470879023717237770853'	,	'2729'	=>	'7.9116905207083384713665257410802068508836'	,
		'2731'	=>	'7.9124231214737050084003953974009318835346'	,	'2741'	=>	'7.9160780963027857914487923965650864130276'	,
		'2749'	=>	'7.9189924881652457126622000882014942113467'	,	'2753'	=>	'7.9204465051426073140145387604631147226013'	,
		'2767'	=>	'7.9255189797869259060233996239925687004614'	,	'2777'	=>	'7.9291264873067995481473815289960806319'	,
		'2789'	=>	'7.933438387627488953186077244103215507074'	,	'2791'	=>	'7.9341552335363221701878642561313798890782'	,
		'2797'	=>	'7.9363026932019597258598821819322262953384'	,	'2801'	=>	'7.9377317752601085241697531437918206015425'	,
		'2803'	=>	'7.9384455511647882789743751505738182727675'	,	'2819'	=>	'7.9441374911141125491947938108206513862988'	,
		'2833'	=>	'7.9490914998305165516044181869945642611384'	,	'2837'	=>	'7.9505024348088513484342852412850482577019'	,
		'2843'	=>	'7.9526151116509997828211652283190260344394'	,	'2851'	=>	'7.9554250889126719926347140108491130588333'	,
		'2857'	=>	'7.9575274022307730721546160274815087234835'	,	'2861'	=>	'7.9589264930501102596202912460515983373715'	,
		'2879'	=>	'7.9651982906121758719562847646388046872818'	,	'2887'	=>	'7.9679731796629350940292546797550419141112'	,
		'2897'	=>	'7.9714309977693503990143434809748186596695'	,	'2903'	=>	'7.9734999640246298921333018551029219356211'	,
		'2909'	=>	'7.9755646584952016323137251869909148707235'	,	'2917'	=>	'7.9783109698677214187298888562696828102898'	,
		'2927'	=>	'7.9817332866918858491082240894329120062592'	,	'2939'	=>	'7.9858246664189173529090062688420334364668'	,
		'2953'	=>	'7.9905768817439226688506868303029103044355'	,	'2957'	=>	'7.991930519852477217409462172238176495897'	,
		'2963'	=>	'7.9939575475735652411734896844205965612893'	,	'2969'	=>	'7.995980474763759802488748395275252307807'	,
		'2971'	=>	'7.9966538754626076418704279956162584654595'	,	'2999'	=>	'8.006034178749009088304957990139394334221'	,
		'3001'	=>	'8.0067008454403671146424066804522934680326'	,	'3011'	=>	'8.0100275284817338302322461058255646743489'	,
		'3019'	=>	'8.012680929706838802092006741037653862494'	,	'3023'	=>	'8.0140049947794580523738934229550361779832'	,
		'3037'	=>	'8.0186254650457487673750433358993067901021'	,	'3041'	=>	'8.0199416876773646460582990305016754164882'	,
		'3049'	=>	'8.0225689469882547812714119510030692234488'	,	'3061'	=>	'8.0264969389454125056143715730315822758539'	,
		'3067'	=>	'8.0284551641142515341390978196229274963749'	,	'3079'	=>	'8.0323601479245003733272402897302686414927'	,
		'3083'	=>	'8.033658427886150358339860707486848454466'	,	'3089'	=>	'8.0356026929185817060673897978594039385241'	,
		'3109'	=>	'8.042056410058753811420056537250944601444'	,	'3119'	=>	'8.0452677166078032600153517248893169204358'	,
		'3121'	=>	'8.0459087422707794297685497716485050051183'	,	'3137'	=>	'8.0510222081906781488825410229403132551349'	,
		'3163'	=>	'8.0592762233056488405874039490417048013921'	,	'3167'	=>	'8.0605400465386397960089553828955500192332'	,
		'3169'	=>	'8.0611713596909207457982787047630203487335'	,	'3181'	=>	'8.0649508917491441090059344975888224817118'	,
		'3187'	=>	'8.0668353144173364114919932634877772976629'	,	'3191'	=>	'8.0680896262782435091357448798587938153522'	,
		'3203'	=>	'8.0718431496091581439242932165719479805011'	,	'3209'	=>	'8.0737146411098568701768562214914870056021'	,
		'3217'	=>	'8.0762045272390263474380894548083194540775'	,	'3221'	=>	'8.0774471493311988258700246354525337699257'	,
		'3229'	=>	'8.0799277707582752151995226075968467249942'	,	'3251'	=>	'8.0867179203039053410836183779574706407931'	,
		'3253'	=>	'8.0873329264733514555809764859117404129354'	,	'3257'	=>	'8.0885618052762334908256170471214836219193'	,
		'3259'	=>	'8.0891756788375615421316723443574470525612'	,	'3271'	=>	'8.0928510275383839101108135964104936569017'	,
		'3299'	=>	'8.1013746712285814231976767533174708263593'	,	'3301'	=>	'8.1019807318531930130186861558201919478523'	,
		'3307'	=>	'8.1037967129817927827181119125894228487863'	,	'3313'	=>	'8.1056094022998958618750601889213589505577'	,
		'3319'	=>	'8.1074188117199746119990897550671167604518'	,	'3323'	=>	'8.1086232683545942797300006776200297906854'	,
		'3329'	=>	'8.1104272375750249429520216535861576658324'	,	'3331'	=>	'8.1110278381936796527097673097044433150945'	,
		'3343'	=>	'8.1146238864200986097499701859221136535944'	,	'3347'	=>	'8.1158197012113266098336060799065651959084'	,
		'3359'	=>	'8.1193985896122927453244864682431458913471'	,	'3361'	=>	'8.1199938277251056624302822130052008752546'	,
		'3371'	=>	'8.1229647152340607259354611234460276507591'	,	'3373'	=>	'8.1235578350616502439177269846015468584506'	,
		'3389'	=>	'8.1282901716070513362977330212788037179831'	,	'3391'	=>	'8.1288801421256386131307214104838175471186'	,
		'3407'	=>	'8.1335874176609665653616909162150698655415'	,	'3413'	=>	'8.13534694890670704116646822710339848256'	,
		'3433'	=>	'8.1411897934576920556078531221782235955592'	,	'3449'	=>	'8.1458396129368409067858529692789203650056'	,
		'3457'	=>	'8.1481564399216245340125241213932314655698'	,	'3461'	=>	'8.1493128436353442525535212228705707626665'	,
		'3463'	=>	'8.1498905444024219617016928353436604838136'	,	'3467'	=>	'8.151044945685023432762106154172618157827'	,
		'3469'	=>	'8.1516216469697497096729769211399012882808'	,	'3491'	=>	'8.1579435071050360333312078308811517031504'	,
		'3499'	=>	'8.1602324923676880266753852312060831160337'	,	'3511'	=>	'8.1636561761684322428074872137019168070047'	,
		'3517'	=>	'8.1653636324739824553435175051934413579681'	,	'3527'	=>	'8.1682029302360519940841849648897165846384'	,
		'3529'	=>	'8.1687698236752700671051223879031326292505'	,	'3533'	=>	'8.1699026473591452177990966381711634659758'	,
		'3539'	=>	'8.1715994803454633803118460411228041271316'	,	'3541'	=>	'8.1721644521119037331921032024411536216542'	,
		'3547'	=>	'8.1738574547736218307740241845888698580667'	,	'3557'	=>	'8.1766727719484551988024782231299445297405'	,
		'3559'	=>	'8.1772348855101926755977388575143139438975'	,	'3571'	=>	'8.1806009475944484443051631493470944997299'	,
		'3581'	=>	'8.1833973699984327009942661771268150912072'	,	'3583'	=>	'8.1839557173049538117833765623143036291988'	,
		'3593'	=>	'8.1867427871135187300711506192511868067198'	,	'3607'	=>	'8.1906316809035389933306558396023114292917'	,
		'3613'	=>	'8.1922937311476402241803870382831323776812'	,	'3617'	=>	'8.193400231952097947120170379806234489242'	,
		'3623'	=>	'8.1950576908950772319101730390221284682968'	,	'3631'	=>	'8.1972633714143357850876390388550875300603'	,
		'3637'	=>	'8.1989144449869890347379849524649114679143'	,	'3643'	=>	'8.2005627970085637962749304234404057683614'	,
		'3659'	=>	'8.2049451650192068103948882343833948306058'	,	'3671'	=>	'8.2082193834968342930006204878660811377794'	,
		'3673'	=>	'8.208764045819667310631661773931568987583'	,	'3677'	=>	'8.2098524813012720067064436114118048776487'	,
		'3691'	=>	'8.2136527030299985711355982985609271543941'	,	'3697'	=>	'8.2152769589366319136140792215462775560885'	,
		'3701'	=>	'8.2163583323861559754817182061875627632094'	,	'3709'	=>	'8.2185175774895908030871473209495409115854'	,
		'3719'	=>	'8.2212100939250700436566520485903544808011'	,	'3727'	=>	'8.2233588994792584140347441286604456476325'	,
		'3733'	=>	'8.2249674789145838414025112065547010285785'	,	'3739'	=>	'8.2265734749771137185422672897316829863181'	,
		'3761'	=>	'8.2324401584703363909966341737705307395072'	,	'3767'	=>	'8.2340342076920410686808191832088031404442'	,
		'3769'	=>	'8.2345649932671354302079492987548311536942'	,	'3779'	=>	'8.2372147033494889673393409673259612263861'	,
		'3793'	=>	'8.2409125416888989372601077432203728019416'	,	'3797'	=>	'8.2419665602318023248941725174414286854686'	,
		'3803'	=>	'8.2435455079282596570727870345158413711269'	,	'3821'	=>	'8.2482674474468999503484751222688354756796'	,
		'3823'	=>	'8.2487907336964127925636990795009582124765'	,	'3833'	=>	'8.2514030653805550887572323869723585632336'	,
		'3847'	=>	'8.2550489027522951224156247906436751289152'	,	'3851'	=>	'8.2560881338149088906724273510376595908541'	,
		'3853'	=>	'8.2566073446261575868175600718200761847445'	,	'3863'	=>	'8.2591993626662813054995206782627569476357'	,
		'3877'	=>	'8.2628169376709291271526935912768089987399'	,	'3881'	=>	'8.2638481313689063054548554868807916351686'	,
		'3889'	=>	'8.2659073341557472866066954293122806276349'	,	'3907'	=>	'8.2705250950550705850836432610445938602686'	,
		'3911'	=>	'8.2715483747555141194117853844111003929012'	,	'3917'	=>	'8.2730813336658313049869116206880712163909'	,
		'3919'	=>	'8.2735917981996314597910702994003443345941'	,	'3923'	=>	'8.2746119462095525635991957260858777379919'	,
		'3929'	=>	'8.2761402195584597640654972371497680058753'	,	'3931'	=>	'8.2766491254218603228731978106068936111952'	,
		'3943'	=>	'8.2796971338776271778172659536436807867396'	,	'3947'	=>	'8.28071107566284711243486213540094062415'	,
		'3967'	=>	'8.285765420514330138608776791389546297339'	,	'3989'	=>	'8.2912958519054066251305083069780701560903'	,
		'4001'	=>	'8.2942996088572350278545437589160135364623'	,	'4003'	=>	'8.2947993589925736167572320776528426016197'	,
		'4007'	=>	'8.2957981106361445554964791218881549926974'	,	'4013'	=>	'8.2972943702669167249655456849946940195898'	,
		'4019'	=>	'8.2987883944492011092050965893979235898175'	,	'4021'	=>	'8.2992859068972740211025431321222850634453'	,
		'4027'	=>	'8.3007769608514541667158851790682622724366'	,	'4049'	=>	'8.3062252160321611222433652871437983920619'	,
		'4051'	=>	'8.3067190432026905573611404557555598037598'	,	'4057'	=>	'8.3081990632064472336748294524015325164188'	,
		'4073'	=>	'8.3121351076484125797553963720513178472438'	,	'4079'	=>	'8.3136071393175584527574130262789914800968'	,
		'4091'	=>	'8.316544717929398565276590623791640472182'	,	'4093'	=>	'8.3170334764924030020621503265485271813133'	,
		'4099'	=>	'8.3184983205043375604803468959114983229058'	,	'4111'	=>	'8.3214215868978784107889002296022998305857'	,
		'4127'	=>	'8.3253060297525818167540549431385359116252'	,	'4129'	=>	'8.3257905258860902349737841602808852564864'	,
		'4133'	=>	'8.3267588145117323593905426062244006058488'	,	'4139'	=>	'8.3282094917487324043781205786533197536585'	,
		'4153'	=>	'8.3315862436307535388294240464518150433861'	,	'4157'	=>	'8.3325489392526374414430616827721922897319'	,
		'4159'	=>	'8.3330299397429116706699301043140669220315'	,	'4177'	=>	'8.3373485644971753357767016412817075941005'	,
		'4201'	=>	'8.3430778711693820611266268121652021525148'	,	'4211'	=>	'8.3454554281619277736480724626920291743009'	,
		'4217'	=>	'8.3468792537465598603774528431319281042059'	,	'4219'	=>	'8.3473534121243386720723867594773042054535'	,
		'4229'	=>	'8.3497208374724885804368709237722510564076'	,	'4231'	=>	'8.3501936507200674758763182917024745923972'	,
		'4241'	=>	'8.3525543694745907132701431473935909581683'	,	'4243'	=>	'8.3530258452023248544385737360692114165615'	,
		'4253'	=>	'8.355379895253633535436146600915206532313'	,	'4259'	=>	'8.3567896699232134876395856280529268711316'	,
		'4261'	=>	'8.3572591534999120333352017325359306251499'	,	'4271'	=>	'8.3596032708414664964831297816696789586066'	,
		'4273'	=>	'8.3600714356440249500393853924195016903558'	,	'4283'	=>	'8.3624089776153709782062489307916806747337'	,
		'4289'	=>	'8.3638088845168804589440277970161500807492'	,	'4297'	=>	'8.3656723837749951082192726441442253692404'	,
		'4327'	=>	'8.372629740224884788438044368281340847794'	,	'4337'	=>	'8.3749381438353662357349581949557925710188'	,
		'4339'	=>	'8.3753991857983507021126876796500007575076'	,	'4349'	=>	'8.3777012125976384009676180264699571160113'	,
		'4357'	=>	'8.3795390261174421138769730189680819029644'	,	'4363'	=>	'8.3809151731236096050249474110159680844667'	,
		'4373'	=>	'8.3832045514129205966540373679754958567814'	,	'4391'	=>	'8.3873122705617174452020155027311533908274'	,
		'4397'	=>	'8.3886777691808101193940148674626924434904'	,	'4409'	=>	'8.3914031853579376276812039295660729654071'	,
		'4421'	=>	'8.3941211938262432050714208007972932501898'	,	'4423'	=>	'8.3945734778683267590449628997875036725552'	,
		'4441'	=>	'8.398634855292102270232502834997685028092'	,	'4447'	=>	'8.3999849905106964481249117978858976689668'	,
		'4451'	=>	'8.4008840690158543223698083161801592922645'	,	'4457'	=>	'8.4022311729465558204868371547316148905165'	,
		'4463'	=>	'8.4035764646292699075932851177837905914493'	,	'4481'	=>	'8.4076015147861430261500112400383554756616'	,
		'4483'	=>	'8.4080477441554394953364573005441244137443'	,	'4493'	=>	'8.4102759090701599492104971286802339901528'	,
		'4507'	=>	'8.4133870226906482746685375635405410807502'	,	'4513'	=>	'8.4147173998270011873870832833958645362152'	,
		'4517'	=>	'8.4156033356546041612049665983821873224874'	,	'4519'	=>	'8.416046009411279683346371853965827534509'	,
		'4523'	=>	'8.4169307694778431549361719282048064167968'	,	'4547'	=>	'8.4222229538250105600125659949402235058039'	,
		'4549'	=>	'8.4226627075700040866767607437697442626743'	,	'4561'	=>	'8.4252971767117004326097602823157176867606'	,
		'4567'	=>	'8.4266118131849989653819893613672871985708'	,	'4583'	=>	'8.4301090845091240571989894119195972720632'	,
		'4591'	=>	'8.4318531442492220475815488204080161641861'	,	'4597'	=>	'8.43315919580622799240778177994803582706'	,
		'4603'	=>	'8.434463543817241436493979840186051605496'	,	'4621'	=>	'8.4383664108702663822344841201079844670554'	,
		'4637'	=>	'8.441822884391460829930571649034785859994'	,	'4639'	=>	'8.4422541047517436744952608123980428488221'	,
		'4643'	=>	'8.4431159880199217078765956544885851903078'	,	'4649'	=>	'8.4444074216905847383719527813252556121415'	,
		'4651'	=>	'8.4448375292240970139925134601860971080789'	,	'4657'	=>	'8.4461267429823772104361700323990156117066'	,
		'4663'	=>	'8.4474142968083208594594962750454196661343'	,	'4673'	=>	'8.4495565427004261706610881536655687149645'	,
		'4679'	=>	'8.4508396908662162872339632219562573457493'	,	'4691'	=>	'8.4534010583284580288075432173017105226798'	,
		'4703'	=>	'8.4559558819450479802297567475627061320751'	,	'4721'	=>	'8.4597759205462867427010065417597259603449'	,
		'4723'	=>	'8.4601994698961171129962684000806868707463'	,	'4729'	=>	'8.4614690426438757797919062043583129981384'	,
		'4733'	=>	'8.4623145299062479845630493208102218387283'	,	'4751'	=>	'8.4661104011869213247024396102489427669936'	,
		'4759'	=>	'8.4677928411211104587530087186323512408074'	,	'4783'	=>	'8.4728232436802968914230335848949251790101'	,
		'4787'	=>	'8.4736591893925090283528172431396791767196'	,	'4789'	=>	'8.4740769003426093638208735969039169630541'	,
		'4793'	=>	'8.4749117991596312817619074491576620789628'	,	'4799'	=>	'8.4761628418582455220590259035696273852022'	,
		'4801'	=>	'8.4765795085309403524629229152522688695829'	,	'4813'	=>	'8.4790758693031093679747401837269659804626'	,
		'4817'	=>	'8.47990660663022079052360601195887521552'	,	'4831'	=>	'8.4828087645544066681564921230849815149881'	,
		'4861'	=>	'8.4889994570454554914509363177779018185138'	,	'4871'	=>	'8.4910545338065426603582883191935233211938'	,
		'4877'	=>	'8.4922855557100525996942063633837225687714'	,	'4889'	=>	'8.4947430625786455551084691253380182568632'	,
		'4903'	=>	'8.4976025416512332513902186059057012006573'	,	'4909'	=>	'8.4988255340580524921007457633682879107646'	,
		'4919'	=>	'8.500860536795339809787676135363077776093'	,	'4931'	=>	'8.5032970862241261105993879549955507276476'	,
		'4933'	=>	'8.5037026012337382497778836573456567615135'	,	'4937'	=>	'8.504513138258862887528940655214627256608'	,
		'4943'	=>	'8.5057277133069592955439719219785974807952'	,	'4951'	=>	'8.5073448553614230527479223136640913074508'	,
		'4957'	=>	'8.5085559980205738909547592701246328394212'	,	'4967'	=>	'8.5105713151073505074608237056781739879952'	,
		'4969'	=>	'8.5109738916023205770349185819817239303848'	,	'4973'	=>	'8.5117785587147385449032013153392552265485'	,
		'4987'	=>	'8.5145898055461225456351025800505961997929'	,	'4993'	=>	'8.5157922105006092830836366097110588314034'	,
		'4999'	=>	'8.5169931714135703599240563621170554435249'	,	'5003'	=>	'8.517793011488205042198961694266593687711'	,
		'5009'	=>	'8.5189915733576168001307619447899779287901'	,	'5011'	=>	'8.5193907749597246483909815870942677438547'	,
		'5021'	=>	'8.5213843960347054975614704442407475799394'	,	'5023'	=>	'8.5217826437500447130915934234458348197314'	,
		'5039'	=>	'8.5249629286805980913597962149135121117249'	,	'5051'	=>	'8.5273415224680525754475529154700985543853'	,
		'5059'	=>	'8.5289241142919360936108070574927233473809'	,	'5077'	=>	'8.5324758149473943297563722981946996999957'	,
		'5081'	=>	'8.5332633715937318938948989392718110008824'	,	'5087'	=>	'8.5344435448227650192090741126358485505198'	,
		'5099'	=>	'8.5367997210551557367465083419476433611139'	,	'5101'	=>	'8.5371918779229265540192418123987050429065'	,
		'5107'	=>	'8.5383674266476439102453842022819582110459'	,	'5113'	=>	'8.5395415950799992405644503656345048516969'	,
		'5119'	=>	'8.5407143864575832499277058903265199395909'	,	'5147'	=>	'8.5461692996527545252418063314559886492285'	,
		'5153'	=>	'8.5473343483282242714076009571675272399083'	,	'5167'	=>	'8.5500475282871846107432526488535598636134'	,
		'5171'	=>	'8.5508213723962214779073943982634257366361'	,	'5179'	=>	'8.5523672664238914617529241435161820562067'	,
		'5189'	=>	'8.5542962793677396334926544247545388882203'	,	'5197'	=>	'8.5558368150084418565367372732385672045303'	,
		'5209'	=>	'8.5581431777451915397739846438475273642488'	,	'5227'	=>	'8.5615927787129218415659328203465098135862'	,
		'5231'	=>	'8.5623577433706110697042967196551273576502'	,	'5233'	=>	'8.5627400063722078141625624365712538898064'	,
		'5237'	=>	'8.563504094279487681998943445714271382438'	,	'5261'	=>	'8.5680764017308072266938471925068949543011'	,
		'5273'	=>	'8.5703547395304697822840993512698694091527'	,	'5279'	=>	'8.5714919648236162321984048428938901917992'	,
		'5281'	=>	'8.5718707527069331596038533422449295792515'	,	'5297'	=>	'8.5748959015445266791736305338899635912554'	,
		'5303'	=>	'8.5760279771371299923805526957294384616376'	,	'5309'	=>	'8.5771587725836714845279156773307923016343'	,
		'5323'	=>	'8.5797923331727573894274515829847490585852'	,	'5333'	=>	'8.5816692106006022143044362692070189311255'	,
		'5347'	=>	'8.5842909349487315648413398541923084049845'	,	'5351'	=>	'8.5850387383113046229745513423087614344437'	,
		'5381'	=>	'8.5906295094894196448758108647069591623878'	,	'5387'	=>	'8.5917439226805337547219457342508768373561'	,
		'5393'	=>	'8.592857095337227014278332185624598186833'	,	'5399'	=>	'8.5939690302182869803865413095778562402199'	,
		'5407'	=>	'8.5954496893820048505814886766851542746613'	,	'5413'	=>	'8.5965587467969778935104486346584967195455'	,
		'5417'	=>	'8.5972974356578988678586351714501329787753'	,	'5419'	=>	'8.5976665755661142078219600068925614452197'	,
		'5431'	=>	'8.5998785580348452756507653459377180231559'	,	'5437'	=>	'8.6009827171459206637440644920923130702027'	,
		'5441'	=>	'8.6017181464859253404165097033012610141298'	,	'5443'	=>	'8.6020856584342000259432955790846413421367'	,
		'5449'	=>	'8.603187384583098344214607142797368110234'	,	'5471'	=>	'8.6072166940638259230361328642930771193975'	,
		'5477'	=>	'8.6083127847837213233087113711738254711821'	,	'5479'	=>	'8.6086778815384157263752884775764178651342'	,
		'5483'	=>	'8.609407675404048462590545781945381782559'	,	'5501'	=>	'8.6126851728754580816522452341668813082247'	,
		'5503'	=>	'8.6130486770597587993219754695183188230062'	,	'5507'	=>	'8.6137752892624814931457560317237868361252'	,
		'5519'	=>	'8.6159519634395012825117803469688447210108'	,	'5521'	=>	'8.6163142822840446081405240681163207233765'	,
		'5527'	=>	'8.617400451833262952316102030030255085517'	,	'5531'	=>	'8.6181239099946780187387474934514274064529'	,
		'5557'	=>	'8.6228136732799212523464773902939978626077'	,	'5563'	=>	'8.6238928100752932128251873615197405682745'	,
		'5569'	=>	'8.6249707835896686058533698791386710559322'	,	'5573'	=>	'8.6256887875695363561481352736824251471039'	,
		'5581'	=>	'8.6271232507884335715926622241518300315861'	,	'5591'	=>	'8.6289134410266453089437153795140930144093'	,
		'5623'	=>	'8.6346206082922017039554923756729617276259'	,	'5639'	=>	'8.6374620238071821200749923943455023928154'	,
		'5641'	=>	'8.6378166337399760977396675078639454336357'	,	'5647'	=>	'8.6388797096728366946337894722953462139517'	,
		'5651'	=>	'8.6395877996298433260743845329229632430297'	,	'5653'	=>	'8.6399416566752908021404232410868455703476'	,
		'5657'	=>	'8.6406489953431556996874172238845547016501'	,	'5659'	=>	'8.6410024771425238327799212681426765526422'	,
		'5669'	=>	'8.6427680143243036965844200894158792051378'	,	'5683'	=>	'8.6452345412971214918448382890649231084687'	,
		'5689'	=>	'8.6462897647506473902098179502773275601617'	,	'5693'	=>	'8.646992628951081882108421194580937220074'	,
		'5701'	=>	'8.6483968770315818653487891130717247567216'	,	'5711'	=>	'8.6501494186648629173347454136585331125319'	,
		'5717'	=>	'8.65119947126397128630847173819096559911'	,	'5737'	=>	'8.6546917046018710614739404309557819483164'	,
		'5741'	=>	'8.6553886901676368089881774419319147975404'	,	'5743'	=>	'8.6557370008642965193435200154412961892847'	,
		'5749'	=>	'8.6567812056232909118680291517157166220733'	,	'5779'	=>	'8.6619859363177779745465307787718462401198'	,
		'5783'	=>	'8.6626778581582182576266293470652041227642'	,	'5791'	=>	'8.6640602672257897995003900599412547999677'	,
		'5801'	=>	'8.6657855954660643263298196444637542483035'	,	'5807'	=>	'8.6668193653720498707377054402208640605811'	,
		'5813'	=>	'8.6678520677013505662615407120187881734805'	,	'5821'	=>	'8.6692273472717355112039914070271319812991'	,
		'5827'	=>	'8.6702575671430741929112877479542075044786'	,	'5839'	=>	'8.6723148282835376082238495402213633877751'	,
		'5843'	=>	'8.6729996425544370308091346482319049503677'	,	'5849'	=>	'8.6740259854430257843554249569085238938741'	,
		'5851'	=>	'8.6743678657882361025951239789671256889486'	,	'5857'	=>	'8.6753928060897822764370240689921226214903'	,
		'5861'	=>	'8.6760755164764292280450863922643511067812'	,	'5867'	=>	'8.6770987089258598871774582357743408570661'	,
		'5869'	=>	'8.6774395405583345009433750847875276530696'	,	'5879'	=>	'8.6791419584022549377983626469029193968726'	,
		'5881'	=>	'8.6794820944599559734425044513688457287412'	,	'5897'	=>	'8.6821990260005041339367887394717273449625'	,
		'5903'	=>	'8.6832159752406893660798100736102726498113'	,	'5923'	=>	'8.6865983562769651688705164081734673340706'	,
		'5927'	=>	'8.6872734617878381616890265914993273944847'	,	'5939'	=>	'8.6892960480158602029609303936042804150478'	,
		'5953'	=>	'8.6916505731533901047782901449697110059599'	,	'5981'	=>	'8.696343057044557018120181911689043398596'	,
		'5987'	=>	'8.6973457309253520460599312997620078954914'	,	'6007'	=>	'8.7006807348501614276266416552198484913292'	,
		'6011'	=>	'8.7013464030391620452876423625338034019894'	,	'6029'	=>	'8.7043364384894055656099710450465019200898'	,
		'6037'	=>	'8.7056624787964261572792817288999786211732'	,	'6043'	=>	'8.706655856361558522401696410158539451163'	,
		'6047'	=>	'8.7073175602732128959061606191752216642419'	,	'6053'	=>	'8.7083092958916872364704732490433842518483'	,
		'6067'	=>	'8.7106195279422978407164127637263419017473'	,	'6073'	=>	'8.7116079958975753434099405142466251506465'	,
		'6079'	=>	'8.7125954877487224912237749203549507411826'	,	'6089'	=>	'8.7142391436085740778964698218219502101645'	,
		'6091'	=>	'8.714567550836484622700794491879207891323'	,	'6101'	=>	'8.7162079711518524445487306331380551393674'	,
		'6113'	=>	'8.7181729300287254000650793348530184147513'	,	'6121'	=>	'8.7194807608510698402716196360242056173676'	,
		'6131'	=>	'8.7211131477626879313151827041655463586099'	,	'6133'	=>	'8.7214393056259837279992735819441891469333'	,
		'6143'	=>	'8.7230685011639274099037674281240917544107'	,	'6151'	=>	'8.7243699492083682715235096669133601715463'	,
		'6163'	=>	'8.7263189509622431450198547122696623066634'	,	'6173'	=>	'8.7279402223938958876621607018482877103164'	,
		'6197'	=>	'8.7318205829621074836780631034078265391615'	,	'6199'	=>	'8.7321432677019193972288531581146423655119'	,
		'6203'	=>	'8.7327883249731175308761113723941837614965'	,	'6211'	=>	'8.7340771925593029783523521338572030463632'	,
		'6217'	=>	'8.7350427542693375294786931483711798218842'	,	'6221'	=>	'8.7356859445150197768543920952398674554179'	,
		'6229'	=>	'8.7369710852541455250630523013144124812523'	,	'6247'	=>	'8.7398566274935699062829101568236630173198'	,
		'6257'	=>	'8.7414561159983634880540438158338234285445'	,	'6263'	=>	'8.7424145825254128546202203227761032899878'	,
		'6269'	=>	'8.7433721312739685194661165919060631845462'	,	'6271'	=>	'8.7436911105430208260560315388721082342358'	,
		'6277'	=>	'8.7446474383175317280611762610358903144297'	,	'6287'	=>	'8.7462392883830610876212547043180562374989'	,
		'6299'	=>	'8.7481461696219290105167132272293657910707'	,	'6301'	=>	'8.7484636299420554934449018164315518693292'	,
		'6311'	=>	'8.7500494215842395280974193392224258721245'	,	'6317'	=>	'8.7509996908987003893910059166326604328615'	,
		'6323'	=>	'8.7519490580586132051174266372225434207823'	,	'6329'	=>	'8.7528975247753053564915266872473289638961'	,
		'6337'	=>	'8.754160749323516969393770488822326024712'	,	'6343'	=>	'8.7551071216338971378863069319464840142772'	,
		'6353'	=>	'8.7566824212665332476777192415886418507518'	,	'6359'	=>	'8.7576264112674077842192767491929470080414'	,
		'6361'	=>	'8.7579408766788042332444799906037585445947'	,	'6367'	=>	'8.7588836800170253301483485234222105884268'	,
		'6373'	=>	'8.7598255953142941224646825956533857321139'	,	'6379'	=>	'8.7607666242419553073474938777124390720967'	,
		'6389'	=>	'8.7623330406023432712351131846424648319469'	,	'6397'	=>	'8.7635844094501376246801871405129387885876'	,
		'6421'	=>	'8.7673291477940483711046435515211767346076'	,	'6427'	=>	'8.7682631453712861872318871422932877472127'	,
		'6449'	=>	'8.7716803590103773803478928207161980088206'	,	'6451'	=>	'8.771990436532241671547154469270681548365'	,
		'6469'	=>	'8.7747768160439854282407421081682220832948'	,	'6473'	=>	'8.7753949585455101874102648408359801192174'	,
		'6481'	=>	'8.7766300984277159915197749120695033287916'	,	'6491'	=>	'8.7781718810334685751903729768486137615273'	,
		'6521'	=>	'8.7827830173932022798890826010644291092186'	,	'6529'	=>	'8.7840090711866334795546222626571450321509'	,
		'6547'	=>	'8.7867622084410913682828729475865372810639'	,	'6551'	=>	'8.7873729887318763512976802043921135610267'	,
		'6553'	=>	'8.7876782390394968679378338085586120173614'	,	'6563'	=>	'8.7892030944737227504706425675907401327531'	,
		'6569'	=>	'8.7901168928924729437762449416842697665964'	,	'6571'	=>	'8.7904213068978678673312286621440328817336'	,
		'6577'	=>	'8.7913339933013510175851295818363342852476'	,	'6581'	=>	'8.7919419884561191234747805472517024635383'	,
		'6599'	=>	'8.7946734013834216238743366999370444065687'	,	'6607'	=>	'8.7958849720298856953025791972131572231715'	,
		'6619'	=>	'8.7976995801189227943634814135556273978582'	,	'6637'	=>	'8.8004153331459249663046141169087600759992'	,
		'6653'	=>	'8.8028231597418875157937187141980593448608'	,	'6659'	=>	'8.8037246021106223665407913567264027894526'	,
		'6661'	=>	'8.804024902413179430394152786521639823602'	,	'6673'	=>	'8.8058248129036065488318912344488922085756'	,
		'6679'	=>	'8.8067235547256359715244306327865261299338'	,	'6689'	=>	'8.8082196651184080421230451449037445603494'	,
		'6691'	=>	'8.8085186187828169433021777677605742266985'	,	'6701'	=>	'8.8100120479731707196480666515293841579189'	,
		'6703'	=>	'8.8103104663579576870271248181658490810093'	,	'6709'	=>	'8.8112051875628880496778362210774160128363'	,
		'6719'	=>	'8.8126946129201499666714373866430265133499'	,	'6733'	=>	'8.8147760885452808829208115439667224630624'	,
		'6737'	=>	'8.8153700009606598462995598963721561529936'	,	'6761'	=>	'8.8189260870906778930793056583588691505101'	,
		'6763'	=>	'8.8192218575749399501441056530128493054246'	,	'6779'	=>	'8.8215848774309656125894115424167410140986'	,
		'6781'	=>	'8.821879862683842119454908578540050538637'	,	'6791'	=>	'8.8233534851137914007515560097769000654896'	,
		'6793'	=>	'8.8236479491913019301199015944842846178393'	,	'6803'	=>	'8.8251189703450607754622475914125105292259'	,
		'6823'	=>	'8.8280545368154236269265853324124489112988'	,	'6827'	=>	'8.8286406174182803043907327361123026844124'	,
		'6829'	=>	'8.8289335289610892570315264039493158010067'	,	'6833'	=>	'8.8295190947807782887608270900346397858446'	,
		'6841'	=>	'8.830689198760998004355723898354503519707'	,	'6857'	=>	'8.8330253072843644396616871847846933905401'	,
		'6863'	=>	'8.8338999429086346630938397367396757552978'	,	'6869'	=>	'8.8347738142138816080701445102157973236991'	,
		'6871'	=>	'8.8350649350310759634821822629840023643142'	,	'6883'	=>	'8.8368098823983641938280443547427142670071'	,
		'6899'	=>	'8.8391317525461086912094042972135582242362'	,	'6907'	=>	'8.840290669088972907082658496257337709663'	,
		'6911'	=>	'8.8408696240913943329019409107056510649513'	,	'6917'	=>	'8.8417374286005847188376432217453842927412'	,
		'6947'	=>	'8.8460651906928809107496375867870625560437'	,	'6949'	=>	'8.8463530433143273493305040090420491462595'	,
		'6959'	=>	'8.847791064844850052208497330988100597665'	,	'6961'	=>	'8.8480784211686664711913432720092040639842'	,
		'6967'	=>	'8.8489399950301189058233317481362524278211'	,	'6971'	=>	'8.8495139654863987203769831761196369001613'	,
		'6977'	=>	'8.8503743039392365641037004123136562402088'	,	'6983'	=>	'8.8512339028460352941516778647064377491144'	,
		'6991'	=>	'8.8523788865119851597732785941136281319294'	,	'6997'	=>	'8.853236764745896730776429295790293681342'	,
		'7001'	=>	'8.853808274977197580550373072077971127912'	,	'7013'	=>	'8.8555208485369104468357686508159912582021'	,
		'7019'	=>	'8.8563760367304214814285705852558530385196'	,	'7027'	=>	'8.8575151511921977146589834934585978549069'	,
		'7039'	=>	'8.8592213936081316035647660186872493024919'	,	'7043'	=>	'8.8597894947454103471353476222251343115871'	,
		'7057'	=>	'8.8617753110008302428269500654686050747494'	,	'7069'	=>	'8.8634743061709540498821943739652536343766'	,
		'7079'	=>	'8.8648879337741892461493043122029020755226'	,	'7103'	=>	'8.8682725089978099645991660012284827406115'	,
		'7109'	=>	'8.8691168659294831013563512077458575563038'	,	'7121'	=>	'8.8708034439821247588117571977449132280817'	,
		'7127'	=>	'8.8716456675018707195660532497453200104052'	,	'7129'	=>	'8.8719262511176284628631068760518571538933'	,
		'7151'	=>	'8.8750074860483959502448172286223031198791'	,	'7159'	=>	'8.8761255853961850138813020726691562419771'	,
		'7177'	=>	'8.8786367474300718925827734999415629924066'	,	'7187'	=>	'8.8800291174684426181362680340209957106835'	,
		'7193'	=>	'8.8808636098673562172852396453571599485147'	,	'7207'	=>	'8.8828080549244410411835490763813542015048'	,
		'7211'	=>	'8.88336291691675952404940587960374325959'	,	'7213'	=>	'8.8836402325036726303224320939316160567276'	,
		'7219'	=>	'8.8844717181391610140569815633201944899822'	,	'7229'	=>	'8.8858559930002971378544296585287367060662'	,
		'7237'	=>	'8.8869620348661276907856907138387915005098'	,	'7243'	=>	'8.887790764195326053576586713923086398213'	,
		'7247'	=>	'8.8883428691092814174811219911942510219076'	,	'7253'	=>	'8.8891704553634123830127366351715101616725'	,
		'7283'	=>	'8.8932981442179151490656952443618878125622'	,	'7297'	=>	'8.8952185837656201058061028353558020168569'	,
		'7307'	=>	'8.8965880717912178180345651095614899647051'	,	'7309'	=>	'8.896861744480391708307922542714459909884'	,
		'7321'	=>	'8.8985022096466426776832033763972346897862'	,	'7331'	=>	'8.8998672112235865814959884350108786887667'	,
		'7333'	=>	'8.9001399880937995115930717183867809020735'	,	'7349'	=>	'8.9023195285288712333400131743344812557888'	,
		'7351'	=>	'8.9025916373740876329670795964260413296852'	,	'7369'	=>	'8.9050372907669993018550812253223788879046'	,
		'7393'	=>	'8.9082888855571000513248741931077486711642'	,	'7411'	=>	'8.9107206619513588696528834648586301122118'	,
		'7417'	=>	'8.9115299417365580714051828649783064941386'	,	'7433'	=>	'8.9137613470966114692359172211389154706967'	,
		'7451'	=>	'8.9161035305537275044711134615942483443726'	,	'7457'	=>	'8.9169084675437948207430400763526841981197'	,
		'7459'	=>	'8.917176635955163246075338068626776845889'	,	'7477'	=>	'8.9195869209999155427659225579152826449033'	,
		'7481'	=>	'8.9201217518724049157125757269999799183927'	,	'7487'	=>	'8.9209234622306852131263042522187642345348'	,
		'7489'	=>	'8.9211905562493670866735534425404472110997'	,	'7499'	=>	'8.9225249573013893839329598679635267684662'	,
		'7507'	=>	'8.9235911975730023649865974971673099226665'	,	'7517'	=>	'8.924922401177468883468748314221919203468'	,
		'7523'	=>	'8.9257202735602215651446199015363164719731'	,	'7529'	=>	'8.9265175098501222889821067033694842960798'	,
		'7537'	=>	'8.9275795038434698902659095617958754666316'	,	'7541'	=>	'8.9281100782026470202696869033958805226403'	,
		'7547'	=>	'8.928905412284868407840878958361710347098'	,	'7549'	=>	'8.9291703831396248456122135477378892704916'	,
		'7559'	=>	'8.9304941852921767042209118242497655426012'	,	'7561'	=>	'8.9307587355582698885949933649791252590189'	,
		'7573'	=>	'8.9323445691138226784070527174045071627639'	,	'7577'	=>	'8.9328726219313733836579824446515861350512'	,
		'7583'	=>	'8.9336641787009355283081576935293493788728'	,	'7589'	=>	'8.9344551094039128134643544228901932124857'	,
		'7591'	=>	'8.934718614016768208302205072849717006737'	,	'7603'	=>	'8.9362981852284366443924407713079929327912'	,
		'7607'	=>	'8.9368241549973011719613152410389152076381'	,	'7621'	=>	'8.9386628736661174548574929787909674041635'	,
		'7639'	=>	'8.9410219835413597000549454237866037636441'	,	'7643'	=>	'8.9415454752428840886739409753785288487402'	,
		'7649'	=>	'8.942330199321866031769289194312177033001'	,	'7669'	=>	'8.944941507764859244434980481112046031397'	,
		'7673'	=>	'8.9454629521776652355884322692414919943168'	,	'7681'	=>	'8.9465050259986819373204216051956245066569'	,
		'7687'	=>	'8.9472858693491319849353458472690774856707'	,	'7691'	=>	'8.9478060930570538085389020016753837854347'	,
		'7699'	=>	'8.9488457292780495592459367909023712000621'	,	'7703'	=>	'8.9493651423529658013435360427989932695195'	,
		'7717'	=>	'8.9511809664576030470096309966131490138285'	,	'7723'	=>	'8.9519581685692638706034722206060420233899'	,
		'7727'	=>	'8.9524759679335838783916965736064199872333'	,	'7741'	=>	'8.9542861572047134174077310314859459580459'	,
		'7753'	=>	'8.9558351442189590188473386375492253658808'	,	'7757'	=>	'8.9563509404908715824810900471850630573772'	,
		'7759'	=>	'8.9566087388939492660884585327366211900923'	,	'7789'	=>	'8.9604677609199485267422512777758311652154'	,
		'7793'	=>	'8.96098117384356093546061098207929541506'	,	'7817'	=>	'8.9640561282203304240333723499905511215777'	,
		'7823'	=>	'8.9648233916850806298239410941263968896979'	,	'7829'	=>	'8.9655900669079141904902193759481329111489'	,
		'7841'	=>	'8.9671216562309219457730615640715366739232'	,	'7853'	=>	'8.9686509033748746329320867219867073202793'	,
		'7867'	=>	'8.9704320743292424999064908293150223645339'	,	'7873'	=>	'8.9711944631844671988226422919295489099922'	,
		'7877'	=>	'8.9717023997033243207730886685536722138133'	,	'7879'	=>	'8.971956271245688092456953622569471455395'	,
		'7883'	=>	'8.9724638210599082342667442284909489858585'	,	'7901'	=>	'8.9747446127227332770056645908358424980569'	,
		'7907'	=>	'8.9755037220709270394664955312114582333425'	,	'7919'	=>	'8.9770202142104124837952919519523412208348'	,
		'7927'	=>	'8.9780299328371558628073205551570208037149'	,	'7933'	=>	'8.9787865533020029323132018623982937605586'	,
		'7937'	=>	'8.9792906490908755457676392731266413351089'	,	'7949'	=>	'8.9808014135731126393048308764269300150021'	,
		'7951'	=>	'8.9810529859014834702552535948810696232419'	,	'7963'	=>	'8.9825610922574448495033805450824793304003'	,
		'7993'	=>	'8.9863214376260190405722053402193303901453'	,	'8009'	=>	'8.9883211883236822637144530242996541871589'	,
		'8011'	=>	'8.9885708762151168047686404462334112668353'	,	'8017'	=>	'8.9893195660429516221548797285576222173861'	,
		'8039'	=>	'8.9920599763279608293552470937055155055557'	,	'8053'	=>	'8.9937999717955448984805696357241756863673'	,
		'8059'	=>	'8.9945447583245113190740104552588661863092'	,	'8069'	=>	'8.99578483784850656403294346665564028348'	,
		'8081'	=>	'8.997270906233447636904471137937257397757'	,	'8087'	=>	'8.9980131130958221434295924642886740720974'	,
		'8089'	=>	'8.9982603930179526116093347521713764593206'	,	'8093'	=>	'8.9987547694957018844951003618807673626088'	,
		'8101'	=>	'8.9997427898304912440171471411771040230356'	,	'8111'	=>	'9.0009764440703447213698619739310344125665'	,
		'8117'	=>	'9.0017159067611756966069659569827766010469'	,	'8123'	=>	'9.0024548230509538541396610051758166150761'	,
		'8147'	=>	'9.0054050403106417746716293872572059593569'	,	'8161'	=>	'9.0071219894692428677688922174388071385367'	,
		'8167'	=>	'9.0078569233582756835691493350376361893752'	,	'8171'	=>	'9.0083465793847074387110610568280170026085'	,
		'8179'	=>	'9.0093251727349740996612259848314786317258'	,	'8191'	=>	'9.0107912695156020401824347081659834094289'	,
		'8209'	=>	'9.0129863923482661615557353179607970443209'	,	'8219'	=>	'9.0142038261485000124342426434491041300185'	,
		'8221'	=>	'9.0144471351521334120934208360692757385761'	,	'8231'	=>	'9.0156627929726439782018076503047484394634'	,
		'8233'	=>	'9.0159057472984260239654563997571462741722'	,	'8237'	=>	'9.0163914789412487411446305952283110501295'	,
		'8243'	=>	'9.0171196343132275179077476504729677513859'	,	'8263'	=>	'9.0195429967011843595727508755320429980159'	,
		'8269'	=>	'9.0202688617221666983133135241935850222619'	,	'8273'	=>	'9.0207524791901828936326495907191886681433'	,
		'8287'	=>	'9.0224433008490424794004202842380842856541'	,	'8291'	=>	'9.0229258681162187035708514976374621976613'	,
		'8293'	=>	'9.0231670644512037428045266955692375058463'	,	'8297'	=>	'9.0236492826642852941055658862710268763608'	,
		'8311'	=>	'9.0253352175530263466296121436713823160967'	,	'8317'	=>	'9.0260568918686875093289279769703352935064'	,
		'8329'	=>	'9.0274986799353404898795372492965258132231'	,	'8353'	=>	'9.0303760347559062783994423152360932419628'	,
		'8363'	=>	'9.0315724933815257655839199899767763445951'	,	'8369'	=>	'9.0322896820328740537271991647228434983708'	,
		'8377'	=>	'9.0332451341538095003222556748247127567657'	,	'8387'	=>	'9.034438166984411514671447471970162866841'	,
		'8389'	=>	'9.0346766028462945948689132718250532249187'	,	'8419'	=>	'9.0382463353376639884739122187130620421671'	,
		'8423'	=>	'9.038721338315363700621128620341076311741'	,	'8429'	=>	'9.0394334199974821623896717359326969646281'	,
		'8431'	=>	'9.0396706679226756494983275578806716076692'	,	'8443'	=>	'9.0410929746694999251716682435236328045655'	,
		'8447'	=>	'9.0415666277274966576962703679320483161424'	,	'8461'	=>	'9.0432226489245008875887395122093057283085'	,
		'8467'	=>	'9.0439315336422772072300486477492328167719'	,	'8501'	=>	'9.0479390826173588571616060233900496161147'	,
		'8513'	=>	'9.0493496858840570480668729125942923665888'	,	'8521'	=>	'9.0502889838279559650907922571888859198454'	,
		'8527'	=>	'9.0509928787420495858084945836044212604741'	,	'8537'	=>	'9.0521649370103063986637606463078831452213'	,
		'8539'	=>	'9.0523991839076061489730520145263711822372'	,	'8543'	=>	'9.052867513151618648680172258329321005776'	,
		'8563'	=>	'9.055205875026192045568793635758653251956'	,	'8573'	=>	'9.056373008678755939517265947783002301299'	,
		'8581'	=>	'9.0573057358071209376419870204370085978808'	,	'8597'	=>	'9.0591685841744440779273501643915602609625'	,
		'8599'	=>	'9.0594011964108965174966029023416099393186'	,	'8609'	=>	'9.0605634466579546306198092554011072087336'	,
		'8623'	=>	'9.0621883309523244460282456693348291727001'	,	'8627'	=>	'9.0626520990765787792573620481966116800065'	,
		'8629'	=>	'9.0628839025083075080263524502605944974228'	,	'8641'	=>	'9.0642735958413992854296858996818397364405'	,
		'8647'	=>	'9.0649677189604302259956435838933003966787'	,	'8663'	=>	'9.0668163618901402952294799536528210182748'	,
		'8669'	=>	'9.067508722868640394509412370040374588683'	,	'8677'	=>	'9.0684311257934897079884434122857836075905'	,
		'8681'	=>	'9.0688920083918079769395749727468384030255'	,	'8689'	=>	'9.069813136839205989191142945717828687127'	,
		'8693'	=>	'9.070273383079064333093106755551951603368'	,	'8699'	=>	'9.0709633555075407560623111569659845617657'	,
		'8707'	=>	'9.0718825788286155963172611566641828623374'	,	'8713'	=>	'9.0725714422312868238595550171282317292755'	,
		'8719'	=>	'9.0732598314278150295820222845275152811168'	,	'8731'	=>	'9.0746351898108076510183047891300683334654'	,
		'8737'	=>	'9.0753221602980946012525232947832058546163'	,	'8741'	=>	'9.0757798785804879347882275011812380842264'	,
		'8747'	=>	'9.0764660634198549081460779954843305292572'	,	'8753'	=>	'9.0771517777324380004201601442513683969848'	,
		'8761'	=>	'9.0780653326663638201979688879139865502862'	,	'8779'	=>	'9.0801177849262087432050656872390247175462'	,
		'8783'	=>	'9.0805733139171173967692233739819313835659'	,	'8803'	=>	'9.0828478514609061287180969340225034579053'	,
		'8807'	=>	'9.0833021388054594881998870172521625515588'	,	'8819'	=>	'9.0846637638881807872587516391480778891991'	,
		'8821'	=>	'9.0848905212587669343689383018708336738526'	,	'8831'	=>	'9.086023537468802218825549268532297802489'	,
		'8837'	=>	'9.0867027315180044235417021262082291100077'	,	'8839'	=>	'9.0869290270609479566320016142650217322864'	,
		'8849'	=>	'9.0880597372673501825873784867604171295361'	,	'8861'	=>	'9.0894149040473024067856039205072418576845'	,
		'8863'	=>	'9.0896405867383979585236783694893459772382'	,	'8867'	=>	'9.0900917993800070146341122250263544862819'	,
		'8887'	=>	'9.0923448137384752039664333174121381383371'	,	'8893'	=>	'9.0930197293996400603346797622879245185885'	,
		'8923'	=>	'9.0963874919001514309850931746187622979133'	,	'8929'	=>	'9.0970596855172164240066144575855513630512'	,
		'8933'	=>	'9.097507563701839081700424374393241100289'	,	'8941'	=>	'9.0984027187353180659428123809389355827692'	,
		'8951'	=>	'9.0995205368709389540773042833284874438731'	,	'8963'	=>	'9.100860271357361689414654691475381531974'	,
		'8969'	=>	'9.1015294661180030916189542743945727412497'	,	'8971'	=>	'9.1017524315592835373262042409901694095345'	,
		'8999'	=>	'9.1048687390339485320823517027005562925335'	,	'9001'	=>	'9.1050909612570852490530031955882823657023'	,
		'9007'	=>	'9.1057573317837428276575991210157296709798'	,	'9011'	=>	'9.1062013322350373257558714156107928420188'	,
		'9013'	=>	'9.1064232585564097790048261655152680770343'	,	'9029'	=>	'9.1081968983074791802743763677068492351426'	,
		'9041'	=>	'9.1095250667373664327686460601684546330719'	,	'9043'	=>	'9.1097462567404801431837007850492720242841'	,
		'9049'	=>	'9.1104095333511332417363061395749143839567'	,	'9059'	=>	'9.1115140176692877944429655295242153054136'	,
		'9067'	=>	'9.1123967276460561119954840575522544207144'	,	'9091'	=>	'9.115040192121858209358847048789858406279'	,
		'9103'	=>	'9.1163593085052887889533318219334255405961'	,	'9109'	=>	'9.1170182147448098426178514557792584842248'	,
		'9127'	=>	'9.1189923325168773011938790572313526077765'	,	'9133'	=>	'9.1196495066916789382649398851275962672737'	,
		'9137'	=>	'9.1200873829986205788257185908601674111078'	,	'9151'	=>	'9.1216184419153781831746105547678582315369'	,
		'9157'	=>	'9.1222738931077321411428242489318936624953'	,	'9161'	=>	'9.1227106220152086537904683101148191788895'	,
		'9173'	=>	'9.1240196655096555635116045121025808194328'	,	'9181'	=>	'9.1248914101437000004997382935970968466408'	,
		'9187'	=>	'9.1255447202714664486707989028406678449528'	,	'9199'	=>	'9.1268500614771572585136716648877495722045'	,
		'9203'	=>	'9.1272847968388568866018066141309321273172'	,	'9209'	=>	'9.1279365457213670214511416587821704966599'	,
		'9221'	=>	'9.1292387705391412404526320588272434922436'	,	'9227'	=>	'9.1298892475785558315097506567791431610979'	,
		'9239'	=>	'9.1311889336707451405831409773637489855265'	,	'9241'	=>	'9.1314053838880404273170982954541543500315'	,
		'9257'	=>	'9.1331353010672112634475829400445063231752'	,	'9277'	=>	'9.1352934976532715027366654489099237203464'	,
		'9281'	=>	'9.1357245785953928081246253922740292549143'	,	'9283'	=>	'9.1359400493999325565188845495187854225917'	,
		'9293'	=>	'9.1370167075573393148374184341639739296066'	,	'9311'	=>	'9.1389517758885297920503241006561873182935'	,
		'9319'	=>	'9.1398106057856554877475612527358500561661'	,	'9323'	=>	'9.1402397442966936403453080983545644436775'	,
		'9337'	=>	'9.1417402804839258903075190541246900368252'	,	'9341'	=>	'9.1421685918728487102140077136091703384102'	,
		'9343'	=>	'9.1423826787929556325241100534271228922326'	,	'9349'	=>	'9.1430246646913156737643239739068491120199'	,
		'9371'	=>	'9.1453750931238236222041481060666668922187'	,	'9377'	=>	'9.1460151614196251701288814891821255379616'	,
		'9391'	=>	'9.147507062804613583380867844554686155935'	,	'9397'	=>	'9.1481457683830649785890476315587423380193'	,
		'9403'	=>	'9.1487840662770769040535946844585051194113'	,	'9413'	=>	'9.1498469915472202314199097476400696727516'	,
		'9419'	=>	'9.150484204822817127970945653020910350356'	,	'9421'	=>	'9.1506965190486677530676315013344653802165'	,
		'9431'	=>	'9.1517574145438848149761274608153033843815'	,	'9433'	=>	'9.1519694586498531974832351183024031032119'	,
		'9437'	=>	'9.1523934120213330229787550261451673654202'	,	'9439'	=>	'9.1526053213249444087406299642081306442371'	,
		'9461'	=>	'9.1549333647044442387215042486819905901669'	,	'9463'	=>	'9.1551447365082326914693996087303306268687'	,
		'9467'	=>	'9.1555673461288912190602261107650008201966'	,	'9473'	=>	'9.1562009258755344763290147271911454300498'	,
		'9479'	=>	'9.1568341044530416053040605933999843730287'	,	'9491'	=>	'9.1580992601304921952340323753741146159066'	,
		'9497'	=>	'9.1587312382429525034271159074215532726672'	,	'9511'	=>	'9.1602043024823855005010488275174094964527'	,
		'9521'	=>	'9.161255164285691380888664271383969220062'	,	'9533'	=>	'9.1625147424935781469043632336546189088959'	,
		'9539'	=>	'9.1631439371452080707208275265208176186392'	,	'9547'	=>	'9.1639822479980331835597709313847255309988'	,
		'9551'	=>	'9.1644011400347375692860662948253702096049'	,	'9587'	=>	'9.1681632930769965852379223907266657058176'	,
		'9601'	=>	'9.1696225386976237817536588015877135308503'	,	'9613'	=>	'9.170871628065816163262931467634198692982'	,
		'9619'	=>	'9.1714955881526155698453188940018964074366'	,	'9623'	=>	'9.1719113453564008330543188417329219204903'	,
		'9629'	=>	'9.1725346572402839466048148563554621473626'	,	'9631'	=>	'9.1727423415608642992698185846928564525736'	,
		'9643'	=>	'9.1739875425103844159676482532298103831242'	,	'9649'	=>	'9.1746095620203838078567689652092679046852'	,
		'9661'	=>	'9.1758524415175095877226193508055612648213'	,	'9677'	=>	'9.1775072148809425189954829342457507831689'	,
		'9679'	=>	'9.1777138691490885888878951245972118246707'	,	'9689'	=>	'9.1787465003850041240005851795985916296266'	,
		'9697'	=>	'9.1795718383045462453734398110090456662847'	,	'9719'	=>	'9.1818380115034705999875187518659619243415'	,
		'9721'	=>	'9.1820437728210689833858374777395411525545'	,	'9733'	=>	'9.1832774524264936086797976732278178420394'	,
		'9739'	=>	'9.1838937219611992443105657922552586362225'	,	'9743'	=>	'9.1843043574253412380804464993352787456039'	,
		'9749'	=>	'9.184919994629271525607071267297513986175'	,	'9767'	=>	'9.1867646354474770321479305611786800602483'	,
		'9769'	=>	'9.1869693856529425427712051484588652041167'	,	'9781'	=>	'9.188197007290492910763867518517479839717'	,
		'9787'	=>	'9.1888102534258195062327887507377175404213'	,	'9791'	=>	'9.1892188753540713494508087855370572420244'	,
		'9803'	=>	'9.1904437402617261421924114954866615336392'	,	'9811'	=>	'9.191259484163390810675669377159147263014'	,
		'9817'	=>	'9.1918708556925213967925945245178921876805'	,	'9829'	=>	'9.1930924785666293484799282479332664616562'	,
		'9833'	=>	'9.1934993547801562278301876423194739682227'	,	'9839'	=>	'9.1941093588657654684845320826719425518064'	,
		'9851'	=>	'9.1953282518556791387813603111344282428643'	,	'9857'	=>	'9.1959371416654389722570290609348306672188'	,
		'9859'	=>	'9.1961400225750413368923987468182695649971'	,	'9871'	=>	'9.1973564444178879728035413527136007979645'	,
		'9883'	=>	'9.1985713883761838911477536930020322043769'	,	'9887'	=>	'9.1989760418971329544277942638327865984742'	,
		'9901'	=>	'9.2003910411225146535570835445267294218823'	,	'9907'	=>	'9.200996856973030245362967838387811325028'	,
		'9923'	=>	'9.2026105739142415082080163292569051321956'	,	'9929'	=>	'9.2032150470335941049133720525518510761791'	,
		'9931'	=>	'9.2034164569033585549907655764848843098642'	,	'9941'	=>	'9.2044228982121451299816891757338480154716'	,
		'9949'	=>	'9.205227322589359714977709299640582793177'	,	'9967'	=>	'9.2070349149674562244307062360997501542917'	,
	} ;

	my $r = ( defined $pln->{ $n } ) ? __PACKAGE__->new( $pln->{ $n } ) : undef ;

	return $r ;
}

#-------------------------------------------------------------------------------
#
# 素数判定
#
#-------------------------------------------------------------------------------

=head2 is_prime

  print decimal( 2 )->is_prime() ;        # 1
  print decimal( 10 )->is_prime() ;       # 0
  print decimal( 9973 )->is_prime() ;     # 1

=cut

sub is_prime {
	#-----------------------------------------------------------------------
	#
	# 素数判定
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	#
	# 単純に判定が可能なもの。
	#
	return 0	if ( $n < 2 ) ;
	return 1	if ( $n < 7 and $n->value() =~ /^[235]$/ ) ;		# 2 , 3 , 5 は素数。
	return 0	if ( $n->{'val'}->[0] =~ /[05]$/ ) ;			# 5 の倍数は合成数。

	return 0	if ( $n->modulus( 6 )->value() !~ /^[15]$/ ) ;		# 6 の倍数の前後でなければ合成数。

	#
	# レピュニット素数を検査 ( レピュニットは 1 の羅列でできている数値 )
	#
	if ( $n->value() =~ /^1+$/ ) {
		foreach ( length( $n ) ) {
			/^(?:2|19|23|317|1031)$/		&& do { return 1 ; } ;
			/^(?:49081|86453|109297|270343)$/	&& do { return 1 ; } ;	# PRP ( probable prime )
		}
	}

	#
	# 階乗素数および交互階乗素数
	#
	return 1	if ( $n == ( $n->factorial_primes() )[-1] ) ;

	#
	# メルセンヌ素数
	#
	return 1	if ( lucas_lehmer( $n ) ) ;
	
	#
	# ミラー・ラビン法
	#
	return 1	if ( miller_rabin( $n ) ) ;
	
	return 0 ;
}

sub is_twin_prime {
	#-----------------------------------------------------------------------
	#
	# 双子素数の判定
	#
	#   二つの正の整数 p , p + 2 が双子素数であるための必要十分条件は、
	#
	#     4 * ( ( p - 1 )! + 1 ) + p ≡ 0 ( mod p( p + 2 ) )
	#
	#   階乗計算が必要なため、それなりのコストがかかる。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return 0	if ( $n < 2 ) ;
	return 1	if ( $n =~ /^[35]$/ ) ;

	my $m = $n % 6 ;
	return 0	unless ( $m =~ /^[15]$/ ) ;

	my @p = ( $m == 1 )
		? ( $n - 2 , $n     )	# n == 6k + 1
		: ( $n     , $n + 2 )	# n == 6k - 1
	;

	foreach ( @p ) {
		return 0	if ( $_ > 5 and  $_->{'val'}->[0] =~ /[05]$/ ) ;
	}

	#
	# 法
	#
	$m = $p[0] * $p[1] ;	# m == p * ( p + 2 )

	#
	# 階乗数
	#
	#   f == ( p - 1 )! % m 
	#
	my $f = $p[0]->add( '-1' )->modfactorial( $m ) ;

	#
	# 判定
	#
	my $r = ( ( $f + 1 ) * 4 + $p[0] ) % $m ;

	return ( $r == 0 ) ? 1 : 0 ;
}

sub fermat_test {
	#-----------------------------------------------------------------------
	#
	# フェルマーテスト
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return 0	if ( $n <  2 ) ;
	return 1	if ( $n == 2 ) ;
	return 1	if ( $n == 3 ) ;

	my $x = $n->add( '-2' )->random() + 2 ;	# 2 <= $x < $n

	return 0	unless ( gcd( $x , $n ) == 1 ) ;
	return 0	unless ( ( ( $x ** ( $n - 1 ) ) % $n ) == 1 ) ;
	return 1 ;
}

sub willson_prime_test {
	#-----------------------------------------------------------------------
	#
	# ウィルソンの定理による素数判定
	#
	#   階乗を使用した素数判定法
	#
	#   任意の素数 $p について、
	#
	#     ( $p - 1 )! ≡ -1 ( mod $p )
	#
	#   が成立し、 $p > 1 において上記合同式が成立するならば $p は素数。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return 0	if ( $n < 2 ) ;

	my $m = __PACKAGE__->new( 1 ) ;
	foreach ( my $i = __PACKAGE__->new( 2 ) ; $i < $n ; $i++ ) {
		$m *= $i ;
		$m %= $n ;
		last	if ( $m->is_zero() ) ;
	}

	return ( $m == ( $n - 1 ) ) ? 1 : 0 ;
}

sub factorial_prime_test {
	#-----------------------------------------------------------------------
	#
	# ウィルソンの定理による素数判定の応用
	#
	#   ウィルソンの定理は、任意の素数 $p について、
	#
	#     ( $p - 1 )! ≡ -1 ( mod $p )
	#
	#   が成立し、 $p > 1 において上記合同式が成立すれば $p は素数であると言うもの。
	#
	#   $p が合成数と考えると、 ( $p - 1 ) 以下の正の整数の中に 2 つ以上の因数が存在することになる。
	#   したがって、 ( $p - 1 )! を計算する過程で $p 自身若しくはその公倍数が現われれば $p は合成数ということになる。
	#   また、これらの因数は ( $p / 2 ) を境にしてその両側に少なくとも 1 つ存在するはず。
	#
	#   これは、法 $p の下で ( $p - 1 )! を計算すると、その過程で 0 が現われることを意味している。
	#   それ以降の演算結果は全て 0 となる。
	#   言い換えると、法 $p の下で ( $p - 1 )! を計算すると、演算結果は 0 若しくは ( $p - 1 ) の何れかになると言うことでもある。
	#
	#   2 以外の素数が全て奇数であること、 6n+1 や 6n-1 型以外の奇数が 6n+3 と 6n-3 ( 何れも 3 の倍数 ) のみであることから、
	#   $p が 2 や 3 の倍数でないことを確認した後、 6n+1 及び 6n-1 型の奇数値の総積を法 $p の下で評価するのが効率的かもしれない。
	#   ( $p が 6n-1 型の合成数であれば、その因数には 6n-1 型の素数が 1 つ以上含まれる。 )
	#
	#   理想を言えば、ランダム且つユニークに 6n+1 や 6n-1 となる $p より小さい奇数値を効率的に取り出すような乱数生成器が欲しいところ。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return 0	if ( $n < 2 ) ;
	return 1	if ( $n->value() =~ /^[23]$/ ) ;
	return 0	if ( $n->is_even() ) ;			# 6m+0 , 6m+2 , 6m+4
	return 0	if ( $n->modulus( 3 )->is_zero() ) ;	# 6m+3

	my $mid = $n->divide( 2 )->integer() ;
	my $m = $n - 1 ;
	foreach ( my $i = __PACKAGE__->new( 2 ) ; $i < $n ; $i++ ) {
		$m *= $i * ( $n - $i ) ;
		$m %= $n ;
		last	if ( $m->is_zero() ) ;
	}

	return ( $m == ( $n - 1 ) ) ? 1 : 0 ;
}

sub leibniz_prime_test {
	#-----------------------------------------------------------------------
	#
	# ライプニッツの定理による素数判定
	#
	#   内容はウィルソンの定理と同じ。
	#
	#   任意の素数 $p について、
	#
	#     ( $p - 2 )! ≡ 1 ( mod $p )
	#
	#   が成立する。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;

	my $m = __PACKAGE__->new( 1 ) ;
	foreach ( my $i = __PACKAGE__->new( 2 ) ; $i < ( $n - 1 ) ; $i++ ) {
		$m *= $i ;
		$m %= $n ;
		last	if ( $m->is_zaro() ) ;
	}

	return ( $m == 1 ) ? 1 : 0 ;
}

sub miller_rabin {
	#-----------------------------------------------------------------------
	#
	# ミラーラビン素数判定法 ( Miller-Rabin primality test )
	#
	#
	#   $n が任意の奇素数である場合、
	#   $k == ( $n - 1 ) である $k と 任意の正の整数 $a において、
	#
	#      sqrt( $a ** $k ) ≡ 1 or -1 ( mod $n )
	#
	#   となる事を利用している。
	#
	#   フェルマーの小定理より、$n と $a との間には以下の関係がある。
	#
	#      $a ** ( $n - 1 ) ≡ 1 ( mod $n )
	#
	#   $k == ( $n - 1 ) より、
	#
	#      $a ** $k ≡ 1 ( mod $n )
	#
	#   となる。
	#
	#   $n が奇数であることから $k は偶数であり、 $a ** $k は平方根を持つ。
	#   ここで sqrt( $a ** $k ) == $A とおくと、
	#
	#     $a ** $k == $A ** 2 ≡ 1 ( mod $n )
	#     -> ( $A ** 2 ) - 1 ≡ 0 ( mod $n )
	#     -> ( $A + 1 ) * ( $A - 1 ) ≡ 0 ( mod $n )
	#
	#   であり、 ( $A + 1 ) と ( $A - 1 ) の何れかが $n で割り切れる数ということになる。
	#   よって、 $A ≡ 1 or -1 ( mod $n ) となる。
	#
	#   一方、 $k は偶数なので、
	#
	#     $k == ( 2 ** $s ) * $d
	#
	#   とおくことができる。 ( $s は正の整数で $d は奇数。 )
	#
	#   $s > 0 なので $k は常に 2 の冪であり、
	#
	#     sqrt( $a ** $k ) == $a ** ( ( 2 ** ( $s - 1 ) ) * $d ) ≡ 1 or -1 ( mod $n )
	#
	#   仮に $s == 0 であれば ( $a ** $k ) は平方根を持たない ( 整数の平方根を持つ整数は全て平方数である ) ので、
	#
	#     $a ** ( ( 2 ** 0 ) * $d ) == $a ** $d ≡ 1 ( mod $n )
	#
	#   ただし、合同式の左辺が $n 以下の時には、剰余は左辺そのものか 0 になるのでこれらは成り立たない。
	#   また、 $a が平方数で $d == 1 の時には $a ** $d ≡ -1 ( mod $n ) もあり得る。
	#
	#   これを整理すると、
	#   任意の正の整数 $a と ( $n - 1 ) == ( 2 ** $s ) * $d となる $s , $d 及び 0 <= $r < $s となる $r を用いて、
	#
	#     $a ** ( 2 ** $r * $d ) ≡ 1 or -1 ( mod $n )
	#
	#   が成り立つ $r が存在すれば $a と $n は互いに素と言うことになる。
	#
	#   ちなみに、 $a ** ( 2 ** $r * $d ) == $A とおいた時、 $A ≡ 1 or -1 ( mod $n ) であれば、
	#
	#     $a ** ( 2 ** ( $r + 1 ) * $d ) == $A ** 2
	#     ( $A ** 2 ) % $n == ( ( $A % $n ) * ( $A % $n ) ) % $n == 1
	#
	#   よって、
	#
	#     $a ** ( 2 ** ( $r + 1 ) * $d ) == $A ** 2 ≡ 1 ( mod $n )
	#
	#   となり、これ以降 $r がいくら増えても 1 が返ることになる。
	#
	#   つまり、 0 <= $r < $s の何れかの $r によって $a ** ( 2 ** $r * $d ) ≡ 1 or -1 ( mod $n ) が成り立てば、
	#   $a ** ( $n - 1 ) ≡ 1 ( mod $n ) であることの証となるということ。
	#
	#   以上の手法によって、任意の $a について $a と $n が互いに素であるかどうかを検証できるようになったので、
	#   これを複数の $a に対して試した結果、常にこれが成り立つならば $n を素数とみなせるということになる。
	#
	#
	#   素数の性質から言って、 $a には $a < $n となる正の整数を用いればよい。
	#   単一の $a に対する試行回数は $r に依存し、最大でも $n のビット幅程度の回数となる。
	#
	#   擬素数を誤って素数と判定してしまう確立は、サンプルとして使用する $a の個数に依存するとされており、
	#   この個数を $k とすると、およそ 4 ** ( -1 * $k ) 程度の頻度とされている。
	#   $k == 20 とすると、10**(-12) 程度の確立となる。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;
	return 1	if ( $n == 2 ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	#
	# Gerhard Jaeschke による決定的素数判定のための係数。
	#
	my @k = () ;
	if	( $n <       '4_759_123_141' )	{ @k = ( 2 , 7 , 61 ) ;				} # 32 ビット強 ( 5 の冪を誤判定することがある。)
	elsif	( $n <   '2_152_302_898_747' )	{ @k = ( 2 , 3 , 5 , 7 , 11 ) ;			} # 40 ビット強
	elsif	( $n <   '3_474_749_660_383' )	{ @k = ( 2 , 3 , 5 , 7 , 11 , 13 ) ;		} # 41 ビット強
	elsif	( $n < '341_550_071_728_321' )	{ @k = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 ) ;	} # 48 ビット強
	else {
		@k = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 ) ;
		while ( @k < 20 ) {
			my $x = int( rand( $n - ( $k[-1] + 1 ) ) ) + ( $k[-1] + 1 ) ;
			push( @k , $x ) ;
		}
	}
	foreach my $i ( 0 .. $#k ) {
		#
		# $k[ $i ] < $n とする。
		# 条件に合致しない値についてはランダムな値を使用する。
		#

		$k[ $i ] = __PACKAGE__->new( $k[ $i ] ) ;

		if ( $k[ $i ] >= $n )	{
			$k[ $i ] = $n->subtract( 3 )->random() + 2 ;
		}
	}

	#
	# ( $n - 1 ) == ( 2 ** $s ) * $d に分解
	#
	my( $s , $d ) = ( __PACKAGE__->new( 0 ) , $n->add( '-1' ) ) ;
	{
		while ( $d->is_even() ) { $s++ ; $d = $d->divide( 2 , 0 ) ; }
	}

	#
	# テスト
	#
	my $r = $s - 1 ;
	foreach my $x ( @k ) {

		my $ispp = 0 ;

		#
		# $x ** ( 2 ** $r * $d ) ≡ 1 or -1 ( mod $n )
		#
		# を検証する。
		#
		# $y の初期値に
		#
		#    $y == ( $x ** ( 2 ** 0 * $d ) ) % $n
		#       == ( $x ** $d ) % $n
		#
		# を与えると、
		#
		# $x ** ( 2 ** $r * $d )
		#    == ( $x ** $d ) ** ( 2 ** $r )
		#    == $y ** ( 2 ** $r )
		#    == ( $y ** 2 ) ** $r
		#
		# であり、 1 <= $r <= $s - 1 の範囲の $r についての剰余演算は、
		#
		#   $y = ( $y ** 2 ) % $n
		#
		# を $r 回繰り返すことに等しく、演算に要するコストも低い。
		#
		# 全ての試行において「一度でも合成数とみなされたものが合成数である」ことの対偶を持って素数判定を行う。
		# よって、素数 ( の可能性がある ) とみなされている間は残りの試行を継続しなければならない。
		#
		my $y = $x->modexp( $d , $n ) ;
		if ( $y == 1 or $y == ( $n - 1 ) ) { $ispp = 1 ; }
		else {
			return 0	if ( $y == 0 ) ;
			foreach ( 1 .. $r ) {
				$y = $y->modexp( 2 , $n ) ;
				if ( $y == 1 or $y == ( $n - 1 ) ) { $ispp = 1 ; last ; }
			}
		}
		return 0	if ( $ispp == 0 ) ;
	}

	return 1 ;
}

sub lucas_lehmer {
	#-----------------------------------------------------------------------
	#
	# リュカ - レーマー・テスト ( Lucas-Lehmer prime test )
	#
	#   メルセンヌ数に特化した素数判定法
	#
	#   以下の条件の下で、
	#
	#     $n == M( $p ) == 2 ** $p - 1
	#     S( 0 ) == 4
	#     S( $x ) == S( $x - 1 ) ** 2 - 2        ( $x >= 1 )
	#
	#   以下が成り立てば $n は素数
	#
	#     S( $x - 2 ) ≡ 0 ( mod M( $p ) )
	#
	#   ただし、 $p は奇素数。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	#
	# $n がメルセンヌ数でなければ undef を返す。
	#
	my $p = $n->mersenne_power() ;
	return undef	unless ( defined $p ) ;

	return 0	unless ( $p->is_prime() ) ;	# 2 以上の偶数はこれによって篩い落とされる。
	return 1	if ( $p == 2 ) ;		# $p == 2 -> $n == 3 はリュカ - レーマー・テストのの対象外だが、明らかに素数。

	if ( $p->modulus( 4 ) == 3 ) {
		#
		# $p が素数であり、 $q == 2 * $p + 1 もまた素数である時、
		# $p をソフィー・ジェルマン素数 ( Sophie Germain prime )
		# $q を安全素数 ( safe prime ) と呼ぶ。
		#
		# ソフィー・ジェルマン素数 $p は、 $p > 3 において $p ≡ 5 ( mod 6 ) の形を採る。 ( 6n-1 型の素数 )
		# また、 $p != 2 且つ $p != 5 の時、 $p の一の位は 1 , 3 , 9 の何れかとなる。
		#
		# メルセンヌ数 $m == 2 ** $p - 1 となる $p がソフィー・ジェルマン素数であり、
		# 且つ $p ≡ 3 ( mod 4 ) であれば、 安全素数 $q が $m の約数となる。
		#
		# ここでは、 $q が安全素数かどうかは無視し、これがメルセンヌ数の約数と成り得る可能性のみを検査する。
		#
		my $q = $p * 2 + 1 ;
		return 0	if ( $n > $q and $n->modulus( $q )->is_zero() ) ;
	}

	#
	# リュカ - レーマー・テスト
	#
	my $s = __PACKAGE__->new( 4 ) ;
	my $two_mod_n = __PACKAGE__->new( 2 )->modulus( $n ) ;
	foreach ( 1 .. ( $p - 2 ) ) {
		#
		# $s = ( modexp( $s , 2 , $n ) - ( 2 % $n ) ) % $n ;
		#
		$s = $s->modexp( 2 , $n )->subtract( $two_mod_n )->modulus( $n ) ;
	}

	return ( $s == 0 ) ? 1 : 0 ;
}

#-------------------------------------------------------------------------------
#
# 因数分解
#
#-------------------------------------------------------------------------------

=head2 prime_factor

Try prime factorization and return it's result.

If the prime factorization is succeeded, return following variables.

  @r = $n->prime_factor() ;

  @r == (
      { 'factor' => $f[0] , 'power' => $p[0] } ,
      { 'factor' => $f[1] , 'power' => $p[1] } ,
      ........................................ ,
      { 'factor' => $f[n] , 'power' => $p[n] } ,
   ) ;

   -> $n == ( $r[0]->{'factor'} ** $r[0]->{'power'} )
          + ( $r[1]->{'factor'} ** $r[1]->{'power'} )
          + ( ..................................... )
          + ( $r[n]->{'factor'} ** $r[n]->{'power'} )
      ;

=cut

sub prime_factor {
	#-----------------------------------------------------------------------
	#
	# 素因数分解
	#
	#   素因数を示すオブジェクトとその乗数を無名ハッシュに格納した配列を返す。
	#
	#   return (
	#   	{ 'factor' => f , 'power' => p }
	#   	..........
	#   ) ;
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return ( { 'factor' => $n->copy() , 'power' => 1 } )	if ( $n->is_prime() ) ;

	my $pf = {} ;

	if ( $n < 0 ) {
		$pf->{'-1'} = { 'factor' => __PACKAGE__->new( '-1' ) , 'power' => 1 } ;
		$n *= ( -1 ) ;
	}

	#
	# エラトステネスの篩を利用した試し割り。
	#
	foreach my $p ( decimal( 10000 )->primes() ) {
		while ( $n >= $p and $n->modulus( $p )->is_zero() ) {
			if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'}++ ; }
			else				{ $pf->{ $p } = { 'factor' => $p , 'power' => 1 } ; }
			$n = $n->divide( $p , 0 ) ;
		}
	}

	#
	# 素数階乗を使用した試行。
	#
	while ( $n > 1 ) {
		#
		# $n が合成数であれば、 2 <= $f <= sqrt( $n ) の範囲に 1 つ以上の素因数 $f が存在するはず。
		# これは、
		#
		#   $p <= sqrt( $n )
		#
		# となる素数 $p によって生成される素数階乗と $n の間に公約数が存在することを意味する。
		#
		# $p < 10000 程度の素数 $p は、エラトステネスの篩を利用して容易にリストすることができるため、
		# ここでは、 2 <= $p < 10000 の範囲の素因数を探索する。
		#
		# p#+1 型及び p#-1 型の素数階乗素数での試し割りもここで行う。
		# ( 素数リストを生成するコストを抑えるため。 )
		#
		my $sq = $n->sqrt( 0 ) ;
		my $prs = ( $sq > 10000 ) ? __PACKAGE__->new( 10000 )->primorial_series() : $sq->primorial_series() ;
		my $g = $prs->{'primorial'}->gcd( $n ) ;

		my @fa ;
		if ( $g > 1 and $g < $n ) {
			#
			# sqrt( $n ) の素数階乗との間に公約数が存在する。
			#
			if ( $g->is_prime() )	{ push( @fa , $g ) ; }
			else			{ foreach ( $g->prime_factor() ) { push( @fa , $_->{'factor'} ) ; } }
		}
		else {
			#
			# 素数階乗素数での試し割り。
			#
			my $pp = {} ;
			foreach my $p ( sort { $a <=> $b } ( @{ $prs->{'primes_p'} } , @{ $prs->{'primes_m'} } ) ) {
				next	if ( defined $pp->{ $p } ) ;
				last	if ( $n < $p ) ;
				$pp->{ $p } = 1 ;
				if ( $n->modulus( $p )->is_zero() ) {
					push( @fa , $p ) ;
				}
			}
		}

		last	unless ( @fa ) ;

		foreach my $f ( @fa ) {
			unless ( defined $pf->{ $f } ) {
				$pf->{ $f } = { 'factor' => $f , 'power' => 0 } ;
			}
			my $ref = \%{ $pf->{ $f } } ;
			while ( $n >= $f and $n->modulus( $f ) == 0 ) {
				$ref->{'power'}++ ;
				$n = $n->divide( $f , 0 ) ;
			}
		}
	}

	#
	# 階乗素数と交互階乗素数を使用した試し割り
	#
	if ( $n > 1 and ! $n->is_prime() ) {
		foreach my $p ( $n->factorial_primes() ) {
			last    if ( $n < $p ) ;
			while ( $n >= $p and $n->modulus( $p )->is_zero() ) {
				if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'}++ ; }
				else				{ $pf->{ $p } = { 'factor' => $p , 'power' => 1 } ; }
				$n = $n->divide( $p , 0 ) ;
			}
		}
	}

	#
	# 楕円曲線法で試行。
	#
	while ( my $p = $n->elliptic_factor() ) {
		last    if ( $p == $n ) ;
		while ( my $p1 = $p->elliptic_factor() ) {
			last    if ( $p1 == $p ) ;
			$p = $p1 ;
		}
		last    if ( $p == $n ) ;
		while ( $n >= $p and $n->modulus( $p ) == 0 ) {
			if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'}++ ; }
			else				{ $pf->{ $p } = { 'factor' => $p , 'power' => 1 } ; }
			$n = $n->divide( $p , 0 ) ;
		}
	}

	#
	# レピュニット素数 ( repunit prime ) を振るい落とす。 ( 49081 桁以降は PRP ( probable prime ) )
	#
	foreach my $len ( 2 , 19 , 23 , 317 , 1031 , 49081 , 86453 , 109297 , 270343 ) {
		my $rp = __PACKAGE__->new( '1' x $len ) ;
		while ( $n >= $rp and $n->modulus( $rp ) == 0 ) {
			if ( defined $pf->{ $rp } )	{ $pf->{ $rp }->{'power'}++ ; }
			else				{ $pf->{ $rp } = { 'factor' => $rp , 'power' => 1 } ; }
			$n = $n->divide( $rp , 0 ) ;
		}
		last    if ( $n < $rp ) ;
	}

	#
	# メルセンヌ数の分解を試みる。
	#
	if ( my $p = mersenne_power( $n ) ) {
		#
		# $p がソフィー・ジェルマン素数であれば、安全素数 ( $q == 2 * $p + 1 ) がメルセンヌ数の約数に成り得る。
		# 厳密には $p と $q が素数であることを確認する必要があるが、ここで必要なのは $q で割れるかどうかと言う点のみ。
		#
		# ここでは $q で割り切れるかどうかを確認した後、 $q の素因数で分解する。
		# ( $q の素因数分解を通じて $q が素数であるかどうかは明確になる。 )
		#
		my $q = ( $p > 10 and $p->value() =~ /[139]$/ )
			? $p * 2 + 1
			: undef
		;

		if ( defined $q and $n >= $q and $n->modulus( $q ) == 0 ) {
			foreach my $r ( sort { $a->{'factor'} <=> $b->{'factor'} } $q->prime_factor() ) {
				my $f = $r->{'factor'} ;
				last    if ( $n < $f ) ;
				while ( $n >= $f and $n->modulus( $f ) == 0 ) {
					if ( defined $pf->{ $f } )	{ $pf->{ $f }->{'power'}++ ; }
					else				{ $pf->{ $f } = { 'factor' => $f , 'power' => 1 } ; }
					$n = $n->divide( $f , 0 ) ;
				}
			}
		}
	}

	#
	# 二次篩法
	#
	#while ( $n > 1 and ! $n->is_prime() ) {
	#	my @pa = $n->qsieve() ;
	#	last    unless ( @pa ) ;
	#	my @pb ;
	#	foreach my $p ( @pa ) {
	#		if ( $p->is_prime() ) {
	#			push( @pb , $p ) ;
	#		}
	#		else {
	#			foreach ( sort { $a->{'factor'} <=> $b->{'factor'} } $p->prime_factor() ) {
	#				push( @pb , $_->{'factor'} ) ;
	#			}
	#		}
	#	}
	#	foreach my $p ( @pb ) {
	#		last    if ( $n < $p ) ;
	#		while ( $n >= $p and $n->modulus( $p ) == 0 ) {
	#			if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'}++ ; }
	#			else				{ $pf->{ $p } = { 'factor' => $p , 'power' => 1 } ; }
	#			$n = $n->divide( $p , 0 ) ;
	#		}
	#	}
	#}

	#
	# SQUFOF
	#
	if ( $n > 1 and ! $n->is_prime() ) {
		my @pa ;
		if ( my $r = $n->squfof() ) {
			foreach my $p ( $r , $n->divide( $r ) ) {
				if ( $p->is_prime() ) {
					push( @pa , $p ) ;
				}
				else {
					foreach ( sort { $a->{'factor'} <=> $b->{'factor'} } $p->prime_factor() ) {
						push( @pa , $_->{'factor'} ) ;
					}
				}
			}
			foreach my $p ( @pa ) {
				last    if ( $n < $p ) ;
				while ( $n >= $p and $n->modulus( $p ) == 0 ) {
					if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'}++ ; }
					else				{ $pf->{ $p } = { 'factor' => $p , 'power' => 1 } ; }
					$n = $n->divide( $p , 0 ) ;
				}
			}
		}
	}

	#
	# ロー法での因数分解
	#
	#$DB::single = 1 ;
	while ( $n > 1 ) {
		#
		# 素数判定
		#
		last	if ( $n->is_prime() ) ;

		#
		# ロー法で分解
		#
		# ロー法は任意の因数を返す ( 素因数とは限らない ) ので、分解不能になるまで繰り返す。
		#
		my $p = $n->pollard_brent_rho() ;
		last	unless ( defined $p ) ;
		last	if ( $p == $n ) ;

		while ( ! $p->is_prime() ) {
			my $p1 = $p->pollard_brent_rho() ;
			last	unless ( defined $p1 ) ;
			last    if ( $p1 == $p ) ;
			$p = $p1 ;
		}
		last	if ( $p == $n ) ;

		#
		# 得られた素数 $p における乗数を計算した後、 $n を $p で除算した値で更新。
		#
		my $pow = 1 ;
		my $pp = __PACKAGE__->new( $p ) ;
		while ( $n >= $pp and $n->modulus( $pp ) == 0 ) {
			$pp *= $p ;
			$pow++ ;
		}
		if ( --$pow > 0 ) {
			if ( defined $pf->{ $p } )	{ $pf->{ $p }->{'power'} += $pow ; }
			else				{ $pf->{ $p } = { 'factor' => $p , 'power' => $pow } ; }
			$n = $n->divide( $p->power( $pow ) , 0 ) ;
		}
	}

	#
	# $n が素数であればこれを追加。
	#
	if ( $n > 1 ) {
		if ( defined $pf->{ $n } )	{ $pf->{ $n }->{'power'}++ ; }
		else				{ $pf->{ $n } = { 'factor' => $n , 'power' => 1 } ; }
	}

	return values %{ $pf } ;
}

sub pollard_rho {
	#-----------------------------------------------------------------------
	#
	# ポラード・ロー因数分解法 ( Pollard's rho algorithm )
	#
	#   ポラード・ロー因数分解法は因数を確率的手法で割り出す乱択アルゴリズム。
	#
	#   このアルゴリズムは、
	#
	#     ランダムに選択された 1.177 * sqrt( $p ) 個の数値の半分以上が
	#     2 つの数値 $x , $y を共に割り切れる時、$p は $x , $y を共に割り切れる。
	#
	#   と言う観測結果に基づいている。
	#
	#   この時、任意の数値 $n の因数 $p は以下のように表現される。
	#
	#     $p = gcd( abs( $x - $y ) , $n )
	#     1 < $p <= $n
	#
	#   $x , $y は少なくとも 1 < $x <= $n , 1 < $y <= $n となるような乱数でなければならない。
	#   これは、 $x と $y を生成する擬似乱数発生関数が $n を法とするように設計することで実現される。
	#   これとは別に、 $x , $y を抽出するに当たって、条件に合致する数値を網羅しつつ重複選択を避けるような仕組みも必要となる。
	#
	#   ポラード・ロー因数分解法は、フロイドの循環検出法に基づいて作られており、
	#   一定の周期で同じパターンの乱数列が返るような関数が用いられる。
	#   そして、 $x == $y となることを持って擬似乱数列が一巡したことを検出できるようになっている。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $c = shift || 1 ;
	$c = __PACKAGE__->new( $c )	unless ( ref( $c ) eq __PACKAGE__ ) ;
	$c = __PACKAGE__->new( 1 )	unless ( defined $c ) ;

	my $x = __PACKAGE__->new( 2 ) ;
	my $y = __PACKAGE__->new( 2 ) ;
	my $d = __PACKAGE__->new( 1 ) ;

	#
	# 線形合同法による漸化式
	#
	# y = ( x^2 + c ) % n
	#
	my $fx = sub { my $r = ( $_[0] * $_[0] + $c ) % $n ; return $r ; } ;

	#
	# 主処理
	#
	while ( $d == 1 ) {
		$x = $fx->( $x ) ;
		$y = $fx->( $fx->( $y ) ) ;
		$d = $x->subtract( $y )->abs()->gcd( $n ) ;	# $d = gcd( abs( $x - $y ) , $n )
	}

	if ( $d == $n ) {
		if ( ++$c > 5 )	{ return $n ; }
		else		{ return pollard_rho( $n , $c ) ; }
	}

	return $d ;
}

sub pollard_brent_rho {
	#-----------------------------------------------------------------------
	#
	# ポラード・ロー因数分解法のブレント ( Richard P. Brent ) による改良版
	#
	#   ポラード・ロー法よりも格段に速いが、ロジックはやや複雑。
	#   ポラード・ロー法と比較すると、処理を繰り返すごとに $y の値がより大きく変動するように調整されている。
	#   また、公約数の演算を行う際に複数の $y を一度に検査するような工夫がなされている。
	#   大きな因数の検出には相応の時間がかかるが、今のところ他の方式と比べて最も信頼性が高い。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $retry = shift || 1 ;
	my $count = 0 ;

	my $g = undef ;

	while ( ++$count <= $retry ) {

		my $c1 = $n->add( '-2' )->random()->add( 1 ) ;
		my $c2 = $n->add( '-5' )->random()->add( 1 ) ;

		my $x = __PACKAGE__->new( 2 ) ;
		my $y = __PACKAGE__->new( 2 ) ;
		my $r = __PACKAGE__->new( 1 ) ;
		my $q = __PACKAGE__->new( 1 ) ;
		my $m = $n->add( '-1' )->random()->add( 1 ) ;

		#
		# 線形合同法による漸化式
		#
		# y = ax^2 + b
		#
		# 定数 b には 0 , -2 以外の任意の数値が使用できる。
		#
		my $fx = sub {
			#
			# $n を法とする値を返すので、合同式の四則演算により、以下の何れの方法でも同じ結果が返る。
			#
			#   $r == ( $c1 * $_[0] ** 2 + $c2 ) % $n ;
			#      == ( ( $c1 % $n ) * ( ( $_[0] % $n ) ** 2 ) % $n ) + ( $c2 % $n ) ) % $n ;
			#
			# 単精度や倍精度の数値しか扱えない環境では後者の方法を採用することで桁あふれを予防できる。
			# 多倍長整数が扱える環境では前者の方法でもかまわない。
			# 除算の負荷が問題にならない程小さければ、後者のほうが有利。
			#
			my $r = ( $c1 * $_[0] ** 2 + $c2 ) % $n ;
			return $r ;
		} ;

		#
		# 主処理
		#
		my $zero = __PACKAGE__->new( 0 ) ;
		while () {
			$x = $y->copy() ;
			foreach ( 1 .. $r ) {
				$y = $fx->( $y ) ;
			}

			my $k = $zero->copy() ;
			while () {
				my( $limit ) = sort { $a <=> $b } ( $m , ( $r - $k ) ) ;
				foreach ( 1 .. $limit ) {
					#
					# $y = $fx->( $y ) ;
					# $q = ( $q * abs( $x - $y ) ) % $n ;
					#
					$y = $fx->( $y ) ;
					$q = ( $q * $x->subtract( $y )->abs() ) % $n ;
				}

				$g = $q->gcd( $n ) ;
				$k += $m ;

				last	if ( $k >= $r or $g > 1 ) ;
			}
			last	if ( $g > 1 ) ;
			$r *= 2 ;
		}

		last	if ( $g > 1 and $g < $n ) ;

		$g = undef ;
	}

	return $g ;
}

sub p_minus_factor {
	#-----------------------------------------------------------------------
	#
	# ポラードの p - 1 法による因数分解
	#
	#   フェルマーの小定理より、任意の素数 $p には、
	#
	#     $a ** ( $p - 1 ) ≡ 1 ( mod $p )
	#
	#   となる整数 $a が存在する。 ( $a と $p は互いに疎 )
	#   これより、素数を因数に持つ合成数 $c は、
	#
	#     $c == $a ** ( $p - 1 ) - 1 == $k * $p
	#
	#   と表すことができる。
	#   また、
	#
	#     $d = gcd( $c , $n )
	#
	#   で得られる $d が $d != 1 and $d != $n であるならば $n は $c と $d を因数に持つ合成数であり、
	#   $c が前述の条件を満たすように生成されたものであれば、 $c は何らかの素数の倍数であることが保証される。
	#
	#   これを整理すると、
	#
	#     $d = gcd( ( $a ** $m ) - 1 , $n )
	#
	#   と表すことができ、更に、
	#
	#      $a = ( $a ** $m ) % $n
	#      $d = gcd( $a - 1 , $n )
	#
	#   として繰り返し $d を検査することで効率よく $n の因数を探索することができる。
	#
	#
	#   $a と $m がうまくはまると非常に高速に因数を見つけることができるが、因数が必ず見つかるとは限らない。
	#   因数が見つからない場合の終了条件についてもこれと言った目安がない。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return $n			if ( $n <= 3 ) ;

	my $x = shift || 2 ;
	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;

	my $k = __PACKAGE__->new( 0 ) ;
	my $r = undef ;
	while () {
		$x = $x->modexp( ++$k , $n ) ;
		$r = $x->add( '-1' )->gcd( $n ) ;
		last	if ( $r > 1 and $r < $n ) ;
	}

	return $r ;
}

sub elliptic_factor {
	#-----------------------------------------------------------------------
	#
	# 楕円曲線法による因数分解
	#
	#   楕円曲線法による因数分解はポラードの p - 1 法を応用したもの。
	#   比較的小さい素因数で構成されている合成数に対して効果的とされている。
	#   ( ポラードのアルゴリズムを応用したものはこのような性格を持つ。 )
	#
	#   y^2 ≡ x^3 + ax + b ( mod n ) が重解を持たない場合に可換になることを利用している。
	#
	#   右辺が重解を持たない条件は、
	#
	#     4a^3 + 27b^2 != 0
	#
	# とりあえず動く程度の実装はできているが、精度・速度共にエラトステネスの篩よりはましと言う程度。
	# 現状では 10 進数 7 桁程度の因数すら検出できていない。
	# p - 1 法と似た傾向があり、うまくはまったときの処理はすばらしく速い。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	#
	# 拡張ユークリッドの互除法
	#
	my $ec_exgcd = sub {
		my $p = shift ;
		my $q = shift ;

		foreach ( $p , $q ) {
			$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
			return undef			unless ( defined $_ ) ;
		}

		my $x  = __PACKAGE__->new( 0 ) ;
		my $y  = __PACKAGE__->new( 1 ) ;
		my $lx = __PACKAGE__->new( 1 ) ;
		my $ly = __PACKAGE__->new( 0 ) ;
		while ( ! $q->is_zero() ) {
			my $r = $p->divide( $q , 0 ) ;
			( $p , $q ) = ( $q , $p->modulus( $q ) ) ;
			( $x , $lx ) = ( $lx - $r * $x , $x ) ;
			( $y , $ly ) = ( $ly - $r * $y , $y ) ;
		}

		if ( $p < 0 ) {
			foreach ( $p , $lx , $ly ) { $_ *= -1 ; }
		}

		return ( $p , $lx , $ly ) ;
	} ;

	#
	# 楕円曲線の係数を決定する関数
	#
	my $ec = sub {
		#
		# y^2 == x^3 + ax + b の a , b , x , y を生成する。
		#
		my( $c1 , $c2 , $x , $y ) ;
		while () {
			$c1 = $n->add( '-1' )->random()->add( 1 ) ;				# 係数 a
			$x  = $n->add( '-1' )->random()->add( 1 ) ;
			$y  = $n->add( '-1' )->random()->add( 1 ) ;
			$c2 = ( $y ** 2 - $x ** 3 - $c1 * $x ) % $n ;				# 係数 b
			last    unless ( ( 4 * ( $c1 ** 3 ) + 27 * ( $c2 ** 2 ) ) == 0 ) ;	# 重解を持たないための判別式
		}

		my $coef = [ $c1 , $c2 ] ;
		my $p = { 'x' => $x , 'y' => $y } ;

		return ( $coef , $p ) ;
	} ;

	#
	# 楕円曲線法による法 $n の下での加算
	#
	my $ec_add = sub {
		my( $p , $q , $coef ) = @_ ;

		#return ( $q , __PACKAGE__->new( 1 ) )	if ( ref( $p ) eq 'HASH' ) ;
		#return ( $p , __PACKAGE__->new( 1 ) )	if ( ref( $q ) eq 'HASH' ) ;
		return ( $q , __PACKAGE__->new( 1 ) )	unless ( ref( $p ) eq 'HASH' ) ;
		return ( $p , __PACKAGE__->new( 1 ) )	unless ( ref( $q ) eq 'HASH' ) ;

		foreach ( $p , $q ) {
			$_->{'x'} %= $n ;
			$_->{'y'} %= $n ;
		}

		my( $c1 , $c2 ) = @{ $coef } ;			# 楕円曲線の係数 a , b
		my( $x1 , $y1 ) = @{ $p }{ 'x' , 'y' } ;
		my( $x2 , $y2 ) = @{ $q }{ 'x' , 'y' } ;

		my( $d , $u , $v ) = ( __PACKAGE__->new( 1 ) , undef , undef ) ;
		my $r = undef ;
		if ( $x1 == $x2 and ( ( $y1 + $y2 ) % $n ) == 0 ) {
			#
			# 無限遠点
			#
			# 2 点を結ぶ直線が x 軸に直交 ( == y 軸と平行 ) する。
			#
			$r = __PACKAGE__->new( 0 ) ;
		}
		else {
			#
			# R = P + Q となる点の座標を求める。
			#
			my $lambda ;
			if ( $x1 == $x2 ) {
				#
				# 2 倍点 ( R = P + P )
				#
				( $d , $u , $v ) = $ec_exgcd->( $y1 * 2 , $n ) ;
				$lambda = ( ( $x1 ** 2 * 3 + $c1 ) * $u ) % $n ;
			}
			else {
				#
				# 通常の加算 ( R = P + Q )
				#
				( $d , $u , $v ) = $ec_exgcd->( $x1 - $x2 , $n ) ;
				$lambda = ( ( $y1 - $y2 ) * $u ) % $n ;
			}
					
			my $x3 = ( $lambda ** 2 - $x1 - $x2 ) % $n ;
			my $y3 = ( ( -1 ) * $y1 - $lambda * ( $x3 - $x1 ) ) % $n ;

			$r = { 'x' =>  $x3 , 'y' => $y3 } ;
		}

		return ( $r , $d ) ;
	} ;

	#
	# 楕円曲線法による法 $n の下での乗算
	#
	my $ec_mult = sub {
		my( $p , $m , $coef ) = @_ ;

		my $r = __PACKAGE__->new( 0 ) ;
		my $d = __PACKAGE__->new( 1 ) ;

		while ( $m != 0 ) {
			if ( $m->is_odd() == 1 )	{ ( $r , $d ) = $ec_add->( $r , $p , $coef ) ; }
			else				{ ( $p , $d ) = $ec_add->( $p , $p , $coef ) ; }
			last	unless ( $d == 1 ) ;
			$m = $m->divide( 2 , 0 ) ;
		}

		return ( $r , $d ) ;
	} ;

	#
	# 主処理
	#
	my $m = factorial( 10 ) ;
	my $d = __PACKAGE__->new( 1 ) ;
	my $t = __PACKAGE__->new( 5 ) ;
	my( $p , $q , $coef ) ;
	
	#$DB::single = 1 ;
	foreach my $i ( 1 .. $t ) {
		#
		# 楕円曲線を生成
		#
		#   $coef は、楕円曲線を決定する係数 a , b を要素に持つ配列参照。
		#   $p は、係数を決定する際に使用した楕円曲線上の座標を格納したハッシュ参照。
		#   $p は、この後の処理における楕円曲線上の基点座標となる。
		# 
		( $coef , $p ) = $ec->( $n ) ;

		#
		# 楕円曲線上での乗算
		#
		( $q , $d ) = $ec_mult->( $p , $m , $coef ) ;

		last    unless ( $d == 1 ) ;
	}

	return ( $d == 1 ) ? $n : $d ;
}

sub sqrt_diff_factor {
	#-----------------------------------------------------------------------
	#
	# フェルマーの平方差法 ( difference of squares method ) による因数分解
	#
	#   任意の合成数 $n について
	#
	#     $n == ( $x + $y ) * ( $x - $y ) == $x ** 2 - $y ** 2
	#
	#   となるような $x , $y の組み合わせを探索すると言うアプローチ。
	#
	#   任意の $x について
	#
	#     ( $x ** 2 ) - $n == ( $y ** 2 )
	#
	#   が成立するような $x , $y が見つかれば、 ( $x + $y ) , ( $x - $y ) が $n の因数と言うことになる。
	#
	#   $x , $y , $n の関係を合同式で表すと、
	#
	#     ( $x ** 2 ) ≡ ( $y ** 2 ) ( mod $n )
	#
	#   となる。
	#
	#
	#   $n の因数が sqrt( $n ) の近傍に存在する時に非常に効率的に機能する。
	#   sqrt( $n ) からどの程度かけ離れた時に処理を打ち切るかと言った点を考慮する必要がある。
	#
	#   ここでは、 sqrt( $n ) - sqrt( $n ) / 4 <= $i <= sqrt( $n ) + sqrt( $n ) / 4 の範囲で探索を行うこととする。
	#   この関数は最大で 2 つの因数を返す。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	my $sq = $n->sqrt( 0 ) ;
	return $sq	if ( $n == ( $sq * $sq ) ) ;

	my $r = undef ;
	my $i = __PACKAGE__->new( 1 ) ;
	while ( ( $i * 4 ) < $sq ) {
		foreach my $j ( $i , $i * ( -1 ) ) {
			my $x = $sq + $i ;
			my $y2 = ( $x * $x ) - $n ;
			last	if ( $y2 < 1 ) ;

			my $y = $y2->sqrt() ;
			if ( $y2 == ( $y * $y ) ) {
				$r = [ $x - $y , $x + $y ] ;
				last ;
			}
		}
		last	if ( defined $r ) ;
		$i++ ;
	}

	return ( defined $r ) ? @{ $r } : () ;
}

sub qsieve {
	#-----------------------------------------------------------------------
	#
	# 二次篩法 ( Quadratic Sieve ) による因数分解
	#
	#   平方差法の応用
	#   平方差法では任意の整数 $n を平方差で表現する因数の組み合わせを探索するという手法を採っている。
	#   二次篩法では  sqrt( $n ) の近傍の数値を使用して半ば強引に平方差を作り出すという手法を採る。
	#
	#   生成された平方差 ( $x ** 2 - $y ** 2 ) を分解して得られる ( $x + $y ) と ( $x - $y ) は $n よりも大きな数値となり、
	#   これらの数値と $n との間の最大公約数を採ることで $n の因数が得られる。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	#
	# 探索範囲を規定する変数
	#
	my $area = shift || [ 1 , 5000 ] ;
	confess( "Invalid argument.\n" )        if ( ! defined $area or ref( $area ) ne 'ARRAY' ) ;

	my $sq = $n->sqrt( 0 ) ;
	return ( $sq )  if ( $n == ( $sq * $sq ) ) ;

	foreach ( @{ $area } ) {
		$_ = __PACKAGE__->new( $_ ) ;
		confess( "Invalid argument $_\n" )	unless ( defined $_ ) ;
		confess( "Invalid argument $_\n" )      if ( $_ < 0 ) ;
		confess( "Invalid argument $_\n" )      if ( $_ >= $sq ) ;
	}
	@{ $area } = sort { $a <=> $b } @{ $area } ;

	#
	# 演算用の変数
	#
	my $r = undef ;
	my( $i , $limit ) = @{ $area } ;
	my $smp = __PACKAGE__->new( 0 ) ;
	my $xm  = __PACKAGE__->new( 1 ) ;
	my $ym  = __PACKAGE__->new( 1 ) ;

	#
	# 基底素数を選定
	#
	my @bp ;
	foreach my $p ( primes( 10000 ) ) {
		my $s = ( $n ** ( ( $p - 1 ) * 0.5 ) ) % $p ;
		if ( $s == 1 ) {
			push( @bp , $p ) ;
		}
		last	if ( @bp >= 8 ) ;
	}
	return ()	unless ( @bp ) ;

	while ( $i <= $limit ) {
		foreach my $j ( $i , ( -1 ) * $i ) {
			#
			# sqrt( $n ) 付近の値を基にして $x , $y の平方数を求める。
			#
			my $x = $sq + $j ;
			my $x2 = $x * $x ;
			my $y2 = $x2 - $n ;
			$y2 %= $n ;
			next	if ( $x2 == $y2 ) ;
			
			#
			# $y の平方数 $y2 が負の場合には -1 ** 1 が掛けられているものとして処理する。
			# 逆に $y2 が正の場合には -1 ** 2 が掛けられているものとして処理する。
			#
			if ( $y2 < 0 )	{ $smp += 1 ; $y2 *= ( -1 ) ; }
			else		{ $smp += 2 ; }

			#
			# $y2 が既に平方数であれば、因数を求めてループを抜ける。
			#
			my $y = $y2->sqrt( 0 ) ;
			if ( $y2 == ( $y * $y ) ) {
				$r = [] ;
				foreach ( ( $x - $y ) , ( $x + $y ) ) {
					my $g = $_->abs()->gcd( $n ) ;
					if ( $g > 1 and $g < $n ) {
						push( @{ $r } , $g ) ;
					}
				}
				last	if ( @{ $r } ) ;
				$r = undef ;
			}

			#
			# $y2 を比較的小さな素数で分解する。
			# $y2 が完全に分解できなければこれを不採用とする。
			# ( この辺りの処理が「篩」となっている。 )
			#
			my $m = $y2 ;
			my $mp = {} ;
			foreach my $p ( @bp ) {
				last	if ( $m < $p ) ;
				while ( $m->modulus( $p ) == 0 ) {
					$mp->{ $p }++ ;
					$m = $m->divide( $p , 0 ) ;
				}
			}
			next	if ( $m > 1 ) ;

			#
			# $y2 が完全に分解されていれば $x2 と $y2 の総積を更新し、
			# $y2 を分解した素因数の乗数を法 2 の下で加算する。
			#
			$xm *= $x2 ;
			$ym *= $y2 ;
			foreach my $pow ( values %{ $mp } ) {
				$smp += $pow ;
			}
			$smp %= 2 ;

			#
			# 乗数の総和が偶数であれば、収集した $y2 の総積 $ym は平方数となる。
			# $x2 の総積 $xm は元々平方数であるため、 $xm と $ym の平方根を改めて $x , $y と名づけると、
			#
			#   ( $xm - $ym ) == ( $x ** 2 - $y ** 2 )
			#                 == ( $x + $y ) * ( $x - $y )
			#                 ≡ 0 ( mod $n )
			#
			# と言う関係が得られる。
			#
			# この時、
			#
			#   $g = gcd( abs( $x + $y ) , $n )
			#      又は
			#   $g = gcd( abs( $x - $y ) , $n )
			#
			# によって得られる値 $g が 1 < $g < $n であれば、 $g が $n の因数となる。
			#
			if ( $smp == 0 ) {
				my( $x , $y ) = ( $xm->sqrt( 0 ) , $ym->sqrt( 0 ) ) ;
				$r = [] ;
				foreach ( ( $x - $y ) , ( $x + $y ) ) {
					my $g = $_->abs()->gcd( $n ) ;
					if ( $g > 1 and $g < $n ) {
						push( @{ $r } , $g ) ;
					}
				}
				last	if ( @{ $r } ) ;
				$xm = __PACKAGE__->new( 1 ) ;
				$ym = __PACKAGE__->new( 1 ) ;
				$r = undef ;
			}
		}
		last	if ( defined $r ) ;
		$i++ ;
	}

	return ( defined $r and @{ $r } ) ? @{ $r } : () ;
}

sub squfof {
	#-----------------------------------------------------------------------
	#
	# SQUFOF ( Shanks' square forms factorization )
	#
	#   連分数展開を応用した因数分解とのこと。
	#
	#   二次篩法と同じく、
	#
	#     x^2 ≡ y^2 ( mod n )
	#     -> factor == gcd( x + y , n ) or gcd( x - y , n )
	#
	#   となる x , y を求める。
	#
	#   分解したい数 n の平方根は、
	#
	#     sqrt( n ) == a + 1 / b
	#
	#   の形をとり、 b もまた b == a' + 1 / b' と言う構造を持つ。
	#   ( a , a' , b , b' が何れも規則性を持ち、特定の漸化式によって演算できる点がミソ )
	#   これを展開していくことで sqrt( n ) の近似値が求められる。
	#
	#   この時、 i 回展開した時点の状態は、
	#
	#     A[i] / B[i] == Q[i]
	#
	#   で表すことができ、ここから
	#
	#     A[i]^2 - B[i]^2 * n == ( -1 )^i * Q[i]
	#     -> A[i]^2 ≡ (-1)^i * Q[i] ( mod n )
	#
	#   が得られる。
	#   ここで右辺の値が平方数になれば x^2 ≡ y^2 ( mod n ) が得られたことになる。
	#   これはつまり i が偶数である時に完全平方数となる連分数展開の近似値 Q[i] を求めることに等しい。
	#   ( モリソンとブリルハートのアルゴリズム )
	#
	#   シャンクスは、この考え方を元にして Q[i] を効率的に求める方法を考案し SQUFOF を確立したとされている。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	my $try = shift || 1 ;

	my $k = __PACKAGE__->new( 0 ) ;
	my $w = [] ;
	my $p = [] ;
	my $q = [] ;

	my $g = undef ;

	while ( ++$k <= $try ) {
		#
		# 前進過程
		#
		#   k を k >= 1 の任意の整数とし、以下のように初期化する。
		#
		#     w[0] = floor( sqrt( k * n ) )
		#     p[0] = w[0]
		#     q[0] = 1
		#     q[1] = ( k * n ) - ( w[0] ** 2 )
		#
		#   以下の処理を繰り返す。
		#
		#                     w[0] + p[i-1]
		#     w[i] = floor( ----------------- )
		#                         q[i]
		#
		#     p[i]   = q[i] * w[i] - p[i-1]
		#     q[i+1] = q[i-1] + ( p[i-1] - p[i] ) * w[i]
		#
		#     ( i == 1 -> ∞ )
		#
		#   初期値を含めた偶数回目の i において sqrt( q[i] ) が整数になるものを抑えて後退過程へ進む。
		#   ただし、 sqrt( q[i] ) が奇数回目の時の q[i] と一致する場合には、不採用とする。
		#
		#   ちなみに sqrt( k * n ) を正規連分数展開した数列の要素を cf[i] で表現すると、 w[i] == cf[i] と言う関係になる。
		#   ただし、展開を繰り返していく内に両者は次第に一致しなくなる。
		#   q[i] の有効な値は、 w[i] == cf[i] である範囲の中にしか現われないような気がするが、詳細は不明。
		#
		my $sq = $n->multiply( $k )->sqrt() ;
		#my @cf = @{ $sq->cfraction( 100 ) } ;
		$w->[0] = $sq->floor() ;					# w[0] = floor( sqrt( k * n ) )
		$p->[0] = $w->[0]->copy() ;					# p[0] = w[0]
		$q->[0] = __PACKAGE__->new( 1 ) ;				# q[0] = 1
		$q->[1] = $n->multiply( $k ) - ( $p->[0]->power( 2 ) ) ;	# q[1] = ( k * n ) - ( p[0] * p[0] )

		my $pq = [] ;
		my $qi_odd = { $q->[1] => 1 } ;
		foreach my $i ( 0 .. 100 ) {
			$w->[1] = $w->[0]->add( $p->[0] )->divide( $q->[1] )->floor() ;	# w[1] = ( w[0] + p[0] ) / q[1]

			#last	if ( $cf[ $i + 1 ] != $w->[1] ) ;

			$p->[1] = ( $q->[1] * $w->[1] ) - $p->[0] ;			# p[1] = ( q[1] * w[1] ) - p[0]
			$q->[2] = $q->[0] + ( ( $p->[0] - $p->[1] ) * $w->[1] ) ;	# q[2] = q[0] + ( p[0] - p[1] ) * w[1]

			$p = [ $p->[1] ] ;
			$q = [ $q->[1] , $q->[2] ] ;

			if ( ( $i & 1 ) == 1 ) {
				unless ( defined $qi_odd->{ $q->[1] } ) {
					$qi_odd->{ $q->[1] } = 1 ;
				}
			}
			else {
				my $sq_qi = $q->[1]->sqrt() ;
				if ( $sq_qi->is_integer() and ! defined $qi_odd->{ $sq_qi } ) {
					push( @{ $pq } , { 'p' => $p->[0]->copy() , 'q' => $q->[1]->copy() } ) ;
					last ;
				}
			}
		}

		next	unless ( @{ $pq } ) ;

		#
		# 後退過程
		#
		#   前進過程で検出した p[i-1] と q[i] を使用して以下のように初期化する。 ( q[i] は整数の二乗 )
		# 
		#                     floor( sqrt( k * n ) ) - p[i-1] 
		#     w[0] = floor( ----------------------------------- )
		#                            sqrt( q[i] ) 
		#
		#     p[0] = w[0] * sqrt( q[i] ) + p[i-1]
		#
		#     q[0] = sqrt( q[i] )
		#
		#              ( k * n ) - p[0]^2
		#     q[1] = ----------------------
		#                    q[0]
		#
		#
		#   以下の処理を繰り返す。
		#
		#                     floor( sqrt( k * n ) ) + p[i-1]
		#     w[i] = floor( ----------------------------------- )
		#                                 q[i]
		#
		#     p[i]   = q[i] * w[i] - p[i-1]
		#     q[i+1] = q[i-1] + ( p[i-1] - p[i] ) * w[i]
		#       
		#     ( i == 1 -> ∞ )
		#
		#   この過程で p[i] == p[i-1] となったら、処理を打ち切り、 n と p[i] との間の最大公約数を求める。
		#   最大公約数 g が 1 < g < n であれば、これが n の因数となる。
		#
		#
		#   ちなみに、 w[i] は前進過程で得られた p[i-1] , q[i] を用いて得られる
		#
		#                sqrt( q[i] )
		#     v == --------------------------
		#            sqrt( k * n ) - p[i-1]
		#
		#   を正規連分数展開した結果と等しくなり、
		#
		#                sqrt( q[i] )              floor( sqrt( k * n ) ) + p[i-1] 
		#     v == -------------------------- == -----------------------------------
		#            sqrt( k * n ) - p[i-1]                   q[i]
		#
		#   という関係になっている。
		#
		foreach ( @{ $pq } ) {
			my( $pv , $qv ) = ( $_->{'p'} , $_->{'q'} ) ;
			my $sqv = $qv->sqrt() ;

			#@cf = @{ $sqv->divide( $sq - $pv )->cfraction() } ;

			$w->[0] = $sq->floor()->subtract( $pv )->divide( $sqv )->floor() ;
			$p->[0] = ( $w->[0] * $sqv ) + $pv ;
			$q->[0] = $sqv->copy() ;
			$q->[1] = $n->multiply( $k )->subtract( $p->[0]->power( 2 ) )->divide( $q->[0] , 0 ) ;

			next	unless ( $q->[1]->is_integer() ) ;

			foreach my $i ( 0 .. 100 ) {
				$w->[1] = $sq->floor()->add( $p->[0] )->divide( $q->[1] )->floor() ;	# w[1] = ( floor( sqrt( k * n ) ) + p[0] ) / q[1]
				$p->[1] = ( $q->[1] * $w->[1] ) - $p->[0] ;				# p[1] = ( q[1] * w[1] ) - p[0]
				$q->[2] = $q->[0] + ( ( $p->[0] - $p->[1] ) * $w->[1] ) ;		# q[2] = q[0] + ( p[0] - p[1] ) * w[1]

				#warn( join( "\t" , $i , $p->[0] , $q->[1] , $w->[1] , $cf[ $i ] ) , "\n" ) ;

				last	if ( $p->[1] == $p->[0] ) ;

				$p = [ $p->[1] ] ;
				$q = [ $q->[1] , $q->[2] ] ;
			}

			next	if ( @{ $p } < 2 or $p->[1] != $p->[0] ) ;

			#
			# 因数を求める
			#
			$g = $n->gcd( $p->[0] ) ;
			last	if ( $g > 1 and $g < $n ) ;

			$g = undef ;
		}
	}

	return $g ;
}

sub shor_factorization {
	#-----------------------------------------------------------------------
	#
	# ショアの因数分解アルゴリズム ( Shor's factorization )
	#
	#   ショアのアルゴリズムは、合同式の冪乗算 ( 冪剰余演算 ) が周期性を持った数列を生成することを利用したアルゴリズム。
	#
	#   このアルゴリズムは確率的アルゴリズムであり、処理時間は一定しない。
	#   古典計算機 ( 現在のコンピューター ) では冪剰余演算で導かれる数列の周期性を検出するのに膨大な時間が必要になるとされているが、
	#   量子コンピューターではこれを迅速に求めることができるため、高速な因数分解が可能となるらしい。
	#
	#   量子コンピューター向けのアルゴリズムは量子アルゴリズムとも呼ばれる。
	#   ショアのアルゴリズムは量子アルゴリズムの代表的なものの内の一つ。
	#
	#
	#   任意の正の整数 n と 1 < a < n となる任意の正の整数 a について、
	#
	#     a^r ( mod n )          ( k == 1 -> n - 1 ) 
	#
	#   によって生成される数列は一定の周期性を持った数列となる。
	#
	#   n が素数である場合、 1 < a < n となる任意の正の整数 a の中に、
	#
	#     a^r ≡ 1 ( mod n )     ( r < n )
	#
	#   となる a が必ず存在し、 r == n - 1 の時のみ、この合同式が成立する。
	#   この時の a は 素数 n を法とする原始根となる。
	#
	#   n の原始根 a は、
	#
	#     a^m ≡ b ( mod n )     ( m == 1 -> ∞ )
	#
	#   において、 0 < b < n となる全ての自然数 b を生成する元となる。 ( これが「原始根」という名前の由来。 )
	#
	#   任意の正の整数 n が原始根を持つのは、任意の奇素数 p と正の整数 m を用いて、
	#
	#     n == 2 , 4 , p^m , ( p^m ) * 2
	#
	#   の 4 種類の場合のみに限られるとされており、 n が素数であれば、 a < n となる任意の原始根 a を伴って
	#
	#     a^r ≡ 1 ( mod n )      ( a < n , r < n )
	#
	#   を満たす r は r == n - 1 のみとなる。
	#   言い換えると、 n が素数である場合のみ、 a^r ≡ b ( mod n ) が a < n , r < n の範囲で唯一つの周期を持つと言うことになり、
	#   n が合成数である場合には、これが原始根を持つかどうかに関わらず、複数の周期を持つことになる。
	#
	#   この周期性を利用して因数を見つけるのがショアのアルゴリズム。
	#   ( n と a が互いに素でなければ両者の公約数が n の因数となる。 )
	#
	#
	#   ここでは、全ての正の整数についてその周期性を利用できる数値として、
	#
	#     a^r ≡ 1 ( mod n )
	#
	#   を足掛かりにして処理を行う。
	#
	#   処理手順は以下の通り、
	#
	#     a^r ≡ 1 ( mod n ) となる a , r を探す。
	#
	#       a は n と互いに素となる 0 < a < n な整数であることが最低限の条件となる。
	#       ( 任意に選んだ a が n と互いに素な関係でなければ、 gcd( a , n ) が解の一つとなる。 )
	#
	#       a^r ≡ 1 ( mod n ) となる k を探す際には、合同式の除法より、
	#
	#         a^r ≡ a^m ( mod n )
	#         -> a^r / a^m ≡ a^m / a^m ( mod n )
	#         -> a^( r - m ) ≡ 1 ( mod n )
	#
	#       も利用することができる。
	#
	#     a^r ≡ 1 ( mod n ) であれば、合同式の乗法から、以下の二つの式が成り立つ。 ( 後者の場合、 r は偶数である必要がある。 )
	#
	#        ( a^r )^2   ≡ 1 ( mod n )
	#        a^( r/2 )^2 ≡ 1 ( mod n )
	#
	#     この二つの式は、
	#
	#        ( a^r )^2 - 1   == ( a^r + 1 ) * ( a^r - 1 )             ≡ 0 ( mod n )
	#        a^( r/2 )^2 - 1 == ( a^( r/2 ) + 1 ) * ( a^( r/2 ) - 1 ) ≡ 0 ( mod n )
	#
	#     を意味しており、以下の演算によって因数が見つかる可能性がある。
	#
	#        gcd( a^r + 1 , n )
	#        gcd( a^r - 1 , n )
	#        gcd( a^( r/2 ) + 1 , n )
	#        gcd( a^( r/2 ) - 1 , n ) 
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	return undef	unless( $n->is_integer() ) ;
	return undef	if ( $n < 0 ) ;

	if ( $n->is_even() ) {
		my $fa = {} ;
		foreach ( __PACKAGE__->new( 2 ) , $n->divide( 2 , 0 ) ) { $fa->{ $_ } = $_ ; }
		return sort { $a <=> $b } values %{ $fa } ;
	}

	#
	# Gerhard Jaeschke による決定的素数判定のための係数。
	# ( ミラーラビン法から流用 )
	#
	my @k = () ;
	if	( $n <       '4_759_123_141' )	{ @k = ( 2 , 7 , 61 ) ;				} # 32 ビット強 ( 5 の冪を誤判定することがある。)
	elsif	( $n <   '2_152_302_898_747' )	{ @k = ( 2 , 3 , 5 , 7 , 11 ) ;			} # 40 ビット強
	elsif	( $n <   '3_474_749_660_383' )	{ @k = ( 2 , 3 , 5 , 7 , 11 , 13 ) ;		} # 41 ビット強
	elsif	( $n < '341_550_071_728_321' )	{ @k = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 ) ;	} # 48 ビット強
	
	while ( @k < 20 ) {
		my $x = $n->subtract( $k[-1] + 1 )->abs()->random() + ( $k[-1] + 1 ) ;
		push( @k , $x ) ;
	}
	foreach ( @k ) {
		$_ = __PACKAGE__->new( $_ ) ;
	}

	#
	# 主処理
	#
	my @r = () ;
	foreach my $x ( @k ) {
		#
		# $x < $n とする。
		# 条件に合致しない値についてはランダムな値で置き換える。
		#
		if ( $x >= $n ) {
			$x = $n->add( '-3' )->random()->add( 2 ) ;
		}

		#
		# $x と $n が公約数を持つならばそれが $n の因数。
		#
		my $f = $x->gcd( $n ) ;
		if ( $f > 1 and $f < $n ) {
			my $fa = {} ;
			foreach ( $f , $n / $f ) { $fa->{ $_ } = $_ ; }
			@r = values %{ $fa } ;
			last ;
		}

		#
		# 周期を検査
		#
		# このループを超並列演算で処理できれば劇的な速度改善が見込める。
		#
		# 超並列演算が実現すれば foreach で扱う $p0 全てを同時に並列で試すことができる。
		# この場合、逆元を求めて検査する必要もなくなる。
		#
		my $p0min = $n->divide( 2 , 0 ) ;
		foreach ( my $p0 = ( $n - 1 ) ; $p0 >= $p0min ; $p0 -= 2 ) {
			#
			# $x ** $pow ≡ 1 ( mod $n ) を探す。
			#
			my $pow = $p0 ;
			my $m = $x->modexp( $pow , $n ) ;	# $x ** $pow ≡ $m ( mod $n )
			unless ( $m == 1 ) {
				#
				# $x ** $pow に法 $n の下での乗法における逆元が存在するかどうかを検査する。
				# 逆元が存在すれば $x ** $k ≡ 1 ( mod $n ) となる $k を導出できる。
				#
				#   $x ** $pow ≡ $x ** $p ( mod $n ) であれば、
				#   $x ** ( $pow - $p ) ≡ 1 ( mod $n )
				#
				next	unless ( $m->modulus( $x ) == 0 ) ;

				my $p = __PACKAGE__->new( 0 ) ;
				while ( $m >= $x and $m->modulus( $x ) == 0 ) { $p++ ; $m = $m->divide( $x , 0 ) ; }

				$pow -= $p	if ( $m == 1 ) ;
			}
			next	unless ( $m == 1 ) ;

			#
			# ここまでの処理で、( mod $n ) が ( $x ** $pow ) で循環している可能性がある。
			# もしそうであるならば、以下の二つの式も共に成立する。
			#
			# ( $x ** $pow ) ** 2 ≡ 1 ( mod $n )
			# ( $x ** $pow )      ≡ 1 ( mod $n )
			#
			# 前者から以下の演算によって因数が見つかる可能性が示唆される。
			#
			#   gcd( ( $x ** $pow + 1 ) , $n )
			#   gcd( ( $x ** $pow - 1 ) , $n )
			#
			# 同様に、後者からは以下の演算によって因数が見つかる可能性が示唆される。
			#
			#   gcd( ( $x ** ( $pow / 2 ) + 1 ) , $n )
			#   gcd( ( $x ** ( $pow / 2 ) - 1 ) , $n )
			#
			foreach my $i ( 0 .. 3 ) {
				my $f = undef ;
				if	( $i == 0 )	{ $f = $x->power( $pow )->add(  '1' )->gcd( $n ) ; }
				elsif	( $i == 1 )	{ $f = $x->power( $pow )->add( '-1' )->gcd( $n ) ; }
				elsif	( $i == 2 )	{ $f = $x->power( $pow->divide( 2 , 0 ) )->add(  '1' )->gcd( $n ) ; }
				elsif	( $i == 3 )	{ $f = $x->power( $pow->divide( 2 , 0 ) )->add( '-1' )->gcd( $n ) ; }
				last	unless ( defined $f ) ;

				if ( $f > 1 and $f < $n ) {
					@r = ( $f , $n->divide( $f ) ) ;
				}
				last	if ( @r ) ;
			}
			last	if ( @r ) ;
		}
		last	if ( @r ) ;
	}

	@r = sort { $a <=> $b } @r	if ( @r ) ;

	return @r ;
}

sub shor_fft_factorization {
	#-----------------------------------------------------------------------
	#
	# FFT を利用したショアのアルゴリズム
	#
	#   本来のショアのアルゴリズムでは量子フーリエ変換を使うが、ここでは FFT を使った実装を試みる。
	#   フーリエ変換に伴う処理コストが莫大なものになるため、実用性は乏しい。
	#
	#   ショアのアルゴリズムは、
	#
	#     a^r ≡ 1 ( mod n )        ( 1 < a < n , gcd( a , n ) == 1 , 1 < r < n - 1 )
	#
	#   となるような r を探索することによって実現される。
	#
	#   これは a^r mod n によって生成される数列が、ある周期を持って循環する事実に基づいており、
	#   r はこの周期の位数となって現れる。
	#
	#   この r の検出に FFT を使うと言うのがここでのアプローチ。
	#   FFT は波形を現す数値配列からその特徴的な成分を検出する処理であり、入力として使用する数列は
	#   その波形を十分に表現できるものであればよく、取り得る値全体ではなく、その部分配列を使用することもできる。
	#
	#   例えば、 n == 15 , a == 7 , 冪剰余を格納する配列を m[] とした場合、 FFT に掛ける数列の要素は、最大で
	#
	#     m[ 1 ]  == 7^1  mod 15 ==  7
	#     m[ 2 ]  == 7^2  mod 15 ==  4
	#     m[ 3 ]  == 7^3  mod 15 == 13
	#     .......
	#     m[ 14 ] == 7^14 mod 15 ==  4
	#
	#   の 14 種類になるが、 m[ 1 ] ～ m[ 6 ] の範囲を検査することで r == 4 を導くことができる。
	#
	#     gcd( 4 + 1 , 15 ) == 5
	#     gcd( 4 - 1 , 15 ) == 3
	#     -> 15 == ( 4 + 1 ) * ( 4 - 1 ) == 5 * 3
	#
	#   冪剰余で形成される数列がどこで循環するかを予め知ることはできないが、数列のサイズを比較的小さめに採っておき、
	#   徐々に拡張しながら探索を繰り返すといったアプローチは可能と思われる。
	#   FFT は解析する数列の要素数によって性能が大幅に変化するので、部分配列を使って試行ができるのは大きなメリットになるかもしれない。
	#
	#   数列の周期性を見るだけなので、 FFT は正変換でも逆変換でもかまわない。
	#   デバッグ時の見通しを良くするため、ここでは逆変換を使用している。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	return undef	unless( $n->is_integer() ) ;
	return undef	if ( $n < 0 ) ;

	if ( $n->is_even() ) {
		my $fa = {} ;
		foreach ( __PACKAGE__->new( 2 ) , $n->divide( 2 , 0 ) ) { $fa->{ $_ } = $_ ; }
		return sort { $a <=> $b } values %{ $fa } ;
	}

	my @r = () ;

	#
	# 任意の自然数を選択。
	#
	my $x = $n->add( '-3' )->random()->add( 2 ) ;
	{
		my $g = $n->gcd( $x ) ;
		return ( $g , $n / $g )	if ( $g > 1 ) ;
	}

	#
	# 冪剰余を集める。
	#
	my @m = () ;
	foreach ( my $i = decimal( 1 ) ; $i < $n ; $i++ ) {
		push( @m , $x->modexp( $i , $n ) ) ;
	}

	#
	# フーリエ逆変換に掛け、結果の行列式を集める。
	#
	my $f = ifft( [ @m ] ) ;
	my @det = () ;
	foreach ( my $i = 0 ; $i < @{ $f } ; $i++ ) {
		$det[ $i ] = $f->[ $i ]->det() ;
	}

	#
	# 上位 5 % に属する値をピーク値とみなし、その値を生成した乗数を集める。
	#
	my $th = ( percentile( @det , { 'perc' => 5 } ) )[-2] ;
	my @ord = () ;
	foreach ( my $i = 1 ; $i < @det ; $i++ ) {
		push( @ord , $i + 1 )	if ( $det[ $i ] >= $th ) ;
	}

	#
	# 集めた乗数を用いて検査。
	#
	my $fa = {} ;
	foreach my $i ( @ord ) {
		foreach my $f ( $i + 1 , $i - 1 ) {
			my $g = $n->gcd( $f ) ;
			if ( $g > 1 and $g < $n ) {
				$fa->{ $g } = 1 ;
				$fa->{ $n / $g } = 1 ;
			}
		}
	}
	
	if ( my @k = keys %{ $fa } ) {
		@r = sort { $a <=> $b } @k ;
	}

	return @r ;
}

#-------------------------------------------------------------------------------
#
# 原始根
#
#-------------------------------------------------------------------------------

sub has_pr {
	#-----------------------------------------------------------------------
	#
	# 原始根を持つかどうかを返す。
	#
	#   n == 2 , 4 , p^k or 2 * p^k の形でなければ原始根は存在しない。 ( p は奇素数 )
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef 	unless ( defined $n ) ;
	return undef	unless ( $n->is_integer() ) ;
	return undef	if ( $n < 0 ) ;

	#
	# 2 , 4 , p , 2p は原始根を持つ。 ( p は奇素数 )
	#
	return 1	if ( $n->value() =~ /^[24]$/ ) ;
	$n /= 2		if ( $n->is_even() ) ;			# n が偶数であれば 1 回だけ 2 で除算。
	return 0	if ( $n->is_even() ) ;			# n が偶数であれば不合格。
	return 1	if ( $n->is_prime() ) ;			# n が奇素数であれば合格。

	#
	# 比較的小さな素数を用いて最小の素因数を探索。
	#
	#   元の n が n == 2 * p^k 形式であったとしても、この時点では n == p^k に修正されている。
	#   これ以降の処理では、 n == p^k かどうかを検査することになる。
	#
	#   n == p^1 == p となるような n は前段階で既に検査済み。
	#   よって、探索の過程で p^2 > n となるような p が現れた場合には、 n == p^k では有り得ないことになる。
	#
	my $p = undef ;
	foreach my $f ( primes( 10000 ) ) {
		return 0	if ( $f->power( 2 ) > $n ) ;	# f^2 > n であれば不合格。
		if ( $n->modulus( $f ) == 0 ) {
			$p = $f ;
			last ;
		}
	}

	#
	# 素因数が見つからなければ、ロー法を用いて任意の素因数を探索する。
	# ロー法は任意の因数を一つだけ返すので、素数が現れるまで分解を繰り返す必要がある。
	#
	unless ( defined $p ) {
		$p = $n->pollard_brent_rho() ;
		while ( defined $p ) {
			last	if ( $p->is_prime() ) ;
			$p = $p->pollard_brent_rho() ;
		}
	}

	#
	# n == p^k かどうかを検査。
	#
	# 元の n が n == 2 * p^k 形式であったとしても、この時点では n == p^k に修正されている。
	# したがって、素因数 2 を検査する必要はない。
	#
	if ( defined $p ) {
		#
		# 素因数が見つかった場合。
		#
		my $f = $p->copy() ;
		while ( $f < $n ) { $f *= $p ; }
		return 1	if ( $f == $n ) ;		# n == p^k であり、合格。
		return 0 ;
	}
	else {
		#
		# 素因数が見つからなかった場合には n を完全に素因数分解することを試みる。
		# これには大きなコストがかかるが、成功すれば全ての素因数を網羅した配列を得ることができる。
		#
		# ここで扱う n は奇数なので、素因数に 2 は現れない。
		#
		my $pf = [ $n->prime_factor() ] ;
		return 1	if ( @{ $pf } == 1 ) ;		# 素因数が単一の素数であれば合格。
		return 0 ;
	}

	return undef ;
}

sub primitive_root {
	#-----------------------------------------------------------------------
	#
	# 原始根を返す。
	#
	#   primitive_roots メソッドからコールされた場合には、原始根のリストを返す。
	#   それ以外の場合には、最小の原始根を返す。
	#
	#
	#   原始根は既約剰余類群が巡回群になる時の生成元を指す。
	#   既約剰余類は、法 n の下で n の剰余類を形成した時にその全ての要素が n と互いに素となるようなものを指す。
	#
	#   n が素数である場合には、法 n の下での剰余類は既約剰余類となり、巡回群をなす。 ( 原始根が必ず存在する。)
	#   つまり素数には必ず原始根が存在し、素数 n を法とする原始根 a の冪乗数 a^k ( mod n ) は n-1 以下の全ての正の整数を網羅しながら巡回する数列を形成する。
	#
	#   n が合成数の場合、 n が特定の条件を満たす合成数である場合のみ原始根が存在する。
	#   合成数には約数が存在するため、 a^k ( mod n ) は飛び飛びの値を取りながら巡回する数列を形成することになる。
	#
	#
	#   任意の素数 p について、以下の合同式を満たす整数 a が存在するとする。
	#
	#     a^k ≡ 1 ( mod p )
	#
	#   k == p - 1 の時のみこの合同式を満たす a が素数 p の原始根。 ( k は位数と呼ばれる。 )
	#
	#   素数の原始根は phi( p - 1 ) 個存在する。
	#   phi() はオイラーのトーシェント関数であり、素数 p の原始根の数は ( p - 1 ) と互いに素な ( p - 1 ) 以下の数の個数に等しくなる。
	#
	#
	#   正の整数が原始根を持つことができるのは、 n >= 2 , p を奇素数、 k を正の整数として、
	#
	#     n == 2 , 4 , p^k , 2p^k
	#
	#   の時に限られる。
	#   この条件を満たす整数が合成数である場合、
	#
	#     a^k ≡ 1 ( mod n )
	#
	#   となる k は k == phi( n ) となる。
	#
	#   任意の素数 p について、
	#
	#     phi( p ) == p - 1 
	#
	#   であるため、任意の正の整数 n が原始根を持つ場合、
	#
	#     a^( phi( n ) ) ≡ 1 ( mod n )
	#
	#   を満たすことが a が原始根であることを示す必要条件を一般化したものとなる。
	#   十分条件は、任意の指数 k を伴って
	#
	#     a^k ≡ 1 ( mod n )      ( k < phi( n ) )
	#
	#   を満たす k が存在しないこととなる。
	#
	#   この時、原始根の総数は、 phi( phi( n ) ) で表される数値となる。
	#   n が素数であれば、 phi( phi( n ) ) == phi( n - 1 ) となる。
	#
	#
	#   任意の奇素数 p について、 g がその原始根である場合、
	#
	#     g^( p - 1 ) ≡ 1 ( mod p )
	#
	#     -> ( g^( ( p - 1 ) / 2 ) )^2 ≡ 1 ( mod p )
	#     -> g^( ( p - 1 ) / 2 ) ≡ ± 1 ( mod p )
	#
	#   g が p の原始根であることより、
	#
	#     g^( ( p - 1 ) / 2 ) !≡ 1 ( mod p )
	#     -> g^( ( p - 1 ) / 2 ) ≡ -1 ( mod p )
	#                            ≡ ( p - 1 ) ( mod p )
	#
	#   でなければならない。
	#
	#
	#   例 )
	#
	#     n == 4 とすると、 phi( 4 ) == 2
	#
	#     2^2 == 4 ≡ 0 ( mod 4 )         NG
	#     -> 2^2 は mod 4 の零元であり、以後、指数 k == 2 -> ∞ において 2^k は全て 0 ( mod 4 ) となる。
	#
	#     3^2 == 9 ≡ 1 ( mod 4 )         OK
	#     -> 3^1 ≡ 3 ( mod 4 ) なので、 a == 3 は 4 の原始根。
	#
	#     phi( phi( 4 ) ) == 1 なので、 4 の原始根は 3 のみ。
	#     原始根 3 によって生成される冪剰余は 1 と 3 のみ。
	#
	#
	#     n == 5 の場合、 phi( 5 ) == 4
	#
	#     2^4 == 16 ≡ 1 ( mod 5 )
	#     -> 2^1 ≡ 2 ( mod 5 ) , 2^2 ≡ 4 ( mod 5 ) , 2^3 ≡ 3 ( mod 5 ) なので、 a == 2 は 5 の原始根。
	#
	#     3^4 == 81 ≡ 1 ( mod 5 )
	#     -> 3^1 ≡ 3 ( mod 5 ) , 3^2 ≡ 4 ( mod 5 ) , 3^3 ≡ 2 ( mod 5 ) なので、 a == 3 は 5 の原始根。
	#
	#     phi( phi( 5 ) ) == 2 なので、 5 の原始根は 2 , 3 のみ。
	#     5 は素数なので、原始根 2 , 3 によって生成される冪剰余は 1 .. 4 の範囲の全ての整数値を網羅する。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;

	my $caller = ( caller 1 )[3] ;
	my $wa = ( defined $caller and $caller =~ /::primitive_roots$/ ) ? 1 : 0 ;

	return ( $wa ) ? () : undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return ( $wa ) ? () : undef 	unless ( defined $n ) ;

	return ( $wa ) ? () : undef	unless( $n->is_integer() ) ;
	return ( $wa ) ? () : undef	if ( $n < 0 ) ;

	#
	# 原始根を持つ数かどうかを検査。
	#
	# n == 2 , 4 , p^k , 2 * p^k の形でなければ原始根は存在しない。 ( p は奇素数 , k は自然数 )
	#
	return ( $wa ) ? () : undef	unless ( $n->has_pr() ) ;

	#
	# 原始根を求める。
	#
	# n の原始根 g は k == totient( n ) の時のみ
	#
	#   g^k ≡ 1 ( mod n )       ( 1 < g < n )
	#
	# となるような数。( n が素数であれば k == n - 1 )
	# 逆に言うと、 totient( n ) の因数を用いて上記合同式が成り立つような g は不合格と言うこと。
	#
	my $c = $n->totient() ;		# phi( n )
	my $limit = $c->totient() ;	# phi( phi( n ) ) 
	$limit = 1	unless ( $wa ) ;

	my $pf = [ $c->prime_factor() ] ;
	my $g = __PACKAGE__->new( 1 ) ;

	my $r = [] ;

	while ( ++$g < $n ) {
		#
		# g^( totient( n ) ) ≡ 1 でなければ失格。
		#
		next	unless ( $g->modexp( $c , $n ) == 1 ) ;

		#
		# n が 5 以上の奇素数の場合
		#
		#   c == totient( n ) == n - 1
		#
		# g が原始根であれば
		#
		#   g^( c / 2 ) ≡ -1 ( mod n )
		#
		# でなければならない。
		#
		if ( $n > 4 and $c == ( $n - 1 ) ) {
			unless ( $g->modexp( $c->divide( 2 , 0 ) , $n ) == ( $n - 1 ) ) {
				next ;
			}
		}

		#
		# g^c が唯一の 1 ( mod n ) であることを確認する。
		#
		# これは、 c の全ての因数 k で
		#
		#   g^k ≡ 1 ( mod n )
		#
		# が成立しないことを確認することになる。
		# この時、 c の任意の素因数 k を用いて、 m == c / k とし、
		#
		#   g^m ≡ 1 ( mod n )
		#
		# が成立しないことを確認することで処理コストを抑えることができる。
		# ( m は c の素因数を複数包含する可能性が高くなる。 )
		#
		my $flg = 1 ;
		foreach my $f ( @{ $pf } ) {
			#
			# c を c の素因数で割った値を用いることで、より多くの因数を一度に検査する。
			#
			if ( $g->modexp( $c->divide( $f->{'factor'} ) , $n ) == 1 ) {
				$flg = 0 ;
				last ;
			}
		}

		if ( $flg == 1 ) {
			push( @{ $r } , $g ) ;
		}
		last	if ( @{ $r } >= $limit ) ;
	}

	return ( $wa ) ? @{ $r } : $r->[0] ;
}

sub primitive_roots {
	#-----------------------------------------------------------------------
	#
	# 原始根のリストを返す。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return ()	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return ()	unless ( defined $n ) ;

	return $n->primitive_root() ;
}

=head1 'Decimal' object - special numbers.

=cut

#-------------------------------------------------------------------------------
#
# 特殊な数
#
#-------------------------------------------------------------------------------

=head2 bernoulli

Return Bernoulli number

  bernoulli( 0 ) == 1
                              1
  bernoulli( n ) == (-1) * ------- *  sum( binomial( n + 1 , k ) * bernoulli( k ) )     ( k == 0 -> n - 1 )
                            n + 1

  if n >= 3 and n is odd, bernoulli( n ) is always 0.
  else bernoulli( n ) will always return rational number.

  print decimal( 0 )->bernoulli() ;                    # 1
  print decimal( 1 )->bernoulli() ;                    # -1/2
  print decimal( 2 )->bernoulli() ;                    # 1/6
  print decimal( 3 )->bernoulli() ;                    # 0
  print decimal( 4 )->bernoulli() ;                    # -1/30
  print decimal( 5 )->bernoulli() ;                    # 0
  print decimal( 6 )->bernoulli() ;                    # 1/42
  print decimal( 7 )->bernoulli() ;                    # 0
  print decimal( 8 )->bernoulli() ;                    # -1/30
  print decimal( 9 )->bernoulli() ;                    # 0
  print decimal( 10 )->bernoulli() ;                   # 5/66

=cut

sub bernoulli {
	#-----------------------------------------------------------------------
	#
	# ベルヌーイ数
	#
	#   B( 0 ) == 1
	#                -1
	#   B( n ) == --------- Σ{ binomial( n + 1 , k ) * B( k ) }          ( k == 0 -> n - 1 )
	#               n + 1
	#
	#   ベルヌーイ数は全て有理数であるため、分数で表現する。
	#   bernoulli( n ) において、 n が 3 以上の奇数値である場合、結果は全て 0 となる。
	#
	#   bernoulli( n ) を求めるには、 bernoulli( 0 ) ～ bernoulli( n - 1 ) を全て計算し、それらを全て保持しておく必要がある。
	#   このため、演算負荷は非常に高い。
	#
	#  2014/12
	#    B( n ) の n が n > 1 における奇数である場合に B( n ) == 0 となる点をコードに反映。
	#    二項係数を都度求めるのではなく ( n + 1 ) 次の二項係数を一括して取得するように変更。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;

	my $r = [] ;
	$r->[0] = fraction(  1 , 1 ) ;	# bernoulli( 0 )
	$r->[1] = fraction( -1 , 2 ) ;	# bernoulli( 1 )

	return $r->[0]		if ( $n == 0 ) ;
	return $r->[1]		if ( $n == 1 ) ;
	return fraction( 0 )	if ( $n->is_odd() ) ;

	foreach ( my $i = 2 ; $i <= $n ; $i++ ) {
		#
		# $i が奇数であれば $r->[ $i ] == 0
		#
		if ( ( $i & 1 ) == 1 ) {
			$r->[ $i ] = fraction( 0 ) ;
			next ;
		}

		#
		#                 -1
		# $r->[ $i ] = -------- * { binomial( $i + 1 , 0 ) * $r->[0] + binomial( $i + 1 , 1 ) * $r->[1] ..... }
		#                $i+1
		#
		my $n1 = $i + 1 ;
		my $nCk = [ binomial_coefficients( $n1 ) ] ;	# ( $n1 + 1 ) 次の二項係数の全リスト
		my $s = fraction( 0 , 1 ) ;
		foreach ( my $k = __PACKAGE__->new( 0 ) ; $k < $i ; $k++ ) {
			my $f = $r->[ $k ]->multiply( $nCk->[ $k ] ) ;
			$s += $f ;
		}
		$r->[ $i ] = $s->multiply( fraction( -1 , $n1 ) )->reduce() ;
	}

	return $r->[ $n ] ;
}

=head2 binomial

Return the binomial coefficient.

Alias : nCk

  print decimal( 2 )->binomial( 0 ) ;      # 1
  print decimal( 2 )->nCk( 0 ) ;           # 1




                               m!            m + ( 1 - 1 )     m + ( 1 - 2 )            m + ( 1 - k )
  binomial( m , n ) == ----------------- == --------------- * --------------- * .... * ---------------     ( k == 0 -> n )
                        ( m - n )! * n!           1                 2                        k


  m == 2 , n == 0 -> m

  -> binomial( 2 , 0 ) == 1
     binomial( 2 , 1 ) == 2
     binomial( 2 , 2 ) == 1

  -> ( x + 1 )^2 == 1 * x^2 + 2 * x^1 + 1 * x^0
                    ~         ~         ~


  m == 3 , n == 0 -> m

  -> binomial( 3 , 0 ) == 1
     binomial( 3 , 1 ) == 3
     binomial( 3 , 2 ) == 3
     binomial( 3 , 3 ) == 1

  -> ( x + 1 )^3 == 1 * x^3 + 3 * x^2 + 3 * x^2 + 1 * x^0
                    ~         ~         ~         ~

  In general,
                                                    m * ( m - 1 ) * ......... * 1               m! / 0!
     binomial( m , 0 ) == binomial( m , m - 0 ) == --------------------------------------- == ------------
                                                    1 * 2 * ..... * ( m - 1 ) * ( m - 0 )      ( m - 0 )!

                                                    m * ( m - 1 ) * ......... * 2               m! / 1!
     binomial( m , 1 ) == binomial( m , m - 1 ) == --------------------------------------- == ------------
                                                    1 * 2 * ..... * ( m - 2 ) * ( m - 1 )      ( m - 1 )!

                                                    m * ( m - 1 ) * ......... * 3               m! / 2!
     binomial( m , 2 ) == binomial( m , m - 2 ) == --------------------------------------- == ------------
                                                    1 * 2 * ..... * ( m - 3 ) * ( m - 2 )      ( m - 2 )!

     .....................

                                                     m! / n!               m!
     binomial( m , n ) == binomial( m , m - n ) == ------------ == -----------------
                                                    ( m - n )!      ( m - n )! * n!


=cut

sub binomial {
	#-----------------------------------------------------------------------
	#
	# 二項係数 ( binomial coefficient )
	#
	#                                 m!
	#   binomial( m , n ) == --------------------
	#                          ( m - n )! * n!
	#
	#                          m( m - 1 )( m - 2 ) .... ( m - ( n - 1 ) ) 
	#                     == ---------------------------------------------
	#                                             n!
	#
	#                             m - ( n - k )
	#                     == Π( --------------- )            ( k == 1 -> n )
	#                                   k
	#
	#                             m + ( 1 - k )
	#                     == Π( --------------- )            ( k == 1 -> n )
	#                                   k
	#
	#
	#   m == 2 , n = 0 -> m とした時、
	#
	#      binomial( 2 , 0 ) == 1
	#      binomial( 2 , 1 ) == 2
	#      binomial( 2 , 2 ) == 1
	#
	#   であり、
	#
	#     ( x + y )^2 == x^2 + 2xy + y^2
	#
	#  と展開した時の右辺の各係数に等しくなる。
	#
	#  m == 3 , n = 0 -> m の時、
	#
	#     ( x + y )^3 == x^3 + 3( x^2 * y ) + 3( x * y^2 ) + y^3
	#
	#     binomial( 3 , 0 ) == 1
	#     binomial( 3 , 1 ) == 3
	#     binomial( 3 , 2 ) == 3
	#     binomial( 3 , 3 ) == 1
	#
	#  であり、任意の ( x + y )^m について同様の結果が得られる。
	#
	#  階乗を使用した演算であるため、 m , n は共に整数でなければならず、
	#  m > 0 , n >= 0 且つ m >= n でなければならない。
	#
	#  結果は常に正の整数となる。
	#
	#  binomial( m , n ) ( m == 0 -> ∞ , n == 0 -> m ) を階段状に並べたものは
	#  パスカルの三角形として知られている。
	#
	#-----------------------------------------------------------------------
	my( $m , $n ) = @_ ;

	foreach ( $m , $n ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $_ ) ;
	}

	my $r = $m->factorial()
		/ $m->subtract( $n )->factorial()->multiply( $n->factorial() )
	;

	return $r ;
}

=head2 binomial_coefficients

Return all binomial coefficients.

Alias : nCkAll

  print join ' ' , decimal( 1 )->binomial_coefficients() ;        # 1 1           ( == coefficients of ( x + 1 )^1 )
  print join ' ' , decimal( 2 )->binomial_coefficients() ;        # 1 2 1         ( == coefficients of ( x + 1 )^2 )
  print join ' ' , decimal( 3 )->nCkAll() ;                       # 1 3 3 1       ( == coefficients of ( x + 1 )^3 )
  print join ' ' , decimal( 4 )->nCkAll() ;                       # 1 4 6 4 1     ( == coefficients of ( x + 1 )^4 )
  print join ' ' , decimal( 5 )->nCkAll() ;                       # 1 5 10 10 5 1 ( == coefficients of ( x + 1 )^5 ) 

=cut

sub binomial_coefficients {
	#-----------------------------------------------------------------------
	#
	# 二項式の n 乗の展開によって現れる全ての係数 ( 二項係数 ; binomial coefficients ) を全て返す。
	#
	#                                 m!
	#   binomial( m , n ) == --------------------
	#                          ( m - n )! * n!
	#
	#   binomial_coefficients( m ) == binomial( m , n )     ( n == 0 -> m )
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;

	$m = __PACKAGE__->new( $m )	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $m ) ;

	my $mf = [] ;
	foreach my $n ( __PACKAGE__->new( 0 ) .. $m ) {
		if ( $n == 0 )	{ $mf->[ $n ] = __PACKAGE__->new( 1 ) ; }
		else		{ $mf->[ $n ] = $mf->[ $n - 1 ] * $n ;  }
	}

	my $r = [] ;

	foreach my $n ( __PACKAGE__->new( 0 ) .. $m ) {
		$r->[ $n ] = $mf->[ $m ] / ( $mf->[ $m - $n ] * $mf->[ $n ] )
	}

	return @{ $r } ;
}

sub nCk		{ return binomial( @_ ) ;		}
sub nCkAll	{ return binomial_coefficients( @_ ) ;	}

sub gamma {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   ガンマ関数は階乗の複素数への拡張版。
	#
	#   自然数 n においては、
	#
	#     gamma( n + 1 ) == n!
	#
	#   実部が正である任意の複素数 z について、
	#
	#     gamma( z ) == ∫( t^(z-1) * exp( -t ) * dt )     ( t == 0 -> ∞ ; real( z ) > 0 ) 
	#
	#   で表される。
	#
	#   自然数 n において、
	#
	#     gamma( n ) == ( n - 1 )!
	#                != n!
	#
	#   であることに注意が必要。
	#
	#   自然数における定義では gamma( 1 ) は定義できないが、複素数における定義により、
	#
	#     gamma( 1 ) == 1
	#
	#   となる。
	#
	#   また、 z == 1/2 の時、ガンマ関数はガウス積分
	#
	#     gamma( z ) == ∫( exp( -z^2 ) * dz ) == sqrt( PI )
	#
	#   となることが知られており、ここから、任意の自然数 n について、
	#
	#                          ( 2n - 1 )!!
	#     gamma( 1/2 + n ) == -------------- * sqrt( PI )
	#                              2^n
	#
	#                            ( -2 )^n
	#     gamma( 1/2 - n ) == -------------- * sqrt( PI )
	#                          ( 2n - 1 )!!
	#
	#   が成立する。
	#
	#   より一般には、任意の複素数 z について、
	#
	#                           n^z * n!
	#     gamma( z ) == lim( -------------- )         ( n == 0 -> ∞ , k == 0 -> n )
	#                         Π( z + k )
	#
	#   と定義される。 ( ただし、 z が負の整数の場合のみ発散する。 )
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;
	return undef	if ( $n == 0 ) ;

	my $r = undef ;

	if ( $n == 1 ) {
		#
		# gamma( 1 ) == 1
		#
		$r = __PACKAGE__->new( 1 ) ;
	}
	elsif ( $n->can_integer() ) {
		#
		# gamma( n ) == ( n - 1 )!
		#
		$r = $n->integer()->subtract( 1 )->factorial()	if ( $n > 0 ) ;
	}
	elsif ( $n =~ /\.5$/ ) {
		if ( $n > 1 ) {
			#
			#                      ( 2n - 1 )!!
			# gamma( 1/2 + n ) == -------------- * sqrt( π )
			#                          2^n
			#
			my $ni = $n - 0.5 ;
			my $f = ( $ni * 2 - 1 )->double_factorial() ;
			$r = ( $f * pi()->sqrt() ) / __PACKAGE__->new( 2 )->power( $ni ) ;
		}
		elsif ( $n > 0 ) {
			#
			# gamma( 1/2 ) == sqrt( π )
			#
			$r = pi()->sqrt() ;
		}
		else {
			#
			#                        ( -2 )^n
			# gamma( 1/2 - n ) == -------------- * sqrt( π )
			#                      ( 2n - 1 )!!
			#
			my $ni = $n->abs() + 0.5 ;
			my $f = ( $ni * 2 - 1 )->double_factorial() ;
			$r = ( __PACKAGE__->new( -2 )->power( $ni ) * pi()->sqrt() ) / $f ;
		}
	}

	if ( ! defined $r and $n->can_decimal() ) {
		#
		# ランチョスの近似にかける。
		#
		$r = $n->gamma_l() ;
	}

	return $r ;
}

sub gamma_s {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   Stirling の近似計算
	#
	#   精度は小数点以下 8 ～ 9 桁程度。
	#   演算効率も非常に悪い。
	#
	#   実数冪の演算負荷が高いため、 Perl 標準の数値演算で実装。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = $n->value()	if ( ref( $n ) eq __PACKAGE__ ) ;
	return undef		if ( ref( $n ) ) ;

	my $r = undef ;

	if ( $n < 100 ) {
		no warnings qw( recursion ) ;
		$r = gamma_s( $n + 1 ) / $n ;
	}
	else {
		my $e = CORE::exp(1) ;
		my $pi = pi()->value() ;
		$r = CORE::sqrt( $n * $pi * 2 ) * ( $n / $e + 1 / ( $n * $e * 12 ) ) ** $n / $n ;
	}

	return ( defined $r ) ? __PACKAGE__->new( $r ) : $r ;
}

sub gamma_l {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   ランチョス ( Lanczos ) 法による近似。
	#
	#   精度は小数点以下 12 桁程度。
	#
	#   実数冪の演算負荷が高いため、 Perl 標準の数値演算で実装。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = $n->value()	if ( ref( $n ) eq __PACKAGE__ ) ;
	return undef		if ( ref( $n ) ) ;

	my $r = undef ;

	if ( $n < 0.5 ) {
		my $pi = pi()->value() ;
		$r = $pi / CORE::sin( $pi * $n ) / gamma_l( 1 - $n ) ;
	}
	else {
		my $g = 9 ;
		my $c = [
			 1.000000000000000174663 ,
			 5716.400188274341379136 ,
			-14815.30426768413909044 ,
			 14291.49277657478554025 ,
			-6348.160217641458813289 ,
			 1301.608286058321874105 ,
			-108.1767053514369634679 ,
			 2.605696505611755827729 ,
			-0.7423452510201416151527e-2 ,
			 0.5384136432509564062961e-7 ,
			-0.4023533141268236372067e-8 ,
		] ;

		my $pi = pi()->value() ;
		my $x = $c->[0] ;
		foreach my $i ( 1 .. $#{ $c } ) {
			$x += $c->[ $i ] / ( $n + $i - 1 ) ;
		}

		my $t = $n + $g - 0.5 ;
		$r = CORE::sqrt( $pi * 2 ) * ( $t ** ( $n - 0.5 ) ) * CORE::exp( $t * (-1) ) * $x ;
	}

	return ( defined $r ) ? __PACKAGE__->new( $r ) : $r ;
}

sub gamma_t {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   テイラー展開による実装。
	#
	#   精度は小数点以下 15 桁程度。
	#
	#   演算負荷が高いため、 Perl 標準の数値演算で実装。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	$n = $n->value()	if ( ref( $n ) eq __PACKAGE__ ) ;
	return undef		if ( ref( $n ) ) ;

	my $r = undef ;

	no warnings qw( recursion ) ;

	if ( $n < 0.5 ) {
		$r = gamma_t( $n + 1 ) / $n ;
	}
	elsif ( $n > 1.5 ) {
		$r = ( $n - 1 ) * gamma_t( $n - 1 ) ;
	}
	else {
		my $c = [
			 0.00000000000000000002 , -0.00000000000000000023 ,  0.00000000000000000141 ,
			 0.00000000000000000119 , -0.00000000000000011813 ,  0.00000000000000122678 ,
			-0.00000000000000534812 , -0.00000000000002058326 ,  0.00000000000051003703 ,
			-0.00000000000369680562 ,  0.00000000000778226344 ,  0.00000000010434267117 ,
			-0.00000000118127457049 ,  0.00000000500200764447 ,  0.00000000611609510448 ,
			-0.00000020563384169776 ,  0.00000113302723198170 , -0.00000125049348214267 ,
		 	-0.00002013485478078824 ,  0.00012805028238811619 , -0.00021524167411495097 ,
			-0.00116516759185906511 ,  0.00721894324666309954 , -0.00962197152787697356 ,
			-0.04219773455554433675 ,  0.16653861138229148950 , -0.04200263503409523553 ,
			-0.65587807152025388108 ,  0.57721566490153286061 ,  1.00000000000000000000 ,
		] ;

		$r = 0 ;

		foreach ( @{ $c } ) {
			$r *= ( $n - 1 ) ;
			$r += $_ ;
		}

		$r = 1 / $r ;
	}

	return ( defined $r ) ? __PACKAGE__->new( $r ) : $r ;
}

sub gamma_h {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   Hastigs による 8 次多項式近似。
	#
	#   任意の正の実数 n に対応しているが、精度は小数点以下 1 ～ 2 桁程度。
	#
	#-----------------------------------------------------------------------
	my( $n ) = @_ ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;
	return undef	if ( $n <= 0 ) ;

	my $c = [
		            1 ,
		 -0.577191652 , 0.988205891 ,
                 -0.897056937 , 0.918206857 ,
		 -0.756704078 , 0.482199394 ,
		 -0.193527818 , 0.035868343 ,
	] ;

	my $r1 = __PACKAGE__->new( 1 ) ;

	while ( $n > 1 ) {
		$r1 *= --$n ;
	}

	my $r = __PACKAGE__->new( $c->[8] ) ;
	foreach my $i ( reverse( 0 .. 7 ) ) {
		$r = $r * $n + $c->[ $i ] ;
	}

	return $r1 * $r / $n ;
}

sub zeta {
	#-----------------------------------------------------------------------
	#
	# リーマン・ゼータ関数
	#
	#   リーマン・ゼータ関数は以下の式で表現される。
	#
	#                        1
	#     zeta( s ) == Σ( ----- )       ( n == 1 -> ∞ )
	#                       n^s
	#
	#   非常に簡潔な数式だが、収束は恐ろしく遅い。
	#
	#   リーマン・ゼータ関数はガンマ関数を使用して
	#
	#                       1               u^( s - 1 )
	#     zeta( s ) == ------------ * ∫( --------------- ) * du 
	#                   gamma( s )         exp( u ) - 1
	#
	#   とも表現される。 ( これがどのくらいの速度で収束するのかはよく判らない。 )
	#
	#
	#   ディリクレの L 関数 ( Dirichlet L-function ) を介した定義では、
	#
	#                          1                    1
	#     zeta( s ) == ----------------- * Σ( ------------- * Σ( ( -1 )^k * nCk * ( k + 1 )^( -s ) ) )      ( n == 0 -> ∞ , k == 0 -> n )
	#                   1 - 2^( 1 - s )         2^( n + 1 )
	#
	#   と表現される。
	#
	#   ここでは、 s が偶数の場合には
	#
	#                                       B(2n) * ( 2 * PI )^( 2n )
	#     zeta( 2n ) == ( -1 )^( n + 1 ) * ---------------------------
	#                                            2 * ( 2 * n )!
	#
	#   負の整数の場合には
	#
	#                      B( n + 1 )
	#     zeta( -n ) == - ------------               ( n >= 1 )
	#                        n + 1
	#
	#   奇数の場合には、ディリクレの L 関数に基づく公式を用いている。
	#    
	#
	#
	#   オイラーによって示されたかなり有名な話として、
	#
	#                          1
	#     zeta( -1 ) == Σ( -------- ) == Σ( n ) == ∞       ( n == 1 -> ∞ )
	#                        n^(-1)
	#
	#                            B( 2 )        1/6        1
	#     zeta( - ( +1 ) ) == - -------- == - ----- == - ----
	#                              2            2         12
	#
	#   というものがある。
	#
	#   これは、
	#
	#     zeta( -1 ) を本来の定義通りに演算すると、自然数の総和となって無限大に発散する。
	#     一方、解析接続によって拡張された定義に照らすと、 -1/12 に収束する。
	#
	#   というもの。
	#
	#   多分、後者が前者の拡張版であることを意識しないと混乱するのではないかな？
	#   同じ s == -1 を代入して異なる結果が返るということは、少なくとも s == -1 に関しては両者は同じ世界を共有していないと言えるのでは？
	#   と言うことは、そもそも s == -1 では両者は「解析接続できていない」ということになるんじゃないのか？？？
	#   ( 後者の演算では積分定数 C が省略されており、この C が C == ∞ であると言う解釈もある。 )
	#
	#-----------------------------------------------------------------------
	my( $s ) = @_ ;

	$s = __PACKAGE__->new( $s )	unless ( ref( $s ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $s ) ;
	return undef	unless ( $s->is_integer() ) ;

	my $r = undef ;

	if ( $s < 0 ) {
		#
		#                  B( n + 1 )
		# zeta( -n ) == - ------------               ( n >= 1 )
		#                    n + 1
		#
		$s = $s * (-1) + 1 ;
		$r = $s->bernoulli() * ( -1 ) / $s ;
	}
	elsif ( $s->is_even() ) {
		#
		#                                   B(2n) * ( 2 * PI )^( 2n )
		# zeta( 2n ) == ( -1 )^( n + 1 ) * ---------------------------
		#                                        2 * ( 2 * n )!
		#
		$s /= 2 ;
		$r = ( __PACKAGE__->new( -1 )->power( $s + 1 ) )
		   * ( ( $s * 2 )->bernoulli() * ( pi() * 2 )->power( $s * 2 ) )
		   / ( ( $s * 2 )->factorial() * 2 )
		;
	}
	else {
		#
		# ディリクレの L 関数に基づく近似 ( 精度は小数点以下 16 桁程度 )
		#
		#                      1                    1
		# zeta( s ) == ----------------- * Σ( ------------- * Σ( ( -1 )^k * nCk * ( k + 1 )^( -s ) ) )      ( n == 0 -> ∞ , k == 0 -> n )
		#               1 - 2^( 1 - s )         2^( n + 1 )
		#
		$r = __PACKAGE__->new( 0 ) ;
		my $n = 0 ;
		while () {
			my $c1 = 1 / ( 2 ** ( $n + 1 ) ) ;
			my $c2 = 0 ;
			my $nck = [ nCkAll( $n ) ] ;
			foreach ( my $k = 0 ; $k <= $n ; $k++ ) {
				$c2 += ( $nck->[ $k ]->value() / ( ( $k + 1 ) ** $s->value() ) ) * ( ( -1 ) ** $k ) ;
			}
			my $diff = __PACKAGE__->new( $c1 * $c2 ) ;
			last	unless ( defined $diff ) ;
			last	if ( $diff->round( 128 ) == 0 ) ;
			$r += $diff ;
			$n++ ;
		}
		$r /= ( __PACKAGE__->new( 1 ) - __PACKAGE__->new( 2 )->power( __PACKAGE__->new( 1 ) - $s ) ) ;
		$r = $r->round( 16 )	if ( defined $r ) ;
	}

	return ( defined $r ) ? $r->decimal() : $r ;
}

sub zeta_euler_product {
	#-----------------------------------------------------------------------
	#
	# オイラー積によるゼータ関数
	#
	#                         1
	#   zeta( s ) == Π( ------------ )         ( p == all primes )
	#                     1 - p^(-s)
	#
	#-----------------------------------------------------------------------
	my( $s ) = @_ ;

	$s = __PACKAGE__->new( $s )	unless ( ref( $s ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $s ) ;

	my $numer = __PACKAGE__->new( 1 ) ;
	my $denom = __PACKAGE__->new( 1 ) ;
	foreach my $p ( __PACKAGE__->new( 40000 )->primes() ) {
		#
		#                       1                     1                    1                  p^s
		# zeta( s ) == Π( ------------ ) == Π( ----------- ) == Π( ----------- ) == Π( --------- )
		#                   1 - p^(-s)                  1               p^s - 1             p^s - 1 
		#                                         1 - -----            ---------
		#                                              p^s                p^s
		#
		my $pps = $p->power( $s ) ;
		$numer *= $pps ;
		$denom *= ( $pps - 1 ) ;
	}
	my $r = $numer / $denom ;
	return $r->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
}

=head2 mersenne

Return mersenne number.

  mersenne( p ) == 2^p - 1

  print decimal( 0 )->mersenne() ;         # 0
  print decimal( 1 )->mersenne() ;         # 1
  print decimal( 2 )->mersenne() ;         # 3
  print decimal( 3 )->mersenne() ;         # 7
  print decimal( 4 )->mersenne() ;         # 15
  print decimal( 5 )->mersenne() ;         # 31

=cut

sub mersenne {
	#-----------------------------------------------------------------------
	#
	# メルセンヌ数
	#
	#   引数として以下の計算式で使用する指数 $p を受け取り、メルセンヌ数 $n を生成する。
	#
	#     $n == ( 2 ** $p ) - 1
	#
	#-----------------------------------------------------------------------
	my $p = shift ;

	$p = 2				unless ( defined $p ) ;
	$p = __PACKAGE__->new( $p )	unless ( ref( $p ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $p ) ;

	my $n = __PACKAGE__->new( 2 )->power( $p ) - 1 ;

	return $n ;
}

=head2 mersenne_power

This method accept mersenne number n == 2^p - 1 , and return p.

  print decimal( 30 )->mersenne_power() ;   # undef  ( 30 is not a mersenne number )
  print decimal( 31 )->mersenne_power() ;   # 5      ( 31 == 2^5 - 1 )


If the integer value n is a mersenne number,

  n == 2^p - 1

  -> n + 1 == 2^p == 0b10000000.......

Then

  p == length( bin( n + 1 ) ) - 1


=cut

sub mersenne_power {
	#-----------------------------------------------------------------------
	#
	# メルセンヌ数を構成する指数を返す。
	#
	#   $n がメルセンヌ数であれば、
	#
	#     $n == ( 2 ** $p ) - 1
	#     -> 2 ** $p == $n + 1 == 0b1000........
	#
	#   であり、求める指数 $p は、 $n + 1 を 2 進数表記した時の連続する 0 の長さに等しくなる。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	my $m = $n + 1 ;
	my $bin = $m->bin() ;
	return undef	unless ( $bin =~ /^10+$/ ) ;

	my $p = length( $bin ) - 1 ;

	return __PACKAGE__->new( $p ) ;
}

=head2 is_mersenne

Return a value is mersenne number or not.

  print decimal( 30 )->is_mersenne() ;          # 0
  print decimal( 31 )->is_mersenne() ;          # 1   ( 31 == 2^5 - 1 )

=cut

sub is_mersenne {
	#-----------------------------------------------------------------------
	#
	# メルセンヌ数かどうかを返す。
	#
	#-----------------------------------------------------------------------
	return ( defined $_[0]->mersenne_power() ) ? 1 : 0 ;
}

=head2 fibonacci

Return fibonacci number

  fibonacci( 0 ) == 0
  fibonacci( 1 ) == 1
  fibonacci( 2 ) == fibonacci( 0 ) + fibonacci( 1 ) == 0 + 1 == 1
  fibonacci( 3 ) == fibonacci( 1 ) + fibonacci( 2 ) == 1 + 1 == 2
  fibonacci( 4 ) == fibonacci( 2 ) + fibonacci( 3 ) == 1 + 2 == 3


  print decimal( 4 )->fibonacci() ;      # 3
  print decimal( 5 )->fibonacci() ;      # 5
  print decimal( 10 )->fibonacci() ;     # 55

=cut

sub fibonacci {
	#-----------------------------------------------------------------------
	#
	# フィボナッチ数 ( Fibonacci number )
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			if ( $n < 0 ) ;

	my $r = [] ;
	my $i = __PACKAGE__->new( -1 ) ;

	while ( ++$i <= $n ) {
		if ( $i < 3 ) {
			if	( $i == 0 )	{ $r->[0] = __PACKAGE__->new( 0 ) ; next ; }
			elsif	( $i == 1 )	{ $r->[1] = __PACKAGE__->new( 1 ) ; next ; }
			elsif	( $i == 2 )	{ $r->[2] = $r->[1] + $r->[0] ; next ; }
		}

		shift( @{ $r } ) ;
		$r->[2] = $r->[1] + $r->[0] ;
	}

	return $r->[-1] ;
}

=head2 fibonacci_seq

Return fibonacci sequence.

  print join ' ' , decimal( 10 )->fibonacci_seq() ;     # 0 1 1 2 3 5 8 13 21 34 55
  print join ' ' , decimal( 20 )->fibonacci_seq() ;     # 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765

=cut

sub fibonacci_seq {
	#-----------------------------------------------------------------------
	#
	# フィボナッチ数列 ( Fibonacci sequence )
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			if ( $n < 0 ) ;

	return ( __PACKAGE__->new( 0 ) )				if ( $n < 1 ) ;
	return ( __PACKAGE__->new( 0 ) , __PACKAGE__->new( 1 ) )	if ( $n < 2 ) ;

	my $r = [
		__PACKAGE__->new( 0 ) ,
		__PACKAGE__->new( 1 ) ,
	] ;

	my $i = __PACKAGE__->new( 1 ) ;

	while ( ++$i <= $n ) {
		$r->[ $i ] = $r->[ $i - 1 ] + $r->[ $i - 2 ] ;
	}

	return @{ $r } ;
}

=head2 lucas_number

Return Lucas number.

The Lucas number is similar to Fibonacci number.

   print decimal( 0 )->lucas_number() ;            # 2
   print decimal( 1 )->lucas_number() ;            # 1
   print decimal( 2 )->lucas_number() ;            # 3    ( 3 == 2 + 1 )
   print decimal( 3 )->lucas_number() ;            # 4    ( 4 == 1 + 3 )
   print decimal( 4 )->lucas_number() ;            # 7    ( 7 == 3 + 4 )
   print decimal( 5 )->lucas_number() ;            # 11   ( 11 == 4 + 7 )

=cut

sub lucas_number {
	#-----------------------------------------------------------------------
	#
	# リュカ数 ( Lucas number )
	#
	# 初期値が異なるだけで処理内容はフィボナッチ数と同じ。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			if ( $n < 0 ) ;

	my $r = [] ;
	my $i = __PACKAGE__->new( -1 ) ;

	while ( ++$i <= $n ) {
		if ( $i < 3 ) {
			if	( $i == 0 )	{ $r->[0] = __PACKAGE__->new( 2 ) ; next ; }
			elsif	( $i == 1 )	{ $r->[1] = __PACKAGE__->new( 1 ) ; next ; }
			elsif	( $i == 2 )	{ $r->[2] = $r->[1] + $r->[0] ; next ; }
		}

		shift( @{ $r } ) ;
		$r->[2] = $r->[1] + $r->[0] ;
	}

	return $r->[-1] ;
}

=head2 lucas_seq_assoc

Return Asssociated Lucas sequence.

  print join ' ' , decimal( 10 )->lucas_seq_assoc() ;      # 2 1 3 4 7 11 18 29 47 76 123
  print join ' ' , decimal( 20 )->lucas_seq_assoc() ;      # 2 1 3 4 7 11 18 29 47 76 123 199 322 521 843 1364 2207 3571 5778 9349 15127

=cut

sub lucas_seq_assoc {
	#-----------------------------------------------------------------------
	#
	# 同伴リュカ数列 ( Associated Lucas sequence )
	#
	# 初期値が異なるだけで処理内容はフィボナッチ数列と同じ。
	#
	# 「リュカ数列」はより一般化されたリュカ数列を意味するので呼称を変えてある。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			if ( $n < 0 ) ;

	return ( __PACKAGE__->new( 2 ) )				if ( $n < 1 ) ;
	return ( __PACKAGE__->new( 2 ) , __PACKAGE__->new( 1 ) )	if ( $n < 2 ) ;

	my $r = [
		__PACKAGE__->new( 2 ) ,
		__PACKAGE__->new( 1 ) ,
	] ;

	my $i = __PACKAGE__->new( 1 ) ;

	while ( ++$i <= $n ) {
		$r->[ $i ] = $r->[ $i - 1 ] + $r->[ $i - 2 ] ;
	}

	return @{ $r } ;
}

=head2 fermart_number

Return Fermat number.

  fermat_number( n ) == 2^( 2^n ) + 1

  print decimal( 0 )->fermat_number() ;          # 3
  print decimal( 1 )->fermat_number() ;          # 5
  print decimal( 2 )->fermat_number() ;          # 17
  print decimal( 3 )->fermat_number() ;          # 257
  print decimal( 4 )->fermat_number() ;          # 65537
  print decimal( 5 )->fermat_number() ;          # 4294967297
  print decimal( 6 )->fermat_number() ;          # 18446744073709551617

=cut

sub fermat_number {
	#-----------------------------------------------------------------------
	#
	# フェルマー数
	#
	#   Fn = 2^( 2^n ) + 1
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;
	return undef			if ( $n < 0 ) ;

	my $two = __PACKAGE__->new( 2 ) ;
	my $r = $two->power( $two->power( $n ) ) + 1 ;

	return $r ;
}

=head2 nth_fermat

Return is n-th fermat number.

If the integer value F(n) is

  F(n) == 2^( 2^n ) + 1

then, this method will return "n".


  print decimal( 256 )->nth_fermat() ;      # undef ( 256 is not a fermat number )
  print decimal( 257 )->nth_fermat() ;      # 3     ( 257 is a third fermat number )

=cut

sub nth_fermat {
	#-----------------------------------------------------------------------
	#
	# フェルマー数を生成する際に用いられる n の値を返す。
	#
	#   フェルマー数
	#
	#     Fn = 2^( 2^n ) + 1
	#
	#   における n を返すということ。
	#
	#   引数で与えられた数値がフェルマー数でなければ undef を返す。
	#
	#-----------------------------------------------------------------------
	my $fn = shift ;
	return undef	unless ( defined $fn ) ;

	$fn = __PACKAGE__->new( $fn )	unless ( ref( $fn ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $fn ) ;

	#
	# $fn - 1 ( 2 の冪 ) の乗数を求める。
	#
	my $m = $fn - 1 ;
	return undef	unless ( $m->is_even() ) ;

	my $bin = $m->bin() ;
	return undef	unless ( $bin =~ /^10+$/ ) ;

	my $pow = length( $bin ) - 1 ;

	#
	# 取り出した乗数を更に 2 の冪として扱い、その乗数を求める。
	#
	$bin = __PACKAGE__->new( $pow )->bin() ;
	return undef	unless ( $bin =~ /^10+$/ ) ;

	my $n = length( $bin ) - 1 ;

	return __PACKAGE__->new( $n ) ;
}

=head2 is_fermat_number

Return a value is a Fermat number or not.

  print decimal( 256 )->is_fermat() ;      # 0
  print decimal( 257 )->is_fermat() ;      # 1

=cut

sub is_fermat_number {
	#-----------------------------------------------------------------------
	#
	# フェルマー数の判定
	#
	#-----------------------------------------------------------------------
	my $fn = shift ;
	return undef	unless ( defined $fn ) ;

	$fn = __PACKAGE__->new( $fn )	unless ( ref( $fn ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $fn ) ;
	return 0			if ( $fn < 0 ) ;

	return 0	if ( $fn->is_even() ) ;			# フェルマー数は必ず奇数
	return 0	if ( $fn < 3 ) ;
	return 1	if ( $fn->value() =~ /^[35]$/ ) ;	# 3 , 5 はフェルマー数

	#
	# フェルマー数 Fn の n で判定 ( n >= 0 )
	#
	return 0	unless ( $fn->nth_fermat() ) ;
	return 1 ;
}

sub pepin_test {
	#-----------------------------------------------------------------------
	#
	# ぺパン ( Pepin ) によるフェルマー素数の判定法
	#
	#   3^( ( Fn - 1 ) / 2 ) ≡ -1 ( mod Fn )
	#
	#   フェルマー数は非常に大きな値となりやすく、冪剰余演算に伴う負荷が高くなる。
	#
	#   F0 == 3 , F1 == 5 , F2 == 17 , F3 == 257 , F4 == 65537 が素数である事は知られているが、
	#   F5 以降の素数はまだ見つかっていない。
	#
	#-----------------------------------------------------------------------
	my $fn = shift ;
	return undef	unless ( defined $fn ) ;

	$fn = __PACKAGE__->new( $fn )	unless ( ref( $fn ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $fn ) ;
	return 0			if ( $fn < 0 ) ;

	return undef	unless ( $fn->is_odd() ) ;		# フェルマー数は必ず奇数
	return undef	unless ( $fn->is_fermat_number() ) ;	# フェルマー数かどうか

	my $ev = $fn - 1 ;
	my $m = __PACKAGE__->new( 3 )->modexp( $ev * 0.5 , $fn ) ;

	return 1	if ( $m == $ev ) ;
	return 0 ;
}

sub fermat_factor {
	#-----------------------------------------------------------------------
	#
	# フェルマー数の素因数を一つ返す。
	#
	#   オイラー ( Euler ) によるフェルマー数の分解法。
	#
	#   フェルマー数 Fn が合成数であるならば、その素因数 p は以下の合同式で表現される。
	#
	#     p ≡ 1 ( mod 2^( n + 1 ) )
	#
	#   よって、 p は任意の正の整数 k を伴って
	#
	#     p = k * 2^( n + 1 ) + 1
	#
	#   で表される値となる。
	#
	#   k を効率的に導く方法は無く、試し割りをするしかない。
	#   n の値によってかなりの確率で不規則に k が非常に大きな値となるため、実用性は低い。
	#
	#-----------------------------------------------------------------------
	my $fn = shift ;
	return undef	unless ( defined $fn ) ;

	$fn = __PACKAGE__->new( $fn )	unless ( ref( $fn ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $fn ) ;

	my $n = $fn->nth_fermat() ;
	return undef	unless ( defined $n ) ;
	return $fn	if ( $n < 5 ) ;		# F0 - F4 までは全て素数。

	my $m = __PACKAGE__->new( 2 )->power( $n + 1 ) ;
	my $k = __PACKAGE__->new( 1 ) ;
	my $p = ( $k * $m ) + 1 ;
	while ( ( $p * $p ) <= $fn ) {
		return $p	if ( $fn->modulus( $p )->is_zero() ) ;
		$p = ( ++$k * $m ) + 1 ;
	}

	return undef ;
}

=head2 totient

Euler's totient function.

  totient( n ) == a count of gcd( n , k ) == 1      ( k == 1 -> n - 1 )

If n is prime, totient( n ) == n - 1.
else needs high cost calculation.

  totient( 36 ) == totient( 2^2 * 3^2 )
                == 36 * ( 1 - 1/2 ) * ( 1 - 1/3 )
                == 36 * 1/2 * 2/3
                == 12

totient( n ) can also be defined using by Fourier transformation.

                                                     k
  totient( n ) == sum( gcd( k , n ) * cos( PI * 2 * --- ) )         ( k == 0 -> n - 1 )
                                                     n



  print decimal( 3 )->totient() ;        # 2  ( 3 is prime then totient( 3 ) == 3 - 1 == 2 )
  print decimal( 36 )->totient() ;       # 12
  print decimal( 256 )->totient() ;      # 128


=cut

sub totient {
	#-----------------------------------------------------------------------
	#
	# オイラーのトーシェント関数 ( Euler's totient function )
	#
	#   別名：オイラーのファイ ( φ ; phi ) 関数
	#
	#   任意の整数 n について 0 < k < n となる整数 k について n と互いに素となる k の総数を返す。
	#  「互いに素」とは「 1 以外に公約数を持たない」と言う意味だが、トーシェント関数は 1 を含めた数を返す。
	#
	#   つまり、「 n より小さい正の整数から n の因数を取り除いた整数の個数」となる。
	#   ただし、 n == 1 の場合にはトーシェント関数は 1 を返すことになっている。
	#
	#
	#   一般的な定義
	#
	#     任意の素数を p とおくと、 p には因数が存在しないことから
	#
	#       phi( p ) == p - 1
	#
	#     となる。
	#
	#     素数 p の冪を任意の自然数 k を用いて p^k で表すと、 p^k の因数は p の倍数であり、その数は p^( k - 1 ) 個存在する。
	#     よって、
	#
	#       phi( p^k ) == p^k - p^( k - 1 )
	#
	#                                  1
	#                  == p^k * ( 1 - --- )
	#                                  p
	#     となる。
	#
	#     全ての自然数は素因数の冪の総乗で表されることから、
	#     任意の自然数を n とおき、その素因数を p1 , p2 , .... , pk とおくと、
	#
	#                              1              1                       1
	#       phi( n ) == n * ( 1 - ---- ) * ( 1 - ---- ) * ...... * ( 1 - ---- )
	#                              p1             p2                      pk
	#
	#     と表される。
	#
	#     例 )
	#
	#       phi( 36 ) == phi( 2^2 * 3^2 )
	#                 == 36 * ( 1 - 1/2 ) * ( 1 - 1/3 )
	#                 == 36 * 1/2 * 2/3
	#                 == 12
	#
	#     
	#     phi( n ) は、 0 < k < n となる自然数 k について、「 n と互いに素な k の数」なので、
	#     全ての k / n となる分数を通分した時に分母が変化しないものの数と考えることもできる。
	#
	#
	#
	#   フーリエ変換との関係
	#
	#     フーリエ変換の関数を F{x} 、その m 番目の値を F{x}[m] で表現し、
	#
	#                                                      m * k
	#       F{x}[m] == Σ( x[k] * exp( i * ( -1 ) * 2PI * ------- ) )         ( k == 0 -> ( n - 1 ) , x[k] == gcd( k , n ) )
	#                                                        n
	#
	#     という関係を定義すると、
	#
	#                                                                      k
	#       phi( n ) == F{x}[1] == Σ( gcd( k , n ) * exp( ( -1 ) * 2PI * --- ) )
	#                                                                      n
	#
	#     となるらしい。
	#     ここから、
	#
	#                                                  k
	#       phi( n ) == Σ( gcd( k , n ) * cos( 2PI * --- ) )      ( k == 0 -> n - 1 )
	#                                                  n
	#
	#     と表現できるとのこと。
	#
	#
	#  トーシェント関数の性質
	#
	#     a | b -> phi( a ) | phi( b )            a が b の因数であれば phi( a ) は phi( b ) の因数。
	#     n | phi( a^n - 1 )   ( a , n > 1 )      n が a^n - 1 で表されるならば n は phi( a^n - 1 ) の因数。
	#
	#     phi( m * n ) == phi( m ) * phi( n ) * ( d / phi( d ) )        ( d == gcd( m , n ) )
	#
	#     phi( 2 * m ) == 2 * phi( m )           if ( m is even )
	#                  == phi( m )               if ( m is odd )
	#
	#     phi( n^m ) == n^( m - 1 ) * phi( n )
	#
	#     phi( lcm( m , n ) ) * phi( gcd( m , n ) ) == phi( m ) * phi( n )
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return undef	unless ( $n->is_integer() ) ;
	return undef	if ( $n < 0 ) ;
	return $n	if ( $n == 1 ) ;

	my $k = ( defined $_[0] ) ? __PACKAGE__->new( shift ) : __PACKAGE__->new( 1 ) ;
	return undef			unless ( defined $k ) ;

	return undef	unless ( $k->is_integer() ) ;
	return undef	if ( $k < 0 ) ;

	my $r = undef ;

	if ( $n->is_prime() ) {
		#
		# 引数が素数の冪であり、その素因数と冪乗数が自明であれば減算で求めることができる。
		#
		#   phi( p^k ) == p^k - p^(k-1)
		#
		# これは素数 p について
		#
		#   phi( p ) == p - 1
		#
		# であることを素数の冪乗数について一般化したもの。
		# p^(k-1) は p^k 以下の数列内の p の倍数の数を表している。
		#
		$r = $n->power( $k ) - $n->power( $k - 1 ) ;
	}
	else {
		#
		# 引数が合成数又は合成数の冪で与えられている場合には、素因数分解を行う。
		# 得られた素因数とその乗数で値を求め、その総乗を採る。
		#
		my $pf = [ $n->prime_factor() ] ;
		if ( @{ $pf } > 0 ) {
			if ( $k > 1 ) {
				foreach ( @{ $pf } ) {
					$_->{'power'} *= $k ;
				}
			}

			$r = __PACKAGE__->new( 1 ) ;
			foreach my $p ( @{ $pf } ) {
				#
				# phi( mn ) == phi( m ) * phi( n )
				#
				$r *= totient( $p->{'factor'} , $p->{'power'} ) ;
			}
		}
		else {
			$r = totient_basic( $n ** $k ) ;
		}
	}

	return $r ;
}

sub totient_basic {
	#-----------------------------------------------------------------------
	#
	# オイラーのトーシェント関数 ( Euler's totient function )
	#
	# 定義に基づいて実直に実装した場合の例。
	#
	#-----------------------------------------------------------------------
	my $n = shift ;
	return undef	unless ( defined $n ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $n ) ;

	return undef	unless ( $n->is_integer() ) ;
	return undef	if ( $n < 0 ) ;

	return $n->add( '-1' )	if ( $n->is_prime() ) ;

	my $bitmap = '' ;
	vec( $bitmap , $n , 1 ) = 0 ;

	#
	# $n が偶数であれば 2 の倍数にビットを立てる。
	#
	if ( $n->is_even() ) {
		my $i = __PACKAGE__->new( 2 ) ;
		while ( $i < $n ) {
			vec( $bitmap , $i , 1 ) = 1 ;
			$i += 2 ;
		}
	}

	#
	# $n の素因数の倍数にビットを立てる。
	# ここでは奇数の奇数倍のみを扱う。
	#
	my $i = __PACKAGE__->new( 3 ) ;
	while ( ( $i * 2 ) < $n ) {
		if ( $n->modulus( $i ) == 0 ) {
			vec( $bitmap , $i , 1 ) = 1 ;
			my $j = __PACKAGE__->new( 3 ) ;
			while ( ( $i * $j ) < $n ) {
				vec( $bitmap , ( $i * $j ) , 1 ) = 1 ;
				$j += 2 ;
			}
		}
		$i += 2 ;
	}

	#
	# ビットが落ちている数値を数える。
	#
	$i = __PACKAGE__->new( 1 ) ;
	my $r = __PACKAGE__->new( 0 ) ;
	while ( $i < $n ) {
		if ( vec( $bitmap , $i , 1 ) == 0 ) {
			$r++ ;
		}
		$i++ ;
	}

	return $r ;
}

sub phi	{ return totient( @_ ) ; }

sub sgn {
	#-----------------------------------------------------------------------
	#
	# 対称群における置換 ( permutation ) の符号 ( signature )
	#
	#   置換の符号とは、与えられた数値配列が偶置換 ( even permutation ) か奇置換 ( odd permutation ) かを示す符号のこと。
	#
	#   置換の内、2 つの要素を入れ替えることを互換 ( transposition ) と呼ぶ。
	#   置換は互換の積として表される。
	#   互換が偶数回行われた置換を偶置換、奇数回行われた置換を奇置換と呼ぶ。 ( 置換の偶奇性 ; parity )
	#
	#   置換の偶奇性の判定は、与えられた数値配列とそれをソートしたものを比較し、与えられた数値配列が
	#   ソートされた状態から偶数回の互換を経たものか奇数回の互換を経たものかを判定することを意味する。
	#
	#   ただし、配列要素の中に同じ数値が複数回現われる場合には、偶奇性はない ( 偶置換でも奇置換でもない ) ものとする。
	#
	#
	#   ここでは、配列要素同士の差積を採ることで偶奇性を判定する。
	#   偶置換であれば 1 を奇置換であれば -1 をどちらでもなければ 0 を返す。
	#
	#-----------------------------------------------------------------------
	my( @n ) = @_ ;

	return undef	unless ( @n ) ;

	if ( ref( $n[0] ) eq 'ARRAY' ) {
		@n = @{ $n[0] } ;
	}

	foreach ( @n ) {
		$_ = __PACAKGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
	}

	#
	# 配列要素の前半部分を順次取り出し、その位置より後方に位置する全要素との間で大小の比較を行う
	# 大小の比較を減算で実装することにより、互換が発生していれば負の値が返るようにする。
	# これを繰り返しながら減算の結果を全て積算していくと、結果は正負または 0 の何れかに帰着する。
	# 最終的な演算結果が正の値であれば偶置換であり、負であれば奇置換ということになる。
	#
	my $r = undef ;
	foreach my $i ( 0 .. CORE::int( $#n / 2 ) ) {
		foreach my $j ( ( $i + 1 ) .. $#n ) {
			my $v = ( $n[ $j ] - $n[ $i ] ) ;
			if ( defined $r )	{ $r *= $v ; }
			else			{ $r = __PACAKGE__->new( $v ) ; }
			last	if ( $r == 0 ) ;
		}
		last	if ( $r == 0 ) ;
	}

	$r = __PACAKGE__->new( $r )	unless ( ref( $r ) eq __PACKAGE__ ) ;

	unless ( $r == 0 ) {
		$r /= $r->abs() ;	# 符号のみを残す。
	}

	return $r ;
}

=head1 'Decimal' object - radix conversion.

=cut

#-------------------------------------------------------------------------------
#
# 変換
#
#-------------------------------------------------------------------------------
sub radix_to {
	#-----------------------------------------------------------------------
	#
	# 基数変換
	#
	# 添え字が基数 ( 底 ) の対数 ( 冪指数 ) となるような配列を返す。
	# 添え字は指定された基数における 0 から始まる桁番号に等しい。
	#
	# 10 進数 8 を基数 2 で評価すると、戻り値は ( 0 , 0 , 0 , 1 ) となる。
	# これは、
	#
	#   8 == 0 * 2^0 + 0 * 2^1 + 0 * 2^2 + 1 * 2^3
	#
	# を表す。
	#
	#-----------------------------------------------------------------------
	my( $self , $radix ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless ( defined $radix ) ;
	return ()	unless ( $radix=~ /^\d+$/ ) ;

	if ( $self->{'dlen'} > 0 ) {
		return $self->decimal_radix_to( $radix ) ;
	}

	my $r2l = 0 ;
	my @r = () ;

	if ( $r2l ) {
		#
		# 下位 -> 上位桁への演算
		#
		# 基数で割った余りを配列に格納しながら商を繰り返し割っていくと言う流れ。
		# ロジックは単純だが、比較的大きな数値を小さな基数で割る場合、商の収束が非常に遅くなり、処理効率が悪い。
		#
		my $n = $self->copy() ;
		my $m = 0 ;
		while ( $n > 0 ) {
			( $n , $m ) = $n->divmod( $radix ) ;
			push( @r , $m ) ;
		}
	}
	else {
		#
		# 上位 -> 下位桁への演算
		#
		# 基数の冪で割った商を配列に格納しながら余りを繰り返し割っていくと言う流れ。
		# 基数の冪乗を桁合わせしながら割ることにより、商がその桁の値となる。
		#
		# 演算の過程で基数の冪の方が大きい状況が発生した場合には、商が 0 であることが明白であり、その分の演算を省略することができる。
		# 演算の過程で被除数が基数の冪と等しい状況が発生した場合には、その桁 ( 商 ) は 1 であり、残りの桁は全て 0 となる。
		# 同様に、被除数が基数の冪より 1 だけ小さい状況が発生した場合には、その桁 ( 商 ) は 0 であり、残りの桁は全て ( 基数 - 1 ) となる。
		#
		# 基数の冪を求める演算 ( 桁上げと桁下げ ) に余分なコストがかかるが、そのコストは限定的。
		#
		my $n = 0 ;					# 商
		my $m = $self->copy() ;				# 剰余
		my $divisor = __PACKAGE__->new( $radix ) ;	# 除数
		my $rdxpow = 1 ;				# $divisor == $radix ** $rdxpow 
		my $hvalue = $radix - 1 ;			# the high value in each digits.
		
		#
		# 除数 ( $divisor ) を桁上げ
		#
		#   $divisor == $radix ** $rdxpow となるように管理する。
		#
		while ( $m >= $divisor ) {
			$divisor *= $radix ;
			$rdxpow++ ;
		}

		#
		# 変換
		#
		while ( $divisor >= $radix ) {
			if ( $m == $divisor ) {
				#
				# 被除数が除数 ( 基数の冪乗 ) と等しいケース。
				#
				# 現在の桁が 1 となり、残りが全て 0 となる。
				#
				unshift( @r , 1 ) ;
				foreach ( my $i = 0 ; $i < $rdxpow ; $i++ ) {
					unshift( @r , 0 ) ;
				}
				undef $m ;
				last ;
			}
			elsif ( $m < $divisor ) {
				#
				# 被除数が除数よりも小さいケース。
				#
				# このケースには、被除数が ( 基数の冪乗 - 1 ) と等しいケースがあり得る。
				# 被除数を $m , 基数を $r , 基数の乗数を $p とした時、
				#
				#   $m == ( $r ** $p ) - 1
				#
				# であれば、 0 .. ( $p - 1 ) 桁の全てが ( $r - 1 ) で埋められた値になる。
				#
				# 例)
				#
				#    2^4 - 1 == 0b10000 - 1 == 0b01111
				#   16^4 - 1 == 0x10000 - 1 == 0x0FFFF
				#
				unshift( @r , 0 ) ;
				if ( $m == ( $divisor - 1 ) ) {
					foreach ( my $i = 0 ; $i < $rdxpow ; $i++ ) {
						unshift( @r , $hvalue ) ;
					}
					undef $m ;
					last ;
				}
			}
			else {
				#
				# 商が現在の桁の値。
				# 剰余は次回の被除数。
				#
				( $n , $m ) = $m->divmod( $divisor , 0 ) ;
				unshift( @r , $n ) ;
			}

			#
			# 除数を桁下げ
			#
			$divisor = $divisor->divide( $radix , 0 ) ;
			$rdxpow-- ;
		}

		#
		# 残っている剰余値は最下位の桁の値
		#
		unshift( @r , $m )	if ( defined $m ) ;
	}

	while ( @r > 1 and $r[-1] == 0 ) {
		pop( @r ) ;
	}

	return @r ;
}

sub decimal_radix_to {
	#-----------------------------------------------------------------------
	#
	# 小数値の基数変換
	#
	# 整数部と小数部を個別に変換した配列参照を返す。
	# ( 整数の基数変換では変換後の各桁を格納した配列を返す。 )
	#
	#-----------------------------------------------------------------------
	my( $self , $radix ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless ( defined $radix ) ;
	return ()	unless ( $radix=~ /^\d+$/ ) ;

	#
	# 整数部と小数部に分ける。
	#
	my $n = [ split( /\./ , $self->value() ) ] ;

	#
	# 整数部を変換
	#
	# 整数部は 0 -> ∞ の向きに並ぶ。
	#
	my $r = [ [] , [] ] ;
	$r->[0] = [ __PACKAGE__->new( $n->[0] )->radix_to( $radix ) ] ;

	#
	# 小数値の形をした整数であれば、整数部を基数変換した結果を配列で返す。
	#
	if ( ! defined $n->[1] or $n->[1] =~ /^0+$/ ) {
		return @{ $r->[0] } ;
	}

	#
	# 小数部を変換
	#
	# 小数部は 1 -> 0 の向きに並べる。
	#
	my $dp = __PACKAGE__->new( '0.' . $n->[1] ) ;
	while ( @{ $r->[1] } < $DECIMAL_PART_LENGTH_LIMIT ) {
		$dp *= $radix ;
		my $i = $dp->integer() ;
		push( @{ $r->[1] } , $i ) ;
		$dp -= $i ;
		last	if ( $dp->is_zero() ) ;
	}

	return $r ;
}

=head2 bin

Return binary format as string.

  print decimal( 10 )->bin() ;              # 1010
  print decimal( 2 )->power( 32 )->bin() ;  # 100000000000000000000000000000000
  print decimal( 0.1 )->bin() ;             # 0.0001100110011001100110011001100110011001

=cut

sub bin {
	#-----------------------------------------------------------------------
	#
	# 2 進数変換
	#
	# オブジェクトが保持している数値を 2 進数文字列に変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @r = $self->abs()->radix_to( 2 ) ;
	my $sgn = ( $self < 0 ) ? '-' : '' ;

	#
	# 戻り値が整数であれば一次元の配列が返る。
	#
	return  $sgn . join( '', reverse( @r ) )	unless ( ref( $r[0] ) eq 'ARRAY' ) ;

	#
	# 戻り値が小数であれば $r[0] に配列参照が返る。
	#
	my $bin = $sgn . join( '.' ,
		join( '' , reverse( @{ $r[0]->[0] } ) ) ,	# 整数部は 0 -> ∞ 方向に並んでいる。
		join( '' , @{ $r[0]->[1] } ) ,			# 小数部は 1 ->  0 方向に並んでいる。
	) ;

	return $bin ;
}

=head2 oct

Return octal format as string.

  print decimal( 10 )->oct() ;              # 12
  print decimal( 0.1 )->oct() ;             # 0.0631463146314631463146314631463146314631

=cut

sub oct {
	#-----------------------------------------------------------------------
	#
	# 8 進数変換
	#
	# オブジェクトが保持している数値を 8 進数文字列に変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @r = $self->abs()->radix_to( 8 ) ;
	my $sgn = ( $self < 0 ) ? '-' : '' ;

	#
	# 戻り値が整数であれば一次元の配列が返る。
	#
	return $sgn . join( '', reverse( @r ) )	unless ( ref( $r[0] ) eq 'ARRAY' ) ;

	#
	# 戻り値が小数であれば $r[0] に配列参照が返る。
	#
	my $oct = $sgn . join( '.' ,
		join( '' , reverse( @{ $r[0]->[0] } ) ) ,	# 整数部は 0 -> ∞ 方向に並んでいる。
		join( '' , @{ $r[0]->[1] } ) ,			# 小数部は 1 ->  0 方向に並んでいる。
	) ;

	return $oct ;
}

=head2 hex

Return hexadecimal format as string.

  print decimal( 10 )->hex() ;              # A
  print decimal( 0.1 )->hex() ;             # 0.1999999999999999999999999999999999999999

=cut

sub hex {
	#-----------------------------------------------------------------------
	#
	# 16 進数変換
	#
	# オブジェクトが保持している数値を 16 進数文字列に変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @r = $self->abs()->radix_to( 16 ) ;
	my $sgn = ( $self < 0 ) ? '-' : '' ;

	my $hex = undef ;

	unless ( ref( $r[0] ) eq 'ARRAY' ) {
		#
		# 戻り値が整数であれば一次元の配列が返る。
		#
		foreach ( @r ) {
			/^10$/	&& do { $_ = 'A' ; } ;
			/^11$/	&& do { $_ = 'B' ; } ;
			/^12$/	&& do { $_ = 'C' ; } ;
			/^13$/	&& do { $_ = 'D' ; } ;
			/^14$/	&& do { $_ = 'E' ; } ;
			/^15$/	&& do { $_ = 'F' ; } ;
		}
		$hex = $sgn . join( '' , reverse( @r ) ) ;
	}
	else {
		#
		# 戻り値が小数であれば $r[0] に配列参照が返る。
		#
		foreach ( @{ $r[0]->[0] } , @{ $r[0]->[1] } ) {
			/^10$/	&& do { $_ = 'A' ; } ;
			/^11$/	&& do { $_ = 'B' ; } ;
			/^12$/	&& do { $_ = 'C' ; } ;
			/^13$/	&& do { $_ = 'D' ; } ;
			/^14$/	&& do { $_ = 'E' ; } ;
			/^15$/	&& do { $_ = 'F' ; } ;
		}

		$hex = $sgn . join( '.' ,
			join( '' , reverse( @{ $r[0]->[0] } ) ) ,	# 整数部は 0 -> ∞ 方向に並んでいる。
			join( '' , @{ $r[0]->[1] } ) ,			# 小数部は 1 ->  0 方向に並んでいる。
		) ;
	}

	return $hex ;
}

=head2 duodecimal

Return duodecimal format as string.

Aliases : duodec , dozen

   print decimal( 12 )->duodecimal() ;    # 10
   print decimal( 14 )->duodecimal() ;    # 12
   print decimal( 256 )->duodecimal() ;   # 194 

=cut

sub duodecimal {
	#-----------------------------------------------------------------------
	#
	# 12 進数 ( Duodecimal system ; Dozenal system ; base12 ) 変換
	#
	# オブジェクトが保持している数値を 12 進数文字列に変換して返す。
	# 戻り値は一桁を 0 .. B で表現した文字列となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @r = $self->abs()->radix_to( 12 ) ;
	my $sgn = ( $self < 0 ) ? '-' : '' ;

	my $duo = undef ;

	unless ( ref( $r[0] ) eq 'ARRAY' ) {
		#
		# 戻り値が整数であれば一次元の配列が返る。
		#
		foreach ( @r ) {
			/^10$/	&& do { $_ = 'A' ; } ;
			/^11$/	&& do { $_ = 'B' ; } ;
		}
		$duo = $sgn . join( '' , reverse( @r ) ) ;
	}
	else {
		#
		# 戻り値が小数であれば $r[0] に配列参照が返る。
		#
		foreach ( @{ $r[0]->[0] } , @{ $r[0]->[1] } ) {
			/^10$/	&& do { $_ = 'A' ; } ;
			/^11$/	&& do { $_ = 'B' ; } ;
		}

		$duo = $sgn . join( '.' ,
			join( '' , reverse( @{ $r[0]->[0] } ) ) ,	# 整数部は 0 -> ∞ 方向に並んでいる。
			join( '' , @{ $r[0]->[1] } ) ,			# 小数部は 1 ->  0 方向に並んでいる。
		) ;
	}

	return $duo ;
}

sub duodec	{ return $_[0]->duodecimal() ; }
sub dozen 	{ return $_[0]->duodecimal() ; }

=head2 sexagesimal

Return sexagesimal format as string. ( comma separated string. )

Alias : base60

   print decimal( 60 )->sexagesimal() ;    # 1,0      ( 60 == 1 * 60^1 + 0 * 60^0 ) 
   print decimal( 256 )->sexagesimal() ;   # 4,16     ( 256 == 4 * 60^1 + 16 * 60^0 ) 

=cut

sub sexagesimal {
	#-----------------------------------------------------------------------
	#
	# 60 進数 ( sexagesimal system ) 変換
	#
	# オブジェクトが保持している数値を 60 進数文字列に変換して返す。
	# 戻り値は一桁を 10 進数で表し、各桁をカンマで結合した文字列となる。
	# 小数点はセミコロンで表現される。
	#
	# 60 進数はシュメールやバビロニアで用いられた命数法に由来し、
	# 現在では時間や角度の単位にその名残りがある。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @r = $self->abs()->radix_to( 60 ) ;
	my $sgn = ( $self < 0 ) ? '-' : '' ;

	my $sexa = undef ;

	unless ( ref( $r[0] ) eq 'ARRAY' ) {
		#
		# 戻り値が整数であれば一次元の配列が返る。
		#
		$sexa = $sgn . join( ',' , reverse( @r ) ) ;
	}
	else {
		#
		# 戻り値が小数であれば $r[0] に配列参照が返る。
		#
		$sexa = $sgn . join( ';' ,
			join( ',' , reverse( @{ $r[0]->[0] } ) ) ,	# 整数部は 0 -> ∞ 方向に並んでいる。
			join( ',' , @{ $r[0]->[1] } ) ,			# 小数部は 1 ->  0 方向に並んでいる。
		) ;
	}

	return $sexa ;
}

sub base60	{ return $_[0]->sexagesimal() ; }

sub fraction_cf {
	#-----------------------------------------------------------------------
	#
	# 小数を分数に変換し、分子と分母を要素に持つ配列参照を返す。
	#
	# 分数への変換には連分数展開を用いた近似計算を行う。
	# 変換結果はあくまでも近似値であるため、誤差が発生する可能性はある。
	# ただし、これはプログラム中で無限小数を正確に表現することができないため。
	#
	# プログラム中に現われる小数値は、どんなルーツによるものであれ、有限小数でしかない。
	# このため、理屈上は必ず有理分数へ変換できると言うことになる。
	#
	#-----------------------------------------------------------------------
	my( $numer , $denom ) = @_ ;

	#
	# 引数を評価
	#
	$denom = 1	unless ( defined $denom ) ;

	foreach ( $numer , $denom ) {
		$_ = ( ref( $_ ) eq __PACKAGE__ )
			? __PACKAGE__->new( $_->value() )
			: __PACKAGE__->new( $_ )
		;
	}

	#
	# 符合を抑えて絶対値に直す。
	#
	my $sgn = ( $numer->{'sgn'} * $denom->{'sgn'} ) ;
	foreach ( $numer , $denom ) {
		$_ = $_->abs() ;
	}

	#
	# 分母が整数になるように通分する。
	#
	if ( $denom->{'dlen'} > 0 ) {
		my $p = $denom->{'dlen'} ;
		$numer = __PACKAGE__->new( $numer->multiply( _pow10( $p ) )->value() ) ;
		$denom = __PACKAGE__->new( $denom->multiply( _pow10( $p ) )->value() ) ;
	}

	#
	# 主処理
	#
	my $f = [] ;
	
	if ( ( $numer->{'dlen'} + $denom->{'dlen'} ) == 0 ) {
		#
		# 分子と分母が共に整数であれば値を格納するだけ。
		# ( 後続の処理で約分される。 )
		#
		$f = [ $numer , $denom ] ;
	}
	else {
		#
		# 分子を連分数展開
		#
		my @cf = @{ $numer->cfraction( 100 , 1 ) } ;
		foreach my $i ( 1 .. ( $#cf - 1 ) ) {
			if ( @{ $cf[ $i ]->{'val'} } > 2 ) {
				@cf = @cf[ 0 .. ( $i - 1 ) ] ;
				last ;
			}
		}

		#
		# 連分数を分数に組み立てなおす。
		#
		if ( @cf > 0 ) {
			if ( @cf == 1 ) {
				$f = [ $cf[0] , 1 ] ;
			}
			else {
				@cf = reverse( @cf ) ;
				$f = [ ( $cf[1] * $cf[0] ) + 1 , $cf[0] ] ;
				foreach ( my $i = 2 ; $i < @cf ; $i++ ) {
					#
					# 前回の処理で得られた分数の逆数を採り、 $cf[ $i ] の値との間で通分する。
					#
					my( $n , $d ) = @{ $f }[ 1 , 0 ] ;
					$f->[0] = ( $cf[ $i ] * $d ) + $n ;
					$f->[1] = $d ;
				}
			}

			#
			# 元の分母を反映
			#
			$f->[1] *= $denom ;
		}
	}

	if ( @{ $f } > 0 ) {
		#
		# 約分
		#
		while ( my $g = gcd( @{ $f } ) ) {
			last	if ( $g == 1 ) ;
			$f->[0] /= $g ;
			$f->[1] /= $g ;
		}

		#
		# 小数点以下の桁数を調整しなおす。
		# ( どちらも整数になるはず。 )
		#
		foreach ( @{ $f } ) {
			$_ = __PACKAGE__->new( $_->value() ) ;
		}

		#
		# 符号を分子に適用。
		#
		$f->[0] *= $sgn ;
	}

	return $f ;
}

sub rat2frac {
	#-----------------------------------------------------------------------
	#
	# 小数を分数に変換し、分子と分母を要素に持つ配列参照を返す。
	#
	#
	# 有限小数と循環小数は有理分数に変換できる。
	#
	#   有限小数
	#
	#     有限小数は、特定の桁以降が 0 で循環している小数とみなすことができる。
	#     これは、基数である 10 の冪乗を掛けて小数部が無くなる位置を特定すればよい。
	#
	#   純循環小数
	#
	#     純循環小数は小数点以下に特定の一桁以上の数値の並びが繰り返し表れるもの。
	#     これに関しては 10 の冪を掛けた結果から元の値を減算した時に小数部が無くなるような変換を行う。
	#     純循環小数を分数に変換した直後の分母は 9 の羅列になる。 ( 約分によってその約数に変わりうる。 )
	#
	#   混合循環小数
	#
	#     混合循環小数は、小数部がある程度桁下がりした位置から循環しているもの。
	#     考え方は純循環小数と同じだが、二種類の 10 の冪を用いた差分を用いることで変換される。
	#     このため、混合循環小数の変換が最もコストが高くなる。
	#
	# 有理分数に変換できる小数は有理数 ( rational number ) でもある。
	# 小数が無理数である場合や、循環小数であっても循環周期が非常に長い場合には変換不能となる。
	#
	# このモジュールでは、小数点の位置を抑えることで小数の演算負荷を軽減しており、小数点以下の桁数が本来必要な長さよりも長くなることがある。
	# 一方、このメソッドでは小数点以下の桁数の多さが演算負荷や精度に直結するため、小数点以下の桁数を適宜調整する必要がある。
	# オブジェクトを文字列化して再度オブジェクト化するといった多少回りくどい方法を度々使用しているのは、このため。
	#
	# 無理数や循環周期が非常に長い循環小数を扱うと、文字列化すら失敗することがある。
	#
	#-----------------------------------------------------------------------
	my( $numer , $denom ) = @_ ;

	#
	# 引数を評価
	#
	$denom = 1	unless ( defined $denom ) ;

	foreach ( $numer , $denom ) {
		$_ = ( ref( $_ ) eq __PACKAGE__ )
			? __PACKAGE__->new( $_->value() )
			: __PACKAGE__->new( $_ )
		;
	}

	#
	# 符合を抑えて絶対値に直す。
	#
	my $sgn = ( $numer->{'sgn'} * $denom->{'sgn'} ) ;
	foreach ( $numer , $denom ) {
		$_ = $_->abs() ;
	}

	#
	# 分母が整数になるように通分する。
	#
	if ( $denom->{'dlen'} > 0 ) {
		my $p = $denom->{'dlen'} ;
		$numer = __PACKAGE__->new( $numer->multiply( _pow10( $p ) )->value() ) ;
		$denom = __PACKAGE__->new( $denom->multiply( _pow10( $p ) )->value() ) ;
	}

	#
	# 主処理
	#
	my $f = [] ;

	if ( ( $numer->{'dlen'} + $denom->{'dlen'} ) == 0 ) {
		#
		# 分子と分母が共に整数であれば値を格納するだけ。
		# ( 後続の処理で約分される。 )
		#
		$f = [ $numer , $denom ] ;
	}
	else {
		#
		# 分子が小数である場合。
		#
		# 分子を 10 の冪で桁上げしながら、小数点以下の桁数に留意しつつ桁上げ前の値を試し引きする。
		# 結果として整数が戻れば、その値が求めている分子となる。
		# 分母は、このときに使用した 10 の冪から求めることができる。
		#
		# 混合循環小数の場合は、同様の処理を二重ループでまわす必要があるが、
		# 小数の種類を予め知る事は難しいため、どんな小数値に対しても、値が確定するまで二重ループを廻し続けることになる。
		#
		$f->[0] = __PACKAGE__->new( $numer->divide( $denom )->value() ) ;
		$f->[1] = 1 ;

		#
		# 分子が小数であれば、変換を試みる。
		#
		if ( $f->[0]->{'dlen'} > 0 ) {
			my $v = $f->[0]->copy() ;
			my( $n , $d ) = ( undef , undef ) ;
			foreach ( my $p = __PACKAGE__->new( 1 ) ; $p <= $v->{'dlen'} ; $p++ ) {
				#
				# 有限小数 ( 1/2 等 )
				#
				my $t1 = __PACKAGE__->new( $v->multiply( _pow10( $p ) )->value() ) ;
				if ( $t1 == $t1->integer() ) { $n = $t1->copy() ; $d = _pow10( $p ) ; last ; }

				#
				# 純循環小数 ( 1/3 等 )
				#
				# 循環小数の場合、 Perl 標準の除算で末尾一桁が四捨五入されている可能性があるため、
				# 切り捨てされている場合と四捨五入されている場合の双方を検査する。
				#
				foreach my $v2 ( $v->round_down( $t1->{'dlen'} ) , $v->round( $t1->{'dlen'} ) ) {
					my $t2 = $t1->subtract( $v2 ) ;
					if ( $t2 == $t2->integer() ) { $n = $t2->copy() ; $d = _pow10( $p )->subtract( 1 ) ; last ; }
				}
				last	if ( defined $n ) ;

				#
				# 混合循環小数 ( 1/6 等 )
				#
				# 純循環小数の場合と同様、切り捨てされている場合と四捨五入されている場合の双方を検査する。
				#
				foreach ( my $q = $p->subtract( 1 ) ; $q >= 0 ; $q-- ) {
					foreach my $v3 (
						$v->multiply( _pow10( $q ) )->round_down( $t1->{'dlen'} ) ,
						$v->multiply( _pow10( $q ) )->round( $t1->{'dlen'} )
					) {
						my $t3 = $t1->subtract( $v3 ) ;
						if ( $t3 == $t3->integer() ) { $n = $t3->copy() ; $d = _pow10( $p )->subtract( _pow10( $q ) ) ; last ; }
					}
					last	if ( defined $n ) ;
				}

				last	if ( defined $n ) ;
			}

			if ( defined $n ) {
				@{ $f } = ( $n , $d ) ;
			}
		}
	}

	if ( @{ $f } > 0 ) {
		#
		# 約分
		#
		while ( my $g = gcd( @{ $f } ) ) {
			last	if ( $g == 1 ) ;
			$f->[0] /= $g ;
			$f->[1] /= $g ;
		}

		#
		# 小数点以下の桁数を調整しなおす。
		# ( どちらも整数になるはず。 )
		#
		foreach ( @{ $f } ) {
			$_ = __PACKAGE__->new( $_->value() ) ;
		}

		#
		# 符号を分子に適用。
		#
		$f->[0] *= $sgn ;
	}

	return $f ;
}

=head2 cfraction

The continued fractoin expansion.

This method will convert the 'Decimal' object to an array reference, which means the regular continued fraction.

  $cf = decimal( 0.1 )->cfraction() ;
  print join( ' ' , @{ $cf } ) ;                       # 0 10       ( it means [ 0 ; 10 ] == 0 + 1/10 == 1/10 )

This method can be used for 'Decimal' to 'Fraction' conversion.

  $d = decimal( 1 ) / 3 ;
  print $d ;                                           # 0.3333333333333333333333333333333333333333

  $cf = $d->cfraction() ;
  print join( ' '  , @{ $cf } ) ;                      # 0 3 3333333333333333333333333333333333333333 3 33333...... ... 

  $cf->[0] means integer 0.
  $cf->[1] means fraction 1/3.
  $cf->[2] means fraction 1/3333333333333333333333333333333333333333

  $cf->[2] and all of other elements, except $cf->[0] and $cf->[1], are too small decimal values, and these are neary equal 0.
  Then

    $d == $cf->[0] + ( 1 / $cf->[1] )
       == 0 + 1/3
       == 1/3


for some examples.


  decimal( 2.3 )->cfraction()     # [ 2 , 3 , 3 , 3333333333333333333333333333333333333333 , 3 , 33333333..... ]
                                  # -> [ 2 , 3 , 3 ]
				  # == [ 2 , 3 + 1/3 ]         == [ 2 , 10/3 ]
				  # == [ 2 + 3/10 ]
				  # == 23/10

  decimal( 0.1 )->cfraction()     # [ 0 , 10 ]
                                  # == [ 0 + 1/10 ]
                                  # == 1/10

  decimal( 0.2 )->cfraction()     # [ 0 , 5 ]
                                  # == [ 0 + 1/5 ]
                                  # == 1/5

  decimal( 0.3 )->cfraction()     # [ 0 , 3 , 3 , 3333333333333333333333333333333333333333 , 3 , 3333..... , .... ]
                                  # -> [ 0 , 3 , 3 ]
				  # -> [ 0 , 3 + 1/3 ]         == [ 0 , 10/3 ]
				  # == [ 0 + 3/10 ]
				  # == 3/10
 
  decimal( 0.4 )->cfraction()     # [ 0 , 2 , 2 ]
                                  # == [ 0 , 2 + 1/2 ]         == [ 0 , 5/2 ]
				  # == [ 0 + 2/5 ]
                                  # == 2/5

  decimal( 0.5 )->cfraction()     # [ 0 , 2 ]
                                  # == [ 0 + 1/2 ]
                                  # == 1/2

  decimal( 0.6 )->cfraction()     # [ 0 , 1 , 1 , 1 , 1 , 2500000000000000000000000000000000000000 ]
                                  # -> [ 0 , 1 , 1 , 1 , 1 ]
				  # -> [ 0 , 1 , 1 , 1 + 1/1 ] == [ 0 , 1 , 1 , 2 ]
				  # == [ 0 , 1 , 1 + 1/2 ]     == [ 0 , 1 , 3/2 ]
				  # == [ 0 , 1 + 2/3 ]         == [ 0 , 5/3 ]
				  # == [ 0 + 3/5 ]
				  # == 3/5

  decimal( 0.7 )->cfraction()     # [ 0 , 1 , 2 , 2 , 1 , 303030303030303030303030303030303030303 , 33 , 303030303030303030303030303... ]
                                  # -> [ 0 , 1 , 2 , 2 , 1 ]
				  # -> [ 0 , 1 , 2 , 2 + 1/1 ] == [ 0 , 1 , 2 , 3 ]
				  # == [ 0 , 1 , 2 + 1/3 ]     == [ 0 , 1 , 7/3 ]
				  # == [ 0 , 1 + 3/7 ]         == [ 0 , 10/7 ]
				  # == [ 0 + 7/10 ]
				  # == 7/10

  decimal( 0.8 )->cfraction()     # [ 0 , 1 , 4 ]
                                  # == [ 0 , 1 + 1/4 ]         == [ 0 , 5/4 ]
				  # == [ 0 + 4/5 ]
				  # == 4/5

  decimal( 0.9 )->cfraction()     # [ 0 , 1 , 9 , 1111111111111111111111111111111111111111 , 9 , 1111111111111111111..... ]
                                  # -> [ 0 , 1 , 9 ]
				  # == [ 0 , 1 + 1/9 ]         == [ 0 , 10/9 ]
				  # == [ 0 + 9/10 ]
				  # == 9/10


The irrational numbers does not have these pattern.

  deciaml( 2 )->sqrt()->cfraction()	# [ 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , ..... ]

  pi()->cfraction()                     # [ 3 , 7 , 15 , 1 , 292 , 1 , 1 , 1 , 2 , 1 , 3 , 1 , 14 , 2 , 1 , ..... ]


=cut

sub cfraction {
	#-------------------------------------------------------------------------------
	#
	# 連分数展開 ( continued fraction expansion )
	#
	#   正則連分数 ( regular continued fraction ) を返す。
	#
	#   戻り値は、以下のような配列参照となる。
	#
	#     $r == [ a0 , a1 , a2 , ..... ]
	#
	#   この内、 a0 が整数部、a1 以降が 1 / an を表す値となる。
	#   これを数学的な表現で表すと、
	#
	#     $r == [ a0 ; a1 , a2 , ...... ]
	#
	#   となる。
	#
	#   正則連分数は、分母に連続して表れる分数の分子が全て 1 であるような連分数を指す。
	#
	#   有限小数と循環小数は有理数であり、連分数展開を繰り返すことで分母が整数で収束する箇所を見つけることができる。
	#   有限小数や循環小数を連分数展開すると、収束点となる数値の後に巨大な数値が現われ、以後、同じパターンの数列が繰り返し現われるようになる。
	#   これにより、巨大な数値が現われた時点でその一つ前を収束点とみなすことができる。
	#   ( 循環することなく収束する場合もある。 )
	#
	#   例 )
	#
	#     cfraction( 0.1 ) == [ 0 ; 10 ] == 0 + 1/10
	#                      == 1/10
	#
	#     cfraction( 0.2 ) == [ 0 ; 5 ] == 0 + 1/5
	#                      == 1/5
	#
	#     cfraction( 0.3 ) == [ 0 ; 3 , 3 , 33333333... , ... ]
	#                      -> [ 0 ; 3 , 3 ]
	#                      == [ 0 ; 3 + 1/3 ] == 0 + 3/10
	#                      == 3/10
	#
	#     cfraction( 0.4 ) == [ 0 ; 2 , 2 ] == [ 0 ; 2 + 1/2 ) == 0 + 2/5
	#                      == 2/5
	#
	#     cfraction( 0.5 ) == [ 0 ; 2 ] == 0 + 1/2
	#                      == 1/2
	#
	#     cfraction( 0.6 ) == [ 0 ; 1 , 1 , 1 , 1 , 2500000... , ... ]
	#                      -> [ 0 ; 1 , 1 , 1 , 1 ]
	#                      == [ 0 ; 1 , 1 , 1 + 1/1 ] == [ 0 ; 1 , 1 + 1/2 ] == [ 0 ; 1 + 2/3 ] == 0 + 3/5
	#                      == 3/5
	#
	#     cfraction( 0.7 ) == [ 0 ; 1 , 2 , 2 , 1 , 3030303... , ... ]
	#                      -> [ 0 ; 1 , 2 , 2 , 1 ]
	#                      == [ 0 ; 1 , 2 , 2 + 1/1 ] == [ 0 ; 1 , 2 + 1/3 ] == [ 0 ; 1 + 3/7 ] == 0 + 7/10
	#                      == 7/10
	#
	#     cfraction( 0.8 ) == [ 0 ; 1 , 4 ]
	#                      == [ 0 ; 1 + 1/4 ] == 0 + 4/5
	#                      == 4/5
	#
	#     cfraction( 0.9 ) == [ 0 ; 1 , 9 , 1111111... , ... ]
	#                      -> [ 0 ; 1 , 9 ]
	#                      == [ 0 ; 1 + 1/9 ] == 0 + 9/10
	#                      == 9/10
	#
	#   円周率 ( 無理数 ) の正則連分数表現は以下の通りであり、規則性がない。
	#   ( 正則でない連分数表現を用いることで規則性を見出す事はできるらしい。 )
	#
	#     cfraction( PI )  == [ 3 ; 7 , 15 , 1 , 292 , 1 , 1 , 1 , 2 , 1 , 3 , 1 , 14 , 2 , 1 , 1 , 2 , 2 , 2 , 2 , 1 , 84 , ...... ]
	#
	#-------------------------------------------------------------------------------
	my( $decimal , $depth , $quick ) = @_ ;

	$decimal = __PACKAGE__->new( $decimal )	unless ( ref( $decimal ) eq __PACKAGE__ ) ;
	return []	unless ( defined $decimal ) ;

	#
	# 冪根の展開には 100 回程度の深さが必要。
	#
	$depth = 100	unless ( defined $depth ) ;

	#
	# 展開
	#
	my @r = () ;
	my $one = __PACKAGE__->new( 1 ) ;
	foreach ( 1 .. $depth ) {
		my $i = __PACKAGE__->new( $decimal->integer_part()->value() ) ;

		last	if ( $quick and $i->integer_digits() >= 7 ) ;	# 収束点と思しき箇所で打ち切る。

		push( @r , $i ) ;

		$decimal = __PACKAGE__->new( $decimal->decimal_part()->value() ) ;
		last	if ( $decimal->is_zero() ) ;
		$decimal = $one->divide( $decimal ) ;
	}

	return [ @r ] ;
}

sub cfraction_iter {
	#-------------------------------------------------------------------------------
	#
	# 連分数展開イテレータ
	#
	#   処理内容は cfraction と全く同じ。
	#
	#-------------------------------------------------------------------------------
	my( $decimal , $depth ) = @_ ;

	$decimal = __PACKAGE__->new( $decimal )	unless ( ref( $decimal ) eq __PACKAGE__ ) ;
	return []	unless ( defined $decimal ) ;

	$depth = 100	unless ( defined $depth ) ;
	my $count = 0 ;
	my $one = __PACKAGE__->new( 1 ) ;

	return sub {
		return undef	if ( $decimal->is_zero() ) ;
		return undef	if ( ++$count >= $depth ) ;

		my $i = __PACKAGE__->new( $decimal->integer_part()->value() ) ;
		$decimal = __PACKAGE__->new( $decimal->decimal_part()->value() ) ;
		$decimal = $one->divide( $decimal )	if ( ! $decimal->is_zero() ) ;
		return $i ;
	} ;
}

#-------------------------------------------------------------------------------
#
# 方程式の解
#
#-------------------------------------------------------------------------------

sub newton {
	#-----------------------------------------------------------------------
	#
	# ニュートン法による近似
	#
	#   n 次方程式の解の一つを返す。
	#
	#   三次以上の方程式は実根を持つとは限らない上、 四次以上の方程式では実根を持つかどうかの判別すら困難となる。
	#   このため、演算は複素数の領域で行っている。
	#
	#   ニュートン法は任意に定めた初期値から値を近似させて行くため、 n 次方程式の解を一度に全て得る事はできない。
	#   また、適切な初期値を導く法則も存在しないため、全ての解を適切に導く手段とは成りえない。
	#
	#   ニュートン法は初期値の採り方によって発散や振動といった現象が発生することがあり、必ずしも収束するとは限らない。
	#   発散は演算過程の値が正負何れかの方向の無限大へ向かう現象であり、振動は演算過程の値が変曲点付近を往復する現象。
	#   何れも、初期値と変曲点の位置関係によって生じる問題であり、発生頻度は非常に低い。
	#
	#   発散や振動が発生した場合、初期値を採り直して再実行することで多くの場合問題は解決するはずだが、
	#   適切な初期値を選び取るのは容易ではなく、一般化された手法も存在しない。
	#
	#   その代わりに、 n 次方程式を減次することで対処することもできる。
	#   減次は n 次多項式で表現されるグラフを X 軸方向にずらした写像を採ることに等しく、
	#   これを行うことで変曲点の位置を変えることができる。
	#
	#   このメソッドでは、
	#
	#     a[0] * X^n + a[1] * X^(n-1) + .... + a[n] == 0
	#
	#   の係数列を受け取り、
	#
	#     X^n + ( a[n] / a[0] ) == 0
	#
	#   の解の一つを初期値として近似値を計算している。
	#   ( 実数解が存在すれば、それが採用される。 )
	#   
	#-----------------------------------------------------------------------
	my( @c ) = @_ ;
	@c = @{ $c[0] }	if ( ref( $c[0] ) eq 'ARRAY' ) ;

	return undef	unless ( @c > 1 ) ;

	foreach ( @c ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( defined $_ ) ;
	}

	while ( $c[0] == 0 ) {
		shift( @c ) ;
	}

	my $n = scalar( @c ) - 1 ;	# 次数
	my $x = undef ;

	#
	# 一次及び二次方程式の場合
	#
	if ( $n == 1 ) {
		#
		# 一次方程式
		#
		$x = $c[1] * ( -1 ) / $c[0] ;
	}
	elsif ( $n == 2 ) {
		#
		# 二次方程式
		#
		my $d = ( $c[1] ** 2 ) - ( $c[0] * $c[2] * 4 ) ;	# 判別式
		$d = $d->complex()	unless ( $d->is_complex() ) ;
		$d = ( $d->sqrt() )[0] ;
		$x = ( $d - $c[1] ) / ( $c[0] * 2 ) ;
	}

	return $x	if ( defined $x ) ;

	#
	# 三次以上の方程式は漸化式を用いて近似する。
	#
	#   n 次多項式 f(X) を
	#
	#     f(X) == a[0] * X^n
	#           + a[1] * X^(n-1)
	#           + ..... 
	#           + a[n]
	#
	#   とすると、その微分方程式 d(X) は、
	#
	#     d(X) == a[0] *   n       * X^(n-1)
	#           + a[1] * ( n - 1 ) * X^(n-2) 
	#           + .... 
	#           + a[n-1]
	#
	#   となる。
	#
	#   漸化式は、
	#
	#                       f( X[k-1] )
	#     X[k] == X[k-1] - -------------
	#                       d( X[k-1] )
	#
	#   X の初期値として、
	#
	#     a[0] * X^n + a[n] * X^0 == 0
	#
	#   の解 ( a[n] / a[0] の n 乗根 ) の一つを使用する。
	#
	#   この解に実数解があればこれを採用する。
	#   実数解がない場合には、任意の解を一つ選択する。 ( 複素数の n 乗根の絶対値は全て等しい。 )
	#
	#   補足 :
	#
	#     X についての n 次方程式 f(X) == 0 は、その解 x[i] と各項の係数 a[j] によって
	#
	#       f(X) == Π( X - x[i] )           ( i == 1 -> n )
	#            == Σ( a[j] * X^(n-j) )     ( j == 0 -> n )
	#            == 0
	#
	#     と表される。
	#
	#     この時、 X^0 の項 a[n] は、
	#
	#       a[n] == Π( x[i] )               ( i == 1 -> n )
	#
	#     であり、 f(X) == 0 の解 x[i] と a[n] との間に
	#
	#       abs( x[i] ) <= abs( a[n] )       ( i == 1 -> n )
	#
	#     と言う関係が成り立つ。
	#
	#     つまり、 abs( a[n] ) は abs( x[i] ) の上限であり、 a[n] の n 乗根は x[i] の中央値の近似値としての意味を持つことになる。
	#
	$x = $c[-1] * ( -1 ) / $c[0] ;
	$x = $x->complex()	unless ( $x->is_complex() ) ;

	$x = [ $x->root( $n ) ] ;
	foreach ( @{ $x } ) {
		if ( $_->can_decimal() ) { $x = $_ ; last ; }
	}
	$x = $x->[0]	if ( ref( $x ) eq 'ARRAY' ) ;

	my $fx = [ @c ] ;		# 元の方程式の係数
	my $dx = [] ;			# 微分方程式の係数
	foreach my $i ( 0 .. ( $#c - 1 ) ) {
		$dx->[ $i ] = $c[ $i ] * ( $n - $i ) ;		# 微分方程式の係数 == 元の係数 * その項の次数
	}

	my $cnt = 0 ;
	while ( ++$cnt < 100 ) {
		my $diff = $x->horner_sub( $fx ) / $x->horner_sub( $dx ) ;
		$diff = $diff->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		
		$x -= $diff ;

		last	if ( $diff->det()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
	}

	$x = $x->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	return $x ;
}

sub solve2 {
	#-----------------------------------------------------------------------
	#
	# 二次方程式の解 ( roots of quadratic equation )
	#
	#   aX^2 + bX + c == 0
	#
	#
	#   a != 0 の時、
	#
	#           - b ± sqrt( b^2 - 4ac )
	#     X == --------------------------
	#                    2a
	#
	#     これは、平方完成によって導かれる公式。
	#
	#       aX^2 + bX + c == 0
	#       -> X^2 + b/a * X + c/a == 0
	#       -> X^2 + 2 * ( b/2a ) * X + ( b/2a )^2 - ( b/2a )^2 + c/a == 0
	#       -> ( X + b/2a )^2 == ( b/2a )^2 - c/a
	#
	#                                   sqrt( b^2 - 4ac )
	#       -> ( X + b/2a )^2 == ( ± --------------------- )^2    ..... [1]
	#                                           2a
	#
	#                          sqrt( b^2 - 4ac )
	#       -> X + b/2a == ± -------------------
	#                                2a
	#
	#                 - b ± sqrt( b^2 - 4ac )
	#       -> X == ----------------------------
	#                          2a
	#
	#     この変型の過程で現れる [1] の式が「平方完成」と言う名称の由来。
	#
	#     ここで二次方程式の減次を行ってみる。
	#
	#       aX^2 + bX + c == 0
	#
	#       X == Y - s == Y - b/2a
	#       -> Y == X + b/2a
	#
	#       -> a * ( Y - s )^2 + b * ( Y - s ) + c == 0
	#       -> a * ( Y^2 - 2sY + s^2 ) + bY - bs + c == 0
	#       -> aY^2 + ( b - 2as ) * Y + as^2 - bs + c == 0
	#
	#       -> aY^2 + ( b - 2a * b/2a ) * Y + a * ( b/2a )^2 - bs + c == 0
	#
	#                   b^2       b^2
	#       -> aY^2 + ------- - ------- + c == 0
	#                   4a        2a
	#
	#                  b^2 - 4ac 
	#       -> Y^2 - ------------- == 0                               .... [2]
	#                   ( 2a )^2
	#                   
	#                                  sqrt( b^2 - 4ac )
	#       -> ( X + b/2a )^2 == ( ± ------------------- )^2         .... [3]
	#                                          2a
	#
	#                - b ± sqrt( b^2 - 4ac )
	#       -> X == --------------------------
	#                       2a
	#
	#     [2] が減次の結果得られる式であり、これに X を戻した [3] が平方完成になっている。
	#
	#     三次方程式の解法において減次が「立方完成」とも呼ばれるのはこのため。
	#     減次は四次以上の方程式においても重要な概念となっている。
	#
	#
	#   a == 0 の時、解の公式は成り立たないが、これは一次方程式であるため、
	#
	#     aX^2 + bX + c == bX + c == 0
	#
	#     -> X == -c / b
	#
	#
	#   b == 0 の時、
	#
	#     aX^2 + bX + c == aX^2 + c == 0
	#
	#                         c
	#     -> X == ± sqrt( - --- )
	#                         a
	#
	#     解の公式に当てはめても同じ結果が得られる。
	#
	#
	#   c == 0 の時、
	#
	#     aX^2 + bx + c == aX^2 + bX == 0
	#
	#     -> X * ( aX + b ) == 0
	#
	#                    b
	#     -> X == 0 , - ---
	#                    a
	#
	#     これも、解の公式に当てはめても同じ結果が得られる。
	#
	#-----------------------------------------------------------------------
	my @arg = @_ ;
	return ()	unless ( @arg == 3 ) ;

	foreach ( @arg ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return ()			unless ( defined $_ ) ;
	}

	my $c = [ @arg ] ;
	my @r = () ;

	if ( $c->[0] == 0 ) {
		#
		# bX + c == 0
		#
		#  -> X == -c / b
		#
		@r = (
			( $c->[2] * ( -1 ) ) / $c->[1] ,
		) ;
	}
	elsif ( $c->[1] == 0 ) {
		#
		# aX^2 + c == 0
		#
		#   -> X[0] == + sqrt( -c / a )
		#      X[1] == - sqrt( -c / a )
		#
		my $x = ( $c->[2] * ( -1 ) / $c->[0] ) ;
		$x = $x->complex()	unless ( $x->is_complex() ) ;

		@r = ( $x->sqrt() ) ;
	}
	elsif ( $c->[2] == 0 ) {
		#
		# aX^2 + bX == X * ( aX + b ) == 0
		#
		#   -> X[0] == 0
		#      X[1] == -b / a
		#
		@r = (
			__PACKAGE__->new( 0 )		,
			( $c->[1] * ( -1 ) ) / $c->[0]	,
		) ;
	}
	else {
		#
		# aX^2 + bx + c == 0
		#
		#   -> X[0] = ( -b + sqrt( b^2 - 4ac ) ) / 2a
		#      X[1] = ( -b - sqrt( b^2 - 4ac ) ) / 2a
		#
		my $x = ( $c->[1] ** 2 ) - ( $c->[0] * $c->[2] ) * 4 ;
		$x = $x->complex()	unless ( $x->is_complex() ) ;
		$x = [ $x->sqrt() ] ;

		@r = (
			( $x->[0] - $c->[1] ) / ( $c->[0] * 2 ) ,
			( $x->[1] - $c->[1] ) / ( $c->[0] * 2 ) ,
		) ;
	}

	foreach ( @r ) {
		$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}

	return @r ;
}

sub solve3 {
	#---------------------------------------------------------------
	#
	# カルダノの公式 ( Cardano's method ) による三次方程式の解法
	#
	#   三次方程式の解法は、
	#
	#     aX^3 + bX^2 + cX + d == ( X - x )( X - y )( X - z ) == 0
	#
	#   と言う変換により、 x , y , z を求める方法のこと。
	#   
	#
	#   立方完成
	#
	#     三次方程式を解く場合には、前処理として、
	#
	#       aX^3 + bX^2 + cX + d == Y^3 + pY + q == 0
	#
	#     と言う形に変形する。 ( 立方完成 )
	#     
	#     このように n 次方程式の n - 1 項を消去するような変換は、
	#     減次 ( defration ) またはチルンハウゼン変換 ( Tschirnhausen transformation ) とも呼ばれ、
	#     n 次方程式に X == Y - s を代入することによって実現される。
	#
	#     s の値は方程式の次数によって異なる値が用いられ、三次方程式では、
	#
	#       X == Y - b/3a
	#
	#     となる。
	#
	#     この減次をプログラムで表現する事は困難だが、組み立て除法を用いることで同じ結果を得ることができる。
	#     組み立て除法はプログラムとして書き起こすのに非常に適したアルゴリズムとなっている。
	#
	#     このモジュールでは、この変換を alge_defrated_coef で行っている。
	#     ( 詳細については alge_defrated_coef 関数を参照のこと。 )
	#     
	#
	#   Y の分解
	#
	#     立方完成によって変換された
	#
	#       Y^3 + pY + q == 0
	#
	#     に対して、
	#
	#       Y == u + v
	#
	#     とおくと、
	#
	#       Y^3 + pY + q
	#       == ( u + v )^3 + p * ( u + v ) + q 
	#       == ( u^3 + v^3 + 3u^2v + 3uv^2 ) + p * ( u + v ) + q
	#       == ( u^3 + v^3 + q ) + 3uv * ( u + v ) + p * ( u + v )
	#       == ( u^3 + v^3 + q ) + ( 3uv + p )( u + v )
	#       == 0
	#
	#     となり、これが解を持つ条件は、
	#
	#       u^3 + v^3 + q == 0
	#       ( 3uv + p )( u + v ) == 0
	#
	#     となる。
	#
	#     Y == u + v != 0 であるため、
	#
	#       u^3 + v^3 + q == 0
	#       -> u^3 + v^3 == -q
	#
	#       3uv + p == 0
	#       -> uv == -p / 3
	#       -> v  == -p / 3u
	#
	#       -> u^3 + v^3 + q == u^3 + ( -p / 3u )^3 + q == 0
	#
	#       u^3 + ( -p / 3u )^3 == 0
	#       -> u^6 + ( -p / 3 )^3 + qu^3 == 0
	#       -> ( u^3 )^2  + q * ( u^3 ) + ( -p/3 )^3 == 0
	#
	#       -> ( u^3 )[0] == ( -q + sqrt( q^2 - 4 * ( -p / 3 )^3 ) ) / 2
	#          ( u^3 )[1] == ( -q - sqrt( q^2 - 4 * ( -p / 3 )^3 ) ) / 2
	#
	#     u^3 + v^3 + q == 0 は、 u と v を入れ替えても同じ結果を生むものでなければならない ( u と v は「対称」 ) が、
	#
	#       u^3 == ( -q + sqrt( q^2 - 4 * ( -p / 3 )^3 ) ) / 2
	#       v^3 == ( -q - sqrt( q^2 - 4 * ( -p / 3 )^3 ) ) / 2
	#
	#     とおいても対称性が失われることはない。
	#
	#
	#   u , v の分解
	#
	#     u^3 と v^3 の複素 3 乗根を
	#
	#       u[k] ( k == 0 -> 2 )
	#       v[k] ( k == 0 -> 2 )
	#
	#     で表すこととする。
	#
	#     u[k] と v[k] は、全体で 6 種類の値を採ることができるが、
	#   
	#       3uv + p == 0
	#       -> uv == -p / 3
	#
	#     と言う条件を満たすものとして、
	#
	#       u[0] * v[0] == -p / 3
	#       u[1] * v[2] == -p / 3
	#       u[2] * v[1] == -p / 3
	#
	#     となる u[k] と v[k] の組を定義することができる。
	#
	#     この時、 1 の原始 3 乗根の一つ
	#
	#       w == exp( i * 2PI/3 )
	#
	#     を用いると、 u[k] と v[k] は
	#
	#       u[0] == w^0 * u[0]
	#       u[1] == w^1 * u[0]
	#       u[2] == w^2 * u[0] == conj( w^1 ) * u[0]
	#
	#       v[0] == w^0 * v[0]
	#       v[1] == w^1 * v[0]
	#       v[2] == w^2 * v[0] == conj( w^1 ) * v[0]
	#
	#     と言う構造を持つ。
	#
	#   三次方程式の解は、
	#
	#     Y == X + s == u + v
	#     -> X == ( u + v ) - s
	#
	#     ( X - x )( X - y )( X - z ) == 0
	#
	#   より、
	#
	#     x == ( u[0] + v[0] ) - s == ( u[0]       + v[0]       ) - s
	#     y == ( u[1] + v[2] ) - s == ( u[0] * w   + v[0] * w^2 ) - s
	#     z == ( u[2] + v[1] ) - s == ( u[0] * w^2 + v[0] * w   ) - s
	#
	#   となる。
	#
	#   ちなみに、元の三次方程式が 1 つ以上の実数解を持つならば、
	#
	#     u[0] == conj( v[0] ) 
	#     u[1] == conj( v[2] ) 
	#     u[2] == conj( v[1] ) 
	#
	#   の何れかが成立することになる。
	#
	#   カルダノの公式では、
	#
	#     uv == ( -1 ) * p == 0
	#
	#   の時、演算不能となるが、
	#
	#     Y^3 + 3pY + 2q == Y^3 + 2q == 0
	#
	#   であり、
	#
	#     Y^3 == ( X + a/3 )^3 = -2q
	#     -> X == ( -2q )^(1/3) - a/3
	#
	#   として解を求めることができる。
	#
	#
	#   ラグランジェのリゾルベント ( Lagrange resolvent )
	#
	#     ラグランジェのリゾルベント用いた解法では、三次方程式
	#
	#       ( X - x )( X - y )( X - z ) == X^3 + aX^2 + bX + c == 0
	#
	#     において、リゾルベントを、
	#
	#       w == exp( i * 2PI/3 )
	#
	#       u1 == x +       y +       z
	#       u2 == x + w   * y + w^2 * z
	#       u3 == x + w^2 * y + w   * z
	#
	#     と定義することで、
	#
	#       x == 1/3 * ( u1 +       u2 +       u3 )
	#       y == 1/3 * ( u1 + w^2 * u2 + w   * u3 )
	#       z == 1/3 * ( u1 + w   * u2 + w^2 * u3 )
	#
	#     を得る。
	#
	#     三次方程式を
	#
	#       ( X - x )( X - y )( X - z ) == X^3 - ( x + y + z ) * X^2 + ( xy + yz + zx ) * X - xyz
	#                                   == X^3 + aX^2 + bX + c
	#                                   == 0
	#
	#       a == ( -1 ) * ( x + y + z )
	#       b == xy + yz + zx
	#       c == ( -1 ) * xyz
	#
	#     とする。
	#
	#     この時、 u1 , u2 , u3 の内、
	#
	#       u1 == x + y + z == ( -1 ) * a
	#
	#     となる。
	#      
	#     u2 , u3 は、
	#
	#       ( Y - u2^3 )( Y - u3^3 ) == Y^2 - ( u2^3 + u3^3 ) * Y + ( u2^3 * u3^3 )
	#                                == Y^2 - pY + q
	#                                == 0
	#
	#       -> u2^3 + u3^3 == ( x + w * y + w^2 * z )^3 + ( x * w^2 * y + w * z )^3
	#                      == 2a^3 - 9 * ab + 27 * c
	#
	#          u2 * u3     == ( x + w * y + w^2 * z )( x + w^2 * y + w * z )
	#                      == a^2 - 3b
	#
	#      -> p == 2a^3 - 9ab + 27c
	#         q == a^2 - 3b
	#
	#      -> u2 == ( 1/2 * ( -p + sqrt( p^2 - 4q^3 ) ) )^( 1/3 )
	#         u3 == ( a^2 - 3b ) / u2
	#
	#    となる。
	#
	#---------------------------------------------------------------
	my @arg = @_ ;
	return ()	unless ( @arg == 4 ) ;

	foreach ( @arg ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
	}

	my $c = [ @arg ] ;
	return solve2( @arg[ 1 .. $#arg ] )	if ( $c->[0] == 0 ) ;

	#
	# Y == X - s
	#
	#    aX^3 + bX^2 + cX + d == 0
	# ->  Y^3        + pY + q == 0
	#
	my( $s , $p , $q ) ;
	( $s , $p ) = alge_defrated_coef( @{ $c } ) ;
	( $p , $q ) = @{ $p }[ 2 , 3 ] ;

	my @r = () ;

	#
	# ( X - x )( X - y )( X - z ) == X^3 + aX^2 + bX + c
	#                             == Y^3        + pY + q
	#                             == 0
	if ( $p == 0 ) {
		#
		# Y^3 + pY + q == Y^3 + q == 0
		#
		#   -> Y == X - s == ( -q )^( 1/3 )
		#
		#   -> X == ( -q )^( 1/3 ) - s
		#
		my $u = $q * ( -1 ) ;
		$u = $u->complex()	unless ( $u->is_complex() ) ;
		@r = $u->root( 3 ) ;
		foreach ( @r ) { $_ -= $s ; }
	}
	elsif ( $q == 0 ) {
		#
		# Y^3 + pY + q == Y^3 + pY
		#              == Y * ( Y^2 + p )
		#              == 0
		#
		# -> Y[0] == 0
		#    Y[1] == + sqrt( -p )
		#    Y[2] == - sqrt( -p )
		#
		#    X[i] == Y[i] - s
		#
		@r = (
			__PACKAGE__->new( 0 )	,
			solve2( 1 , 0 , $p )	,
		) ;

		foreach ( @r ) { $_ -= $s ; }
	}
	else {
		#
		#  Y^3 + pY + q == 0
		#
		#  Y == u + v
		#
		#  -> ( u + v )^3 + p * ( u + v ) + q == ( u^3 + v^3 + q ) + ( 3uv + p )( u + v )
		#                                     == 0
		#
		#  -> u^3 + v^3 + q == 0
		#     3uv + p == 0
		#
		#  -> u^3 + v^3 + q == u^3 + ( -p / 3u )^3 + q == 0
		#  -> u^6 + ( -p / 3 )^3 + qu^3 == 0
		#  -> ( u^3 )^2 + q * ( u^3 ) - ( p / 3 )^3 == 0
		#
		my $pm = $p / 3 ;
		my $u3 = ( solve2( 1 , $q , $pm->power( 3 )->round( $DECIMAL_PART_LENGTH_LIMIT ) * ( -1 ) ) )[0] ;

		#
		#  u[k] == ( u3 )^(1/3)       ( k == 0 -> 2 )
		#
		#  u[0] * v[0] == ( -1 ) * ( p / 3 ) -> v[0] == ( -1 ) * ( p / 3 ) / u[0]
		#  u[1] * v[2] == ( -1 ) * ( p / 3 ) -> v[2] == ( -1 ) * ( p / 3 ) / u[1]
		#  u[2] * v[1] == ( -1 ) * ( p / 3 ) -> v[1] == ( -1 ) * ( p / 3 ) / u[2]
		#  
		#  u[0] == w^0 * u[0]
		#  u[1] == w^1 * u[0]
		#  u[2] == w^2 * u[0]
		#
		#  v[0] == w^0 * v[0]
		#  v[1] == w^1 * v[0]
		#  v[2] == w^2 * v[0]
		#
		#  ( w == exp( i * 2/3 * PI ) )
		#
		#  x == ( u[0] + v[0] ) - s == ( u[0]       + v[0]       ) - s
		#  y == ( u[1] + v[2] ) - s == ( u[0] * w   + v[0] * w^2 ) - s
		#  z == ( u[2] + v[1] ) - s == ( u[0] * w^2 + v[0] * w   ) - s
		#
		my $u = [ $u3->root( 3 ) ] ;
		my $v = [] ;
		$pm *= ( -1 ) ;

		$v->[0] = $pm / $u->[0] ;
		$v->[1] = $pm / $u->[2] ;
		$v->[2] = $pm / $u->[1] ;

		foreach my $i ( 0 .. 2 ) {
			$u->[ $i ] = $u->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
			$v->[ $i ] = $v->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}

		@r = (
			$u->[0] + $v->[0] - $s ,
			$u->[1] + $v->[2] - $s ,
			$u->[2] + $v->[1] - $s ,
		) ;
	}

	return @r ;
}

sub solve4 {
	#-----------------------------------------------------------------------
	#
	# フェラーリの公式 ( Ferrari's method ) に基づく四次方程式の解法
	#
	#   考え方はカルダノの公式と同じ
	#
	#   四次方程式の減次
	#
	#     aX^4 + bX^3 + cX^2 + dX + e == 0
	#
	#     Y == X + s == X + b/4a
	#     -> X == Y - s == Y - b/4a
	#
	#     -> Y^4 + pY^2 + qY + r == 0
	#
	#   q == 0 の時
	#
	#     Y^4 + pY^2 + r == ( Y^2 )^2 + p * ( Y^2 ) + r == 0
	#
	#     -> Y^2 == ( -p ± sqrt( p^2 - 4r ) ) / 2
	#
	#     -> Y[0] == + sqrt( -p + sqrt( p^2 - 4r ) ) / sqrt( 2 )
	#             == + sqrt( 2 ) * sqrt( -p + sqrt( p^2 - 4r ) ) / 2
	#             == + sqrt( 2 * ( -p * sqrt( -p + sqrt( p^2 - 4r ) ) ) ) / 2
	#
	#        Y[1] == - sqrt( 2 * ( -p * sqrt( -p + sqrt( p^2 - 4r ) ) ) ) / 2
	#        Y[2] == + sqrt( 2 * ( -p * sqrt( -p - sqrt( p^2 - 4r ) ) ) ) / 2
	#        Y[3] == - sqrt( 2 * ( -p * sqrt( -p - sqrt( p^2 - 4r ) ) ) ) / 2
	#
	#   r == 0 の時、
	#
	#     Y^4 + pY^2 + qY + r == Y^4 + pY^2 + qY
	#                         == Y * ( Y^3 + pY + q )
	#                         == 0
	#
	#     -> Y[0] == 0
	#        Y[i] == solve3( 1 , 0 , p , q )            ( i == 1 , 2 , 3 )
	#
	#
	#   q != 0 且つ r != 0 の時
	#
	#     Y^4 + pY^2 + + qY + r == 0
	#
	#     -> Y^4 == -pY^2 - qY - r
	#
	#     左辺が完全平方になるように変形する。
	#
	#       Y^4 + ( 2tY^2 + t^2 ) == -pY^2 - qY - r + ( 2tY^2 + t^2 )
	#
	#       -> ( Y^2 + t )^2 == ( 2t - p ) * Y^2 - qY + ( t^2 - r )
	#
	#                                                 m           t^2 - n
	#                        == ( 2t - p )( Y^2 - -------- * Y + --------- )
	#                                              2t - p         2t - p
	#
	#     右辺が完全平方になる条件は、二次方程式の判別式より、
	#
	#       ( 2t - p ) * Y^2 - qY + t^2 - r == 0
	#
	#       -> D == q^2 - 4 * ( 2t - p )( t^2 - r )
	#            == -4 * ( 2t^3 - 2rt - pt^2 + pr ) + q^2
	#            == -8t^3 + 4prt^2 + 8rt + q^2
	#            == 0
	#
	#       -> 8t^3 - 4prt^2 - 8rt - q^2 == 0
	#
	#     これをカルダノ法で解くことにより、 t が決定する。 ( t は最大で三種類存在する。 )
	#
	#       t[i] == solve2( 8 , -4pr , -8r , -q^2 )       ( i == 0 , 1 , 2 )
	#
	#     ここで、
	#
	#       u == 2t - p
	#
	#       -> t == ( u + p ) / 2
	#
	#     とおくと、
	#
	#           8 * ( ( u + p ) / 2 )^3
	#       - 4pr * ( ( u + p ) / 2 )^2
	#       -  8r * ( ( u + p ) / 2 )
	#       - q^2
	#
	#       ==      ( u + p )^3
	#        - pr * ( u + p )^2
	#        - 4r * ( u + p )
	#        - q^2
	#
	#     これは ( u + p ) についての三次方程式になっているので、
	#
	#       ( u[i] + p ) == solve3 ( 1 , -pr , -4r , -q^2 )    ( i == 0 , 1 , 2 )
	#
	#     とすることもできる。
	#
	#     右辺の二次式の判別式を D == 0 としたことにより、先の等式は両辺共に完全平方となり、
	#
	#       ( Y^2 + t )^2 == ( 2t - p ) * Y^2 - qY + t^2 - r 
	#
	#                                             q            t^2 - r 
	#                     == ( 2t - p )( Y^2 - -------- * Y + --------- )
	#                                           2t - p         2t - p
	#
	#                                                    q
	#       -> ( Y^2 + t )^2 == ( 2t - k ) * ( Y - --------------- )^2
	#                                               2 * ( 2t - p )
	#                                      q
	#                        == u * ( Y - ---- )^2
	#                                      2u
	#
	#       -> Y^2 + t == ± sqrt( u ) * ( Y - p / 2u )
	#
	#     を得る。
	#
	#     ここで、
	#
	#       A == sqrt( u ) , B == p / 2u
	#
	#     とおくと、
	#
	#       Y^2 + t == ± A * ( Y - B )
	#
	#       -> Y^2 + t ==  AY - AB
	#          Y^2 + t == -AY + AB
	#
	#       -> Y^2 - AY + AB + t == 0     .... [1]
	#          Y^2 + AY - AB + t == 0     .... [2]
	#
	#     の二式が得られる。
	#
	#     [1] の解を Y[0] , Y[1] とし、[2] の解を Y[2] , Y[3] とすると、
	#
	#       Y[0] == 1/2 * (  A + sqrt( A^2 - 4A * ( AB + t ) ) )
	#       Y[1] == 1/2 * (  A - sqrt( A^2 - 4A * ( AB + t ) ) )
	#       Y[2] == 1/2 * ( -A + sqrt( A^2 + 4A * ( AB - t ) ) )
	#       Y[3] == 1/2 * ( -A - sqrt( A^2 + 4A * ( AB - t ) ) )
	#
	#     となり、
	#
	#       X == Y - s == Y - b/4a
	#
	#     より、
	#
	#       X[k] == Y[k] - b/4a      ( k == 0 -> 3 )
	#
	#     となる。
	#
	#     Y[k] は、以下のような特長を持っている必要がある。
	#
	#       Y[0] + Y[1] ==  A
	#       Y[2] + Y[3] == -A
	#
	#       ( Y[0] + Y[1] )( Y[2] + Y[3] ) == ( -1 ) * A^2
	#
	#     これに当てはめるか、または元の四次式に代入して値を確定すればいいのだが、あまりスマートな方法とは言えない。
	#
	#
	#   ラグランジェのリゾルベントを介した解法
	#
	#     四次方程式
	#
	#       Y^4 + pY^2 + qY + r == 0
	#
	#     のリゾルベントを適切に定義すると、その解は、
	#
	#       y == 1/4 * ( L1 + L2 + L3 + L4 )
	#       s == 1/4 * ( L1 - L2 + L3 - L4 )
	#       t == 1/4 * ( L1 + L2 - L3 - L4 )
	#       u == 1/4 * ( L1 - L2 - L3 + L4 )
	#
	#     と表現することができる。
	#
	#     これは、 4 次のアダマール行列
	#
	#       H == [ 1 ,  1 ,  1 ,  1 ]
	#            [ 1 , -1 ,  1 , -1 ]
	#            [ 1 ,  1 , -1 , -1 ]
	#            [ 1 , -1 , -1 ,  1 ]
	#
	#     を用いて、
	#
	#       [ y ] == inverse( H ) * [ L1 ] == 1/4 * H * [ L1 ] == 1/4 * [ L1 + L2 + L3 + L4 ]
	#       [ s ]                   [ L2 ]              [ L2 ]          [ L1 - L2 + L3 - L4 ]
	#       [ t ]                   [ L3 ]              [ L3 ]          [ L1 + L2 - L3 - L4 ]
	#       [ u ]                   [ L4 ]              [ L4 ]          [ L1 - L2 - L3 + L4 ]
	#
	#       [ L1 ] == H * [ y ] == [ y + s + t + u ]
	#       [ L2 ]        [ s ]    [ y - s + t - u ]
	#       [ L3 ]        [ t ]    [ y + s - t - u ]
	#       [ L4 ]        [ u ]    [ y - s - t + u ]
	#
	#     と表すこともできる。
	#
	#     ここで、
	#
	#       ( y - ( s + t + u ) )( y - ( - s + t - u ) )( y - ( s - t - u ) )( y - ( - s - t + u ) )
	#
	#       == ( y - s - t - u )( y + s - t + u )( y - s + t + u )( y + s + t - u )
	#
	#       == ( ( y - u ) - ( s + t ) )( ( y + u ) + ( s - t ) )( ( y + u ) - ( s - t ) )( ( y - u ) + ( s + t ) )
	#
	#       == ( ( y - u )^2 - ( s + t )^2 )( ( y + u )^2 - ( s - t )^2 )
	#
	#       == ( ( y^2 - 2ux + u^2 ) - ( s^2 + 2st + t^2 ) )( ( y^2 + 2ux + u^2 ) - ( s^2 - 2st + t^2 ) )
	#
	#       == ( ( y^2 + u^2 - s^2 - t^2 ) - 2 * ( uy + st ) )( ( y^2 + u^2 - s^2 - t^2 ) + 2 * ( uy + st ) )
	#
	#       == ( y^2 + u^2 - s^2 - t^2 )^2 - 4 * ( uy + st )^2
	#
	#       == y^4 + ( 2 * ( u^2 - s^2 - t^2 ) - 4u^2 ) * y^2 - 8 * stuy + ( u^2 - s^2 - t^2 )^2 - 4 * ( st )^2
	#
	#       == y^4 - 2 * ( s^2 + t^2 + u^2 ) * y^2 - 8stuy + s^4 + t^2 + u^4 - 2 * ( ( st )^2 + ( tu )^2 + ( us )^2 )
	#
	#       == Y^4 + pY^2 + qY + r
	#
	#       -> p == -2 * ( s^2 + t^2 + u^2 )
	#          q == -8 * stu
	#          r == s^4 + t^4 + u^4 - 2 * ( ( st )^2 + ( tu )^2 + ( us )^2 )
	#            == ( s^2 + t^2 + u^2 )^2 - 4 * ( ( st )^2 + ( tu ) ^2 + ( us )^2 )
	#
	#       -> s^2 + t^2 + u^2                == -p / 2
	#          stu                            == -q / 8
	#          ( st )^2 + ( tu )^2 + ( us )^2 == -1/4 * ( r - ( -p / 2 )^2 )
	#                                         == -1/4 * ( r - p^2 / 4 )
	#                                         == p^2/16 - r/4
	#
	#     と言う関係が得られる。
	#
	#     この時、 s^2 , t^2 , u^2 を解に持つ三次方程式は、
	#
	#       ( Z - s^2 )( Z - t^2 )( Z - u^2 )
	#
	#       == Z^3 - ( s^2 + t^2 + u^2 ) * Z^2 + ( ( st )^2 + ( tu )^2 + ( us )^2 ) * Z - ( stu )^2
	#
	#                   p               p^2 - 4r             q^2
	#       == Z^3 - ( --- ) * Z^2 + ( ---------- ) * Z - ( ----- )
	#                   2                  16                64
	#
	#       == 0
	#
	#     と表すことができる。
	#
	#     この三次方程式から s^2 , t^2 , u^2 を求めると、s , t , u は、その平方根として得ることができる。
	#     この時、
	#
	#       stu = -q / 8
	#
	#     となるように s , t , u の符号を選択することで s , t , u が確定する。
	#
	#     s , t , u が確定すれば、
	#
	#       Y^4 + pY^2 + qY + r == 0
	#
	#    の解として、
	#
	#       Y[0] ==   s + t + u 
	#       Y[1] == - s + t - u
	#       Y[2] ==   s - t - u
	#       Y[3] == - s - t + u
	#
	#    を採ることができる。
	#
	#    X == Y - s より、
	#
	#      X[i] == Y[i] - s
	#
	#-----------------------------------------------------------------------
	my @arg = @_ ;
	return ()	unless ( @arg == 5 ) ;
	return ()	if ( $arg[0] == 0 ) ;

	foreach ( @arg ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
	}

	return solve3( @arg[ 1 .. $#arg ] )	if ( $arg[0] == 0 ) ;

	#
	# Y == X - s
	#
	#    aX^4 + bX^3 + cX^2 + dX + e == 0
	# ->  Y^4        + pY^2 + qX + r == 0
	#
	my( $s , $p , $q , $r ) ;
	( $s , $p ) = alge_defrated_coef( @arg ) ;
	( $p , $q , $r ) = @{ $p }[ 2 .. 4 ] ;

	#
	# 主処理
	#
	my @x = () ;

	if ( $q == 0 ) {
		#
		# 複二次方程式 ( biquadratic equation )
		#
		#   q == 0 より、 Y^2 についての二次方程式となる。
		#
		#   Y^4 + pY^2 + qY + r == ( Y^2 )^2 + p * ( Y^2 ) + r == 0
		#
		#   -> Y^2 == solve2( 1 , p , r )
		#
		#   -> Y[0] == + sqrt( ( Y^2 )[0] ) 
		#      Y[1] == - sqrt( ( Y^2 )[0] )
		#      Y[2] == + sqrt( ( Y^2 )[1] )
		#      Y[3] == - sqrt( ( Y^2 )[1] )
		#
		my $y2 = [ solve2( 1 , $p , $r ) ] ;
		foreach ( @{ $y2 } ) {
			$_ = $_->complex()	unless ( $_->is_complex() ) ;
		}

		@x = (
			$y2->[0]->sqrt() ,
			$y2->[1]->sqrt() ,
		) ;

		#
		# X[i] == Y[i] - s
		#
		foreach ( @x ) {
			$_ -= $s ;
		}
	}
	elsif ( $r == 0 ) {
		#
		# Y^4 + pY^2 + qY + r == Y^4 + pY^2 + qY
		#                     == Y * ( Y^3 + pY + q )
		#                     == 0
		#
		# -> Y[0] == 0
		#    Y[ 1 , 2 , 3 ] == ( solve3( 1 , 0 , p , q  ) )
		#
		my $x = [
			__PACKAGE__->new( 0 )		,
			solve3( 1 , 0 , $p , $q  )	,
		] ;

		#
		# X[i] == Y[i] - s
		#
		foreach ( @x ) {
			$_ -= $s ;
		}
	}
	else {
		#
		#    Y^4 + pY^2 + qY + r
		# == Y^4 - 2 * ( s^2 + t^2 + u^2 ) * Y^2 - 8stuY + ( s^4 + t^4 + u^4 - 2 * ( ( st )^2 + ( tu )^2 + ( us )^2 ) )
		# == 0
		#
		# -> p == -2 * ( s^2 + t^2 + u^2 )
		#    q == -8 * stu
		#    r == ( s^4 + t^4 + u^4 ) - 2 * ( ( st )^2 + ( tu )^2 + ( us )^2 )
		#      == ( s^2 + t^2 + u^2 )^2 - 4 * ( ( st )^2 + ( tu )^2 + ( us )^2 )
		#      == ( -p/2 )^2 - 4 * ( ( st )^2 + ( tu )^2 + ( us )^2 )
		#
		# -> s^2 + t^2 + u^2                == -p / 2
		#    stu                            == -q / 8
		#    ( st )^2 + ( tu )^2 + ( us )^2 == ( r - ( p^2/4 ) ) * ( -1 ) / 4
		#                                   == ( p^2 - 4r ) / 16 
		#
		# -> ( Z - s^2 )( Z - t^2 )( Z - u^2 )
		#    == Z^3 - ( s^2 + t^2 + u^2 ) * Z^2 + ( ( st )^2 + ( tu )^2 + ( us )^2 ) * Z - ( stu )^2
		#
		#                p               p^2 - 4r             q^2
		#    == Z^3 + ( --- ) * Z^2 + ( ---------- ) * Z - ( ----- ) == 0
		#                2                  16                 64
		#
		# -> Z[i] == solve3( 1 , p/2 , ( p^2 - 4r ) / 16 , ( -1 ) * q^2 / 64 )
		#
		my $z = [
			solve3( 1 , $p / 2 , ( ( $p ** 2 ) - ( $r * 4 ) ) / 16 , ( ( $q ** 2 ) * ( -1 ) ) / 64 )	,
		] ;

		foreach ( @{ $z } ) {
			$_ = $_->complex()	unless ( $_->is_complex() ) ;
		}

		#
		# Y[0][0] == + sqrt( Z[0] )
		# Y[0][1] == - sqrt( Z[0] )
		#
		# Y[1][0] == + sqrt( Z[1] )
		# Y[1][1] == - sqrt( Z[1] )
		#
		# Y[2][0] == + sqrt( Z[2] )
		# Y[2][1] == - sqrt( Z[2] )
		#
		my $y = [
			[ $z->[0]->sqrt() ] ,
			[ $z->[1]->sqrt() ] ,
			[ $z->[2]->sqrt() ] ,
		] ;

		#
		# 以下の条件で Y[i] の組み合わせを決定する。
		#
		#   stu == Y[0] * Y[1] * Y[2] == -q / 8
		#
		# 精度があまりよくないので、小数点以下 7 桁程度で判定する。
		#
		my $pat = [
			[ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] , [ 0 , 1 , 0 ] , [ 0 , 1 , 1 ] ,
			[ 1 , 0 , 0 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 0 ] , [ 1 , 1 , 1 ] ,
		] ;

		my $qq = $q->round( 7 ) ;
		my $acc = $qq->decimal_digits() ;
		my $ok = 0 ;
		foreach my $i ( @{ $pat } ) {
			my $val = $y->[0]->[ $i->[0] ]
				* $y->[1]->[ $i->[1] ]
				* $y->[2]->[ $i->[2] ]
				* ( -8 )
			;

			$val = $val->round( $acc ) ;

			if ( $val == $qq ) {
				$y = [
					$y->[0]->[ $i->[0] ]	,
					$y->[1]->[ $i->[1] ]	,
					$y->[2]->[ $i->[2] ]	,
				] ;
				$ok = 1 ;
				last ;
			}
		}

		if ( $ok ) {
			#
			# Y[0] ==   s + t + u 
			# Y[1] == - s + t - u
			# Y[2] ==   s - t - u
			# Y[3] == - s - t + u
			#
			# X[i] == Y[i] - s
			#
			@x = (
				$y->[0]          + $y->[1]          + $y->[2]		,
				$y->[0] * ( -1 ) + $y->[1]          + $y->[2] * ( -1 )	,
				$y->[0]          + $y->[1] * ( -1 ) + $y->[2] * ( -1 )	,
				$y->[0] * ( -1 ) + $y->[1] * ( -1 ) + $y->[2]		,
			) ;

			foreach ( @x ) {
				$_ -= $s ;
			}
		}
	}

	return @x ;
}

sub solven {
	#-----------------------------------------------------------------------
	#
	# DKA 法 ( Durand-Kerner-Aberth method ) による n 次方程式の解法
	#
	#   DKA 法は、ワイエルシュトラス法 ( Weierstrass method ) とも呼ばれる。
	#
	#   DKA 法では、 n 次方程式を
	#
	#     f(z) == a[0] * z^n + a[1] * z^(n-1) + a[2] * z^(n-2) + ...... + a[n]
	#
	#          == a[0] * ( z - x[1] )( z - x[2] ) ..... ( z - x[n] )
	#
	#          == a[0] * Π( z - x[j] )           ( j == 1 -> n )
	#
	#          == 0
	#
	#   と捉え、
	#
	#   f(z) を微分した f'(z) を
	#
	#     f'( z[i] ) == a[0] * Π( z[i] - z[j] )        ( j == 1 -> n ; j != i )
	#
	#   と定義する。
	#
	#   これをニュートン法で近似する式は、
	#
	#                                          f( z[i][k] )
	#     z[i][ k + 1 ] == z[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
	#                                 a[0] * Π( z[i][k] - z[j][k] )
	#
	#   と表される。 ( Durand-Kerner の公式 )
	#
	#   この時、各 z[j] の初期値 z[j][0] は、
	#
	#     R0 == ( -1 ) * a[1] / ( n * a[0] )
	#
	#                                   2PI           3
	#     z[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )              ( j == 1 -> n )
	#                                    n            4
	#
	#   で与えられる。 ( Aberth の初期値 )
	#
	#   R は、複素平面上の座標 [ R0 , 0 ] を中心とする円の半径であり、この円の中に解が存在するように設定された値となる。
	#
	#   この時、初期値 z[j][0] は、この円の円弧状に均等に配置されるような値となる。
	#
	#
	#   R の導出
	#
	#     n 次方程式
	#
	#       f(X) == a[0] * X^n + a[1] * X^( n-1 ) + ..... + a[n] == 0
	#
	#     を減次した
	#
	#       g(Y) == b[0] * Y^n + b[2] * Y^( n-2 ) + ..... + b[n] == 0
	#
	#     を利用する。
	#
	#     g(Y) == 0 は、 b[0] == 1 としても一般性は失われないため、
	#
	#       b[k] = b[k] / b[0]
	#
	#       -> g(Y) == Y^n + b[2] * Y^(n-2) + ..... + b[n] == 0
	#
	#     として調整済みとする。
	#
	#     g(Y) の Y^n 以外の項を右辺に移項すると、
	#
	#       Y^n == ( -1 ) * ( b[2] * Y^( n-2 ) + b[3] * Y^( n-3 ) + .... + b[n] )
	#
	#       -> abs( Y^n ) == b[2] * Y^( n-2 ) + b[3] * Y^( n-3 ) + .... + b[n]
	#                     <= abs( b[2] ) * abs( Y^( n-2 ) ) + .... + abs( b[n] )
	#
	#     と言う関係が得られる。
	#
	#     この不等式は Y の絶対値最大の値に対しても成り立ち、
	#     Y の値として絶対値最大の値を採った時に左右の辺は等式で結ばれる。
	#
	#     よって、
	#
	#       R == max( abs( Y ) ) 
	#
	#       R^n == abs( b[2] ) * R^( n-2 ) + ..... + abs( b[n] )
	#
	#       -> R^n - abs( b[2] ) * R^(n-2) - .... - abs( b[n] ) == 0
	#
	#     となる。
	#
	#     b[k] が全て実数であれば、 abs( b[n] ) の n 乗根には必ず実数が現れる。
	#     これを初期値として、上記 R に関する n 次方程式をニュートン法で解くと、
	#     全ての Y を覆い尽くす円の半径 R を実数として得ることができる。
	#
	#-----------------------------------------------------------------------
	my( $c , $r ) ;

	if ( ref( $_[0] ) eq 'ARRAY' )	{ ( $c , $r ) = @_ ; }
	else				{ $c = [ @_ ] ; }

	return ()	unless ( ref( $c ) eq 'ARRAY' ) ;

	foreach ( @{ $c } ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return ()			unless ( defined $_ ) ;
	}

	#
	# X^0 の項が 0 である場合
	#
	#   X * ( a[0] * X^n + a[1] * X^(n-1) + .... + a[n] ) == 0
	#
	if ( $c->[ -1 ] == 0 ) {
		return ( __PACKAGE__->new( 0 ) , solven( @{ $c }[ 0 .. ( $#{ $c } - 1 ) ] ) ) ;
	}

	#
	# R0 == ( -1 ) * a[1] / ( n * a[0] )
	#
	my $n = $#{ $c } ;
	my $r0 = ( $c->[1] / ( $n * $c->[0] ) ) * ( -1 ) ;

	#
	# f(X) == a[0] * X^n + a[1] * X^( n-1 ) + ..... + a[n] == 0
	#
	# -> g(Y) == Y^n + b[2] * Y^( n-2 ) + ..... + b[n] == 0
	#
	# -> R^n - abs( b[2] ) * R^(n-2) - .... - abs( b[n] ) == 0
	#
	unless ( defined $r ) {
		#
		# 減次した係数を取得し、第二項以降 ( 実質的には第三項以降 ) を
		#
		#   b[k] == ( -1 ) * abs( b[k] )
		#
		# に変換する。
		#
		my $d = ( alge_defrated_coef( @{ $c } ) )[1] ;	# 減次した係数
		if ( defined $d ) {
		    foreach my $i ( 1 .. $#{ $d } ) {
		    	$d->[ $i ] = $d->[ $i ]->abs() * ( -1 ) ;
		    }
		}
		else {
			$d = $c ;
		}
		$r = newton( @{ $d } ) ;
	}

	#
	#                               2PI           3
	# z[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )      ( j == 1 -> n )
	#                                n            4
	#
	my $pi2 = pi() * 2 ;
	my $np = $pi2 / $n ;
	my $z = [] ;
	foreach my $j ( 1 .. $n ) {
		my $t = ( $np * ( ( $j * 4 ) - 3 ) / 4 ) % $pi2 ;
		$z->[ $j - 1 ] = $r0 + $r * complex( { 'arg' => $t } ) ;
	}

	#
	#
	# 漸化式
	#
	#                                        f( z[i][k] )
	#   z[i][ k + 1 ] == z[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
	#                               a[0] * Π( z[i][k] - z[j][k] )
	#
	my $cnt = 0 ;
	while ( $cnt++ < 100 ) {
		my $flg = 0 ;
		my $w = [] ;
		foreach my $i ( 0 .. $#{ $z } ) {
			my $fx = horner_sub( $z->[ $i ] , @{ $c } ) ;
			my $dx = $c->[0] ;
			foreach my $j ( 0 .. $#{ $z } ) {
				next	if ( $i == $j ) ;
				$dx *= ( $z->[ $i ] - $z->[ $j ] ) ;
			}

			my $diff = $fx->divide( $dx ) ;

			if ( $diff->is_complex() ) {
				$flg++	if ( $diff->det()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
			}
			else {
				$flg++	if ( $diff->abs()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
			}

			$w->[ $i ] = $z->[ $i ]->subtract( $diff )->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}

		$z = $w ;

		last	if ( $flg >= scalar( @{ $z } ) ) ;
	}

	return @{ $z } ;
}

sub horner_sub {
	#-----------------------------------------------------------------------
	#
	# ホーナー法 ( Honer's method ) による多項式の代入演算 ( substitution )
	#
	#   Y == aX^5 + bX^4 + cX^3 + dX^2 + eX + f
	#     == X * ( aX^4 + bX^3 + cX^2 + dX ) + e ) + f
	#     == X * ( X * ( X * ( aX^3 + bX^2 + cX ) + d ) + e ) + f
	#     == X * ( X * ( X * ( X * ( aX^2 + bX ) + c ) + d ) + e ) + f
	#     == X * ( X * ( X * ( X * ( X * ( X * ( a ) ) + b ) + c ) + d ) + e ) + f
	#
	#   List::Util::reduce で実装すると以下のようになる。
	#
	#     use List::Util qw( reduce ) ;
	#     my $y = reduce { $a * $x + $b } @coef ;
	#
	#-----------------------------------------------------------------------
	my( $x , @c ) = @_ ;

	return undef	unless ( @c ) ;

	@c = @{ $c[0] }	if ( ref( $c[0] ) eq 'ARRAY' ) ;

	$x = __PACKAGE__->new( $x )	unless ( ref( $x ) ) ;
	return undef			unless ( defined $x ) ;
	
	foreach ( @c ) {
		if ( defined $_ ) {
			$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
			$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
			return undef			unless ( defined $_ ) ;
		}
		else {
			$_ = __PACKAGE__->new( 0 ) ;
		}
	}

	my $y = $c[0]->copy() ;
	foreach my $i ( 1 .. $#c ) {
		$y = $y * $x + $c[ $i ] ;
		if ( $i =~ /00$/ ) {
			$y = $y->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}
	}

	$y = $y->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	return $y ;
}

sub horner_transform {
	#-----------------------------------------------------------------------
	#
	# 組み立て除法
	#
	#   組み立て除法は 13 世紀の中国で天元術の一手法として確立されていたとされ、
	#   江戸時代の和算でも広く用いられた。
	#   
	#   西洋ではホーナー法 ( Honer's method ) として知られているが、
	#   組み立て除法は「ホーナー法をベースとした方程式の分解手法」と考えるべきかも知れない。
	#
	#
	#   組み立て除法の流れは以下の通り。
	#
	#     ( x^3 - 2x^2 + 3x + 4 ) / ( x + 1 ) == 0
	#
	#              1   -2               3    -4
	#     -> -1 ) ------------------------------
	#              1   -2 + ( -1 ) * 1 
	#
	#              1   -2   3  -4
	#     -> -1 ) ----------------
	#              1   -3 
	#
	#              1   -2   3                    -4
	#     -> -1 ) ----------------------------------
	#              1   -3   3 + ( -1 ) * ( -3 )
	#
	#              1   -2   3  -4
	#     -> -1 ) ----------------
	#              1   -3   6 
	#
	#              1   -2   3  -4
	#     -> -1 ) -----------------------------
	#              1   -3   6  -4 + ( -1 ) * 6
	#
	#              1   -2   3   -4
	#     -> -1 ) -----------------
	#              1   -3   6  -10
	#
	#              1   -2   3   -4
	#     -> -1 ) -----------------
	#              1   -3   6  -10
	#             ------------
	#              1   -4  10
	#
	#              1   -2   3   -4
	#     -> -1 ) -----------------
	#              1   -3   6  -10   ..... ( x + 1 )(   x^2 - 3x + 6                    ) - 10
	#             ------------
	#              1   -4  10        ..... ( x + 1 )( ( x + 1 )(   x - 4         ) + 10 ) - 10
	#             ------------
	#              1   -5            ..... ( x + 1 )( ( x + 1 )( ( x + 1 ) - 5   ) + 10 ) - 10
	#
	#     -> x^3 - 2x^2 + 3x + 4 == ( x + 1 )( ( x + 1 )( ( x + 1 ) - 5 ) + 10 ) - 10
	#                            == y * ( y * ( y - 5 ) + 10 ) - 10                      .... [1]
	#                            == y^3 - 5y^2 + 10y - 10
	#                            == 0
	#
	#   筆算の左端の -1 は、除数側の一次方程式 x + 1 == 0 の解。
	#   これを被除数側の方程式の係数に掛けて一次元下の係数との間で和を採るという演算を繰り返すと、
	#   多項式の割り算ができると言うことになる。
	#
	#   上述の処理において、 [1] の式はホーナー法による n 次多項式の表現となっている。
	#   このことから、ホーナー法と組み立て除法が表裏一体の関係にあることが判る。
	#
	#
	#   n 次方程式の減次
	#
	#     n 次方程式
	#
	#       a[0] * X^n + a[1] * X^(n-1) + a[2] * X^(n-2) + ..... + a[n] == 0
	#
	#     に対して、
	#
	#       X + ( a[1] / ( n * a[0] ) )
	#
	#     での除算を行うと、 X^(n-1) の項を消した減次となる。
	#
	#     以下、その一例。
	#
	#       2x^3 + 6x^2 + 2x + 2 == 0
	#       -> y == x + ( 6 / ( 3 * 2 ) ) == x + 1
	#
	#                 2   6   2   2 
	#       -> -1 ) -----------------
	#                 2   4  -2   4     ..... ( x + 1 )(   2x^2 + 4x - 2                     ) + 4
	#               -----------------
	#                 2   2  -4         ..... ( x + 1 )( ( x + 1 )(   2x + 2           ) - 4 ) + 4
	#               -----------------
	#                 2   0             ..... ( x + 1 )( ( x + 1 )( ( x + 1 )( 2 ) + 0 ) - 4 ) + 4
	#
	#       -> 2x^3 + 6x^2 + 2x + 2 == ( x + 1 )( ( x + 1 )( ( x + 1 ) * 2 + 0 ) - 4 ) + 4
	#                               == y * ( y * ( 2y + 0 ) - 4 ) + 4
	#                               == 2y^3 - 4y + 4
	#                               == y^3 - 2y + 2
	#                               == 0
	#
	#       -> y^3 - 2y + 2 == ( x + 1 )^3 - 2 * ( x + 1 ) + 2 == 0
	#
	#
	#   ここでは、
	#
	#     g(Y) == f(X) / ( X + d ) == 0
	#
	#   の結果として得られる g(Y) の係数列と d を返す事とする。
	#
	#   d の省略時値は、
	#
	#     f(X) == a[0]X^n + a[1]X^(n-1) + a[2]X^(n-2) + ..... + a[n]
	#
	#   における
	#
	#     d == a[1] / ( n * a[0] )
	#
	#   とする。 ( n 次方程式の減次 )
	#
	#   戻り値は、 g(Y) の係数列を格納した配列参照 $r と変換に用いたスカラー値 $d を用いて、
	#
	#     ( $r , $d )
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $c , $d ) = @_ ;

	return ()	unless ( ref( $c ) eq 'ARRAY' ) ;

	foreach ( @{ $c } ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return ()			unless ( defined $_ ) ;
		$_ = $_->copy() ;
	}

	#
	# 多項式の次数
	#
	my $n = $#{ $c } ;

	#
	# f(X) == c[0] * X^n + c[1] * X^(n-1) + c[2] * X^(n-2) + .... + c[n]
	#
	#      == Σ( c[i] * X^( n - i ) )      ( i == 0 -> n )
	#
	# g(Y) == f(X) / ( X - d )
	#
	#      == r[0] * Y^n + r[1] * Y^(n-1) + r[2] * Y^(n-2) + .... + r[n]
	#
	#      == Σ( r[i] * Y^( n - i ) )      ( i == 0 -> n )
	#
	if ( defined $d ) {
		$d = __PACKAGE__->new( $d )	if ( substr( ref( $d ) , 0 , 9 ) eq 'Math::Big' ) ;
		$d = __PACKAGE__->new( $d )	unless ( ref( $d ) ) ;
		return ()			unless ( defined $d ) ;
		$d *= ( -1 ) ;
	}
	else {
		#
		# d == ( -1 ) * b / ( n * a )
		#
		return ()	if ( $c->[0] == 0 ) ;
		$d = $c->[1] * ( -1 ) / ( $c->[0] * $n ) ;
	}

	#
	# 変換
	#
	my $r = [] ;
	while ( @{ $c } > 0 ) {
		foreach my $i ( 1 .. $#{ $c } ) {
			$c->[ $i ] += $c->[ $i - 1 ] * $d ;
		}
		unshift( @{ $r } , pop( @{ $c } ) ) ;

		if ( @{ $c } == 1 ) {
			unshift( @{ $r } , pop( @{ $c } ) ) ;
		}
	}

	$d *= ( -1 ) ;

	return ( $r , $d ) ;
}

sub alge_defrated_coef {
	#-----------------------------------------------------------------------
	#
	# n 次方程式の減次 
	#
	#   チルンハウゼン変換 ( Tschirnhausen transformation ) やチルンハウス変換とも呼ばれる。
	#
	#   ここでは、 n - 1 次の項を消去する減次を行い、 n 次の項を 1 とする係数列を返す。
	#
	#   これは、 X に関する n 次方程式
	#
	#     f(X) == Σ( a[i] * X^(n-i) ) == 0         ( i == 0 -> n )
	#
	#   に対して、
	#
	#     Y == X - s == X - ( a[1] / ( n * a[0] ) )
	#
	#   を代入して展開した結果から得られる係数列と等しくなる。
	#
	#   二次から四次の方程式では、広く知られている展開式をそのまま用いている。
	#   五次以上の方程式に関しては、組み立て除法 ( ホーナー法に基づく分解 ) により、係数列を得る。
	#
	#   組み立て除法は、二次から四次の方程式に適用することもできる。
	#
	#
	#   n 次の方程式を減次した結果は、
	#
	#     f(X) == Σ( a[i] * X^(n-i) )              ( i == 0 -> n )
	#
	#          == a[0] * X^n + a[1] * X^(n-1) + ..... + a[n]
	#
	#          == 0
	#
	#     -> Y == X - s == X - ( a[1] / ( n * a[0] ) )
	#
	#     -> Y^n + b[2] * Y^(n-2) + b[3] * Y^(n-3) + .... + b[n] == 0
	#
	#   であり、
	#
	#     b[0] == 1
	#     b[1] == 0
	#
	#   として、
	#
	#   ( s , [ b[0] , b[1] , b[2] , .... , b[n] ] ) を返す事とする。
	#
	#-----------------------------------------------------------------------
	my( @c ) = @_ ;

	foreach ( @c ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return ()			unless ( defined $_ ) ;
	}

	while ( $c[0] == 0 ) { shift( @c ) ; last if ( @c == 0 ) ; }

	return ()	if ( @c < 3 ) ;

	my $s = undef ;
	my @r = () ;

	if ( @c == 3 ) {
		#
		# 二次方程式の減次
		#
		#   以下のような変換を行い、 p を返す。
		#
		#        aX^2 + bX + c == 0
		#     ->  Y^2      + p == 0
		#   
		#   Y = X - s を定義して代入し、これを展開する。
		#
		#     aX^2 + bX + c == a( Y - s )^2 + b( Y - s ) + c
		#
		#                   == a * ( Y^2 - 2sY + s^2 )
		#                    + b * (         Y - s   )
		#                    + c
		#
		#                   == aY^2 + ( -2as + b )Y + as^2 - bs + c
		#                   == Y^2 + p
		#                   == 0
		#
		#     -> b - 2as == 0 -> s == b/2a
		#
		#        p == ( as^2 - bs + c ) / a
		#
		$s = $c[1] / ( $c[0] * 2 ) ;
		@r = (
			( ( $c[ 0] * ( $s ** 2 ) ) - ( $c[1] * $s ) + $c[2] ) / $c[0] ,
		) ;

		foreach ( @r ) {
			#$_ /= $c[0] ;
			$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}
	}
	elsif ( @c == 4 ) {
		#
		# 三次方程式の減次
		#
		#   以下のような変換を行い、 p , q を返す。
		#
		#        aX^3 + bX^2 + cX + d == 0
		#     ->  Y^3        + pY + q == 0
		#   
		#   
		#   Y = X - s を定義して代入し、これを展開する。
		#
		#     aX^3 + bX^2 + cX + d == a( Y - s )^3 + b( Y - s )^2 + c( Y - s ) + d
		#
		#                          == a * ( Y^3 - 3sY^2 + 3s^2Y - s^3 )
		#                           + b * (         Y^2 -   2sY + s^2 )
		#                           + c * (                   Y - s   )
		#                           + d
		#
		#                          == aY^3 + ( -3as + b )Y^2 + ( 3as^2 - 2bs + c )Y + ( -as^3 + bs^2 - cs + d )
		#                          ==  Y^3 + pY + q
		#                          == 0
		#
		#   得られた結果から係数を比較し、 Y^2 の項を消去する条件を整える。
		#
		#     b - 3as == 0 -> s == b/3a
		#
		#     p == ( 3as^2 - 2bs + c ) / a
		#     q == ( -as^3 + bs^2 - cs + d ) / a
		#
		$s = $c[1] / ( $c[0] * 3 ) ;
		@r = (
			( $c[0] * ( $s ** 2 ) * 3      ) - ( $c[1] * ( $s      ) * 2    ) +   $c[2]       		, # p
			( $c[0] * ( $s ** 3 ) * ( -1 ) ) + ( $c[1] * ( $s ** 2 )        ) - ( $c[2] * $s ) + $c[3] 	, # q
		) ;

		foreach ( @r ) {
			$_ /= $c[0] ;
			$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}
	}
	elsif ( @c == 5 ) {
		#
		# 四次方程式の減次
		#
		#   以下のような変換を行い、 p , q  , r を返す。
		#
		#        aX^4 + bX^3 + cX^2 + dX + e == 0
		#     ->  Y^4        + pY^2 + qX + r == 0
		#   
		#   
		#   Y = X - s を定義して代入し、これを展開する。
		#
		#     a( Y - s )^4 + b( Y - s )^3 + c( Y - s )^2 + d( Y - s )
		#
		#     ==  a * ( Y^4 - 4sY^3 + 6s^2Y^2 - 4s^3Y + s^4 )
		#       + b * (         Y^3 -   3sY^2 + 3s^2Y - s^3 )
		#       + c * (                   Y^2 -   2sY + s^2 )
		#       + d * (                             Y - s   )
		#       + e
		#
		#     ==  aY^4
		#       + ( -4as + b )Y^3
		#       + ( 6as^2 - 3bs + c )Y^2
		#       + ( -4as^3 + 3bs^2 - 2cs + d )Y
		#       + ( as^4 - bs^3 + cs^2 - ds + e )
		#
		#     == Y^4 + pY^2 + qY + r == 0
		#
		#     -> -4as + b == 0 -> s == b/4a
		#
		#        p == ( 6as^2 - 3bs + c ) / a
		#        q == ( -4as^3 + 3bs^2 - 2cs + d ) / a
		#        r == ( as^4 - bs^3 + cs^2 - ds + e ) / a
		#
		$s = $c[1] / ( $c[0] * 4 ) ;
		my $s2 = $s  * $s ;
		my $s3 = $s2 * $s ;
		my $s4 = $s3 * $s ;

		@r = (
			( $c[0] * $s2 * 6 )      - ( $c[1] * $s  * 3 ) +   $c[2] 					, # p
			( $c[0] * $s3 * ( -4 ) ) + ( $c[1] * $s2 * 3 ) - ( $c[2] * $s * 2 ) + $c[3] 			, # q
			( $c[0] * $s4 )          - ( $c[1] * $s3 )     + ( $c[2] * $s2 )    - ( $c[3] * $s ) + $c[4] 	, # r
		) ;

		foreach ( @r ) {
			$_ /= $c[0] ;
			$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}
	}
	else {
		#
		# 五次以上の高次方程式の減次
		#
		#   組み立て除法 ( ホーナー法 ) による減次を行う。
		#
		my $n = scalar( @c ) - 1 ;
		$s = $c[1] / ( $c[0] * $n ) ;
		@r = @{ ( horner_transform( [ @c ] , $s ) )[0] } ;

		foreach my $i ( 2 .. $#r ) {
			$r[ $i ] /= $r[0] ;
			$r[ $i ] = $r[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}

		@r = @r[ 2 .. $#r ] ;
	}

	if ( @r ) {
		@r = (
			__PACKAGE__->new( 1 )	,
			__PACKAGE__->new( 0 )	,
			@r			,
		) ;
	}

	return ( $s , [ @r ] ) ;
}

#-------------------------------------------------------------------------------
#
# フーリエ変換、離散コサイン変換
#
#-------------------------------------------------------------------------------
sub dft		{ return Complex::dft( @_ ) ;	}	# 離散フーリエ変換
sub idft	{ return Complex::idft( @_ ) ;	}	# 離散フーリエ逆変換

sub fft		{ return Complex::fft( @_ ) ;	}	# 高速フーリエ変換
sub ifft	{ return Complex::ifft( @_ ) ;	}	# 高速フーリエ逆変換

sub rft		{ return Complex::rft( @_ ) ;	}	# 実数列フーリエ変換
sub irft	{ return Complex::irft( @_ ) ;	}	# 実数列フーリエ逆変換

sub dct		{ return Complex::dct( @_ ) ;	}	# 離散コサイン変換
sub idct	{ return Complex::idct( @_ ) ;	}	# 離散コサイン逆変換

sub dct2d	{ return Vector::dct( @_ ) ;	}	# 二次元離散コサイン変換
sub idct2d	{ return Vector::idct( @_ ) ;	}	# 二次元離散コサイン逆変換

sub ntt {
	#-----------------------------------------------------------------------
	#
	# 数論変換 ( Number Theoretic Transform )
	#
	#   離散フーリエ変換 ( DFT ) や高速フーリエ変換 ( FFT ) の回転因子を自然数の剰余類環を利用した因子で置き換えた実装。
	#   整数環 FFT , 高速剰余変換 ( FMT ; Fast Modulo Transform ) とも呼ばれる。
	#
	#   自然数の剰余類環における法 p の採り方によって
	#
	#     離散ガロア体変換 ( DGT ; Discrete Galois Tranform ) 
	#     高速フェルマー変換 ( FFT ; Fast Fermat Transform )
	#
	#   等の呼称が用いられることもある。
	#
	#   n 個の要素を持つ数列 x について、数論変換における変換式は、
	#
	#     正変換
	#     
	#       X[k] == Σ( x[j] * w^(jk) ) ( mod p )            ( j == 0 -> n - 1 , k == 0 -> n - 1 )
	#
	#     逆変換
	#
	#       x[k] == n^(-1) * Σ( X[j] * w^(-jk) ) ( mod p )  ( j == 0 -> n - 1 , k == 0 -> n - 1 )
	#
	#   であり、離散フーリエ変換の変換式に酷似した形となる。
	#
	#   離散フーリエ変換との大きな相違点は、加減算、乗算、冪乗算が全て法 p の下で定義されることにあり、
	#
	#     x[j] * w^(jk) == ( x[j] * w^(jk) ) % p                      ( 合同式の乗算 )
	#                   == ( ( x[j] % p ) * ( w^(jk) % p ) ) % p
	#
	#     w^(jk)  == modexp( w , j * k , p )                          ( 冪剰余演算 )
	#
	#     n^(-1)  == modinverse( n , p )                              ( モジュラー逆数 )
	#             == modexp( n , 1 * totient( p ) , p )
	#
	#     w^(-jk) == ( w^(jk) )^(-1)                                  ( モジュラー逆数 )
	#             == modinverse( w^(jk) , p )
	#             == modexp( w , jk * totient( p ) , p )
	#
	#   等となる。
	#
	#   
	#   数論変換を行うには、変数 n , w , p を決定する必要がある。
	#
	#   p の要件
	#
	#     法 p を決定するための条件はいくつか存在すると思われるが、最も大きな要件は、モジュラー逆数を求める際の演算効率にあるものと考えられる。
	#
	#     オイラーの定理により、モジュラー逆数は
	#
	#       modinverse( x , p ) == x^( totient( p ) - 1 ) % p
	#                           == modexp( x , totient( p ) - 1 , p )
	#
	#     で表される。
	#
	#     p が合成数である場合、 totient( p ) を求めるために非常に大きなコストが必要になる。
	#     モジュラー逆数は拡張ユークリッドの互除法を使用して求めることもできるが、これも高コストな演算となる。
	#     一方、 p が素数である場合、モジュラー逆数は、
	#
	#       modinverse( x , p ) == modexp( x , totient( p ) - 1 , p )
	#                           == modexp( x , p - 2 , p )
	#
	#     となり、演算コストを引き下げることができる。
	#
	#     法 p は、変換対象となる数列のどの要素よりも大きな値である必要がある。
	#
	#       2 * 17 * 41 * 47 + 1       == 5,040 * 12 + 5039 ==        65,519 < 2^16
	#       2^4 * 3^2 * 5 * 7 * 13 + 1 == 5,040 * 13 + 1    ==        65,521 < 2^16
	#       2^31 - 1                                        == 2,147,483,647 < 2^31    ( メルセンヌ素数 )
	#       
	#     等は、このような p の候補と言える。
	#
	#     また、 p は法として使用する値であるため、変換対象の数列の各要素を a[i] ( 0 < i < n ) とした時、
	#
	#       a[i] < p
	#
	#     でなければならない。
	#
	#
	#   n の要件
	#
	#     n は、法 p の下で原始 n 乗根を持つような物でなければならず、 p が素数であれば
	#
	#       gcd( n , p ) == 1   ( p が素数であれば自明 )
	#       n | ( p - 1 )       ( n は p - 1 の約数 )
	#
	#     でなければならない。
	#
	#     当然 n < p でなければならない。
	#
	#
	#   w の要件
	#
	#     w は、離散フーリエ変換における回転因子に当たるものとなる。
	#     離散フーリエ変換における回転因子 w は、複素数体において要素数 n に基づく 1 の原始 n 乗根 ( primitive n-th root of unity ) として定義される。
	#     数論変換における変換因子 w もこれと同じく、法 p の下で要素数 n に基づく 1 の原始 n 乗根である必要があり、
	#
	#       w^n  ≡ 1 ( mod p )
	#       w^k !≡ 1 ( mod p )       ( 0 < k < n )
	#
	#     という条件を満たす必要がある。
	#
	#     w は、 p の原始根と類似した性質を持っており、法 p が奇素数であれば、
	#
	#       w^n == ( w^( n/2 ) )^2 ≡ 1 ( mod p )
	#       -> w^( n/2 ) ≡ ± 1 ( mod p )
	#
	#       w^( n/2 ) !≡ 1 ( mod p )
	#       -> w^( n/2 ) ≡ -1 ( mod p )
	#
	#     と言う性質を持つ。
	#
	#   整理すると、 n , w , p に求められる要件は、 p が素数であれば、
	#   
	#     w^n     ≡  1 ( mod p )
	#     w^(n/2) ≡ -1 ( mod p )
	#
	#   であり、
	#
	#     w^n      ≡  1 ( mod p )
	#     w^(n/2)  ≡ -1 ( mod p )
	#     w^k     !≡  1 ( mod p )    ( 0 < k < n )
	#
	#   が満たされる限りにおいて p は合成数でも可と言うことになる。
	#
	#   このような条件を満たすものとして、
	#
	#     n              w               p     bits
	#     2^17         770     149 * n + 1       24
	#                  201     153 * n + 1       24
	#                   70     155 * n + 1       24
	#                   20     164 * n + 1       24
	#                1,498     165 * n + 1       24
	#     
	#     3 * 2^15      26     173 * n + 1       24
	#                  866     187 * n + 1       24
	#                  562     194 * n + 1       24
	#                  637     204 * n + 1       24
	#                  100     220 * n + 1       24
	#
	#     3^2 * 2^14   175     114 * n + 1       24
	#                  434     132 * n + 1       24
	#                   12     136 * n + 1       24
	#                  604     147 * n + 1       24
	#                  459     150 * n + 1       24
	#
	#     5 * 2^14     329     207 * n + 1       24
	#
	#     2^35         360   8,319 * n + 1       48
	#                  933   8,334 * n + 1       48
	#                1,714   8,549 * n + 1       48
	#                  474   8,756 * n + 1       48
	#                  744   8,759 * n + 1       48
	#
	#     3 * 2^32   9,375  22,100 * n + 1       48
	#                5,549  22,226 * n + 1       48
	#                9,520  22,254 * n + 1       48
	#                3,991  22,314 * n + 1       48
	#                6,955  22,316 * n + 1       48
	#
	#     3^2 * 2^31 8,426  14,636 * n + 1       48
	#                  226  14,771 * n + 1       48
	#                4,987  14,896 * n + 1       48
	#                9,607  14,913 * n + 1       48
	#                7,806  14,994 * n + 1       48
	#
	#     2^50       1,512   1,012 * n + 1       60
	#   
	#   等があるらしい。 ( p は全て素数 )
	#   bits は、
	#
	#     bits == int( log2( p ) ) == int( ln( p ) / ln(2) ) 
	#
	#   で表される値であり、 2^(bits) 以下の値が法 p の下でサポートされることを意味している。
	#
	#   n がより小さな値でよい場合には、 p を据え置いたまま w を調整することができるとのこと。
	#
	#   例えば、 n == 2^8 == 256 の要素数で足りる場合、
	#
	#     p == 149 * 2^17 + 1 == 19,529,729
	#     n == 2^8 == 2^17 / 2^9
	#     w == 770^(2^9) ( mod p )
	#
	#   等とすることができる。
	#
	#
	#
	#   数論変換の一例として、フェルマー数に基づく変換を以下に挙げる。
	#
	#     フェルマー数は、
	#
	#       F(t) == 2^( 2^t ) + 1
	#
	#     で表される数であり、 0 <= t <= 4 の範囲で素数を返す。
	#
	#     要素数 n == 4 の変換を考える場合、
	#
	#       n == 2^t == 4
	#       -> t == 2
	#       -> p == 2^( 2^t ) + 1 == 2^n + 1 == 17
	#
	#       w^(n/2) ≡ -1 ( mod p )
	#       -> w^(4/2) == 16
	#       -> w == 4
	#
	#     とすることができる。
	#
	#     p == 17 に定めたので、数列に格納されている要素の最大値は 16 以下である必要がある。
	#
	#     w == 4 において、 w^k を法 p == 17 の下で求めると、
	#
	#       k >= 0 の時、
	#
	#         w^0  == 4^0  ==    1 ≡  1 ( mod 17 ) ≡ -16 ( mod 17 )
	#         w^1  == 4^1  ==    4 ≡  4 ( mod 17 ) ≡ -13 ( mod 17 )
	#         w^2  == 4^2  ==   16 ≡ 16 ( mod 17 ) ≡  -1 ( mod 17 )
	#         w^3  == 4^3  ==   64 ≡ 13 ( mod 17 ) ≡  -4 ( mod 17 )
	#         w^4  == 4^4  ==  256 ≡  1 ( mod 17 ) ≡ -16 ( mod 17 )
	#         w^5  == 4^5  == 1024 ≡  4 ( mod 17 ) ≡ -13 ( mod 17 )
	#         .......................................................
	#         w^16 == 4^16         ≡  1 ( mod 17 ) ≡ -16 ( mod 17 )
	#
	#       k < 0 の時、
	#
	#         w^(-1) == w^( totient( p ) - 1 )
	#                == w^15
	#
	#       より、
	#
	#         w^(-1)  == 4^(-1)  ≡ ( 4^1 )^15  ( mod 17 ) ≡ 4^(  1 * 15 )  ( mod 17 )  ≡  13 ( mod 17 ) ≡  -4 ( mod 17 )
	#         w^(-2)  == 4^(-2)  ≡ ( 4^2 )^15  ( mod 17 ) ≡ 4^(  2 * 15 )  ( mod 17 )  ≡  16 ( mod 17 ) ≡  -1 ( mod 17 )
	#         w^(-3)  == 4^(-3)  ≡ ( 4^3 )^15  ( mod 17 ) ≡ 4^(  3 * 15 )  ( mod 17 )  ≡   4 ( mod 17 ) ≡ -13 ( mod 17 )
	#         w^(-4)  == 4^(-4)  ≡ ( 4^4 )^15  ( mod 17 ) ≡ 4^(  4 * 15 )  ( mod 17 )  ≡   1 ( mod 17 ) ≡ -16 ( mod 17 )
	#         w^(-5)  == 4^(-5)  ≡ ( 4^5 )^15  ( mod 17 ) ≡ 4^(  5 * 15 )  ( mod 17 )  ≡  13 ( mod 17 ) ≡  -4 ( mod 17 )
	#         ................................................................................
	#         w^(-16) == 4^(-16) ≡ ( 4^16 )^15 ( mod 17 ) ≡ 4^( 16 * 15 )  ( mod 17 )  ≡   1 ( mod 17 ) ≡ -16 ( mod 17 )
	#
	#     となる。
	#
	#
	#     変換因子 w を行列 W で表現すると、正変換用の行列は、
	#
	#       W == [  4^(0*0) , 4^(0*1) , 4^(0*2) , 4^(0*3) ]
	#            [  4^(1*0) , 4^(1*1) , 4^(1*2) , 4^(1*3) ]
	#            [  4^(2*0) , 4^(2*1) , 4^(2*2) , 4^(2*3) ]
	#            [  4^(3*0) , 4^(3*1) , 4^(3*2) , 4^(3*3) ]
	#
	#         == [        1 ,       1 ,       1 ,       1 ]
	#            [        1 ,     4^1 ,     4^2 ,     4^3 ]
	#            [        1 ,     4^2 ,     4^4 ,     4^6 ]
	#            [        1 ,     4^3 ,     4^6 ,     4^9 ]
	#
	#         ≡ [        1 ,       1 ,       1 ,       1 ] ( mod 17 )
	#            [        1 ,       4 ,      16 ,      13 ] 
	#            [        1 ,      16 ,       1 ,      16 ] 
	#            [        1 ,      13 ,      16 ,       4 ] 
	#
	#         ≡ [        1 ,       1 ,       1 ,       1 ] ( mod 17 )
	#            [        1 ,       4 ,      -1 ,      -4 ] 
	#            [        1 ,      -1 ,       1 ,      -1 ] 
	#            [        1 ,      -4 ,      -1 ,       4 ] 
	#
	#     逆変換用の行列は、
	#
	#       totient( 17 ) - 1 == 15
	#
	#       4^(-1) ≡ 4^15 ( mod 17 )
	#              ≡ 13   ( mod 17 )
	#              ≡ -4   ( mod 17 )
	#
	#       W^(-1) == 4^(-1) * [ 4^(-0*0) , 4^(-0*1) , 4^(-0*2) , 4^(-0*3) ]
	#                          [ 4^(-1*0) , 4^(-1*1) , 4^(-1*2) , 4^(-1*3) ]
	#                          [ 4^(-2*0) , 4^(-2*1) , 4^(-2*2) , 4^(-2*3) ]
	#                          [ 4^(-3*0) , 4^(-3*1) , 4^(-3*2) , 4^(-3*3) ]
	#
	#              == 4^(-1) * [        1 ,        1 ,        1 ,        1 ]
	#                          [        1 ,   4^(-1) ,   4^(-2) ,   4^(-3) ]
	#                          [        1 ,   4^(-2) ,   4^(-4) ,   4^(-6) ]
	#                          [        1 ,   4^(-3) ,   4^(-6) ,   4^(-9) ]
	#
	#              ≡ 4^(-1) * [        1 ,          1 ,          1 ,          1 ] ( mod 17 )
	#                          [        1 , ( 4^15 )^1 , ( 4^15 )^2 , ( 4^15 )^3 ]
	#                          [        1 , ( 4^15 )^2 , ( 4^15 )^4 , ( 4^15 )^6 ]
	#                          [        1 , ( 4^15 )^3 , ( 4^15 )^6 , ( 4^15 )^9 ]
	#
	#              ≡ -4     * [        1 ,        1 ,        1 ,        1 ] ( mod 17 )
	#                          [        1 , ( -4 )^1 , ( -4 )^2 , ( -4 )^3 ]
	#                          [        1 , ( -4 )^2 , ( -4 )^4 , ( -4 )^6 ]
	#                          [        1 , ( -4 )^3 , ( -4 )^6 , ( -4 )^9 ]
	#
	#              ≡ -4     * [        1 ,        1 ,        1 ,        1 ] ( mod 17 )
	#                          [        1 ,       -4 ,       16 ,      -13 ]
	#                          [        1 ,       16 ,        1 ,       16 ]
	#                          [        1 ,      -13 ,       16 ,       -4 ]
	#
	#              ≡ 13     * [        1 ,        1 ,        1 ,        1 ] ( mod 17 )
	#                          [        1 ,       13 ,       16 ,        4 ]
	#                          [        1 ,       16 ,        1 ,       16 ]
	#                          [        1 ,        4 ,       16 ,       13 ]
	#     となる。
	#
	#     何れも、 4 つの要素の変換に必要な w^k は、
	#
	#       w^0 , w^1 , w^2 , w^3 , w^4 , w^6 , w^9
	#
	#     の 7 種類のみということになる。
	#
	#
	#     変換する数列 x が
	#
	#       x == [  2 ]
	#            [ 15 ]
	#            [  1 ]
	#            [  0 ]
	#
	#     であるとすると、正変換は、
	#
	#       X == W * x == ( [  1 ,  1 ,  1 ,  1 ] * [  2 ] ) % 17
	#                       [  1 ,  4 , -1 , -4 ]   [ 15 ]
	#                       [  1 , -1 ,  1 , -1 ]   [  1 ]
	#                       [  1 , -4 , -1 ,  4 ]   [  0 ]
	#
	#                  == [ ( 2 + 15 + 1 + 0 ) % 17 ]
	#                     [ ( 2 + 60 - 1 + 0 ) % 17 ]
	#                     [ ( 2 - 15 + 1 - 0 ) % 17 ]
	#                     [ ( 2 - 60 - 1 - 0 ) % 17 ]
	#
	#                  == [ 2 - 2 + 1 + 0 ]
	#                     [ 2 + 9 - 1 + 0 ]
	#                     [ 2 + 2 + 1 - 0 ]
	#                     [ 2 + 8 - 1 - 0 ]
	#
	#                  == [  1 ]
	#                     [ 10 ]
	#                     [  5 ]
	#                     [  9 ]
	#
	#     逆変換は、
	#
	#       x == W^(-1) * X == ( (-4) * [  1 ,  1 ,  1 ,  1 ] * [  1 ] ) % 17
	#                                   [  1 , 13 , 16 ,  4 ]   [ 10 ]
	#                                   [  1 , 16 ,  1 , 16 ]   [  5 ]
	#                                   [  1 ,  4 , 16 , 13 ]   [  9 ]
	#
	#                       == (-4) * [ ( 1 +  10 +  5 +   9 ) % 17 ]
	#                                 [ ( 1 + 130 + 80 +  36 ) % 17 ]
	#                                 [ ( 1 + 160 +  5 + 144 ) % 17 ]
	#                                 [ ( 1 +  40 + 80 + 117 ) % 17 ]
	#
	#                       == (-4) * [ ( 1 -  7 +  5 +  9 ) % 17 ]
	#                                 [ ( 1 + 11 + 12 +  2 ) % 17 ]
	#                                 [ ( 1 +  7 +  5 +  8 ) % 17 ]
	#                                 [ ( 1 +  6 + 12 + 15 ) % 17 ]
	#
	#                       == (-4) * [ ( 1 -  7 +  5 +  9 ) % 17 ]
	#                                 [ ( 1 -  6 -  5 +  2 ) % 17 ]
	#                                 [ ( 1 +  7 +  5 +  8 ) % 17 ]
	#                                 [ ( 1 +  6 -  5 -  2 ) % 17 ]
	#
	#                       == (-4) * [  8 % 17 ] == (-4) * [  8 % 17 ]
	#                                 [ -8 % 17 ]           [ -8 % 17 ]
	#                                 [ 21 % 17 ]           [  4 % 17 ]
	#                                 [  0 % 17 ]           [  0 % 17 ]
	#
	#                       == [ -32 % 17 ]
	#                          [  32 % 17 ]
	#                          [ -16 % 17 ]
	#                          [   0 % 17 ]
	#
	#                       == [  2 ]
	#                          [ 15 ]
	#                          [  1 ]
	#                          [  0 ]
	#
	#     となる。
	#
	#-----------------------------------------------------------------------
	my( $x , $n ) = @_ ;

	return undef	unless ( ref( $x ) eq 'ARRAY' ) ;

	my $nwp = {
		'24'	=> [           '131072' ,   '20' ,            '21495809' ] , # ( n , w , p ) == ( 2^17 ,    20 ,   164 * n + 1 ) ; n < p == 2^24 + 4,718,593
		'48'	=> [      '34359738368' ,  '360' ,     '285838663483393' ] , # ( n , w , p ) == ( 2^35 ,   360 , 8,319 * n + 1 ) ; n < p == 2^48 + 4,363,686,772,737
		'60'	=> [ '1125899906842624' , '1512' , '1139410705724735489' ] , # ( n , w , p ) == ( 2^50 , 1,512 , 1,012 * n + 1 ) ; n < p == 2^60 - 13,510,798,882,111,487
	} ;

	my( $n0 , $w , $p ) = map{ __PACKAGE__->new( $_ ) } @{ $nwp->{'24'} } ;

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::intt$/ ) ? 1 : 0 ;

	#
	# 数列の要素数を調整
	#
	$n = @{ $x }			unless ( defined $n ) ;
	$n = __PACKAGE__->new( $n )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;
	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) ) ;
	return undef			unless ( defined $n ) ;
	return undef			unless ( $n->is_integer() ) ;

	unless ( $n->bin() =~ /^10+$/ ) {
		$n = __PACKAGE__->new( 2 )->power( $n->bits() ) ;	# n を 2 の冪に合わせる。
	}

	while ( @{ $x } < $n ) { push( @{ $x } , 0 ) ; }		# 数列の要素数を n に合わせる。

	foreach ( @{ $x } ) {
		$_ = __PACKAGE__->new( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) ) ;
		return undef			unless ( defined $_ ) ;

		if ( $_ >= $p ) {
			if	( $_ >= $nwp->{'60'}->[2] )	{ return undef ; }
			elsif	( $_ >= $nwp->{'48'}->[2] )	{ ( $n0 , $w , $p ) = map{ __PACKAGE__->new( $_ ) } @{ $nwp->{'60'} } ; }
			else					{ ( $n0 , $w , $p ) = map{ __PACKAGE__->new( $_ ) } @{ $nwp->{'48'} } ; }
		}
	}

	#
	# n の大きさに合わせて w を調整。
	#
	$w = $w->modexp( $n0 / $n , $p ) ;

	#
	# モジュラー逆数に関する変数の調整
	#
	my $t = $p - 2 ;			# t == totient( p ) - 1 == p - 2
	my $ni = undef ;

	if ( $inverse ) {
		$w  = $w->modexp( $t , $p ) ;	# w^1 のモジュラー逆数 w^(-1) ( mod p )
		$ni = $n->modexp( $t , $p ) ;	# n のモジュラー逆数 n^(-1) ( mod p )
	}

	#
	# 変換
	#
	#   w^k は複数回使用する可能性があるため、
	#
	#     wn[k] == w^k
	#
	#   として管理する。
	#
	#   正変換の場合
	#
	#     wn[1] == w^1
	#     wn[k] == ( wn[1] )^k   % p
	#
	#     z == ntt( x )
	#     -> z[i] == Σ( x[j] * w^( ij ) ) ( mod p )              ( i == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#   逆変換の場合
	#
	#     wn[1] == w^(-1)
	#     wn[k] == w^(-k)        % p
	#           == ( w^(-1) )^k  % p 
	#           == ( wn[1] )^k   % p
	#
	#     z == intt( x )
	#     -> z[i] == n^(-1) * Σ( x[j] * w^( -ij ) ) ( mod p )    ( i == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#my $wm = [] ; # for debug
	my $wn = [] ;
	my $z  = [] ;
	foreach my $i ( 0 .. ( $n - 1 ) ) {

		$z->[ $i ] = __PACKAGE__->new( 0 ) ;

		foreach my $j ( 0 .. ( $n - 1 ) ) {

			my $k = $i * $j ;

			unless ( defined $wn->[ $k ] ) {
				$wn->[ $k ] = $w->modexp( $k , $p ) ;
			}
			#$wm->[ $i ]->[ $j ] = $wn->[ $k ] ;

			$z->[ $i ] += ( $x->[ $j ] * $wn->[ $k ] ) ;
			$z->[ $i ] %= $p	if ( $z->[ $i ] >= $p ) ;
		}

		if ( $inverse ) {
			$z->[ $i ] *= $ni ;
			$z->[ $i ] %= $p	if ( $z->[ $i ] >= $p ) ;
		}
	}

	# print matrix( @{ $wm } ) , "\n" ;

	return $z ;
}

sub intt { return ntt( @_ ) ; } 

#-------------------------------------------------------------------------------
#
# 内部メソッド
#
#-------------------------------------------------------------------------------

{

	sub _new_small_integer {
		#-----------------------------------------------------------------------
		#
		# Decimal オブジェクトが用いている基数において 1 桁で収まる程度の小さな整数値オブジェクトを生成する。
		#
		#-----------------------------------------------------------------------
		my( $self , $d , $sgn ) = @_ ;

		my( $class ) = ref( $self ) || $self ;

		my $conf = {
			'sgn'	=> $sgn || 1 ,
			'val'	=> [ $d || 0 ] ,
			'dlen'	=> 0 ,
			'dirty'	=> 0 ,
		} ;

		my $obj = bless $conf , $class ;

		return $obj ;
	}

	sub _regulate {
		#---------------------------------------------------------------
		#
		# 正規化
		#
		#---------------------------------------------------------------
		my( $self ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		if ( $self->{'val'}->[-1] == 0 ) {
			$self->{'dirty'} ++ ;
		}

		return $self	unless ( $self->{'dirty'} ) ;

		my $y = \@{ $self->{'val'} } ;

		#
		# 繰り上がり、繰り下がり
		#
		my $ysz = @{ $y } ;
		foreach ( my $i = 0 ; $i < $ysz ; $i++ ) {
			if ( $y->[ $i ] >= INT_BASE ) {
				#
				# 繰り上がり
				#
				$y->[ $i + 1 ] = 0	unless ( defined $y->[ $i + 1 ] ) ;
				$y->[ $i + 1 ] += CORE::int( $y->[ $i ] / INT_BASE ) ;
				$y->[ $i ] = ( $y->[ $i ] % INT_BASE ) ;
			}
			elsif ( $y->[ $i ] < 0 and $i < ( $ysz - 1 ) ) {
				#
				# 繰り下がり
				#
				$y->[ $i + 1 ] = 0	unless ( defined $y->[ $i + 1 ] ) ;
				$y->[ $i + 1 ] += POSIX::floor( ( $y->[ $i ] / INT_BASE ) ) ;
				$y->[ $i ] = ( $y->[ $i ] % INT_BASE ) ;
			}
		}

		#
		# 桁調整
		#
		while ( @{ $y } > 1 and $y->[-1] == 0 ) {
			pop( @{ $y } ) ;
		}
		while ( $self->{'dlen'} >= $_DIGLEN and $y->[0] == 0 ) {
			last	if ( @{ $y } == 1 ) ;
			shift( @{ $y } ) ;
			$self->{'dlen'} -= $_DIGLEN ;
		}

		#
		# 符合を調整
		#
		if ( $y->[-1] < 0 ) {
			$self->{'sgn'} *= ( -1 ) ;
			$y->[-1] *= ( -1 ) ;
		}
		if ( @{ $y } == 1 and $y->[0] == 0 ) {
			$self->{'sgn'} = 1 ;
		}

		$self->{'dirty'} = 0 ;

		return $self ;
	}

	sub _regulate_decimal_part {
		#---------------------------------------------------------------
		#
		# 小数点の位置を再評価
		#
		#---------------------------------------------------------------
		my( $self ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		return $self	unless ( $self->{'dlen'} > 0 ) ;
		return $self	unless ( $self->{'val'}->[0] =~ /0$/ ) ;

		if ( @{ $self->{'val'} } == 1 and $self->{'val'}->[0] == 0 ) {
			$self->{'dlen'} = 0 ;
			$self->{'sgn'} = 1 ;
			return $self ;
		}

		my $y = \@{ $self->{'val'} } ;
	
		while ( $self->{'dlen'} >= $_DIGLEN and $y->[0] == 0 ) {
			last	if ( @{ $y } == 1 ) ;
			shift( @{ $y } ) ;
			$self->{'dlen'} -= $_DIGLEN ;
		}

		my $fmt = '%0' . $_DIGLEN . 'd' ;
		my $dig = sprintf( "$fmt" , $y->[0] ) ;
		if ( $self->{'dlen'} > 0 and $dig =~ /(0+)$/ ) {
			my $cutoff = ( sort { $a <=> $b } ( length( $1 ) , $self->{'dlen'} ) )[0] ;
			$dig = substr( $dig , 0 , $cutoff * ( -1 ) ) ;
			$y->[0] = sprintf( "$fmt" , $dig || 0 ) ;
			$self->{'dlen'} -= $cutoff ;
		}

		return $self ;
	}

	sub _shiftup {
		#---------------------------------------------------------------
		#
		# 左シフト
		#
		#   基数の冪での乗算
		#
		#---------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1  unless ( defined $n ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		my $v = \@{ $obj->{'val'} } ;

		foreach ( my $i = 0 ; $i < $n ; $i++ ) {
			unshift( @{ $v } , 0 ) ;
		}

		return $obj ;
	}

	sub _shiftup_integer {
		#-----------------------------------------------------------------------
		#
		# 左シフト
		#
		#   基数の冪での乗算 ( 小数点以下切捨て )
		#
		#-----------------------------------------------------------------------
		my $obj = _shiftup( @_ ) ;
		return undef    unless ( defined $obj ) ;
		return $obj->integer() ;
	}

	sub _shiftdown {
		#-----------------------------------------------------------------------
		#
		# 右シフト
		#
		#   基数の冪での除算
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1  unless ( defined $n ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		$obj->{'dlen'} += ( $_DIGLEN * $n ) ;

		return $obj ;
	}

	sub _shiftdown_integer {
		#-----------------------------------------------------------------------
		#
		# 右シフト
		#
		#   基数の冪での除算 ( 小数点以下切捨て )
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1  unless ( defined $n ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		my $v = \@{ $obj->{'val'} } ;
		
		foreach ( my $i = 0 ; $i < $n ; $i++ ) {
			shift( @{ $v } ) ;
			if ( @{ $v } == 0 ) { $v->[0] = 0 ; last ; }
		}

		return $obj ;
	}

	sub _bitshiftup {
		#-----------------------------------------------------------------------
		#
		# 左ビットシフト
		#
		#   2 の冪での乗算 ( 小数点以下切捨て )
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\d+$/ ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		$obj *= __PACKAGE__->new( 2 )->power( $n ) ;

		return $obj->round_down( 0 ) ;
	}

	sub _bitshiftdown {
		#-----------------------------------------------------------------------
		#
		# 右ビットシフト
		#
		#   2 の冪での除算。 ( 小数点以下切捨て ) 
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\d+$/ ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		$obj = $obj->divide( __PACKAGE__->new( 2 )->power( $n ) , 0 ) ;

		return $obj ;
	}

	sub _decshiftup {
		#-----------------------------------------------------------------------
		#
		# 10 進数での左シフト
		#
		#   10 の冪での乗算に相当する処理を行う。
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\-{0,1}\d+$/ ) ;

		return _decshiftdown( $n * ( -1 ) )	if ( $n < 0 ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		if ( $obj->{'dlen'} > 0 ) {
			if ( $obj->{'dlen'} >= $n )	{ $obj->{'dlen'} -= $n ; $n = 0 ; }
			else				{ $n -= $obj->{'dlen'} ; $obj->{'dlen'} = 0 ; }
		}

		#
		# 基数の冪での桁上げ ( 基数自体が 10 の冪であることを前提とする。 )
		#
		if ( $n >= $_DIGLEN ) {
			my $c = CORE::int( $n / $_DIGLEN ) ;
			foreach ( my $i = 0 ; $i < $c ; $i++ ) {
				unshift( @{ $obj->{'val'} } , 0 ) ;
			}
			$n %= $_DIGLEN ;
		}

		#
		# 10 を基数とする桁上げ
		#
		$n = $n->value()	if ( ref( $n ) ) ;

		if ( $n > 0 ) {
			#
			# 下位桁から上位桁に向かって処理を行う。
			#
			#   現在桁の値を 10^n で桁上げした結果に下位桁から上がってきた商を加算し、その結果を基数で除算する。
			#   剰余を現在桁に残し、商を上位桁に引き渡す。
			#
			#   最終的に桁上がりした値に同様の処理を行い、最上位桁を追加する。
			#
			my $tp = 10 ** $n ;
			my( $d , $m ) = ( 0 , 0 ) ;
			my $dig = $#{ $obj->{'val'} } ;

			foreach my $i ( 0 .. $dig ) {
				my $v = ( $obj->{'val'}->[ $i ] * $tp ) + $d ;
				( $d , $m ) = ( CORE::int( $v / INT_BASE ) , $v % INT_BASE ) ;
				$obj->{'val'}->[ $i ] = $m ;
			}

			while ( $d > 0 ) {
				( $d , $m ) = ( CORE::int( $d / INT_BASE ) , $d % INT_BASE ) ;
				$obj->{'val'}->[ ++$dig ] = $m ;
			}

			#
			# 最上位桁を調整
			#
			while ( @{ $obj->{'val'} } > 1 and $obj->{'val'}->[-1] == 0 ) {
				pop( @{ $obj->{'val'} } ) ;
			}
		}

		return $obj ;
	}

	sub _decshiftup00 {
		#-----------------------------------------------------------------------
		#
		# 10 進数での左シフト
		#
		#   10 の冪での乗算に相当する処理を行う。
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\-{0,1}\d+$/ ) ;

		return _decshiftdown( $n * ( -1 ) )	if ( $n < 0 ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		if ( $obj->{'dlen'} > 0 ) {
			if ( $obj->{'dlen'} >= $n )	{ $obj->{'dlen'} -= $n ; $n = 0 ; }
			else				{ $n -= $obj->{'dlen'} ; $obj->{'dlen'} = 0 ; }
		}

		#
		# 基数の冪での桁上げ ( 基数自体が 10 の冪であることを前提とする。 )
		#
		if ( $n >= $_DIGLEN ) {
			my $c = CORE::int( $n / $_DIGLEN ) ;
			foreach ( my $i = 0 ; $i < $c ; $i++ ) {
				unshift( @{ $obj->{'val'} } , 0 ) ;
			}
			$n %= $_DIGLEN ;
		}

		#
		# 10 を基数とする桁上げ
		#
		if ( $n > 0 ) {
			#
			# 追加する '0' の羅列と sprintf 用のフォーマット
			#
			my $pad .= '0' x $n ;
			my $fmt = '%0' . $_DIGLEN . 'd' ;

			#
			# 下位桁から順に桁を増やす。 ( 符号や小数点の扱いは不要 )
			#
			my $v = \@{ $obj->{'val'} } ;
			my $ix = $#{ $v } ;

			foreach my $i ( 0 .. $ix ) {

				my $j = $i + 1 ;

				#
				# 各桁を固定長文字列に変換
				#
				foreach ( $i , $j ) {
					my $dig = ( defined $v->[ $_ ] ) ? length( $v->[ $_ ] ) : 0 ;
					if ( $dig < $_DIGLEN ) {
						$v->[ $_ ] = sprintf( "$fmt" , $v->[ $_ ] || 0 ) ;
					}
				}

				#
				# 最下位桁に '0' の羅列を追加。
				#
				if ( $i == 0 ) {
					$v->[ $i ] .= $pad ;
				}

				#
				# 下位桁の左端を上位桁の右端に連結し、下位桁からは除去する。
				#
				$v->[ $j ] .= substr( $v->[ $i ] , 0 , $n ) ;
				$v->[ $i ]  = substr( $v->[ $i ] , $n ) ;
			}

			#
			# 最上位桁を調整
			#
			if ( @{ $obj->{'val'} } > 1 ) {
				while ( my $len = length( $obj->{'val'}->[-1] ) - $_DIGLEN ) {
					last	if ( $len < 1 ) ;
					my $ix = @{ $obj->{'val'} } ;
					$obj->{'val'}->[ $ix ]     = substr( $obj->{'val'}->[ $ix - 1 ] , 0 , $len ) ;
					$obj->{'val'}->[ $ix - 1 ] = substr( $obj->{'val'}->[ $ix - 1 ] , $len ) ;
				}
			}
			while ( @{ $obj->{'val'} } > 1 and $obj->{'val'}->[-1] == 0 ) {
				pop( @{ $obj->{'val'} } ) ;
			}
		}

		return $obj ;
	}

	sub _decshiftup_integer {
		#-----------------------------------------------------------------------
		#
		# 10 進数での左シフト
		#
		#   10 の冪での乗算 ( 小数点以下切捨て )
		#
		#-----------------------------------------------------------------------
		my $obj = _decshiftup( @_ ) ;
		return undef	unless ( defined $obj ) ;
		return $obj->integer() ;
	}

	sub _decshiftdown {
		#-----------------------------------------------------------------------
		#
		# 10 進数での右シフト
		#
		#   10 の冪での除算に相当する処理を行う。
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\-{0,1}\d+$/ ) ;

		return _decshiftup( $n * ( -1 ) )	if ( $n < 0 ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		#
		# 基数の冪での桁下げ ( 基数自体が 10 の冪であることを前提とする。 )
		#
		$obj->{'dlen'} += $n ;
		while ( $obj->{'dlen'} >= $_DIGLEN ) {
			last	unless ( $obj->{'val'}->[0] == 0 ) ;
			shift( @{ $obj->{'val'} } ) ;
			$obj->{'dlen'} -= $_DIGLEN ;
		}

		#
		# 余分な 0 を落とす。
		#
		#   桁下げは基本的に小数点の位置を調整するだけで実現はできている。
		#   ここでは、末尾の余分な 0 を削減してオブジェクトをできるだけコンパクトに保つ処置を行う。
		#
		if ( $obj->{'dlen'} > 0 and $obj->{'val'}->[0] =~ /(0+)$/ ) {
			#
			# $n を末尾の 0 の数で初期化しなおす。
			#
			$n = length( $1 ) ;
			$n = $obj->{'dlen'}	if ( $obj->{'dlen'} < $n ) ;
			$obj->{'dlen'} -= $n ;

			#
			# 上位桁から下位桁へ向けて処理を行う。
			#
			#   上位桁から降りてきた剰余に基数を掛けて現在の桁に加算し、その結果を 10^n で除算する。
			#   除算によって得られた商を現在桁に残し、剰余を下位桁に引き渡す。
			#
			#   最終的に残った剰余に同様の処置を行って最下位桁として追加し、その分だけ小数点の位置をずらす。
			#
			my $tp = 10 ** $n ;
			my( $d , $m ) = ( 0 , 0 ) ;
			my $dig = $#{ $obj->{'val'} }  ;

			foreach my $i ( reverse( 0 .. $dig ) ) {
				my $v = $obj->{'val'}->[ $i ] + ( $m * INT_BASE ) ;
				( $d , $m ) = ( CORE::int( $v / $tp ) , $v % $tp ) ;
				$obj->{'val'}->[ $i ] = $d ;
			}

			while ( $m > 0 ) {
				my $v = $m * INT_BASE ;
				( $d , $m ) = ( CORE::int( $v / $tp ) , $v % $tp ) ;
				unshift( @{ $obj->{'val'} } , $d ) ;
				$obj->{'dlen'} += $_DIGLEN ;
			}

			#
			# 最上位桁を調整
			#
			while ( @{ $obj->{'val'} } > 1 and $obj->{'val'}->[-1] == 0 ) {
				pop( @{ $obj->{'val'} } ) ;
			}
		}

		return $obj ;
	}

	sub _decshiftdown00 {
		#-----------------------------------------------------------------------
		#
		# 10 進数での右シフト
		#
		#   10 の冪での除算に相当する処理を行う。
		#
		#-----------------------------------------------------------------------
		my( $self , $n ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$n = 1	unless ( defined $n ) ;
		return undef	unless ( $n =~ /^\-{0,1}\d+$/ ) ;

		return _decshiftup( $n * ( -1 ) )	if ( $n < 0 ) ;

		my $obj = $self->copy() ;
		return $obj	if ( $obj->is_zero() or $n == 0 ) ;

		#
		# 基数の冪での桁下げ ( 基数自体が 10 の冪であることを前提とする。 )
		#
		$obj->{'dlen'} += $n ;
		while ( $obj->{'dlen'} >= $_DIGLEN ) {
			last	unless ( $obj->{'val'}->[0] == 0 ) ;
			shift( @{ $obj->{'val'} } ) ;
			$obj->{'dlen'} -= $_DIGLEN ;
		}

		#
		# 10 を基数とした桁下げ
		#
		if ( $obj->{'dlen'} > 0 and $obj->{'val'}->[0] =~ /(0+)$/ ) {
			#
			# 除去する '0' の数を抑え、小数点の位置を調整。
			#
			my $dig = length( $1 ) ;
			$dig = $obj->{'dlen'}	if ( $obj->{'dlen'} < $dig ) ;
			$obj->{'dlen'} -= $dig ;

			#
			# 配列要素の 10 進数値を順次ずらす。
			#
			my $v = \@{ $obj->{'val'} } ;
			push( @{ $v } , 0 )	if ( @{ $v } == 1 ) ;
			my $ix = $#{ $v } ;

			my $fmt = '%0' . $_DIGLEN . 'd' ;

			foreach my $i ( 0 .. $ix ) {
				#
				# 各桁を固定長文字列に変換
				#
				#$v->[ $i ] = '0' x ( $_DIGLEN - length( $v->[ $i ] ) ) . $v->[ $i ] ;
				my $dig = ( defined $v->[ $i ] ) ? length( $v->[ $i ] ) : 0 ;
				if ( $dig < $_DIGLEN ) {
					$v->[ $i ] = sprintf( "$fmt" , $v->[ $i ] || 0 ) ;
				}
			}

			foreach my $i ( 0 .. ( $ix - 1 ) ) {

				my $j = $i + 1 ;

				#
				# 最下位桁の右端の桁を落とす。
				#
				if ( $i == 0 ) {
					$v->[ $i ] = substr( $v->[ $i ] , 0 , ( -1 ) * $dig ) ;
				}

				#
				# 上位桁の右端の値を下位桁の左側に連結。 ( 下位桁への桁下げ )
				# 上位桁からは桁下がりした分を除去。     ( 上位桁の桁下げ )
				#
				$v->[ $i ] = substr( $v->[ $j ] , ( -1 ) * $dig ) . $v->[ $i ] ;
				$v->[ $j ] = substr( $v->[ $j ] , 0 , ( -1 ) * $dig ) ;

				foreach ( $i , $j ) {
					$v->[ $_ ] = $v->[ $_ ] || 0 ;
				}
			}

			#
			# 最上位桁を調整
			#
			while ( @{ $obj->{'val'} } > 1 and $obj->{'val'}->[-1] == 0 ) {
				pop( @{ $obj->{'val'} } ) ;
			}
		}

		return $obj ;
	}

	sub _decshiftdown_integer {
		#-----------------------------------------------------------------------
		#
		# 10 進数での右シフト
		#
		#   10 の冪での除算 ( 小数点以下切捨て )
		#
		#-----------------------------------------------------------------------
		my $obj = _decshiftdown( @_ ) ;
		return undef	unless ( defined $obj ) ;
		return $obj->integer() ;
	}

	sub _dec2int {
		#---------------------------------------------------------------
		#
		# 複数の小数値を受け取り、小数点の位置を揃えた整数値に桁上げして返す。
		#
		#   戻り値は、元の小数値に戻すために必要な桁数と桁上げされた整数値のリストとなる。
		#
		#---------------------------------------------------------------
		my( @args ) = @_ ;

		my $dlen = 0 ;

		return ( $dlen , @args )	if ( @args == 1 ) ;

		foreach my $arg ( @args ) {
			croak( "unexpected errror!!" )	unless ( ref( $arg ) eq __PACKAGE__ ) ;
			$dlen = $arg->{'dlen'}	if ( $dlen < $arg->{'dlen'} ) ;
		}

		foreach my $arg ( @args ) {
			#$arg = $arg->copy()->_decshiftup( $dlen - $arg->{'dlen'} ) ;
			$arg = $arg->copy()->_decshiftup( $dlen ) ;
			croak( "unexpected errror!!" )	unless ( defined $arg ) ;
		}

		return ( $dlen , @args ) ;
	}

	sub _adjust_DP {
		#---------------------------------------------------------------
		#
		# 小数点の位置を桁合わせする。
		#
		# 小数部の桁数が最も大きいものに合わせて桁合わせする。
		#
		#---------------------------------------------------------------
		my( @args ) = @_ ;

		return @args	if ( @args == 1 ) ;

		foreach my $arg ( @args ) {
			croak( "unexpected errror!!" )	unless ( ref( $arg ) eq __PACKAGE__ ) ;
			if ( $arg->{'dlen'} >= $_DIGLEN and $arg->{'val'}->[0] == 0 ) {
				#if ( grep( /^0+$/ , @{ $arg->{'val'} } ) >= ( @{ $arg->{'val'} } - 2 ) ) {
				#	$arg = __PACKAGE__->new( $arg->value() ) ;
				#}
				my $zero_elem = 0 ;
				my $threshold = @{ $arg->{'val'} } - 2 ;
				foreach ( @{ $arg->{'val'} } ) {
					$zero_elem++	if ( $_ + 0 == 0 ) ;
					if ( $zero_elem >= $threshold ) {
						$arg = __PACKAGE__->new( $arg->value() ) ;
						last ;
					}
				}
			}
		}

		my $dlen = 0 ;
		foreach ( @args ) {
			$dlen = $_->{'dlen'} 	if ( $dlen < $_->{'dlen'} ) ;
		}

		foreach my $obj ( @args ) {
			#next	if ( $obj->is_zero() ) ;
			#next	if ( grep( /^0+$/ , @{ $obj->{'val'} } ) == @{ $obj->{'val'} } ) ;	# $obj == 0 
			my $is_zero = 1 ;
			foreach ( @{ $obj->{'val'} } ) {
				#if ( $_ !~ /^0+$/ ) { $is_zero = 0 ; last ; }
				if ( $_ + 0 != 0 ) { $is_zero = 0 ; last ; }
			}
			next	if ( $is_zero ) ;

			$obj = $obj->copy() ;
			my $i = ( $dlen - $obj->{'dlen'} ) ;
			if ( $i > 0 ) {
				my $v = $obj->value() ;
				if ( $v =~ /\.(\d+)$/ )	{ $v .= '0' x ( $dlen - length( $1 ) ) ; }
				else			{ $v .= '0' x $dlen ; }
				$obj = __PACKAGE__->new( $v ) ;
				$obj->{'dlen'} = $dlen ;
			}
		}

		return @args ;
	}

	sub _adjust_bin {
		#---------------------------------------------------------------
		#
		# 複数の整数を 2 進数変換し、桁合わせをして返す。
		#
		#   正の整数は '0' で桁あわせし、負の整数は '1' で桁合わせする。
		#
		#---------------------------------------------------------------
		my( @args ) = @_ ;

		return @args	if ( @args == 1 ) ;
		my @sgn ;

		foreach my $v ( @args ) {
			$v = __PACKAGE__->new( $v )	unless ( ref( $v ) eq __PACKAGE__ ) ;
			return undef			unless ( defined $v ) ;
			return undef			unless ( $v->is_integer() ) ;

			if ( $v < 0 )	{ push( @sgn , -1 ) ; }
			else 		{ push( @sgn , 1 ) ; }

			$v = $v->abs()->bin() ;
		}

		my $len = length( $args[0] ) ;
		foreach ( 1 .. $#args ) {
			my $l = length( $args[ $_ ] ) ;
			if ( $len < $l ) { $len = $l ; }
		}

		foreach my $i ( 0 .. $#args ) {
			my $diff = $len - length( $args[ $i ] ) ;
			if ( $diff > 0 ) {
				if ( $sgn[ $i ] > 0 )	{ $args[ $i ] = '0' x $diff . $args[ $i ] ; }
				else			{ $args[ $i ] = '1' x $diff . $args[ $i ] ; }
			}
		}

		return @args ;
	}

	sub _pow10 {
		#---------------------------------------------------------------
		#
		# 10 の冪を返す。
		#
		# 小数の演算では 10 の冪を多用するので、専用の生成器を用意している。
		#
		# 10 の冪は文字列演算で容易に生成できる。
		# 繰り返し演算子 ( 'x' ) に巨大な数値を指定するとオーバーフローするので多少回りくどい手法を採っている。
		#
		#---------------------------------------------------------------
		my( $p ) = @_ ;

		$p = __PACKAGE__->new( $p )	unless ( ref( $p ) eq __PACKAGE__ ) ;
		croak( "invalid argument." )	unless ( defined $p ) ;

		my $neg = 0 ;
		if ( $p < 0 ) { $neg = 1 ; $p *= ( -1 ) ; }

		my $n = '' ;
		while ( $p > length( $n ) ) {
			$n .= '0' x 10 ;
		}

		#$n = '1' . substr( $n , 0 , $p ) ;
		#my $obj = ( $neg )
		#	? __PACKAGE__->new( 1 )->divide( $n )
		#	: __PACKAGE__->new( $n )
		#;

		$n = substr( $n , 0 , $p ) ;
		if ( $neg )	{ $n .= '1' ; substr( $n , 1 , 0 , '.' ) ; }
		else		{ $n  = '1' . $n ; }
		
		my $obj = __PACKAGE__->new( $n ) ;

		return $obj ;
	}

	sub _separate {
		#---------------------------------------------------------------
		#
		# 二つのオブジェクト $x , $y を受け取り、 $y の桁数に合わせて $x を分割した配列参照を返す。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		foreach ( $x , $y ) {
			if ( ref( $_ ) eq __PACKAGE__ ) {
				$_ = $_->copy() ;
			}
			else {
				$_ = __PACKAGE__->new( $_ ) ;
				croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			}

			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part() == 0 ) ;
		}

		my $xv = \@{ $x->{'val'} } ;
		my $ysz = @{ $y->{'val'} } ;
		my $r = [] ;

		while ( @{ $xv } > 0 ) {
			my @dig = () ;
			if ( @{ $xv } >= $ysz ) {
				@dig = splice( @{ $xv } , 0 , $ysz ) ;
			}
			else {
				@dig = splice( @{ $xv } , 0 ) ;
			}
			my $z = __PACKAGE__->new( 0 ) ;
			$z->{'val'} = [ @dig ] ;
			push( @{ $r } , $z ) ;
		}

		return $r ;
	}

	sub _divmod {
		#---------------------------------------------------------------
		#
		# 正の整数同士の除算
		#
		#   x >= y > 0 となる正の整数 x , y による除算。
		#
		#   x , y が基数 B の下でその桁数の差が 1 桁である場合、
		#
		#     x == Σ( a[k] * B^k )             ( k == 0 -> n )
		#     y == Σ( b[k] * B^k )             ( k == 0 -> n - 1 )
		#
		#   x の上位 2 桁と y の上位 1 桁に注目し、 q == int( x / y ) , q0 を x の上位 2 桁と y の上位 1 桁の商とすると、
		#
		#
		#      ( a[n] * B + a[n-1] ) * B^(n-1)          ( a[n] * B + a[n-1] ) * B^(n-1) + B^(n-1)
		#     --------------------------------- <= q < -------------------------------------------
		#                     y                                             y
		#
		#            ( a[n] * B + a[n-1] ) * B^(n-1)
		#     q0 == ---------------------------------
		#                  b[n-1] * B^(n-1)
		#
		#      ( a[n] * B + a[n-1] ) * B^(n-1)                   x
		#     --------------------------------- <= q0 <= ------------------
		#                     y                           b[n-1] * B^(n-1)
		#
		#     
		#                ( a[n] * B + a[n-1] ) * B^(n-1)     ( a[n] * B + a[n-1] ) * B^(n-1) + B^(n-1)
		#     q0 - q >  --------------------------------- - -------------------------------------------
		#                                y                                       y
		#
		#                (-1) * B^(n-1)
		#            == ----------------
		#                      y
		#
		#       n - 1 は y の最上位桁の次数であることから、
		#
		#                (-1) * B^(n-1)
		#         -1 <= ---------------- < 0
		#                      y
		#
		#         -> q0 - q > -1
		#
		#                       x              ( a[n] * B + a[n-1] ) * B^(n-1)
		#     q0 - q <= ------------------ - ----------------------------------
		#                b[n-1] * B^(n-1)                     y
		#
		#                       x                x      B^(n-1)
		#            <= ------------------ - ( ----- - --------- )
		#                b[n-1] * B^(n-1)        y         y
		#
		#                xy - x * ( b[n-1] * B^(n-1) )     B^(n-1)
		#            == ------------------------------- + ---------
		#                   y * ( b[n-1] * B^(n-1) )         y
		#
		#                x     y - ( b[n-1] * B^(n-1) )     B^(n-1)
		#            == --- * -------------------------- + ---------
		#                y        b[n-1] * B^(n-1)             y
		#
		#       b[n-1] * B^(n-1) は、 y の最上位桁以外を 0 とおいた数に等しいことから、
		#
		#         y - b[n-1] * B^(n-1) < B^(n-1)
		#
		#       B^(n-1) は y の最上位桁を 1 とし、残りを 0 とおいた数に等しいことから、
		#
		#              B^(n-1)
		#         0 < --------- <= 1
		#                 y
		#
		#                       x          B^(n-1)
		#         -> q0 - q <  --- * ------------------ + 1
		#                       y     b[n-1] * B^(n-1) 
		#
		#                       x       1
		#                   <  --- * -------- + 1
		#                       y     b[n-1] 
		#
		#
		#   よって、
		#
		#     x / y < B の時、
		#
		#                        B
		#       -1 < q0 - q < -------- + 1
		#                      b[n-1]
		#
		#     x / y >= B の時、
		#
		#                       B^2
		#       -1 < q0 - q < -------- + 1
		#                      b[n-1]
		#
		#   となる。
		#
		#   不等式の左辺から、
		#
		#     q0 - q > -1 >= 0                   ( q0 , q は共に正の整数 )
		#
		#     -> q0 > q
		#
		#   が保証される。
		#
		#   不等式の右辺より、
		#
		#     x / y < B の時、
		#
		#                   B
		#       q0 - q < -------- + 1
		#                 b[n-1]
		#
		#                        B
		#       -> q > q0 - ( -------- + 1 )
		#                      b[n-1]
		#
		#                  B
		#       -> q0 - -------- - 1  < q < q0
		#                b[n-1]
		#
		#     x / y >= B の時、
		#
		#                  B^2
		#       q0 - q < -------- + 1
		#                 b[n-1]
		#
		#                       B^2
		#       -> q > q0 - ( -------- + 1 )
		#                      b[n-1]
		#
		#                 B^2 
		#       -> q0 - -------- - 1  < q < q0
		#                b[n-1]
		#
		#   x と y の桁数が同じ場合には、 x / y < B のケースにおいて、 n-1 を n に置き換えることで同様の結果が得られる。
		#
		#   こうして得られた q の範囲の中で、剰余値
		#
		#     r = x - q * y
		#
		#   を採り、 0 <= r < y となる q , r を探索することで商と剰余が確定する。
		#
		#
		#   b[n-1] が B/2 若しくは B^2/2 以上になるように x , y を調整すると演算効率が上がる ( 探索範囲が狭まる ) のだが、
		#   永久ループに陥るケースが見つかったため、この実装は削除してある。
		#
		#
		#   B^2 を言語標準の数値で桁あふれなく表現できるような実装であることを前提とすると、
		#   x と y の桁数の差が 1 桁以内であれば、多倍長整数の除算の主な処理を言語標準の数値演算のみで実装できる。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		#
		# x >= y > 0 であり、 x , y 共に正の整数であることを確認する。
		#
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		#
		# y == 1 であれば商は x , 剰余は 0
		# x <  y であれば商は 0 , 剰余は x
		#
		if	( $y == 1 )	{ return ( $x->copy() , __PACKAGE__->new( 0 ) ) ; }
		elsif	( $x < $y )	{ return ( __PACKAGE__->new( 0 ) , $x->copy() ) ; }

		#
		# 桁数の差が 2 以上であれば x を分割して再帰処理する。
		#
		my $this_method = ( caller 0 )[3] ;
		my $base = INT_BASE ;
		my $xdig = @{ $x->{'val'} } ;
		my $ydig = @{ $y->{'val'} } ;
		if ( ( $xdig - $ydig ) > 1 ) {
			my @xv = @{ $x->{'val'} } ;
			my( $q , $r ) = (
				__PACKAGE__->new( 0 ) ,
				__PACKAGE__->new( 0 ) ,
			) ;
			while ( @xv ) {
				my( $qc , $rc ) ;
				$q *= $base ;
				$r = $r * $base + pop( @xv ) ;
				if ( $r >= $y ) {
					( $qc , $rc ) = $r->$this_method( $y ) ;
					$q += $qc ;
					$r = $rc ;
				}
			}
			return( $q , $r ) ;
		}

		#
		# x , y の上位桁を取り出す。
		#
		my $q = ( $xdig == $ydig or $xdig < 2 )
			? $x->{'val'}->[-1]
			: $x->{'val'}->[-1] * $base + $x->{'val'}->[-2]
		;
		my $yh = $y->{'val'}->[-1] ;

		if ( $yh == 0 ) {
			$y->_regulate() ;
			return $x->$this_method( $y ) ;
		}

		#
		# x == q * y + r となる q , r の初期値を求める。
		#
		$q = CORE::int( $q / $yh ) ;
		my $r = $x - ( $y * $q ) ;

		#
		# q , r を絞り込む
		#
		#  q0 >= B   ->  q0 - ( B^2 / b[n-1] ) - 1 < q < q0
		#  q0 <  B   ->  q0 - ( B   / b[n-1] ) - 1 < q < q0
		#
		if ( $r < 0 or $r >= $y ) {

			my $lvalue = CORE::int( $base / $yh ) ;
			my @i = ( $q >= $base )
				? ( $q - ( $lvalue * $base ) - 2 , undef , $q )
				: ( $q - $lvalue - 2             , undef , $q )
			;

			$q = undef ;
			while ( ( $i[2] - $i[0] ) > 3 ) {
				$i[1] = CORE::int( ( $i[0] + $i[2] ) / 2 ) ;
				my $m = $y * $i[1] ;
				if	( $x == $m )	{ $q = $i[1] ; $r = 0 ;	last ; }
				elsif	( $x < $m )	{ $i[2] = $i[1] ;	next ; }
				else			{ $i[0] = $i[1] ;	next ; }
			}

			unless ( defined $q ) {
				foreach my $j ( reverse( $i[0] .. $i[2] ) ) {
					my $m = $y * $j ;
					next	if ( $x < $m ) ;
					$q = $j ;
					$r = $x - $m ;
					last ;
				}
			}
		}

		unless ( defined $q ) {
			croak( "unexpected error!!\n" )	;
		}

		foreach ( $q , $r ) {
			$_ = __PACKAGE__->new( $_ ) ;
		}

		return ( $q , $r ) ;
	}

	sub _divmod20 {
		#---------------------------------------------------------------
		#
		# 正の整数同士の除算
		#
		#   被除数を x , 除数を y とし、
		#
		#     x == q * y + r        ( x >= y > 0 , r < y )
		#
		#   となる q と r を求める。
		#
		#   q と r の初期値を q = 0 , r = x とする。
		#
		#   y の基数を B とし、 y を基数の冪で桁上げした値を m とする。
		#
		#     m == y * B^p
		#
		#   m <= r と言う条件の下で m が最大になるように m と p を定め、
		#
		#     d == int( r / m )
		#
		#   となる d を求める。
		#
		#   この時、 d の採りうる値の範囲は、
		#
		#     1 <= d < B^2
		#
		#   となる。
		#
		#   q , r の近似値は、 B , p , d を用いて、
		#
		#     q += d * B^p
		#     r -= m * d
		#
		#   となる。
		#
		#   これら一連の処理を r < y となるまで繰り返すことで q , r を得ることができる。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		my @r = (
			__PACKAGE__->new( 0 ) ,		# 最終的にここに商が格納される。
			$x->copy() ,			# 被除数 ( 最終的に剰余が残る。 )
		) ;
		my $amod = $y->copy() ;			# 除数

		if ( $r[1] >= $amod ) {
			my $p = 0 ;
			my $m = $amod->copy() ;

			#
			# 除数を桁上げし、桁上げした回数を抑えておく。
			#
			while ( $r[1] >= $m ) { $m = $m->_shiftup( 1 ) ; $p++ ; }

			#
			# 減算
			#
			while ( $m > $amod ) {
				#
				# 除数を被除数以下の最大値になるように桁下げする。 ( 小数点以下切捨て )
				#
				while ( $r[1] < $m ) { $m = $m->_shiftdown_integer( 1 ) ; $p-- ; }

				last	if ( $m < $amod ) ;

				#
				# $m == $y * $d となる $d を抑える。
				# $d の総和が最終的な商となる。
				#
				my $d = __PACKAGE__->new( 1 )->_shiftup( $p ) ;

				#
				# $m を $r[1] から引けるだけ引き、それを @r に反映する。
				# これは同じ桁の中での商を求めてそれを戻り値に反映する処理となる。
				# オブジェクトの基数を $n とした場合、最大で ( $n ** 2 - 1 ) 回のループが発生する。
				#
				#   while ( $r[1] >= $m ) { $r[0] += $d ; $r[1] -= $m ; }
				#
				# 基数が大きくなると単純な減算では性能が劣悪になるため、二分木法で絞り込んでから減算を行う。
				# 基数が 10^7 程度の大きさである場合、単純な減算では 5 * 10^14 回程の減算が必要になることもある。
				# 二分木法で絞り込むと、30 ～ 40 回程度の試行で収束させることができる。
				#
				# 2 進数での桁上げ、桁下げを利用することで更に効率化できる余地はある。
				# ただし、冪乗算や基数変換でこのメソッドを利用しているため、ここでは採用していない。
				# ( 安易に実装すると Deep Recursion を誘発する可能性がある。 )
				#
				my @i = ( 1 , undef , INT_BASE ) ;
				while ( $r[1] > ( $m * $i[2] ) ) {
					$i[0] = $i[2] ;
					$i[2] *= 10 ;
				}
				while ( ( $i[2] - $i[0] ) > 2 ) {
					$i[1] = CORE::int( ( $i[0] + $i[2] ) / 2 ) ;
					my $div = $m * $i[1] ;
					if	( $r[1] > $div )	{ $i[0] = $i[1] ; }
					elsif	( $r[1] < $div )	{ $i[2] = $i[1] ; }
					else				{ last ; }
				}


				if ( $r[1] == ( $m * $i[1] ) ) {
					$r[0] += ( $d * $i[1] ) ;
					$r[1] -= ( $m * $i[1] ) ;
				}
				else {
					foreach my $c ( reverse( $i[0] .. $i[2] ) ) {
						if ( $r[1] >= ( $m * $c ) ) {
							$r[0] += ( $d * $c ) ;
							$r[1] -= ( $m * $c ) ;
							last ;
						}
					}
				}

				if ( $r[1] >= $m ) {
					croak( "unexpected error!!\n" )	;
				}

				last	if ( $r[1] < $amod ) ;
			}
		}
	
		return @r ;
	}

	sub _divmod10 {
		#---------------------------------------------------------------
		#
		# 正の整数同士の除算
		#
		#   除数と被除数の桁合わせを 10 進数 1 桁以内に調整している。
		#   桁合わせを行う際に桁上げのみで実装しているため、ループ 1 回ごとに
		#   除数の桁合わせを一からやり直す結果となってしまい、処理効率を落としてしまっている。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
		}

		my @r = (
			__PACKAGE__->new( 0 ) ,		# 最終的にここに商が格納される。
			$x->copy() ,			# 被除数 ( 最終的に剰余が残る。 )
		) ;
		my $amod = $y->copy() ;			# 除数

		while ( $r[1] >= $amod ) {
			my $p0 = 0 ;
			my $p1 = 0 ;
			my $m = $amod->copy() ;

			#
			# 除数の桁上げ
			#
			if ( $r[1] > $m ) {
				while () {
					#
					# 基数での桁上げ
					#
					my $mn = $m->_shiftup( ++$p0 ) ;
					if ( $mn > $r[1] ) { $m = $m->_shiftup( --$p0 ) ; last ; }
				}
				while () {
					#
					# 10 の冪での桁上げ
					#
					my $mn = $m * ( 10 ** ( ++$p1 ) ) ;
					if ( $mn > $r[1] ) { $m = $m * ( 10 ** ( --$p1 ) ) ; last ; }
				}
			}

			#
			# $m == $y * $d となる $d を抑える。
			# $d の総和が最終的な商となる。
			#
			my $d = __PACKAGE__->new( 1 )->_shiftup( $p0 ) * ( 10 ** $p1 ) ;

			#
			# $m を $r[1] から引けるだけ引き、それを @r に反映する。
			# これは同じ桁の中での商を求めてそれを戻り値に反映する処理となる。
			# オブジェクトの基数を $n とした場合、最大で ( $n - 1 ) 回のループが発生する。
			#
			#   while ( $r[1] >= $m ) { $r[0] += $d ; $r[1] -= $m ; }
			#
			# 被除数 $r[1] と除数 $m の桁数は 10 進数 1 桁以内になるように調整されているので、
			# $m に掛ける係数 $c の範囲は 1 <= $c < 100 となる。
			#
			my @i = ( 1 , undef , 100 ) ;
			while ( ( $i[2] - $i[0] ) > 2 ) {
				$i[1] = CORE::int( ( $i[0] + $i[2] ) / 2 ) ;
				my $div = $m * $i[1] ;
				if	( $r[1] > $div )	{ $i[0] = $i[1] ; }
				elsif	( $r[1] < $div )	{ $i[2] = $i[1] ; }
				else				{ last ; }
			}

			foreach my $c ( reverse( $i[0] .. $i[2] ) ) {
				if ( $r[1] >= ( $m * $c ) ) {
					$r[0] += ( $d * $c ) ;
					$r[1] -= ( $m * $c ) ;
					last ;
				}
			}

			if ( $r[1] >= $m ) {
				croak( "unexpected error!!\n" )	;
			}
		}

		return @r ;
	}

	sub _divmod_p {
		#---------------------------------------------------------------
		#
		# 正の整数同士の除算
		#
		#   筆算を模した処理。
		#
		#   除数を固定し、被除数を高次の桁から順に取り出して判定を行う。
		#   ループ 1 回で確定するのは基本的に 10 進数 1 桁のみ。
		#   除数と被除数の桁数の差が大きいほど処理コストが増大する。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
		}

		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		#
		# 被除数を文字列化し、除数の桁数と同じか 1 桁だけ大きい数値を先頭から切り出して
		# 剰余値 r の初期値としてセットする。
		#
		my $xstr = $x->as_string() ;
		my $yd = $y->integer_digits() ;

		my $q = undef ;
		my $r = __PACKAGE__->new( substr( $xstr , 0 , $yd ) ) ;
		$xstr = substr( $xstr , $yd ) ;
		if ( $r < $y ) {
			$r = ( $r * 10 ) + substr( $xstr , 0 , 1 ) ;
			$xstr = substr( $xstr , 1 ) ;
		}

		#
		# 除算
		#
		#   y <= r <= ( y * 10 ) となるように r を調整しながら商と余りを求める。
		#
		while ( length( $xstr ) > 0 ) {

			while ( length( $xstr ) > 0 and $r < $y ) {
				$q .= '0' ;
				$r = ( $r * 10 ) + substr( $xstr , 0 , 1 ) ;
				$xstr = substr( $xstr , 1 ) ;
			}

			last	if ( $r < $y ) ;

			my @i = ( 1 , 0 , 10 ) ;
			while ( ( $i[2] - $i[0] ) > 2 ) {
				$i[1] = CORE::int( ( $i[0] + $i[2] ) / 2 ) ;
				my $ym = $y * $i[1] ;
				last	if ( $r == $ym ) ;
				if	( $r > $ym )	{ $i[0] = $i[1] ; }
				elsif	( $r < $ym )	{ $i[2] = $i[1] ; }
			}

			foreach my $c ( reverse( $i[0] .. $i[2] ) ) {
				my $ym = $y * $c ;
				if ( $r >= $ym ) {
					$q .= $c ;
					$r -= $ym ;
					if ( length( $xstr ) > 0 ) {
						$r = ( $r * 10 ) + substr( $xstr , 0 , 1 ) ;
						$xstr = substr( $xstr , 1 ) ;
					}
					last ;
				}
			}
		}

		if ( $r >= $y ) {
			foreach my $c ( reverse( 1 .. 10 ) ) {
				my $ym = $y * $c ;
				if ( $r >= $ym ) {
					$q .= $c ;
					$r -= $ym ;
					last ;
				}
			}
		}

		$q = __PACKAGE__->new( $q ) ;

		return ( $q , $r ) ;
	}

	sub _divmod_bin {
		#---------------------------------------------------------------
		#
		# 2 進数での除算
		#
		#   多倍長整数の演算には不適当だが、参考として載せておく。
		#
		#   ビットごとに試し引きを行い、引けた回数を数えると言ったアプローチ。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		#
		# x >= y > 0 であり、 x , y 共に正の整数であることを確認する。
		#
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		#
		# x < y であれば商は 0 , 剰余は x
		#
		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		#
		# m == y * 2^p で且つ m <= x である最大の m を求める。
		#
		my $xv = $x->copy() ;
		my $m = $y->copy() ;
		my $p = 0 ;
		while ( $m < $x ) { $m <<= 1 ; $p++ ; }
		$m >>= 1 ;
		$p-- ;

		#
		# 主処理
		#
		my $q = __PACKAGE__->new( 0 ) ;		# 商
		foreach my $i ( 0 .. $p ) {
			$q <<= 1 ;
			my $t = $xv - $m ;
			if ( $t >= 0 ) { $q++ ; $xv = $t ; }
			$m >>= 1 ;
		}

		my $r = $x - ( $y * $q ) ;		# 剰余

		return ( $q , $r ) ;
	}

	sub _divmod_dec10 {
		#---------------------------------------------------------------
		#
		# 10 進数での除算
		#
		#   2 進数での除算を 10 進数に応用したもの。
		#   多倍長整数の演算には不適当だが、参考として載せておく。
		#
		#   2 進数の場合と比べると 10 進数 1 桁当たり最大で 10 回の試し引きを行っており効率は非常に悪い。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		#
		# x >= y > 0 であり、 x , y 共に正の整数であることを確認する。
		#
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		#
		# x < y であれば商は 0 , 剰余は x
		#
		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		#
		# yp == y * 10^p で且つ yp <= x である最大の yp を求める。
		#
		my $yp = $y->copy() ;
		my $p = 0 ;
		while ( $yp < $x ) { $yp *= 10 ; $p++ ; }
		$yp /= 10 ;
		$p-- ;

		#
		# 主処理
		#
		my $q = __PACKAGE__->new( 0 ) ;		# 商   ( 初期値 == 0 )
		my $r = $x->copy() ;			# 剰余 ( 初期値 == x )

		foreach my $i ( 0 .. $p ) {
			#
			# 商を桁上げ
			#
			$q *= 10 ;

			#
			# 10 進数 1 桁ごとに最大 9 回の試し引きを行う。
			#
			foreach my $j ( 1 .. 9 ) {
				my $rc = $r - $yp ;
				last	if ( $rc < 0 ) ;
				$q += 1 ;	# 商を更新
				$r = $rc ;	# この桁での剰余を次回の非除数とする。
			}
			$yp /= 10 ;
		}

		#
		# 剰余を再計算
		#
		#   正の整数同士の除算なので、剰余値は既に $r に格納されている。
		#   符号付きの整数を扱う際には商と剰余の再調整が必要となる。
		#
		#my $r = $x - ( $y * $q ) ;

		return ( $q , $r ) ;
	}

	sub _divmod_dec20 {
		#---------------------------------------------------------------
		#
		# 10 進数での除算
		#
		#   筆算を模した実装
		#
		#   非除数 x の先頭 1 ないし 2 桁を除数 y の先頭 1 桁で除算した結果を仮商とし、
		#   この仮商を用いて導いた剰余値で検算と補正を行う。
		#   補正後の値で賞を更新し、剰余値は次回の非除数として用いる。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		#
		# x >= y > 0 であり、 x , y 共に正の整数であることを確認する。
		#
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		#
		# x < y であれば商は 0 , 剰余は x
		#
		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		#
		# yp == y * 10^p で且つ x と同じ桁数を持つ yp を求める。 ( 桁揃え )
		#
		my $yp = $y->copy() ;
		my $p = 0 ;
		while ( $yp < $x ) { $yp *= 10 ; $p++ ; }
		unless ( length( $x->value() ) == length( $yp->value() ) ) {
			$yp /= 10 ; $p-- ;
		}

		#
		# 除算
		#
		my $yh = substr( $y->value() , 0 , 1 ) ;
		my $q = __PACKAGE__->new( 0 ) ;		# 商   ( 初期値 == 0 )
		my $r = $x->copy() ;			# 剰余 ( 初期値 == x )

		foreach my $i ( 0 .. $p ) {
			#
			# 商を桁上げ
			#
			$q *= 10 ;

			#
			# 初回は非除数の先頭 1 桁を 2 回目以降は 2 桁を採る。
			#
			my $rh ;
			if ( $i == 0 )	{ $rh = substr( $r->value() , 0 , 1 ) ; }
			else		{ $rh = substr( $r->value() , 0 , 2 ) ; }

			#
			# 非除数の先頭桁と y の先頭 1 桁での除算により、現在桁での商 qc を得る。
			#
			#   結果が基数 == 10 を超える場合には、減基数 == 9 を設定する。
			#
			my $qc = CORE::int( $rh / $yh ) ;
			$qc = 9	if ( $qc > 9 ) ;

			if ( $qc > 0 ) {
				my $rc = $r - $qc * $yp ;	# 現在桁での剰余
				while ( $rc < 0 ) {
					last	if ( $qc < 1 ) ;
					$qc -= 1 ;
					$rc += $yp ;
				}
				if ( $qc > 0 ) {
					$q += $qc ;		# 商を更新
					$r = $rc ;		# 剰余値を次回の非除数とする。
				}
			}
			$yp /= 10 ;
		}

		#
		# 剰余値を再計算
		#
		#   正の整数同士の除算なので結果は既に $r に格納されている。
		#   符号付きの整数の除算においては、商と剰余を再調整する必要がある。
		#
		#$r = $x - ( $y * $q ) ;

		return ( $q , $r ) ;
	}

	sub _divmod_dec30 {
		#---------------------------------------------------------------
		#
		# 10 進数での除算
		#
		#   筆算を模した実装では、除数の先頭桁が小さい値の時に効率が悪くなる。
		#   ここでは、除数の先頭桁が基数の 1/2 以上となるような係数を掛けることでこれを改善する。
		#
		#---------------------------------------------------------------
		my( $x , $y ) = @_ ;

		#
		# x >= y > 0 であり、 x , y 共に正の整数であることを確認する。
		#
		foreach ( $x , $y ) {
			$_ = __PACKAGE__->new( $_ )		unless ( ref( $_ ) eq __PACKAGE__ ) ;
			croak( "invalid method call.\n" )	unless ( defined $_ ) ;
			croak( "invalid method call.\n" )	unless ( $_->{'sgn'} > 0 ) ;
			croak( "invalid method call.\n" )	unless ( $_->decimal_part()->is_zero() ) ;
			unless ( $_->{'dlen'} == 0 ) {
				$_ = __PACKAGE__->new( $_->as_string() ) ;
				croak( "invalid method call.\n" )	unless ( $_->{'dlen'} == 0 ) ;
			}
		}

		croak( "Division by zero.\n" )	if ( $y == 0 ) ;

		#
		# x < y であれば商は 0 , 剰余は x
		#
		if ( $x < $y ) {
			return ( __PACKAGE__->new( 0 ) , $x->copy() ) ;
		}

		#
		# x , y に掛ける係数 d を決定する。
		#
		my $yh = substr( $y->value() , 0 , 2 ) ;	# 除数 y の先頭 2 桁
		my $d = ( $yh < 10 )
			? CORE::int( 10 / ( $yh + 1 ) )
			: CORE::int( ( 10 * 10 ) / ( $yh + 1 ) )
		;

		#
		# x , y を d 倍する。
		#
		$x *= $d ;
		$y *= $d ;

		#
		# yp == y * 10^p で且つ x と同じ桁数を持つ yp を求める。 ( 桁揃え )
		#
		my $yp = $y->copy() ;
		my $p = 0 ;
		while ( $yp < $x ) { $yp *= 10 ; $p++ ; }
		unless ( length( $x->value() ) == length( $yp->value() ) ) {
			$yp /= 10 ; $p-- ;
		}

		#
		# 除算
		#
		$yh = substr( $y->value() , 0 , 1 ) ;	# 除数 y の先頭 1 桁
		my $q = __PACKAGE__->new( 0 ) ;		# 商   ( 初期値 == 0 )
		my $r = $x->copy() ;			# 剰余 ( 初期値 == x )

		foreach my $i ( 0 .. $p ) {
			#
			# 商を桁上げ
			#
			$q *= 10 ;

			#
			# 初回は非除数の先頭 1 桁を 2 回目以降は 2 桁を採る。
			#
			my $rh ;
			if ( $i == 0 )	{ $rh = substr( $r->value() , 0 , 1 ) ; }
			else		{ $rh = substr( $r->value() , 0 , 2 ) ; }

			#
			# 非除数の先頭桁と y の先頭 1 桁での除算により、現在桁での商 qc を得る。
			#
			#   結果が基数 == 10 を超える場合には、減基数 == 9 を設定する。
			#
			my $qc = CORE::int( $rh / $yh ) ;
			$qc = 9	if ( $qc > 9 ) ;

			if ( $qc > 0 ) {
				my $rc = $r - $qc * $yp ;	# 現在桁での剰余
				while ( $rc < 0 ) {
					last	if ( $qc < 1 ) ;
					$qc -= 1 ;
					$rc += $yp ;
				}
				if ( $qc > 0 ) {
					$q += $qc ;		# 商を更新
					$r = $rc ;		# 剰余値を次回の非除数とする。
				}
			}
			$yp /= 10 ;
		}

		#
		# 剰余値を再計算
		#
		#   x , y には予め係数 d が掛かっている。
		#   この時の剰余値 r は
		#
		#     r == int( r / d )
		#
		#   となる。
		#
		#   x , y が符号付き整数の場合には、別途補正が必要となる。
		#
		#
		#   基数が 10 であるため d は 10 進数 1 桁の数値。
		#   r は基数 INT_BASE の多倍長整数オブジェクト ( Decimal オブジェクト ) であるため、
		#   r / d を r に対する係数列の除算を用いて実装している。
		#
		foreach my $i ( reverse( 0 .. $#{ $r->{'val'} } ) ) {
			my $dig = $r->{'val'}->[ $i ] ;
			$r->{'val'}->[ $i ] = CORE::int( $dig / $d ) ;
			if ( $i > 0 ) {
				$r->{'val'}->[ $i - 1 ] += ( $dig % $d ) * INT_BASE ;
			}
		}
		$r->_regulate() ;

		return ( $q , $r ) ;
	}

	sub _atan_cf {
		#--------------------------------------------------------------
		#
		# 連分数展開を使用した逆正接
		#
		#                                  x
		#   atan( x ) == ------------------------------------------
		#                               ( 1 * x )^2
		#                  1 + ------------------------------------
		#                                    ( 2 * x )^2
		#                         3 + -----------------------------
		#                                        ( 3 * x )^2
		#                                5 + ----------------------
		#                                            ( 4 * x )^2 
		#                                      7 + ----------------
		#                                            9 + .........
		#
		#   マクローリン展開では x が 1 の周辺にある時に収束が非常に遅くなるが、
		#   連分数展開では 0.01 <= x < 1 程度の範囲でも精度よく高速に収束する。
		#
		#--------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		#
		# 連分数を組み立てる。
		#
		my $cf = [
			[ __PACKAGE__->new( 0 ) , $x ] ,
		] ;

		my $x2 = $x * $x ;
		foreach ( my $i = __PACKAGE__->new( 1 ) ; $i <= 40 ; $i++ ) {
			#push( @{ $cf } , [ ( $i * 2 - 1 ) , ( $i * $x ) ** 2 ] ) ;
			push( @{ $cf } , [ ( $i * 2 - 1 ) , ( $i ** 2 ) * $x2 ] ) ;
		}

		#
		# 連分数を小数に変換
		#
		@{ $cf } = reverse( @{ $cf } ) ;
		my $r = undef ;
		foreach ( my $i = 0 ; $i < @{ $cf } ; $i++ ) {
			my $ref = \@{ $cf->[ $i ] } ;
			if ( $i == 0 ) {
				$r = fraction( $ref->[0] ) ;
			}
			else {
				$r = $r->inverse() ;
				$r->{'n'} *= $ref->[1] ;
				$r->{'n'} += ( $r->{'d'} * $ref->[0] ) ;
			}
		}

		return $r->decimal( $dlen ) ;
	}

	sub _atan_fact {
		#--------------------------------------------------------------
		#
		# 二重階乗を使用した逆正接
		#
		#
		#   逆正接 ( arctangent ) のマクローリン展開式は以下のとおり。
		#
		#                                   x^( k * 2 + 1 )
		#      atan x   == Σ( ( -1 )^k * ------------------- )           ( k == 0 -> ∞ )
		#                                     k * 2 + 1 
		#
		#   分母は 1 以上の奇数値、分子は x をその値で冪乗した値となっており、加算一回毎に符号が反転する。
		#
		#   使用する奇数値の最大値が予め決まっていれば、最終的な分母は二重階乗で算出できる。
		#   分子を算出する際に、そのときに使用した奇数値を二重階乗から除いた値を掛けておくことで通分された状態になる。
		#   通分された分子を加減算した後、最後に二重階乗の値で割ることで求める値が得られる。
		#
		#   0 <= k <= 100 の範囲で演算を行う場合、上記の式は以下のように表現できる。
		#
		#                                  x^( k * 2 + 1 ) * ( 201!! / ( k * 2 + 1 ) )
		#      atan x   == Σ( ( -1 )^k * --------------------------------------------- )           ( k == 0 -> 100 )
		#                                                 201!!
		#
		#
		#   奇数値の最大値を 81 ( k == 40 ) に設定した場合で精度は小数点以下 30 桁程度。
		#   201 ( k == 100 ) で 40 桁程度。
		#
		#--------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

		return undef	if ( $x->abs() >= 1 ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		my $sz = 200 ;
		my $f = __PACKAGE__->new( 2 * $sz + 1 )->double_factorial() ;	# ( 2k + 1 )!!

		my $x2 = $x * $x ;
		my $xpow = $x->copy() ;
		my $sgn = 1 ;
		my $r = $x * $f ;
		my $diff_stop = __PACKAGE__->new( 0.1 )->power( $dlen + 1 ) * $f ;
		foreach my $k ( 1 .. $sz ) {
			#
			# odd = 2k + 1
			# f = odd!!
			# r += ( -1 ** $k ) * ( x ** odd * ( f / odd )
			#
			$sgn *= ( -1 ) ;
			$xpow *= $x2 ;
			my $odd = 2 * $k + 1 ;
			my $diff = $xpow * ( $f / $odd ) ;
			if ( $diff < $diff_stop ) {
				#warn( "$k\n" ) ;
				last ;
			}
			$r += $diff * $sgn ;
		}

		$r = $r->divide( $f , $dlen ) ;
		#return $r->round_down( $dlen ) ;
		return $r ;
	}

	sub _atan {
		#---------------------------------------------------------------
		#
		# 逆正接のマクローリン展開
		#
		#   逆正接 ( arctangent ) のマクローリン展開式は以下のとおり。
		#
		#                                 x^( k * 2 + 1 )
		#     atan x   == Σ( ( -1 )^k * ----------------- )
		#                                    k * 2 + 1 
		#
		#   -1 < x < 1 という制約があり、演算結果は -PI/4 < atan( x ) < PI/4 の範囲となる。
		#
		#
		#   以下は、 x の逆数のマクローリン展開。
		#
		#                                                 1
		#     atan 1/x == Σ( ( -1 )^k ) * --------------------------------- )
		#                                   x^( k * 2 + 1 ) * ( k * 2 + 1 )
		#
		#
		#   以下は、オイラーのアークタンジェント
		#
		#                      2^( k * 2 ) * ( ( k! )^2 )          x^( k * 2 + 1 )
		#     atan x   == Σ( ---------------------------- * --------------------------- )
		#                             ( k * 2 + 1 )!          ( 1 + ( x^2 ) )^( k + 1 ) 
		#
		#   オイラーのアークタンジェントは abs( x ) >= 1 にも対応しているとのこと。
		#
		#---------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

		return undef	unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		if ( $x->integer_digits() > $dlen ) {
			#
			# +∞  return  PI/2
			# -∞  return -PI/2
			#
			my $r = qpi()->multiply( 2 ) ;
			$r->{'sgn'} *= ( -1 )	if ( $x->{'sgn'} < 0 ) ;
			return $r ;
		}

		return __PACKAGE__->new( 0 )	if ( $x->is_zero() ) ;

		my $xabs = $x->abs() ;
		if ( $xabs == 1 ) {
			#
			# x > 0 return  PI/4
			# x < 0 return -PI/4
			#
			my $r = qpi() ;
			$r->{'sgn'} *= ( -1 )	if ( $x->{'sgn'} < 0 ) ;
			return $r ;
		}

		return undef	if ( $xabs > 1 ) ;

		my $sgn = 1 ;
		my $k = 1 ;
		my $x2 = $x->multiply( $x ) ;	# x^2
		my $xp = $x2->copy() ;		# ( x^2 )^k    ( k = 1 -> ∞ )
		my $r = $x->copy() ;
		while () {
			$sgn *= ( -1 ) ;
			my $odd = ( $k * 2 ) + 1 ;
			my $numer = $xp->multiply( $x )->round_down( $dlen + 4 ) ;
			my $diff = $numer->divide( $odd , $dlen + 4 ) ;

			last	if ( $diff->is_zero() ) ;

			if ( $sgn > 0 )	{ $r += $diff ; }
			else		{ $r -= $diff ; }
			$k++ ;
			$xp *= $x2 ;
		}

		return $r ;
	}

	sub _atan_inv {
		#---------------------------------------------------------------
		#
		# 正接の逆数の逆正接
		#
		#   逆正接 ( arctangent ) のマクローリン展開式は以下のとおり。
		#
		#                                x^( k * 2 + 1 )
		#     atan x   == Σ( ( -1 )^ * ----------------- )
		#                                   k * 2 + 1 
		#
		#   以下は、 x の逆数のマクローリン展開。
		#
		#                                                 1
		#     atan 1/x == Σ( ( -1 )^k ) * --------------------------------- )
		#                                   x^( k * 2 + 1 ) * ( k * 2 + 1 )
		#
		# atan( 1/x ) は演算コストが低いため、これを利用して円周率を求める公式が幾つも存在する。
		#
		#---------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;

		return undef	unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		my $r = [
			__PACKAGE__->new( 0 ) ,		# 分子
			__PACKAGE__->new( 1 ) ,		# 分母
		] ;
		my $k = 0 ;
		#my $f = [] ;

		my $numer = 1 ;							# 分子
		while () {
			my $sgn = ( -1 ) ** $k ;
			my $odd = $k * 2 + 1 ;
			my $denom = $x->power( $odd )->multiply( $odd ) ;	# 分母

			last	if ( length( $denom->value() ) > ( $dlen + 4 ) ) ;

			#push( @{ $f } , [ $numer , $denom ] ) ;

			$r->[0] = ( $r->[0] * $denom ) + ( $numer * $r->[1] * $sgn ) ;
			$r->[1] *= $denom ;

			$k++ ;
		}

		return $r ;
	}

	sub _qpi2cs {
		#-----------------------------------------------------------------------
		#
		# n/4 * PI を意味する n を受け取り、 cos( n/4 * PI ) , sin( n/4 * PI ) を返す。
		# 0 <= n < 8
		#
		#  n   radian                            cos                          sin
		# --+--------+------------------------------+----------------------------
		#                                                                               第 1 象限 ( cos > 0 , sin >= 0 )
		#  0        0                               1                           0
		#  1   1/4 PI                     sqrt(2) / 2                 sqrt(2) / 2
		#                                                                               第 2 象限 ( cos <= 0 , sin > 0 )
		#  2   1/2 PI                               0                           1
		#  3   3/4 PI                -1 * sqrt(2) / 2                 sqrt(2) / 2
		#                                                                               第 3 象限 ( cos < 0 , sin <= 0 )
		#  4       PI                              -1                           0
		#  5   5/4 PI                -1 * sqrt(2) / 2            -1 * sqrt(2) / 2
		#                                                                               第 4 象限 ( cos > 0 , sin < 0 )
		#  6   3/2 PI                               0                          -1
		#  7   7/4 PI                     sqrt(2) / 2            -1 * sqrt(2) / 2
		#
		# これらの値は、 n/4 を約分した時の分母で分類することができる。
		#
		# また、 n の値ごとの戻り値を w[n] で表すと、
		#
		#   w[0]                == { cos => 1                    , sin => 0                    }
		#   w[1]                == { cos => sqrt(2) / 2          , sin => sqrt(2) / 2          }
		#   w[2]                == { cos => 0                    , sin => 1                    }
		#   w[4] == w[1] * (-1) == { cos => -1                   , sin => 0                    }
		#   w[6] == w[2] * (-1) == { cos => 0                    , sin => -1                   }
		#   w[8] == w[0]
		#
		#   w[3] == w[ 4 - 1 ]  == { cos => w[1]->{'cos'} * (-1) , sin => w[1]->{'sin'}        }
		#   w[5] == w[ 8 - 3 ]  == { cos => w[3]->{'cos'}        , sin => w[3]->{'sin'} * (-1) }
		#   w[7] == w[ 8 - 1 ]  == { cos => w[1]->{'cos'}        , sin => w[1]->{'sin'} * (-1) }
		#
		# と分類することができる。
		#
		# これは、 w[n] を複素数に見立てた時に
		#
		#   w[0]                        ==  1 + i * 0
		#   w[1]                        == 1/2 * ( sqrt(2)        + i * sqrt(2) )
		#   w[2]                        ==  0 + i
		#   w[4] == conj( w[0] ) * (-1) == -1 + i * 0
		#   w[6] == conj( w[2] )        ==  0 - i
		#
		#   w[3] == conj( w[1] ) * (-1) == 1/2 * ( sqrt(2) * (-1) + i * sqrt(2) ) 
		#   w[5] == conj( w[3] )        == 1/2 * ( sqrt(2) * (-1) - i * sqrt(2) ) 
		#   w[7] == conj( w[1] )        == 1/2 * ( sqrt(2)        - i * sqrt(2) )
		#
		# となることを意味している。
		#
		#-----------------------------------------------------------------------
		my( $n  ) = @_ ;

		my $r = undef ;

		my $f = fraction( $n , 12 ) ;
		if	( $f->{'d'} == 1 )	{ $r = { 'cos' => _new(  1 )       , 'sin' => _new(  0 )       } ; }	# cos == 1 , sin == 0
		elsif	( $f->{'d'} == 2 )	{ $r = { 'cos' => _new(  0 )       , 'sin' => _new(  1 )       } ; }	# cos == 0 , sin == 1
		elsif	( $f->{'d'} == 4 )	{ $r = { 'cos' => _sqrt( 2 ) * 0.5 , 'sin' => _sqrt( 2 ) * 0.5 } ; }	# cos == sqrt(2)/2 , sin == sqrt(2)/2

		if ( defined $r ) {
			if	( $n >= 6 ) { $r->{'sin'} *= ( -1 ) ; }					# 第 4 象限 ( cos >  0 , sin <  0 )
			elsif	( $n >= 4 ) { $r->{'cos'} *= ( -1 ) ; $r->{'sin'} *= ( -1 ) ; }		# 第 3 象限 ( cos <  0 , sin <= 0 )
			elsif	( $n >= 2 ) { $r->{'cos'} *= ( -1 ) ; }					# 第 2 象限 ( cos <= 0 , sin >  0 )
		}

		return $r ;
	}

	my $_cstab = undef ;

	sub _dpi2cs {
		#-----------------------------------------------------------------------
		#
		# n/12 * PI を意味する n を受け取り、 cos( n/12 * PI ) , sin( n/12 * PI ) を返す。
		# 0 <= n < 24
		#
		# ここでは、複素数における 1 の 24 乗根をテーブル化して該当箇所を返すこととする。
		# 
		# 1 の 24 乗根を w[k] , w[k] の偏角を t で表すと、
		#
		#   t == 0 , PI/4 , PI/2 , PI となる w[k] は、
		#
		#     t == 0    ==  0 * 2PI/24   -> w[0]  ==           1 + i *           0
		#     t == PI/4 ==  3 * 2PI/24   -> w[3]  == sqrt(2) / 2 + i * sqrt(2) / 2
		#     t == PI/2 ==  6 * 2PI/24   -> w[6]  ==           0 + i *           1
		#     t == PI   == 12 * 2PI/24   -> w[12] ==          -1 + i *           0
		#
		#   となる。
		#
		#   0 <= k <= 3 ( 0 <= t <= PI/4 ) の範囲の w[k] は、
		#
		#     w[0]  ==                         1      + i *                         0   # t ==  0 * PI/24
		#     w[1]  == ( sqrt(6) + sqrt(2) ) / 4      + i * ( sqrt(6) - sqrt(2) ) / 4   # t ==  2 * PI/24 == 1 * PI/12
		#     w[2]  ==               sqrt(3) / 2      + i *                         1   # t ==  4 * PI/24 == 2 * PI/12 == PI/6
		#     w[3]  ==               sqrt(2) / 2      + i *               sqrt(2) / 2   # t ==  6 * PI/24 == 3 * PI/12 == PI/4
		#
		#   となる。
		#
		#   3 < k <= 6 ( PI/4 < t <= PI/2 ) の範囲の w[k] は、
		#
		#     w[4]  == w[  6 - 2 ] == imag( w[2] ) + i * real( w[2] )                   # t ==  8 * PI/24 == 4 * PI/12 == PI/3
		#     w[5]  == w[  6 - 1 ] == imag( w[1] ) + i * real( w[1] )                   # t == 10 * PI/24 == 5 * PI/12
		#     w[6]  == w[  6 - 0 ] == imag( w[0] ) + i * real( w[0] )                   # t == 12 * PI/24 == 6 * PI/12 == PI/2
		#
		#   であり、これを一般化すると、
		#
		#     k == 6 - j
		#     -> j == 6 - k
		#
		#     w[k] == imag( w[j] ) + i * real( w[j] )
		#          == imag( w[ 6 - k ] ) + i * real( w[ 6 - k ] ) 
		#
		#   となる。
		#
		#   6 < k <= 12 ( PI/2 < t <= PI ) の範囲の w[k] は、
		#
		#     w[7]  == w[ 12 - 5 ] == conj( w[5] ) * (-1)                               # t == 14 * PI/24 ==  7 * PI/12
		#                          == real( w[5] ) * (-1) + i * imag( w[5] )
		#                          == imag( w[1] ) * (-1) + i * real( w[1] )
		#
		#     w[8]  == w[ 12 - 4 ] == conj( w[4] ) * (-1)                               # t == 16 * PI/24 ==  8 * PI/12 == 2 * PI/3
		#                          == real( w[4] ) * (-1) + i * imag( w[4] )
		#                          == imag( w[2] ) * (-1) + i * real( w[2] )
		#
		#     w[9]  == w[ 12 - 3 ] == conj( w[3] ) * (-1)                               # t == 18 * PI/24 ==  9 * PI/12 == 3 * PI/4
		#                          == real( w[3] ) * (-1) + i * imag( w[3] )
		#
		#     w[10] == w[ 12 - 2 ] == conj( w[2] ) * (-1)                               # t == 20 * PI/24 == 10 * PI/12 == 5 * PI/6
		#                          == real( w[2] ) * (-1) + i * imag( w[2] )
		#
		#     w[11] == w[ 12 - 1 ] == conj( w[1] ) * (-1)                               # t == 22 * PI/24 == 11 * PI/12
		#                          == real( w[1] ) * (-1) + i * imag( w[1] )
		#
		#     w[12] == w[ 12 - 0 ] == conj( w[0] ) * (-1)                               # t == 24 * PI/24 == 12 * PI/12 == PI
		#                          == real( w[0] ) * (-1) + i * imag( w[0] )
		#
		#   であり、これを一般化すると、
		#
		#     k == 12 - j
		#     -> j == 12 - k
		#
		#     j == 0 , 1 , 2 , 3 の時、 k == 12 , 11 , 10 , 9 となり、
		#
		#       w[k] == real( w[j] ) * (-1) + i * imag( w[j] )
		#            == real( w[ 12 - k ] ) * (-1) + i * imag( w[ 12 - k ] )
		#
		#     j == 4 , 5 の時、 k == 8 , 7 となり、
		#
		#       j == 6 - h
		#       -> h == 6 - j
		#            == 6 - ( 12 - k )
		#            == k - 6
		#
		#       w[k] == real( w[j] ) * (-1) + i * imag( w[j] )
		#            == imag( w[h] ) * (-1) + i * real( w[h] )
		#            == imag( w[ 6 - j ] ) * (-1) + i * real( w[ 6 - j ] )
		#            == imag( w[ k - 6 ] ) * (-1) + i * real( w[ k - 6 ] )
		#
		#   となる。
		#
		#   12 < k < 24 ( PI < t < 2PI ) の範囲の w[k] は、 j == 24 - k を伴って、
		#
		#     w[ k ] == w[ j * (-1) ]
		#            == w[ 24 - j ]
		#            == conj( w[j] )
		#            == real( w[j] ) - i * imag( w[j] )
		#
		#   となる。
		#
		#-----------------------------------------------------------------------
		my( $n ) = @_ ;

		$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $n ) ;

		return undef	unless ( $n->is_integer() ) ;
		$n %= 24 ;
		$n = $n->value() ;

		unless ( defined $_cstab ) {
			#
			# 0 <= k <= 3 ( 0 <= t <= PI/4 ) の範囲を定義
			#
			my $d0 = _new( 0 ) ;
			my $d1 = _new( 1 ) ;
			my $d2 = _new( 2 ) ;

			my $sq2 = _sqrt( 2 ) ;
			my $sq3 = _sqrt( 3 ) ;
			my $sq6 = _sqrt( 6 ) ;

			$_cstab = {
				'0'	=> { 'cos' => $d1                     , 'sin' => $d0                      } , # 0
				'1'	=> { 'cos' => ( $sq6 + $sq2 ) * 0.25  , 'sin' => ( $sq6 - $sq2 ) * 0.25   } , # PI/12
				'2'	=> { 'cos' => $sq3 * 0.5              , 'sin' => $d1  * 0.5               } , # PI/6
				'3'	=> { 'cos' => $sq2 * 0.5              , 'sin' => $sq2 * 0.5               } , # PI/4
			} ;
		} 

		return $_cstab->{ $n }	if ( defined $_cstab->{ $n } ) ;

		my $r = undef ;
		my $k = ( $n > 12 ) ? ( 24 - $n ) : $n ;

		if ( $k <= 3 ) {
			#
			# 0 <= t <= PI/4
			#
			$r = {
				'cos' => $_cstab->{ $k }->{'cos'}	,
				'sin' => $_cstab->{ $k }->{'sin'}	,
			} ;
		}
		elsif ( $k >= 4 and $k <= 6 ) {
			#
			# PI/4 < t <= PI/2
			#
			# w[ k ] == imag( w[ 6 - k ] ) + i * real( w[ 6 - k ] ) 
			#
			my $j = 6 - $k ;
			$r = {
				'cos' => $_cstab->{ $j }->{'sin'}	,
				'sin' => $_cstab->{ $j }->{'cos'}	,
			} ;
		}
		elsif ( $k >= 7 and $k <= 8 ) {
			#
			# PI/2 < t < 3 * PI/4
			#
			# w[k] == imag( w[ k - 6 ] ) * (-1) + i * real( w[ k - 6 ] )
			#
			my $j = $k - 6 ;
			$r = {
				'cos' => $_cstab->{ $j }->{'sin'} * (-1)	,
				'sin' => $_cstab->{ $j }->{'cos'}		,
			} ;
		}
		elsif ( $k <= 12 ) {
			#
			# 3 * PI/4 < t <= PI
			#
			# w[k] == real( w[ 12 - k ] ) * (-1) + i * imag( w[ 12 - k ] )
			#
			my $j = 12 - $k ;
			$r = {
				'cos' => $_cstab->{ $j }->{'cos'} * (-1)	,
				'sin' => $_cstab->{ $j }->{'sin'}		,
			} ;
		}

		if ( defined $r ) {
			$r->{'sin'} *= (-1)	if ( $n > 12 ) ;
			$_cstab->{ $n } = { %{ $r } } ;
		}

		return $r ;
	}

	sub _dpi2cs00 {
		#-----------------------------------------------------------------------
		#
		# n/12 * PI を意味する n を受け取り、 cos( n/12 * PI ) , sin( n/12 * PI ) を返す。
		# 0 <= n < 24
		#
		#  n   radian                            cos                               sin
		# --+--------+------------------------------+---------------------------------
		#                                                                               第 1 象限 ( cos > 0 , sin >= 0 )
		#  0        0                               1                                0
		#  1  1/12 PI       ( sqrt(6) + sqrt(2) ) / 4        ( sqrt(6) - sqrt(2) ) / 4
		#  2   1/6 PI                     sqrt(3) / 2                            1 / 2
		#  3   1/4 PI                     sqrt(2) / 2                      sqrt(2) / 2
		#  4   1/3 PI                           1 / 2                      sqrt(3) / 2
		#  5  5/12 PI       ( sqrt(6) - sqrt(2) ) / 4        ( sqrt(6) + sqrt(2) ) / 4
		#                                                                               第 2 象限 ( cos <= 0 , sin > 0 )
		#  6   1/2 PI                               0                                1
		#  7  7/12 PI  -1 * ( sqrt(6) - sqrt(2) ) / 4        ( sqrt(6) + sqrt(2) ) / 4
		#  8   2/3 PI                          -1 / 2                      sqrt(3) / 2
		#  9   3/4 PI                -1 * sqrt(2) / 2                      sqrt(2) / 2
		# 10   5/6 PI                -1 * sqrt(3) / 2                            1 / 2
		# 11 11/12 PI  -1 * ( sqrt(6) + sqrt(2) ) / 4        ( sqrt(6) - sqrt(2) ) / 4
		#                                                                               第 3 象限 ( cos < 0 , sin <= 0 )
		# 12       PI                              -1                                0
		# 13 13/12 PI  -1 * ( sqrt(6) + sqrt(2) ) / 4   -1 * ( sqrt(6) - sqrt(2) ) / 4
		# 14   7/6 PI                -1 * sqrt(3) / 2                           -1 / 2
		# 15 15/12 PI                -1 * sqrt(2) / 2                 -1 * sqrt(2) / 2
		# 16   8/6 PI                          -1 / 2                 -1 * sqrt(3) / 2
		# 17 17/12 PI  -1 * ( sqrt(6) - sqrt(2) ) / 4   -1 * ( sqrt(6) + sqrt(2) ) / 4
		#                                                                               第 4 象限 ( cos >= 0 , sin < 0 )
		# 18   3/2 PI                               0                               -1
		# 19 19/12 PI       ( sqrt(6) - sqrt(2) ) / 4   -1 * ( sqrt(6) + sqrt(2) ) / 4
		# 20  10/6 PI                           1 / 2                 -1 * sqrt(3) / 2
		# 21   7/4 PI                     sqrt(2) / 2                 -1 * sqrt(2) / 2
		# 22  11/6 PI                     sqrt(3) / 2                           -1 / 2
		# 23 23/12 PI       ( sqrt(6) + sqrt(2) ) / 4   -1 * ( sqrt(6) - sqrt(2) ) / 4
		#
		#-----------------------------------------------------------------------
		my( $n ) = @_ ;

		$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $n ) ;

		my $r = undef ;

		#
		#  2PI を 24 分割した n/12 PI と cos , sin の絶対値の関係は以下のようになる。
		# 
		#                       n                                    radian                     abs( cos )                        abs( sin )
		# -----------------------+-----------------------------------------+------------------------------+---------------------------------
		#  0 , 12                                           0 PI ,       PI                              1                                 0
		#  1 , 11 , 13 , 23        1/12 PI , 11/12 PI , 13/12 PI , 23/12 PI      ( sqrt(6) + sqrt(2) ) / 4         ( sqrt(6) - sqrt(2) ) / 4
		#  2 , 10 , 14 , 22         1/6 PI ,   5/6 PI ,   7/6 PI ,  11/6 PI                    sqrt(3) / 2                             1 / 2
		#  3 ,  9 , 15 , 21         1/4 PI ,   3/4 PI ,   5/4 PI ,   7/4 PI                    sqrt(2) / 2                       sqrt(2) / 2
		#  4 ,  8 , 16 , 20         1/3 PI ,   2/3 PI ,   4/3 PI ,   5/3 PI                          1 / 2                       sqrt(3) / 2
		#  5 ,  7 , 17 , 19        5/12 PI ,  7/12 PI , 17/12 PI , 19/12 PI      ( sqrt(6) - sqrt(2) ) / 4         ( sqrt(6) + sqrt(2) ) / 4
		#  6 , 18                                         1/2 PI ,   3/2 PI                              0                                 1
		#
		# 2PI を 48 分割すると、 n/24 PI と cos , sin の絶対値の関係は以下のようになる。
		#
		#                       n                                    radian                             abs( cos )                             abs( sin )
		# -----------------------+-----------------------------------------+--------------------------------------+--------------------------------------
		#  0 , 24                                           0 PI ,       PI                                      1                                      0
		#  1 , 23 , 25 , 47        1/24 PI , 23/24 PI , 25/24 PI , 47/24 PI    sqrt( 2 + sqrt( 2 + sqrt(3) ) ) / 2    sqrt( 2 - sqrt( 2 + sqrt(3) ) ) / 2
		#  2 , 22 , 26 , 46        1/12 PI , 11/12 PI , 13/12 PI , 23/12 PI              ( sqrt(6) + sqrt(2) ) / 4              ( sqrt(6) - sqrt(2) ) / 4
		#  3 , 21 , 27 , 45         1/8 PI ,   7/8 PI ,   9/8 PI ,  15/8 PI                sqrt( 2 + sqrt(2) ) / 2                sqrt( 2 - sqrt(2) ) / 2
		#  4 , 20 , 28 , 44         1/6 PI ,   5/6 PI ,   7/6 PI ,  11/6 PI                          sqrt( 3 ) / 2                                  1 / 2
		#  5 , 19 , 29 , 43        5/24 PI , 19/24 PI , 29/24 PI , 43/24 PI    sqrt( 2 + sqrt( 2 - sqrt(3) ) ) / 2    sqrt( 2 - sqrt( 2 - sqrt(3) ) ) / 2
		#  6 , 18 , 30 , 42         1/4 PI ,   3/4 PI ,   5/4 PI ,   7/4 PI                            sqrt(2) / 2                            sqrt(2) / 2
		#  7 , 17 , 31 , 41        7/24 PI , 17/24 PI , 31/24 PI , 41/24 PI    sqrt( 2 - sqrt( 2 - sqrt(3) ) ) / 2    sqrt( 2 + sqrt( 2 - sqrt(3) ) ) / 2
		#  8 , 16 , 32 , 40         1/3 PI ,   2/3 PI ,   4/3 PI ,   5/3 PI                                  1 / 2                            sqrt(3) / 2
		#  9 , 15 , 33 , 39         3/8 PI ,   5/8 PI ,  11/8 PI ,  13/8 PI                sqrt( 2 - sqrt(2) ) / 2                sqrt( 2 + sqrt(2) ) / 2
		# 10 , 14 , 34 , 38        5/12 PI ,  7/12 PI , 17/12 PI , 19/12 PI              ( sqrt(6) - sqrt(2) ) / 4              ( sqrt(6) + sqrt(2) ) / 4
		# 11 , 13 , 35 , 37       11/24 PI , 13/24 PI , 35/24 PI , 37/24 PI    sqrt( 2 - sqrt( 2 + sqrt(3) ) ) / 2    sqrt( 2 + sqrt( 2 + sqrt(3) ) ) / 2
		# 12 , 36                                         1/2 PI ,   3/2 PI                                      0                                      1
		#
		# ここでは、 n/12 を約分した時の分母の値を用いて n/12 PI をテーブル化している。
		#
		my $f = fraction( $n , 12 ) ;

		unless ( defined $_cstab ) {
			$_cstab = {
				'1'	=> { 'cos' => _new( 1 )		, 'sin' => _new( 0 )		} ,	# $n == 0 ( mod 12 )
				'2'	=> { 'cos' => _new( 0 )		, 'sin' => _new( 1 )		} ,	# $n == 6 ( mod 12 )
				'3'	=> { 'cos' => _new( 0.5 )	, 'sin' => _sqrt( 3 ) * 0.5	} ,	# $n == 4 or 8  ( mod 12 )
				'4'	=> { 'cos' => _sqrt( 2 ) * 0.5	, 'sin' => _sqrt( 2 ) * 0.5	} ,	# $n == 3 or 9  ( mod 12 )
				'6'	=> { 'cos' => _sqrt( 3 ) * 0.5	, 'sin' => _new( 0.5 )		} ,	# $n == 2 or 10 ( mod 12 )
				'12'	=> [
					{ 'cos' => ( _sqrt( 6 ) + _sqrt( 2 ) ) * 0.25 , 'sin' => ( _sqrt( 6 ) - _sqrt( 2 ) ) * 0.25 } ,	# $n == 1 or 11 ( mod 12 )
					{ 'cos' => ( _sqrt( 6 ) - _sqrt( 2 ) ) * 0.25 , 'sin' => ( _sqrt( 6 ) + _sqrt( 2 ) ) * 0.25 } ,	# $n == 5 or 7  ( mod 12 )
				] ,
			} ;
		}

		my $ref = undef ;
		if ( $f->{'d'} == 12 ) {
			if ( $n->value() =~ /^(?:1|11|13|23)$/ )	{ $ref = $_cstab->{'12'}->[0] ; }
			else						{ $ref = $_cstab->{'12'}->[1] ; }
		}
		else {
			$ref = $_cstab->{ $f->{'d'} } ;
		}

		if ( defined $ref ) {
			$r = { 'cos' => $ref->{'cos'}->copy() , 'sin' => $ref->{'sin'}->copy() } ;
		}

		if ( defined $r ) {
			if	( $n >= 18 )	{ $r->{'sin'} *= ( -1 ) ; }				# 第 4 象限 ( cos >= 0 , sin <  0 )
			elsif	( $n >= 12 )	{ $r->{'cos'} *= ( -1 ) ; $r->{'sin'} *= ( -1 ) ; }	# 第 3 象限 ( cos <  0 , sin <= 0 )
			elsif	( $n >=  6 )	{ $r->{'cos'} *= ( -1 ) ; }				# 第 2 象限 ( cos <= 0 , sin >  0 )
		}

		return $r ;
	}

	sub _qpi2tan {
		#-----------------------------------------------------------------------
		#
		# n/4 * PI を意味する n を受け取り、 tan( n/4 * PI ) を返す。
		# 0 <= n < 8
		#
		#-----------------------------------------------------------------------
		my( $n , $dlen ) = @_ ;
		my $cs = _qpi2cs( $n ) ;
		return undef	unless ( defined $cs ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		return undef 	if ( $cs->{'cos'}->is_zero() ) ;
		return $cs->{'sin'}->divide( $cs->{'cos'} , $dlen ) ;
	}

	sub _dpi2tan {
		#-----------------------------------------------------------------------
		#
		# n/12 * PI を意味する n を受け取り、 tan( n/12 * PI ) を返す。
		# 0 <= n < 24
		#
		#-----------------------------------------------------------------------
		my( $n , $dlen ) = @_ ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		$n = [ $n ]	unless ( ref( $n ) eq 'ARRAY' ) ;

		my @r = () ;
		foreach ( @{ $n } ) {
			my $cs = _dpi2cs( $_ ) ;
			if	( ! defined $cs )		{ push( @r , undef ) ; }
			elsif	( $cs->{'cos'}->is_zero() )	{ push( @r , undef ) ; }
			else {
				push( @r , $cs->{'sin'}->divide( $cs->{'cos'} , $dlen ) ) ;
			}
		}

		return @r ;
	}

	sub _deg2tan {
		#-----------------------------------------------------------------------
		#
		# n/180 * PI を意味する n を受け取り、 tan( n/180 * PI ) を返す。
		# 0 <= n < 360
		#
		#   _dpi2tan に比べてやや誤差が大きい。 ( 小数点以下 39 桁目辺りから誤差が生じている。 )
		#
		#-----------------------------------------------------------------------
		my( $n , $dlen ) = @_ ;
		my $cs = _deg2cs( $n ) ;
		return undef	unless ( defined $cs ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		return undef 	if ( $cs->{'cos'}->is_zero() ) ;
		return $cs->{'sin'}->divide( $cs->{'cos'} , $dlen ) ;
	}

	my $_cstab_deg = undef ;

	sub _deg2cs {
		#-----------------------------------------------------------------------
		#
		# n/180 * PI を意味する n を受け取り、 cos( n/180 * PI ) , sin( n/180 * PI ) を返す。
		# 0 <= n < 360
		#
		#   _dpi2cs に比べてやや誤差が大きい。 ( 小数点以下 39 桁目辺りから誤差が生じている。 )
		#
		#-----------------------------------------------------------------------
		my( $n ) = @_ ;

		$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
		return ()			unless ( defined $n ) ;
		return ()			unless ( $n->is_integer() ) ;

		$n %= 360 ;
		$n = 360 - $n	if ( $n < 0 ) ;

		my $imag_unit = complex( [ 0 , 1 ] ) ;

		unless ( defined $_cstab_deg ) {
			#
			# 0 <= n <= 45 の範囲のテーブルを作成する。
			#
			#   テーブルの要素は複素数オブジェクトで管理する。
			#
			#   z[0] == x + iy == 1
			#   z[1] == cos( radian( 1 ) ) + i * sin( radian( 1 ) )
			#
			#   radian( 1 ) は限りなく 0 に近い値であり、テイラー展開による演算コストは非常に小さい。
			#
			#   1 < n <= 45 の範囲の z[ n ] は、
			#
			#     z[ n ] == z[ n - 1 ] * z[ 1 ]
			#   
			#   で精度良く求まる。
			#
			#   複素数の乗算は直交表現のみで完結しているため、演算効率も良い。
			#
			#   数列 z は、 z[1] を回転因子とした円周群を成しており、結果は ( z[1] )^k  ( k == 0 -> n ) の集合に等しい。
			#
			my $x = radian( 1 ) ;

			my $z = [
				complex( [ 1 , 0 ] ) ,
				complex( [ $x->_cosine_tayler_expansion() , $x->_sine_tayler_expansion() ] ) ,
			] ;

			foreach my $i ( 2 .. 45 ) {
				$z->[ $i ] = $z->[ $i - 1 ] * $z->[1] ;
			}

			$_cstab_deg = $z ;
		}

		#
		# 戻り値を求める。
		#
		#   0 <= n <= 180 の範囲は、
		#
		#       0 <= n <=  45    z[ n ]
		#      45  < n <=  90    imag( z[ k ] ) + i * real( z[ k ] )    ( k ==  90 -  n ; n ==  90 - k )
		#      90  < n <= 135    z[ k ] * i                             ( k ==   n - 90 ; n ==  90 + k )
		#     135  < n <= 180    conj( z[ k ] * ( -1 ) )                ( k == 180 -  n ; n == 180 - k )
		#
		#   180 < n < 360 の範囲は、
		#
		#     z[ n ] == conj( z[ k ] )                                  ( k == 360 - n )
		#
		#   となる。
		#
		my $z = \@{ $_cstab_deg } ;
		my $w = undef ;
		my $k = ( $n > 180 ) ? ( 360 - $n ) : $n ;  # n を 0 <= k <= 180 となる k に写像

		if	( defined $z->[ $k ] )	{ $w = $z->[ $k ] ; }							#   0 <= k <=  45
		elsif	( $k <=  90 )		{ $w = complex( [ reverse( $z->[ 90 - $k ]->as_array() ) ] ) ; }	#  45  < k <=  90
		elsif	( $k <= 135 )		{ $w = $z->[ $k - 90 ] * $imag_unit ; }					#  90  < k <= 135
		elsif	( $k <= 180 )		{ $w = $z->[ 180 - $k ]->multiply( '-1' )->conj() ; }			# 135  < k <= 180

		if ( $n > 180 ) {
			$w = $w->conj() ;
		}

		#my $r = [ $w->as_array() ] ;
		my $r = {} ;
		@{ $r }{ 'cos' , 'sin' } = $w->as_array() ;

		return $r ;
	}

	sub _new	{ return __PACKAGE__->new( $_[0] ) ; }
	sub _sqrt	{ return __PACKAGE__->new( $_[0] )->sqrt() ; }

	sub _cosine_sine {
		#-----------------------------------------------------------------------
		#
		# 正弦と余弦
		#
		#   戻り値は ( cos( $x ) , sin( $x ) ) となる配列。
		#
		#-----------------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		my $pi = pi( $dlen ) ;
		my $pi2 = $pi * 2 ;

		#
		# $x を 0 <= $x < 2PI の範囲に変換。
		#
		$x = ( $x >= 0 ) ? ( $x % $pi2 ) : ( $pi2 - ( $x->abs() % $pi2 ) ) ;

		#
		# $x == 0
		#   -> cosine( $x ) == 1 , sine( $x ) == 0
		#
		if ( $x->is_zero() ) {
			return ( __PACKAGE__->new( 1 ) , __PACKAGE__->new( 0 ) ) ;
		}

		#
		# x == ( n * PI / 12 + m )
		# -> sin( x ) == sin( ( n * PI / 12 ) + m )
		#    cos( x ) == cos( ( n * PI / 12 ) + m )
		#
		# dpi == PI * n/12 とおくと、正弦の加法定理より、
		#
		#   sin( x ) == sin( dpi + m )
		#            == sin( dpi ) * cos( m ) + cos( dpi ) * sin( m )
		#   cos( x ) == cos( dpi + m )
		#            == cos( dpi ) * cos( m ) - sin( dpi ) * sin( m )
		#
		# 剰余値の小数点以下 37 桁目以降は誤差の範囲とする。
		#
		my $dpi = $pi->divide( 12 ) ;		# $dpi = PI / 12
		my( $n , $m ) = $x->divmod( $dpi , 0 ) ;

		if ( $m->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
			$m = __PACKAGE__->new( 0 ) ;
		}
		elsif ( $m->abs()->subtract( $dpi )->round_down( CORE::int( 40 * 0.9 ) )->is_zero() ) {
			$n += 1 ;
			$m = __PACKAGE__->new( 0 ) ;
		}

		my( $c , $s ) = () ;

		if ( $n > 0 )	{ ( $c , $s ) = _cs_dpi_add( $n , $m , $dlen ) ; }
		else		{ ( $c , $s ) = ( $x->cosine( $dlen ) , $x->sine( $dlen ) ) ; }

		return ( $c , $s ) ;
	}

	sub _cs_dpi_add {
		#-----------------------------------------------------------------------
		#
		# 正弦及び余弦の加法
		#
		#   sin( n / 12 * PI + diff ) == sin( n / 12 * PI ) * cos( diff ) + cos( n / 12 * PI ) * sin( diff )
		#   cos( n / 12 * PI + diff ) == cos( n / 12 * PI ) * cos( diff ) - sin( n / 12 * PI ) * sin( diff )
		#
		#-----------------------------------------------------------------------
		my( $dpi , $x , $dlen ) = @_ ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		my ( $c , $s ) = () ;

		my $p = _dpi2cs( $dpi ) ;
		if ( defined $p ) {
			my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
			$s = ( $p->{'sin'} * $xt->{'cos'} ) + ( $p->{'cos'} * $xt->{'sin'} ) ;
			$c = ( $p->{'cos'} * $xt->{'cos'} ) - ( $p->{'sin'} * $xt->{'sin'} ) ;
		}

		return ( $c->round( $dlen ) , $s->round( $dlen ) ) ;
	}

	sub _cs_deg_add {
		#-----------------------------------------------------------------------
		#
		# 正弦及び余弦の加法
		#
		#   sin( n / 180 * PI + diff ) == sin( n / 180 * PI ) * cos( diff ) + cos( n / 180 * PI ) * sin( diff )
		#   cos( n / 180 * PI + diff ) == cos( n / 180 * PI ) * cos( diff ) - sin( n / 180 * PI ) * sin( diff )
		#
		#-----------------------------------------------------------------------
		my( $deg , $x , $dlen ) = @_ ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		my ( $c , $s ) = () ;

		my $p = _deg2cs( $deg ) ;
		if ( defined $p ) {
			my $xt = { 'cos' => $x->cosine( $dlen ) , 'sin' => $x->sine( $dlen ) } ;
			$s = ( $p->{'sin'} * $xt->{'cos'} ) + ( $p->{'cos'} * $xt->{'sin'} ) ;
			$c = ( $p->{'cos'} * $xt->{'cos'} ) - ( $p->{'sin'} * $xt->{'sin'} ) ;
		}

		return ( $c->round( $dlen ) , $s->round( $dlen ) ) ;
	}

	sub _sine_tayler_expansion {
		#---------------------------------------------------------------
		#
		# 正弦の級数展開
		#
		#                     ( -1 )^n *  x^( 2 * n + 1 ) 
		#   sine( x ) == Σ( ----------------------------- )       ( n == 0 -> ∞ )
		#                           ( 2 * n + 1 )!
		#
		#                     ( -1 )^n * ( x^2 )^n * x^1
		#             == Σ( ------------------------------ )      ( n == 0 -> ∞ )
		#                           ( 2 * n + 1 )!
		#
		#---------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		return $x->sine( $dlen )	if ( $x > pi()->divide( 12 ) ) ;

		#
		# x を級数展開 ( x < PI * 1/12 )
		#
		my $x2 = $x * $x ;
		my $sz = 100 ;
		my $sgn = 1 ;
		my $numer = $x->copy() ;		# numer == ( -1 )^0 * ( x^2 )^0 * x ) == x
		my $denom = __PACKAGE__->new( 1 ) ;	# denom == ( 2 * 0 + 1 )! == 1!       == 1
		my $r = $x->copy() ;			# r == numer / denom == x / 1         == x

		foreach ( my $k = 1 ; $k <= $sz ; $k++ ) {
			$sgn *= ( -1 ) ;
			my $odd = ( $k * 2 + 1 ) ;

			$numer *= $x2 ;			# numer *= x^2
			$denom *= ( $odd - 1 ) * $odd ;	# denom *= ( 2n * ( 2n + 1 ) )

			my $diff = $numer->divide( $denom , $dlen + 2 ) ;
			last	if ( $diff->is_zero() ) ;

			$r += ( $diff * $sgn ) ;
			#warn join( "\t" , $r , $sgn , $numer , $denom ) , "\n" ;
		}

		return $r->round( $dlen ) ;
	}

	sub _cosine_tayler_expansion {
		#---------------------------------------------------------------
		#
		# 余弦の級数展開
		#
		#                       ( -1 )^n * x^( 2 * n ) 
		#   cosine( x ) == Σ( ------------------------ )       ( n == 0 -> ∞ )
		#                            ( 2 * n )!
		#
		#                       ( -1 )^n * ( x^2 )^n
		#               == Σ( ------------------------ )       ( n == 0 -> ∞ )
		#                            ( 2 * n )!
		#
		#---------------------------------------------------------------
		my( $x , $dlen ) = @_ ;

		$x = __PACKAGE__->new( $x )	unless ( ref( $x ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $x ) ;

		#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
		$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

		return $x->cosine( $dlen )	if ( $x > pi()->divide( 12 ) ) ;

		#
		# x を級数展開 ( x < PI * 1/12 )
		#
		my $x2 = $x * $x ;
		my $sz = 100 ;
		my $sgn = 1 ;
		my $numer = __PACKAGE__->new( 1 ) ;	# numer == ( -1 )^0 * ( x^2 )^0 == 1
		my $denom = __PACKAGE__->new( 1 ) ;	# denom == ( 2 * 0 )!           == 1
		my $r = __PACKAGE__->new( 1 ) ;		# r == numer /denom == 1 / 1    == 1

		foreach ( my $k = 1 ; $k <= $sz ; $k++ ) {
			$sgn *= ( -1 ) ;
			my $even = ( $k * 2 ) ;
			$numer *= $x2 ;
			$denom *= ( $even - 1 ) * $even ;

			my $diff = $numer->divide( $denom , $dlen + 2 ) ;
			last	if ( $diff->is_zero() ) ;

			$r += ( $diff * $sgn ) ;
			#warn join( "\t" , $r , $sgn , $numer , $denom ) , "\n" ;
		}

		return $r->round( $dlen ) ;
	}
}

#===============================================================================
#
# 素数
#
#   エラトステネスの篩に基づいた素数リストを生成し、生成した素数リストを走査するイテレータを提供する。
#   エラトステネスの篩ではあまり巨大な値は扱えないので、内部の数値は基本的に Perl 標準の数値で実装する。
#
#===============================================================================

package Primes ;

use utf8 ;

use strict ;
use warnings ;

use Carp ;

sub is_integer		{ return 0 ; }
sub is_decimal		{ return 0 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 0 ; }
sub is_vector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 0 ; }

sub can_scalar	{ return 0 ; }
sub can_integer	{ return 0 ; }
sub can_decimal	{ return 1 ; }

sub new_decimal { return MyDecimal->new( $_[0] ) ; }

sub new {
	#-----------------------------------------------------------------------
	#
	# コンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $opts ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	return undef	unless ( defined $n ) ;

	$n = new_decimal( $n )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;
	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( defined $n ) ;
	return undef		unless ( $n->is_integer() ) ;
	return undef		if ( $n < 0 ) ;

	$n = $n->value() ;

	my $const = {
		'limit'		=> $n		,
		'pos'		=> 0		,
		'type'		=> 0		, # 0 : 6n-1 型 , 1 : 6n+1 型
		'bitmap'	=> [ '' , '' ]	, # 素数テーブル
		'total'		=> 0		, # 確定された素数の総数
		'max'		=> 0		, # 確定された素数の最大値
		'objectify'	=> 0		, # Decimal オブジェクトで返すかどうか
	} ;

	if ( defined $opts->{'objectify'} ) {
		$const->{'objectify'} = $opts->{'objectify'} ;
	}

	my $obj = bless { %{ $const } } , $class ;

	$obj = $obj->generate() ;

	return $obj ;
}

sub generate {
	#-----------------------------------------------------------------------
	#
	# 素数テーブルを生成しビットマップとして保管する。
	#
	#-----------------------------------------------------------------------
	my( $obj ) = @_ ;
	return undef	unless ( ref( $obj ) eq __PACKAGE__ ) ;

	my $n = $obj->{'limit'} || return undef ;

	#
	# ビットマップを初期化
	#
	my $bitmap = \@{ $obj->{'bitmap'} } ;
	my $blen = int( $n / 6 ) ;
	foreach my $i ( 0 .. $blen ) {
		vec( $bitmap->[ 0 ] , $i , 1 ) = 1 ;
		vec( $bitmap->[ 1 ] , $i , 1 ) = 1 ;
	}

	#
	# 合成数を篩い落とす。
	#
	my $i = 5 ;
	my $t1 = 0 ;
	while () {
		#
		# ビットマップを走査するためのポインター
		#
		my $pos = ( $t1 == 1 )
			? int( $i / 6 )
			: int( $i / 6 ) + 1
		;

		#
		# $i 以下の数値については素数か合成数かは既に確定している。
		# $i より小さな素数での判定は既に終わっているので、 $i が合成数である場合にはこれをスキップすることができる。
		#
		if ( vec( $bitmap->[ $t1 ] , $pos , 1 ) == 1 ) {
			my $j = $i ;		# $j の初期値を $i とし、 $i ** 2 以降の合成数を篩い落とす。
			my $t2 = $t1 ;		# $j が属している $bitmap を特定するフラグ。
			while () {
				my $k = $i * $j ;		# 篩い落とすべき合成数。
				last	if ( $k > $n ) ;

				my $mod = $k % 6 ;
				if	( $mod == 1 )	{ vec( $bitmap->[1] , int( $k / 6 )     , 1 ) = 0 ; }
				elsif	( $mod == 5 )	{ vec( $bitmap->[0] , int( $k / 6 ) + 1 , 1 ) = 0 ; }

				$j += ( $t2 == 0 ) ? 2 : 4 ;
				$t2 = ( $t2 == 0 ) ? 1 : 0 ;
			}
		}

		$i += ( $t1 == 0 ) ? 2 : 4 ;
		$t1 = ( $t1 == 0 ) ? 1 : 0 ;

		last	if ( ( $i * $i ) > $n ) ;
	}

	#
	# 総数と最大値を抑える。
	#
	my $pos = 0 ;
	my $val = 2 ;
	while ( $val <= $n ) {
		#
		# 6n-1 型の素数候補を検査
		#
		#   2 は例外だが、 vec( $bitmap->[0] , 0 , 1 ) が 2 を表すようになっている。
		#
		if ( vec( $bitmap->[ 0 ] , $pos , 1 ) == 1 ) {
			$obj->{'total'}++ ;
			$obj->{'max'} = $val ;
		}

		#
		# 6n+1 型の素数候補を検査
		#
		#   3 は例外だが、 vec( $bitmap->[1] , 0 , 1 ) が 3 を表すようになっている。
		#
		if ( $pos == 0 )	{ $val  = 3 ; }
		else			{ $val += 2 ; }
		last	if ( $val > $n ) ;

		if ( vec( $bitmap->[ 1 ] , $pos , 1 ) == 1 ) {
			$obj->{'total'}++ ;
			$obj->{'max'} = $val ;
		}

		#
		# 次の 6n-1 型へ
		#
		$pos++ ;
		$val += ( $val == 3 ) ? 2 : 4 ;
	}

	return $obj ;
}

sub count	{ return $_[0]->{'total'} ;	}
sub max		{ return $_[0]->{'max'} ;	}
sub last	{ return $_[0]->{'max'} ;	}
sub limit	{ return $_[0]->{'limit'} ;	}

sub next {
	#-----------------------------------------------------------------------
	#
	# イテレーション
	#
	#-----------------------------------------------------------------------
	my( $obj , $objectify ) = @_ ;
	return undef	unless ( ref( $obj ) eq __PACKAGE__ ) ;

	$objectify = $obj->{'objectify'}	unless ( defined $objectify ) ;

	my $bitmap = \@{ $obj->{'bitmap'} } ;
	my $pos = $obj->{'pos'} ;
	my $t   = $obj->{'type'} ;
	my $n   = $obj->{'limit'} ;
	my $r   = undef ;

	while () {
		my $val = $pos * 6 ;
		$val += ( $t == 0 ) ? (-1) : 1 ;

		last	if ( $val > $n ) ;

		if ( vec( $bitmap->[ $t ] , $pos , 1 ) == 1 ) {
			$r = $val ;
		}

		if ( $t == 0 )	{ $t = 1 ; }
		else		{ $t = 0 ; $pos++ ; }

		last	if ( defined $r ) ;
	}

	$obj->{'pos'}  = $pos ;
	$obj->{'type'} = $t ;

	if ( defined $r and $objectify ) {
		$r = new_decimal( $r ) ;
	}

	return $r ;
}

sub all {
	#-----------------------------------------------------------------------
	#
	# 検出された素数の全リストを返す。
	#
	#-----------------------------------------------------------------------
	my( $obj , $objectify ) = @_ ;
	return undef	unless ( ref( $obj ) eq __PACKAGE__ ) ;

	$objectify = $obj->{'objectify'}	unless ( defined $objectify ) ;

	my $bitmap = \@{ $obj->{'bitmap'} } ;
	my $n   = $obj->{'limit'} ;
	my $pos = 0 ;
	my $val = 2 ;
	my @r ;

	while ( $val <= $n ) {
		#
		# 6n-1 型
		#
		#   2 は例外だが vec( $bitmap->[0] , 0 , 1 ) が 2 を表す。
		#
		if ( vec( $bitmap->[ 0 ] , $pos , 1 ) == 1 ) {
			push( @r , $val ) ;
		}

		$val += ( $val == 2 ) ? 1 : 2 ;
		last	if ( $val > $n ) ;

		#
		# 6n+1 型
		#
		#   3 は例外だが vec( $bitmap->[1] , 1 , 1 ) が 3 を表す。
		#
		if ( vec( $bitmap->[ 1 ] , $pos , 1 ) == 1 ) {
			push( @r , $val ) ;
		}

		$pos++ ;
		$val += ( $val == 3 ) ? 2 : 4 ;
	}

	if ( @r and $objectify ) {
		foreach ( @r ) { $_ = new_decimal( $_ ) ; }
	}

	return @r ;
}

sub nth_prime {
	#-----------------------------------------------------------------------
	#
	# k 番目の素数を返す。
	#
	#   0 番目は存在しないものとし、 -1 は検出された最後の素数を返すものとする。
	#
	#   このメソッドは毎回ビットマップ全体を走査するため、連続して複数の値を取り出すのには向いていない。
	#   複数の値を連続して取り出したい場合には seek と next を組み合わせて使用するのが望ましい。
	#
	#-----------------------------------------------------------------------
	my( $obj , $k , $objectify ) = @_ ;
	return undef	unless ( ref( $obj ) eq __PACKAGE__ ) ;
	return undef	unless ( $k =~ /^\-{0,1}\d+$/ ) ;
	return undef	if ( $k == 0 ) ;

	$objectify = $obj->{'objectify'}	unless ( defined $objectify ) ;

	$k = $obj->{'total'} + 1 + $k	if ( $k <  0 ) ;
	return undef			if ( $k <= 0 ) ;

	my $bitmap = \@{ $obj->{'bitmap'} } ;
	my $n   = $obj->{'limit'} ;
	my $pos = 0 ;
	my $val = 2 ;
	my $ix  = 0 ;
	my $r = undef ;

	while ( $val <= $n ) {
		#
		# 6n-1 型
		#
		#   2 は例外だが vec( $bitmap->[0] , 0 , 1 ) が 2 を表す。
		#
		if ( vec( $bitmap->[ 0 ] , $pos , 1 ) == 1 ) {
			$r = $val	if ( ++$ix == $k ) ;
		}

		last	if ( defined $r ) ;

		$val += ( $val == 2 ) ? 1 : 2 ;
		last	if ( $val > $n ) ;

		#
		# 6n+1 型
		#
		#   3 は例外だが vec( $bitmap->[1] , 0 , 1 ) が 3 を表す。
		#
		if ( vec( $bitmap->[ 1 ] , $pos , 1 ) == 1 ) {
			$r = $val	if ( ++$ix == $k ) ;
		}

		last	if ( defined $r ) ;

		$pos++ ;
		$val += ( $val == 3 ) ? 2 : 4 ;
	}

	if ( defined $r and $objectify ) {
		$r = new_decimal( $r ) ;
	}

	return $r ;
}

sub seek {
	#-----------------------------------------------------------------------
	#
	# k 番目の素数に位置合わせする。
	#
	#   0 番目は存在しないものとし、 -1 番目は検出された最後の素数を指すものとする。
	#   位置決めが成功したら 1 を、失敗したら undef を返す。
	#
	#-----------------------------------------------------------------------
	my( $obj , $k ) = @_ ;
	return undef	unless ( ref( $obj ) eq __PACKAGE__ ) ;
	return undef	unless ( $k =~ /^\-{0,1}\d+$/ ) ;
	return undef	if ( $k == 0 ) ;

	$k = $obj->{'total'} + 1 + $k	if ( $k <  0 ) ;
	return undef			if ( $k <= 0 ) ;

	my $bitmap = \@{ $obj->{'bitmap'} } ;
	my $n   = $obj->{'limit'} ;
	my $pos = 0 ;
	my $val = 2 ;
	my $ix  = 0 ;
	my $r = undef ;

	while ( $val <= $n ) {
		#
		# 6n-1 型
		#
		#   2 は例外だが vec( $bitmap->[0] , 0 , 1 ) が 2 を表す。
		#
		if ( vec( $bitmap->[ 0 ] , $pos , 1 ) == 1 ) {
			if ( ++$ix == $k ) {
				$r = 1 ;
				$obj->{'pos'} = $pos ;
				$obj->{'type'} = 0 ;
			}
		}

		last	if ( defined $r ) ;

		$val += ( $val == 2 ) ? 1 : 2 ;
		last	if ( $val > $n ) ;

		#
		# 6n+1 型
		#
		#   3 は例外だが vec( $bitmap->[1] , 0 , 1 ) が 3 を表す。
		#
		if ( vec( $bitmap->[ 1 ] , $pos , 1 ) == 1 ) {
			if ( ++$ix == $k ) {
				$r = 1 ;
				$obj->{'pos'} = $pos ;
				$obj->{'type'} = 1 ;
			}
		}

		last	if ( defined $r ) ;

		$pos++ ;
		$val += ( $val == 3 ) ? 2 : 4 ;
	}

	return $r ;
}

#===============================================================================
#
# 分数
#
#===============================================================================

package Fraction ;

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

use overload
	'""'    => 'as_string'		,
	'0+'    => 'as_numeric'		,
	'+'	=> 'add'		,
	'-'	=> 'subtract'		,
	'*'	=> 'multiply'		,
	'/'	=> 'divide'		,
	'**'    => 'power'		,
	'=='	=> 'equal'		,
	'!='	=> 'not_equal'		,
	'>'	=> 'greater_than'	,
	'>='	=> 'greater_equal'	,
	'<'	=> 'less_than'		,
	'<='	=> 'less_equal'		,
;

#-------------------------------------------------------------------------------
#
# 機能の移管 ( 部分的な継承 )
#
#-------------------------------------------------------------------------------
sub horner_sub	{ return MyDecimal::horner_sub( @_ ) ; 	}
sub solve2	{ return MyDecimal::solve2( @_ ) ;	}
sub solve3	{ return MyDecimal::solve3( @_ ) ;	}
sub solve4	{ return MyDecimal::solve4( @_ ) ;	}
sub solven	{ return MyDecimal::solven( @_ ) ;	}

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------

sub new_decimal { return MyDecimal->new( $_[0] ) ; }

sub new {
	#-----------------------------------------------------------------------
	#
	# デフォルトのコンストラクター
	#
	# 2024/01/15
	#   dec2frac の改修に伴い、 is_rational プロパティを追加。
	#
	#-----------------------------------------------------------------------
	my( $self , $n , $d ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	#
	# 分子と分母を計算
	#
	my @f = ( new_decimal( 0 ) , new_decimal( 1 ) ) ;
	if ( defined $n ) {
		$n =~ s/[\'\"]// ;
		my @fn = split( '/' , $n ) ;
		if	( @fn == 1 )	{ $f[0] = new_decimal( $fn[0] ) ; }
		elsif	( @fn  > 1 )	{ $f[0] = new_decimal( $fn[0] ) ; $f[1] = new_decimal( $fn[1] ) ; }
	}
	if ( defined $d ) {
		$d =~ s/[\'\"]// ;
		my @fd = split( '/' , $d ) ;
		if	( @fd == 1 )	{ $f[1] *= new_decimal( $fd[0] ) ; }
		elsif	( @fd  > 1 )	{ $f[0] *= new_decimal( $fd[1] ) ; $f[1] *= new_decimal( $fd[0] ) ; }
	}

	return undef	if ( $f[1]->is_zero() ) ;

	#
	# コンストラクション
	#
	my $obj = bless {
		'n'	=> $f[0] ,	# numerator
		'd'	=> $f[1] ,	# denominator
		'is_rational' => 0 ,	# 有理数かどうか
	} , $class ;

	#
	# 約分
	#
	$obj->reduce() ;

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# コピーコンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = zero() ;
	$obj->{'n'} = $self->{'n'}->copy() ;
	$obj->{'d'} = $self->{'d'}->copy() ;

	return $obj ;
}

sub zero {
	#-----------------------------------------------------------------------
	#
	# 0 を示すオブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	my $obj = bless {
		'n'	=> new_decimal( 0 ) ,	# numerator
		'd'	=> new_decimal( 1 ) ,	# denominator
	} , __PACKAGE__ ;

	return $obj ;
}

sub one {
	#-----------------------------------------------------------------------
	#
	# 1 を示すオブジェクトを返す。
	#
	#-----------------------------------------------------------------------
	my $obj = zero() ;
	$obj->{'n'} = new_decimal( 1 ) ;
	return $obj ;
}

=head1 'Fraction' object - the properties and translations

=cut

#-------------------------------------------------------------------------------
#
# 属性
#
#-------------------------------------------------------------------------------

sub as_string {
	#-----------------------------------------------------------------------
	#
	# 文字列への変換
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	if ( ! defined $self->{'n'} or ! defined $self->{'d'} ) ;

	$self->reduce() ;

	my $r = ( $self->{'d'} == 1 )
		? $self->{'n'}
		: join( '/' , @{ $self }{ 'n' , 'd' } )
	;

	return $r ;
}

sub as_numeric {
	#-----------------------------------------------------------------------
	#
	# 小数値への変換
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	if ( ! defined $self->{'n'} or ! defined $self->{'d'} ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$self->reduce() ;

	my $r = $self->{'n'}->divide( $self->{'d'} , $dlen ) ;

	return $r ;
}

=head2 numerator , denominator

  print fraction( 1 , 2 ) ;                      # 1/2
  print fraction( 1 , 2 )->numerator() ;         # 1
  print fraction( 1 , 2 )->denominaator() ;      # 2

  print fraction( 1 , 2 )->numer() ;             # 1
  print fraction( 1 , 2 )->denom() ;             # 2

=cut

sub numerator	{ $_[0]->reduce() ; return $_[0]->{'n'} ; }
sub denominator	{ $_[0]->reduce() ; return $_[0]->{'d'} ; }
sub numer	{ $_[0]->reduce() ; return $_[0]->{'n'} ; }
sub denom	{ $_[0]->reduce() ; return $_[0]->{'d'} ; }
sub n		{ return $_[0]->numerator() ; }
sub d		{ return $_[0]->denominator() ; }

=head2 integer , decimal

  print fraction( 4 , 3 ) ;                      # 4/3
  print fraction( 4 . 3 )->integer() ;           # 1
  print fraction( 4 . 3 )->decimal() ;           # 1.3333333333333333333333333333333333333333

  print fraction( 4 , 3 )->integer_part() ;      # 1
  print fraction( 4 , 3 )->decimal_part() ;      # 0.3333333333333333333333333333333333333333

  print fraction( -4 , 3 )->integer_part() ;     # -2
  print fraction( -4 , 3 )->decimal_part() ;     # 0.6666666666666666666666666666666666666666

=cut

sub integer		{ return $_[0]->as_numeric()->integer() ; }		# 絶対値の整数部 x 符号
sub decimal		{ return $_[0]->as_numeric( $_[1] ) ; }			# 分数 -> 小数
sub integer_part	{ return $_[0]->as_numeric()->integer_part() ; }	# 整数部 ( 床関数による小数部切捨て )
sub decimal_part	{ return $_[0]->as_numeric( $_[1] )->decimal_part() ; }	# 小数部 ( 床関数による整数部切捨て )

=head2 abs

  print fraction(  4 , 3 )->abs() ;              # 4/3
  print fraction( -4 , 3 )->abs() ;              # 4/3

=cut

sub abs {
	#-----------------------------------------------------------------------
	#
	# 絶対値
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	if ( ! defined $self->{'n'} or ! defined $self->{'d'} ) ;

	my $obj = $self->copy() ;
	$obj->{'n'} *= ( -1 )	if ( $obj->{'n'} < 0 ) ;

	return $obj ;
}

=head2 is_XXX

  print fraction( 1 , 2 )->is_scalar() ;          # 1
  print fraction( 1 , 2 )->is_integer() ;         # 0
  print fraction( 1 , 2 )->is_decimal() ;         # 0
  print fraction( 1 , 2 )->is_fraction() ;        # 1
  print fraction( 1 , 2 )->is_complex() ;         # 0
  print fraction( 1 , 2 )->is_vector() ;          # 0
  print fraction( 1 , 2 )->is_matrix() ;          # 0

=cut

sub is_scalar		{ return 1 ; }
sub is_integer		{ return 0 ; }
sub is_decimal		{ return 0 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 1 ; }
sub is_complex		{ return 0 ; }
sub is_vector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 0 ; }

=head2 can_XXX

  print fraction( 1 , 2 )->can_scalar() ;         # 1
  print fraction( 1 , 2 )->can_integer() ;        # 0
  print fraction( 2 , 1 )->can_integer() ;        # 1
  print fraction( 1 , 2 )->can_decimal() ;        # 1
  print fraction( 2 , 1 )->can_decimal() ;        # 1

=cut

sub can_scalar	{ return 1 ; }
sub can_integer	{ return $_[0]->decimal()->is_integer() ; }		# 整数で表現できるかどうか。
sub can_decimal	{ return 1 ; }						# 整数又は小数で表現できるかどうか。

sub scalar	{ return $_[0] ; }

#-------------------------------------------------------------------------------
#
# 比較
#
#-------------------------------------------------------------------------------

sub compare {
	#-----------------------------------------------------------------------
	#
	# 比較
	#
	#   通分して分子を比較する。
	#
	# return  1	if ( $x >  $y )
	# return  0	if ( $x == $y )
	# return -1	if ( $x <  $y )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;

	my @n = $x->reduced_numerators( $y ) ;

	return undef	unless ( @n ) ;
	return  1	if ( $n[0] >  $n[1] ) ;
	return -1	if ( $n[0] <  $n[1] ) ;
	return  0 ;
}

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r == 0 ) ? 1 : 0 ;
}

sub not_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( != )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r == 0 ) ? 0 : 1 ;
}

sub greater_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( > )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( $swapped ) {
		( $x , $y ) = ( __PACKAGE__->new( $y ) , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r > 0 ) ? 1 : 0 ;
}

sub greater_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( >= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( $swapped ) {
		( $x , $y ) = ( __PACKAGE__->new( $y ) , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r >= 0 ) ? 1 : 0 ;
}

sub less_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( < )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( $swapped ) {
		( $x , $y ) = ( __PACKAGE__->new( $y ) , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r < 0 ) ? 1 : 0 ;
}

sub less_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( <= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( $swapped ) {
		( $x , $y ) = ( __PACKAGE__->new( $y ) , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r <= 0 ) ? 1 : 0 ;
}

=head1 'Fraction' object - calculations

=cut

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------

sub reduce {
	#-----------------------------------------------------------------------
	#
	# 約分
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	if ( ! defined $self->{'n'} or ! defined $self->{'d'} ) ;

	#
	# 繁分数に対する処置
	#
	#   繁分数 ( compound fraction ) は、分子と分母の一方又は双方が分数になっているもの。
	#
	if ( ref( $self->{'n'} ) eq __PACKAGE__ or ref( $self->{'d'} ) eq __PACKAGE__ ) {
		#
		# $n = $self->{'n'} -> [ $self->{'n'}->{'n'} , $self->{'n'}->{'d'} ] 
		# $d = $self->{'d'} -> [ $self->{'d'}->{'n'} , $self->{'d'}->{'d'} ] 
		#
		my $n = $self->{'n'}->copy() ;
		my $d = $self->{'d'}->copy() ;
		foreach ( $n , $d ) {
			if	( ref( $_ ) eq __PACKAGE__ )	{ $_ = [ $_->{'n'} , $_->{'d'} ] ; }
			else					{ $_ = [ $_ , 1 ] ; }
		}
	
		#
		#           $n       $n->[0] * $d->[1] 
		# $self = ------ == -------------------
		#           $d       $n->[1] * $d->[0]
		#
		$self->{'n'} = ( $n->[0] * $d->[1] ) ;
		$self->{'d'} = ( $n->[1] * $d->[0] ) ;
	}

	#
	# 小数 -> 分数
	#
	$self->dec2frac() ;

	#
	# 約分
	#
	while ( my $g = $self->_gcd() ) {
		last	if ( $g == 1 ) ;
		$self->{'n'} /= $g ;
		$self->{'d'} /= $g ;
	}

	if ( $self->{'d'} < 0 ) {
		$self->{'n'} *= ( -1 ) ;
		$self->{'d'} *= ( -1 ) ;
	}

	return $self ;
}

sub dec2frac {
	#-----------------------------------------------------------------------
	#
	# 小数値を分数に変換 ( 有理数近似 )
	#
	#   連分数展開の過程で仮分数を求める。
	#
	# 任意の実数 d を連分数展開した数列の要素 c[k] と d に近似された仮分数 f[k] の関係は以下のようになる。  
	# 
	#            p[k]      c[k] * p[k-1] + p[k-2]
	#   f[k] == ------ == ------------------------         ( k == 2 -> ∞ )
	#            q[k]      c[k] * q[k-1] + q[k-2]
	# 
	# k == 0 および k == 1 の時の仮分数 f[0], f[1] は、以下の通り。
	# 
	#            p[0]      c[0]
	#   f[0] == ------ == ------
	#            q[0]       1
	# 
	#            p[1]               1        c[1] * c[0] + 1
	#   f[1] == ------ == c[0] + ------- == -----------------
	#            q[1]             c[1]            c[1]
	# 
	# k == 2 を展開すると以下のようになる。
	# 
	#            p[2]                  1                         c[2]            c[2] * ( c[0] * c[1] + 1 ) + c[0]
	#   f[2] == ------ == c[0] + --------------- == c[0] + ----------------- == -----------------------------------
	#            q[2]                      1                c[1] * c[2] + 1               c[2] * c[1] + 1
	# 		              c[1] + ------
	# 		                      c[2]
	#            c[2] * p[1] + p[0]
	#        == --------------------
	# 	     c[2] * q[1] + q[0]
	# 
	# これらを整理すると、 f[0], f[1] を以下のように再定義することで k == 1 -> ∞ に拡張することができる。
	# 
	#            p[1]      c[1] * p[0] + 1          ---> p[-1] == 1
	#   f[1] == ------ == -----------------
	#            q[1]      c[1] * q[0] + 0          ---> q[-1] == 0
	# 
	#            p[0]      c[0]      c[0] * 1 + 0   ---> p[-2] == 0
	#   f[0] == ------ == ------ == --------------
	#            q[0]       1        c[0] * 0 + 1   ---> q[-2] == 1
	# 
	#
	# 2024/01/15
	#   差し替え
	#   以前のロジックは dec2frac_01 として残してある。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $numer , $denom ) = @{ $self }{ 'n' , 'd' } ;
	return $self	if ( $numer->is_integer() and $denom->is_integer() ) ;

	my $is_rational = 0 ;

	# 変数を初期化
	my $d = $numer /= $denom ;
	my $c = [ undef, undef, $d->integer() ] ;
        my $p = [ new_decimal(0), new_decimal(1), $c->[-1] ] ;
        my $q = [ new_decimal(1), new_decimal(0), new_decimal(1) ] ;

	# $d が整数の場合
	if ( $d == $c->[-1] ) {
		@{ $self }{ 'n', 'd', 'is_rational' } = ($d, new_decimal(1), 1) ;
		return $self ;
	}

	# 連分数展開を行いながらその時点の仮分数を求める。
	while () {
        	# 有理数の終了条件
		$d -= $c->[-1] ;
		if ( $d->is_zero() ) {
			$is_rational = 1 ;
			last ;
		}

		$d = $d->inverse() ;
        	if ( $d->abs() >= 1_000_000 ) {
        		$is_rational = 1 ;
            		last ;
		}

		#
		# c[k] == int(d)
		#
		#          c[k] * p[-1] + p[-2]
		# f[k] == ----------------------
		#          c[k] * q[-1] + q[-2]
		#
        	my $ck = $d->integer() ;
        	my $pk = $ck * $p->[-1] + $p->[-2] ;
        	my $qk = $ck * $q->[-1] + $q->[-2] ;

		# 無理数の終了条件
		last	if ( $qk >= $DENOMINATOR_LIMIT ) ;

        	# 二世代分の値を保持 ( 次のループにおける k-1, k-2 の値 )
		$c = [ $c->[-1], $ck ] ;
		$p = [ $p->[-1], $pk ] ;
		$q = [ $q->[-1], $qk ] ;
	}

	@{ $self }{ 'n', 'd', 'is_rational' } = ( $p->[-1], $q->[-1], $is_rational ) ;
	return $self ;
}

sub dec2frac_01 {
	#-----------------------------------------------------------------------
	#
	# 小数値を分数に変換
	#
	#   連分数展開とその逆演算を用いて算出する。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $numer , $denom ) = @{ $self }{ 'n' , 'd' } ;
	return $self	if ( $numer->is_integer() and $denom->is_integer() ) ;

	#
	# 連分数展開
	#
	#   $cf = $n->cfraction() ;	# MyDecimal のメソッド
	#   -> $cf[0]			# 分子
	#      $cf[ 1 .. $#{ $cf } ]	# 連分数展開された分母
	#
	$numer /= $denom ;
	my @cf = @{ $numer->cfraction( 100 , 1 ) } ;
	foreach my $i ( 1 .. ( $#cf - 1 ) ) {
		if ( @{ $cf[ $i ]->{'val'} } > 2 ) {
			@cf = @cf[ 0 .. ( $i - 1 ) ] ;
			last ;
		}
	}
	if ( @cf > 2 and @{ $cf[ -1 ]->{'val'} } > 2 ) {
		pop( @cf ) ;
	}

	#
	# 連分数 -> 分数
	#
	if ( @cf > 0 ) {
		my $f = [ cf2frac( @cf ) ] ;
		$self->{'n'} = $f->[0] ;
		$self->{'d'} = $f->[1] ;
	}
	else {
		$self->{'n'} = $numer ;
		$self->{'d'} = 1 ;
	}

	return $self ;
}

sub cf2frac {
	#-----------------------------------------------------------------------
	#
	# 正則連分数 -> 分数
	#
	#   正則連分数 ( regular continued fraction ) を表す配列を受け取り、分数に変換して返す。
	#   ( 正則連分数展開の逆演算 ) 
	#
	#   正則連分数は、連分数の分子がすべて 1 であるもの。
	#   ここでは、引数で与えられた一次元配列の先頭を整数として、残りを連分数の整数部として演算を行う。
	#
	#     @cf = ( 1 , 2 , 3 , 4 , 5 , 6 ) ;		# 数学での表現は [ 1 ; 2 , 3 , 4 , 5 , 6 ]
	#
	#                                        1
	#     -> cf2frac( @cf ) == 1 + -----------------------
	#                                          1
	#                               2 + ------------------
	#                                             1
	#                                    3 + -------------
	#                                                1
	#                                         4 + --------
	#                                                   1
	#                                              5 + ---
	#                                                   6
	#                           1393
	#                       == ------
	#                            972
	#
	#   上記の例の場合、処理の流れは以下の通り。
	#
	#          1      31
	#     5 + --- == ----
	#          6       6
	#
	#           6      130
	#     4 + ---- == -----
	#          31       31
	#
	#           31      421
	#     3 + ----- == -----
	#          130      130
	#
	#          130      972
	#     2 + ----- == -----
	#          421      421
	#
	#          421      1393
	#     1 + ----- == ------
	#          972       972
	#
	#-----------------------------------------------------------------------
	my( @args ) = @_ ;
	shift( @args )	if ( ref( $args[0] ) eq __PACKAGE__ ) ;

	#
	# 引数を展開 ( 数学的表記もサポートする。 )
	#
	my @cf ;
	if	( ref( $args[0] ) eq 'ARRAY' )	{ @cf = @{ $args[0] } ; }
	elsif	( $args[0] =~ /\[/ )		{ $args[0] =~ s/[\'\"\[\]\s]//g ; @cf = split( /[\;\,]/ , $args[0] ) ; }
	else					{ @cf = @args ; }

	return undef	unless ( @cf ) ;

	#
	# 変換
	#
	my $f = [] ;
	if ( @cf == 1 ) {
		#
		# 結果は整数
		#
		$f = [ new_decimal( $cf[0] ) , new_decimal( 1 ) ] ;
	}
	else {
		#
		# 連分数の下位から順に復元する。
		#
		# @cf = reverse( @cf ) ;
		#                     1           ( $cf[1] * $cf[0] ) + 1
		# f[1] = $cf[1] + ---------- == ---------------------------
		#                   $cf[0]                $cf[0]
		#
		@cf = reverse( @cf ) ;
		$f = [
			( new_decimal( $cf[1] ) * $cf[0] ) + 1 ,
			new_decimal( $cf[0] )
		] ;

		#
		# 前回の処理で得られた分数の逆数を採り、 $cf[ $i ] の値を加算する。 ( $cf[ $i ] は整数 )
		#
		#                   n
		#   f[ $i - 1 ] = -----
		#                   d
		#
		#                          d      ( $cf[ $i ] * n ) + d
		#   f[ $i ] = $cf[ $i ] + ---  == -----------------------           ( $i == 2 -> $#cf )
		#                          n                n
		#
		foreach ( my $i = 2 ; $i < @cf ; $i++ ) {
			( $f->[0] , $f->[1] ) = ( $f->[1] , $f->[0] ) ;
			$f->[0] += ( $cf[ $i ] * $f->[1] ) ;
		}
	}

	return ( wantarray ) ? @{ $f } : __PACKAGE__->new( @{ $f } ) ;
}

sub cf2frac2 {
	#-----------------------------------------------------------------------
	#
	# 非正則連分数 -> 分数
	#
	#   非正則連分数を表す配列参照を受け取り、分数に変換して返す。
	#
	#   非正則連分数は、連分数の分子の何れかが 1 でないものを指す。
	#   ここでは、引数で与えられた二次元配列の各要素を整数部と分子の組として扱う。
	#
	#     $cf = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] , [ 7 , 8 ] , [ 9 , 10 ] ] ;
	#
	#                                              2
	#     -> cf2frac2( @{ $cf } ) == 1 + ----------------------------
	#                                                4
	#                                     3 + -----------------------
	#                                                   6
	#                                          5 + ------------------
	#                                                      8
	#                                               7 + -------------
	#                                                          10       # この分子は無視される。
	#                                                    9 + --------
	#                                                         ......
	#
	#                             == 2329/1511
	#
	#   上記の例の場合、処理の流れは以下の通り。
	#
	#     9 に加算されている分数 ( 10 を分子とする分数 ) は、限りなく 0 に近いものとみなして省略する。
	#
	#              1      71
	#     7 + 8 * --- == ----
	#              9       9
	#
	#               9      409
	#     5 + 6 * ---- == -----
	#              71       71
	#
	#               71      1511
	#     3 + 4 * ----- == ------
	#              409       409
	#
	#               409      2329
	#     1 + 2 * ------ == ------
	#              1511      1511
	#
	#-----------------------------------------------------------------------
	my $cf = ( ref( $_[0] ) eq __PACKAGE__ ) ? $_[1] : $_[0] ;

	return undef	unless ( ref( $cf ) eq 'ARRAY' ) ;

	#
	# 配列要素は全て 2 つの要素を持つ配列でなければならない。 
	#
	foreach ( @{ $cf } ) {
		return undef	unless ( ref( $_ ) eq 'ARRAY' ) ;
		return undef	unless ( @{ $_ } == 2 ) ;
	}

	#
	# 変換
	#
	my $f = [] ;
	if ( @{ $cf } == 1 ) {
		#
		# 結果は整数
		#
		$f = [ new_decimal( $cf->[0]->[0] ) , new_decimal( 1 ) ] ;
	}
	else {
		#
		# 連分数の下位から順に復元する。
		#
		#   $cf = [ reverse( @{ $cf } ) ] ;
		#
		#            $cf->[0]->[0] 
		#   f[0] == ---------------
		#                  1
		#
		$cf = [ reverse( @{ $cf } ) ] ;
		$f = [
			new_decimal( $cf->[0]->[0] )	,
			new_decimal( 1 )		,
		] ;

		#
		# 前回の処理で得られた分数の逆数を採り、分子を $cf->[ $i ]->[1] で乗じた結果に $cf->[ $i ]->[0] を加算する。
		#
		#                   n
		#   f[ $i - 1 ] = -----
		#                   d
		#
		#                                                       d
		#   f[ $i ] == $cf->[ $i ]->[0] + ( $cf->[ $i ]->[1] * --- )
		#                                                       n
		#
		#               ( $cf->[ $i ]->[0] * n ) + ( $cf->[ $i ]->[1] * d )
		#           == ----------------------------------------------------          ( $i == 1 -> $#{ $cf } )
		#                                        n
		#
		my $lim = $#{ $cf } ;
		foreach my $i ( 1 .. $lim ) {
			( $f->[0] , $f->[1] ) = ( $f->[1] , $f->[0] ) ;
			$f->[0] *= $cf->[ $i ]->[1] ;
			$f->[0] += ( $cf->[ $i ]->[0] * $f->[1] ) ;
		}
	}

	return ( wantarray ) ? @{ $f } : __PACKAGE__->new( @{ $f } ) ;
}

=head2 reduced_numerators

  $f[0] = fraction( 1 , 2 ) ;
  $f[1] = fraction( 1 , 3 ) ;
  $f[2] = fraction( 1 , 4 ) ;

  print join ' ' , $f[0]->reduced_numerators( $f[1] , $f[2] ) ;  # 6 4 3  ( == 6/12 4/12 3/12 )

=cut

sub reduced_numerators {
	#-----------------------------------------------------------------------
	#
	# 複数の分数を受け取り、通分された分子を返す。
	#
	#-----------------------------------------------------------------------
	my( @f ) = @_ ;

	my @n = () ;
	my @d = () ;
	foreach ( @f ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		croak( "unexpected error!!\n" )	unless ( defined $_ ) ;
		push( @n , $_->{'n'} ) ;
		push( @d , $_->{'d'} ) ;
	}

	#
	# 分母の最小公倍数
	#
	my $lcm = $d[0]->lcm( @d[ 1 .. $#d ] ) ;

	#
	# 分子を通分
	#
	foreach ( my $i = 0 ; $i < @d ; $i++ ) {
		$n[ $i ] *= $lcm->divide( $d[ $i ] , 0 ) ;
	}

	return @n ;
}

=head2 add

  print fraction( 1 , 2 )->add( fraction( 2 , 3 ) ) ;     # 7/6
  print fraction( 1 , 2 ) + fraction( 2 , 3 ) ;           # 7/6

  my @f = () ;
  foreach ( 2 .. 10 ) {
      push( @f , fraction( 1 , $_ ) ) ;
  }

  print fraction( 1 , 1 )->add( [ @f ] ) ;                # 7381/2521     ( == 1 + 1/2 + 1/3 + .... + 1/10 )
  print fraction( 1 , 1 )->add( [ @f ] )->decimal() ;     # 2.9289682539682539682539682539682539682539

=cut

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	#
	#   二項演算は以下の通り。
	#
	#           a           c
	#     x = ----- , y = -----
	#           b           d
	#
	#                a       c        ad + bc
	#     x + y == ----- + ----- == -----------
	#                b       d         b * d
	#
	#
	#   複数値の加算は分母の最小公倍数を用いて通分する。
	#
	#            $xn            $yn[0]       $yn[1]
	#     $x = ------- , @y = ---------- , ---------- , .......
	#            $xd            $yd[0]       $yd[1]
	#
	#     $lcm = lcm( $xd , @yd )
	#
	#                  ( $lcm / $xd ) * $xn + ( $lcm / $yd[0] ) * $yn[0] + .......
	#     $x + @y == ----------------------------------------------------------------
	#                                        $lcm
	#
	#     $lcm は $x 及び @y の分母の最小公倍数なので、 ( $lcm / $xd ) や ( $lcm / $yd[$i] ) は常に整数を返すことになる。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $obj = undef ;

	if ( ref( $y ) eq 'ARRAY' ) {
		#
		# $y の分母を集め、 $x の分母との間で最大公約数を採る。
		#
		my @yd = () ;
		foreach ( @{ $y } ) {
			$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
			return undef	unless ( defined $_ ) ;
			push( @yd , $_->{'d'} ) ;
		}
		my $lcm = $x->{'d'}->lcm( @yd ) ;

		#
		# 加算
		#
		$obj = zero() ;
		$obj->{'n'} = $x->{'n'} * ( $lcm->divide( $x->{'d'} , 0 ) ) ;
		$obj->{'d'} = $lcm ;
		foreach ( @{ $y } ) {
			$obj->{'n'} += $_->{'n'} * ( $lcm->divide( $_->{'d'} , 0 ) ) ;
		}
	}
	else {
		#
		# 二項演算
		#
		$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $y ) ;

		$obj = zero() ;
		$obj->{'n'} = ( $x->{'n'} * $y->{'d'} ) + ( $y->{'n'} * $x->{'d'} ) ;
		$obj->{'d'} = ( $x->{'d'} * $y->{'d'} ) ;
	}

	return $obj ;
}

=head2 subtract

  print fraction( 1 , 2 )->subtract( fraction( 2 , 3 ) ) ;     # -1/6
  print fraction( 1 , 2 ) - fraction( 2 , 3 ) ;                # -1/6

  my @f = () ;
  foreach ( 2 .. 10 ) {
      push( @f , fraction( 1 , $_ ) ) ;
  }

  print fraction( 1 , 1 )->subtract( [ @f ] ) ;                # -2341/2520     ( == 1 - 1/2 - 1/3 - .... - 1/10 )
  print fraction( 1 , 1 )->subtract( [ @f ] )->decimal() ;     # -0.928968253968253968253968253968253968254

=cut

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( ref( $y ) eq 'ARRAY' ) {
		foreach ( @{ $y } ) {
			$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		}
	}
	elsif ( ref( $y ) ne __PACKAGE__ ) {
		$y = __PACKAGE__->new( $y ) ;
	}
	return undef	unless ( defined $y ) ;

	$x = $x->copy() ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	if ( ref( $y ) eq 'ARRAY' ) {
		foreach ( @{ $y } ) {
			$_->{'n'} *= ( -1 ) ;
		}
	}
	else {
		$y->{'n'} *= ( -1 ) ;
	}

	return $x->add( $y ) ;
}

=head2 multiply

  print fraction( 1 , 2 )->multiply( fraction( 2 , 3 ) ) ;     # 1/3
  print fraction( 1 , 2 ) * fraction( 2 , 3 ) ;                # 1/3

=cut

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $y ) ;

	my $obj = $x->copy() ;

	$obj->{'n'} *= $y->{'n'} ;
	$obj->{'d'} *= $y->{'d'} ;

	return $obj ;
}

=head2 power

  print fraction( 1 , 2 )->power( 3 ) ;                        # 1/8
  print fraction( 1 , 2 ) ** 3 ;                               # 1/8

  print fraction( 1 , 4 )->power( fraction( 1 , 2 ) ) ;        # 1/2
  print fraction( 1 , 4 ) ** fraction( 1 , 2 ) ;               # 1/2

  print fraction( 1 , 4 )->power( fraction( -1 , 2 ) ) ;       # 2
  print fraction( 1 , 4 ) ** fraction( -1 , 2 ) ;              # 2

=cut

sub power {
	#-----------------------------------------------------------------------
	#
	# 冪乗
	#
	#   冪指数を分数に変換し、冪指数の分子での冪乗と分母での冪根を採る。
	#   処理結果が繁分数になることがあるため、約分を必ず行う。
	#
	#-----------------------------------------------------------------------
	my( $x , $n , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	my $obj = $x->copy() ;

	$obj->{'n'} = $obj->{'n'}->power( $n->{'n'} ) ;
	$obj->{'d'} = $obj->{'d'}->power( $n->{'n'} ) ;

	if ( $n->{'d'} != 1 ) {
		$obj->{'n'} = $obj->{'n'}->root( $n->{'d'} ) ;
		$obj->{'d'} = $obj->{'d'}->root( $n->{'d'} ) ;
	}

	return $obj->reduce() ;
}

=head2 root

  print fraction( 1 , 4 )->root( 2 ) ;                         # 1/2
  print fraction( 1 , 4 )->root( -2 ) ;                        # 2

=cut

sub root {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	#   指数の逆数による冪乗に等しい。
	#
	#-----------------------------------------------------------------------
	my( $x , $n ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = __PACKAGE__->new( $n )	unless ( ref( $n ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $n ) ;

	return $x->power( $n->inverse() ) ;
}

=head2 sqrt

  print fraction( 1 , 4 )->sqrt() ;                            # 1/2

=cut

sub sqrt { return $_[0]->root( 2 ) ; }

=head2 divide

  print fraction( 1 , 2 )->divide( 2 ) ;                       # 1/4
  print fraction( 1 , 2 ) / 2 ;                                # 1/4

=cut

sub divide {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	#   除数の逆数による乗算に等しい。
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = __PACKAGE__->new( $y )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	return $x->multiply( $y->inverse() ) ;
}

=head2 inverse

  print fraction( 1 , 2 )->inverse() ;                         # 2
  print fraction( 3 , 2 )->inverse() ;                         # 2/3

=cut

sub inverse {
	#-----------------------------------------------------------------------
	#
	# 逆数
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;
	croak( "numerator is 0\n" )	if ( $self->{'n'} == 0 ) ;

	my $obj = $self->copy() ;
	@{ $obj }{ 'n' , 'd'} = @{ $obj }{ 'd' , 'n' } ;

	return $obj ;
}

#-------------------------------------------------------------------------------
#
# 内部メソッド
#
#-------------------------------------------------------------------------------

{
	sub _gcd {
		#-----------------------------------------------------------------------
		#
		# 分母と分子の最大公約数を返す。
		#
		#-----------------------------------------------------------------------
		my( $self ) = @_ ;
		return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

		my( $n , $d ) = @{ $self }{ 'n' , 'd' } ;

		return $n->gcd( $d ) ;
	}
}


=head1 "Complex" object

The complex field is the algebric extension field, which contains real numbers and squre root of -1.

The complex numbers have some kind of form.

  z == x + iy                             ... orthogonal form
    == r * ( cos( t ) + i * sin( t ) )    ... polar form
    == r * exp( i * t )                   ... exponential form ( Euler's form )

x , y is a real number, i is a imaginary unit ( sqrt(-1) ; In pysics, it is generally represented by 'j' ).
  
When the point of [x,y] is regarded as coordination of the complex plane, r is a distance from the point of the origin.

If r == 1 then the point of [x,y] is placed on the unit circle in the complex plane.
Then, the "r" is sometimes called "radius".

The point of [x,y] gives the angle between the line joining the point to the origin and the positive real axis.
The "t" is this angle.
This angle usually be called an "argument".

=head2 Complex numbers and quadrant.

If one complex number is defined

  z == x + iy
    == r * exp( i * t )

and the point of [x,y] is regarded as coordination of the complex plane, the point of [x,y] is placed on any quadrant of complex plane.

If the argument t is in 0 <= t <= PI/4, this complex number z can be converted to any another quadrant or the area PI/4 <= t <= PI/2, with easy way.

  $z = complex( { degree => 30 } ) ;
  print $z ;                                                                   # 0.866025403784439 + 0.5 i       z ==  x + iy
  print complex( [ $z->imag()        , $z->real()        ] ) ;                 # 0.5 + 0.866025403784439 i       z ==  y + ix
  print complex( [ $z->imag() * (-1) , $z->real()        ] ) ;                 # -0.5 + 0.866025403784439 i      z == -y + ix == ( x + iy ) * i
  print complex( [ $z->real() * (-1) , $z->imag()        ] ) ;                 # -0.866025403784439 + 0.5 i      z == -x + iy == ( y + ix ) * i
  print complex( [ $z->real() * (-1) , $z->imag() * (-1) ] ) ;                 # -0.866025403784439 - 0.5 i      z == -x - iy == conj( -x + iy ) == conj( ( y + ix ) * i )
  print complex( [ $z->imag() * (-1) , $z->real() * (-1) ] ) ;                 # -0.5 - 0.866025403784439 i      z == -y - ix == conj( -y + ix ) == conj( ( x + iy ) * i )
  print complex( [ $z->imag()        , $z->real() * (-1) ] ) ;                 # 0.5 - 0.866025403784439 i       z ==  y - ix == conj(  y + ix )
  print complex( [ $z->real()        , $z->imag() * (-1) ] ) ;                 # 0.866025403784439 - 0.5 i       z ==  x - iy == conj(  x + iy )

  print $z->exp_form() ;                                                       # 1 * exp( i * ( 1/6 * PI ) )     z ==  x + iy == r * exp( i *   t )
  print complex( [ $z->imag()        , $z->real()        ] )->exp_form() ;     # 1 * exp( i * ( 1/3 * PI ) )     z ==  y + ix == r * exp( i *  2t ) == r * exp( i * ( 1/2 PI - t ) )
  print complex( [ $z->imag() * (-1) , $z->real()        ] )->exp_form() ;     # 1 * exp( i * ( 2/3 * PI ) )     z == -y + ix == r * exp( i *  4t ) == r * exp( i * (  t + 1/2 PI ) ) 
  print complex( [ $z->real() * (-1) , $z->imag()        ] )->exp_form() ;     # 1 * exp( i * ( 5/6 * PI ) )     z == -x + iy == r * exp( i *  5t ) == r * exp( i * ( 2t + 1/2 PI ) )
  print complex( [ $z->real() * (-1) , $z->imag() * (-1) ] )->exp_form() ;     # 1 * exp( i * ( -5/6 * PI ) )    z == -x - iy == r * exp( i * -5t )
  print complex( [ $z->imag() * (-1) , $z->real() * (-1) ] )->exp_form() ;     # 1 * exp( i * ( -2/3 * PI ) )    z == -y - ix == r * exp( i * -4t )
  print complex( [ $z->imag()        , $z->real() * (-1) ] )->exp_form() ;     # 1 * exp( i * ( -1/3 * PI ) )    z ==  y - ix == r * exp( i * -2t )
  print complex( [ $z->real()        , $z->imag() * (-1) ] )->exp_form() ;     # 1 * exp( i * ( -1/6 * PI ) )    z ==  x - iy == r * exp( i *  -t )

These conversion needs not to translate to the polar form nor the exponential form.


  z == x + iy
    == r * exp( i * t )

  z * i               == -y + ix == r * exp( i * ( t + 1/4 * PI ) ) 
  z * i^2 == z * (-1) == -x - iy == r * exp( i * ( t + 1/2 * PI ) ) 
  z * i^3 == z * (-i) ==  y - ix == r * exp( i * ( t + 3/4 * PI ) ) 


=cut

#===============================================================================
#
# 複素数
#
#   実数の 2 次の代数拡大 ( 実数の概念に虚数単位 i を付け加えたもの。 )
#   実数倍と和に関して 2 次元ベクトルとしての性質も持つ。 ( 複素数同士の積はベクトルとは異なる。 )
#
#   複素数の表現にはいくつかの種類がある。
#
#     z == x + iy					直交形式     ( orthogonal form )
#       == r * ( cos( theta ) + i * sin( theta ) )	極形式       ( polar form )
#       == r * exp( i * theta )				オイラー表示 ( Euler's form ) or 指数表現 ( exponential form ; 指数関数表現 )
#
#     -> x == r * cos( theta )
#        y == r * sin( theta )
#        r == abs( z )
#        theta == arg( z )
#
#===============================================================================

package Complex ;

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

use overload
	'""'    => 'as_string'		,
	'0+'    => 'as_numeric'		,
	'+'	=> 'add'		,
	'-'	=> 'subtract'		,
	'*'	=> 'multiply'		,
	'/'	=> 'divide'		,
	'**'    => 'power'		,
	'=='	=> 'equal'		,
	'!='	=> 'not_equal'		,
	'>'	=> 'greater_than'	,
	'>='	=> 'greater_equal'	,
	'<'	=> 'less_than'		,
	'<='	=> 'less_equal'		,
;

#-------------------------------------------------------------------------------
#
# 機能の移管 ( 部分的な継承 )
#
#-------------------------------------------------------------------------------
sub horner_sub	{ return MyDecimal::horner_sub( @_ ) ; 	}
sub solve2	{ return MyDecimal::solve2( @_ ) ;	}
sub solve3	{ return MyDecimal::solve3( @_ ) ;	}
sub solve4	{ return MyDecimal::solve4( @_ ) ;	}
sub solven	{ return MyDecimal::solven( @_ ) ;	}

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------

sub new_decimal		{ return MyDecimal->new( $_[0] ) ; }
sub new_fraction	{ return Fraction->new( @_ ) ; }
sub pi			{ return MyDecimal::pi() ; }

sub new {
	#-----------------------------------------------------------------------
	#
	# デフォルトのコンストラクター
	#
	#   複素数を複素平面上の座標 [ x , y ] で表現する。
	#
	#     z == x + iy
	#       == r * ( cos( theta ) + i * sin( theta ) )
	#       == r * exp( i * theta )
	#
	#     -> x == r * cos( theta )
	#        y == r * sin( theta )
	#
	#-----------------------------------------------------------------------
	my( $self , $arg ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	my $conf = [] ;

	if ( ref( $arg ) eq 'HASH' ) {
		#
		# 複素平面上の偏角や半径を用いて初期化
		#
		my $r = undef ;
		if	( defined $arg->{'r'} )		{ $r = new_decimal( $arg->{'r'} ) ; }
		elsif	( defined $arg->{'abs'} )	{ $r = new_decimal( $arg->{'abs'} ) ; }
		elsif	( defined $arg->{'radius'} )	{ $r = new_decimal( $arg->{'radius'} ) ; }
		else					{ $r = new_decimal( 1 ) ; }

		my $t = undef ;
		if	( defined $arg->{'theta'} )	{ $t = new_decimal( $arg->{'theta'} ) ; }
		elsif	( defined $arg->{'arg'} )	{ $t = new_decimal( $arg->{'arg'} ) ; }
		elsif	( defined $arg->{'radian'} )	{ $t = new_decimal( $arg->{'radian'} ) ; }
		elsif	( defined $arg->{'degree'} )	{ $t = new_decimal( $arg->{'degree'} ) * pi() / 180 ; }
		else					{ $t = new_decimal( 0 ) ; }

		return undef	if ( ! defined $r or ! defined $t ) ;

		#$conf = [ $r * $t->cosine() , $r * $t->sine() ] ;
		$conf = [ $t->_cosine_sine() ] ;

		foreach ( @{ $conf } ) {
			$_ = $_->decimal()	unless ( $_->is_decimal() ) ;
			#$_ = new_decimal( $_->value() ) ;
			$_ = new_decimal( $_->multiply( $r )->value() ) ;
		}
	}
	elsif( ref( $arg ) eq 'ARRAY' ) {
		#
		# 複素平面上の座標を用いて初期化
		#
		my( $x , $y ) = @{ $arg } ;

		foreach ( $x , $y ) {
			$_ = new_decimal( 0 )	unless ( defined $_ ) ;
			$_ = new_decimal( $_ )	if ( substr( ref( $_ ) , 0 , 9 ) eq 'Math::Big' ) ;
			$_ = new_decimal( $_ )	unless ( ref( $_ ) ) ;
		}

		return undef	if ( ! defined $x or ! defined $y ) ;

		$conf = [ $x , $y ] ;
	}
	else {
		#
		# 実数 ( y == 0 )
		#
		my $x = undef ;
		if	( ! ref( $arg ) or substr( ref( $arg ) , 0 , 9 ) eq 'Math::Big' )	{ $x = new_decimal( $arg ) ; }
		elsif	( $arg->is_decimal() )							{ $x = $arg->copy() ; }
		elsif	( $arg->can_decimal() )							{ $x = $arg->decimal() ; }

		return undef	unless ( defined $x ) ;
		
		$conf = [ $x , new_decimal( 0 ) ] ;
	}

	#
	# オブジェクトを生成
	#
	my $obj = undef ;
	if ( ref( $conf->[0] ) eq __PACKAGE__ or ref( $conf->[1] ) eq __PACKAGE__ ) {
		#
		# 引数のいずれかが複素数の場合、複素数の加算処理となる。
		#
		#   結果が実数になることもあるので、結果を確認して複素数オブジェクトに変換する必要がある。
		#
		my( $x , $y ) = @{ $conf } ;
		$obj = $x + imag_unit() * $y ;
		$obj = bless [ $obj , new_decimal( 0 ) ] , $class	unless ( ref( $obj ) eq __PACKAGE__ ) ;
	}
	else {
		#
		# 通常のコンストラクション
		#
		$obj = bless [ @{ $conf } ] , $class ;
	}

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# コピーコンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $class ) = ref( $self ) || $self ;

	my $conf = [ @{ $self } ] ;

	my $obj = bless [ @{ $conf } ] , $class ;

	return $obj ;
}

sub imag_unit {
	#-----------------------------------------------------------------------
	#
	# 虚数単位 ( imaginary unit )
	#
	#   虚数単位の定義は以下の通り。
	#
	#     i^2 == -1
	#     i   == sqrt( -1 )
	#
	#   行列表現
	#
	#     i == [ 0 , -1 ] == ( -1 ) * [  0 , 1 ] == ( -1 ) * transpose( i )
	#          [ 1 ,  0 ]             [ -1 , 0 ]
	#
	#     i * transpose( i ) == [ 0 , -1 ] * [  0 , 1 ] == [ 1 , 0 ] = E
	#                           [ 1 ,  0 ]   [ -1 , 0 ]    [ 0 , 1 ]
	#
	#     -> inverse( i ) == transpose( i )
	#
	#     i^2 == i * i
	#
	#         == [ 0 , -1 ] * [ 0 , -1 ]
	#            [ 1 ,  0 ]   [ 1 ,  0 ]
	#
	#         == [ 0 , -1 ] * ( -1 ) * [  0 , 1 ]
	#            [ 1 ,  0 ]            [ -1 , 0 ]
	#
	#         == i * ( -1 ) * transpose( i )
	#
	#         == [ -1 ,  0 ]
	#            [  0 , -1 ]
	#
	#         == ( -1 ) * E
	#
	#     i / i == i * i^(-1)
	#           == i * inverse( i )
	#           == i * transpose( i )
	#
	#           == [ 0 , -1 ] * [  0 , 1 ]
	#              [ 1 ,  0 ]   [ -1 , 0 ]
	#
	#           == [ 1 , 0 ]
	#              [ 0 , 1 ]
	#
	#           == E
	#
	#   複素数表現
	#
	#     i == 0 + i
	#       == 1 * ( cos( PI/2 ) + i * sin( PI/2 ) )
	#       == 1 * exp( i * PI/2 )
	#
	#     i == 0 + i
	#       == ( -1 ) * ( 0 - i )
	#       == ( -1 ) * conj( i )
	#       == ( -1 ) * ( cos( -PI/2 ) + i * sin( -PI/2 ) )
	#       == ( -1 ) * exp( i * -PI/2 )
	#       == ( -1 ) * exp( i * PI/2 )^( -1 )
	#       == ( -1 ) * i^( -1 )
	#
	#     -> i^( -1 ) == i / -1 == -i
	#                 == inverse( i ) == 1 / i == -i
	#                 == 0 - i
	#                 == conj( i )
	#
	#     i^2 == -1 + 0 * i
	#         == 1 * ( cos( PI ) + i * sin( PI ) )
	#         == 1 * exp( i * PI )
	#         == -1
	#
	#     i / i == i * i^( -1 )
	#           == i * conj( i )
	#           == i * ( -i )
	#           == 1
	#
	#   円周率との関係
	#
	#     i == exp( i * PI/2 )
	#
	#                         1
	#     -> log( i ) == i * --- * PI
	#                         2
	#
	#          log( i )       1
	#     -> ------------ == --- * PI
	#             i           2
	#
	#   冪乗
	#
	#     i^( 4n )     ==  1.0
	#     i^( 4n + 1 ) ==  i
	#     i^( 4n + 2 ) == -1.0
	#     i^( 4n + 3 ) == -i
	#
	#     -> i^( n ) == i^( n mod 4 )
	#                == cos( n * PI/2 ) + i * sin( n * PI/2 )
	#
	#     i^i == exp( i * ( PI/2 + 2 * k * PI ) )^i
	#         == exp( i^2 * ( PI/2 + 2 * k * PI )
	#         == exp( ( -1 ) * ( PI/2 + 2 * k * PI )
	#
	#         ( k == 0 -> ∞ )
	#
	#       k == 0 の時、主値
	#
	#         i^i == exp( ( -1 ) * PI/2 ) == 0.207879576.....
	#
	#      を得る。
	#
	#
	#   三角関数
	#                                  e + 1/e        e^2 + 1
	#     cos( i ) == cosh( 1.0 ) == ----------- == ----------- == 1.54308064.....
	#                                     2              2
	#
	#                                      e - 1/e            e^2 - 1
	#     sin( i ) == i * sinh( 1.0 ) == ----------- * i == ----------- * i == i * 1.17520119.....
	#                                         2                2 * e
	#
	#-----------------------------------------------------------------------
	return __PACKAGE__->new( [ 0 , 1 ] ) ;
}

=head1 'Complex' object - stringify

=cut

#-------------------------------------------------------------------------------
#
# フォーマット変換
#
#-------------------------------------------------------------------------------

sub as_array {
	#-----------------------------------------------------------------------
	#
	# 直交形式の x , y を返す。
	#
	#   z == x + iy						直交形式
	#     == r * ( cos( theta ) + i * sin( theta ) )	極形式
	#     == r * exp( i * theta )				オイラー表示
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;

	foreach ( @{ $self } ) {
		if ( $_->{'dlen'} > 0 and $_->{'val'}->[0] =~ /0+$/ ) {
			$_ = new_decimal( $_->value() ) ;
		}
	}

	return @{ $self }[ 0 , 1 ] ;
}

sub as_string {
	#-----------------------------------------------------------------------
	#
	# 文字列化
	#
	#   z == x + iy					直交形式
	#     == r ( cos( theta ) + i * sin( theta )	極形式
	#     == r * exp( i * theta )			オイラー表示
	#
	#   実部と虚部を小数点以下 15 桁の小数で表現する。 ( 小数点以下 16 桁目で四捨五入 )
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#$dlen = 15	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : 15 ;

	my( $x , $y ) = $self->as_array() ;
	foreach ( $x , $y ) {
		$_ = $_->round( $dlen ) ;
	}

	my $z = undef ;
	if ( $y == 0 ) {
		$z = $x->as_string() ;
	}
	else {
		my $sgn = ( $y > 0 ) ? ' + ' : ' - ' ;
		if ( $y->abs() == 1 )	{ $z = join( $sgn , $x->as_string() , 'i' ) ; }
		else			{ $z = join( $sgn , $x->as_string() , $y->abs()->as_string() ) . ' i' ; }
	}

	return $z ;
}

=head2 value , orthogonal

Return othogonal format as string. ( default )

  print complex( [ 1 , 2 ] )->value() ;        # 1 + 2 i
  print complex( [ 1 , 2 ] )->othogonal() ;    # 1 + 2 i
  print complex( [ 1 , 2 ] ) ;                 # 1 + 2 i

  print complex( { arg => radian( 60 ) } ) ;   # 0.5 + 0.866025403784439 i

=cut

sub orthogonal	{ return $_[0]->as_string( $_[1] ) ; }
sub value	{ return $_[0]->as_string( $_[1] ) ; }

=head2 fraction

Return fractional format, if posssible.

  print complex( { arg => radian( 60 ) } ) ;               # 0.5 + 0.866025403784439 i
  print complex( { arg => radian( 60 ) } )->fraction() ;   # 1/2 + 0.866025403784439 i

=cut 

sub fraction {
	#-----------------------------------------------------------------------
	#
	# 文字列化 ( 分数で表現 )
	#
	#   z == x + iy					直交形式
	#     == r ( cos( theta ) + i * sin( theta )	極形式
	#     == r * exp( i * theta )			オイラー表示
	#
	#   実部と虚部が分数で表記できるようであれば分数で表現する。
	#   小数で表記する場合は小数点以下 15 桁で表現する。 ( 小数点以下 16 桁目で四捨五入 )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $self->as_array() ;
	foreach ( $x , $y ) {
		my $f = new_fraction( $_ ) ;
		if ( $f->{'n'}->integer_digits() < 4 and $f->{'d'}->integer_digits() < 4 ) {
			$_ = $f->copy() ;
		}
		else {
			$_ = $_->round( 15 ) ;
		}
	}

	my $z = undef ;
	if ( $y == 0 ) {
		$z = $x->as_string() ;
	}
	else {
		my $sgn = ( $y > 0 ) ? ' + ' : ' - ' ;
		if ( $y->abs() == 1 )	{ $z = join( $sgn , $x->as_string() , 'i' ) ; }
		else			{ $z = join( $sgn , $x->as_string() , $y->abs()->as_string() ) . ' i' ; }
	}

	return $z ;
}

sub as_numeric {
	#-----------------------------------------------------------------------
	#
	# 虚部がなければ実部を返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self->real()	unless ( $self->is_imag() ) ;
	return undef ;
}

sub scalar	{ return $_[0] ; }
sub integer	{ return ( $_[0]->can_integer() ) ? $_[0]->as_numeric() : undef ; }
sub decimal	{ return $_[0]->as_numeric() ; }

=head2 pollar_form

  print complex( [ 1 , 1 ] )->pollar_form() ;                    # 1.41421 * ( cos( 1/4 * PI ) + i * sin( 1/4 * PI ) )
  print complex( { arg => radian( 60 ) } )->pollar_form() ;      # 1 * ( cos( 1/3 * PI ) + i * sin( 1/3 * PI ) )

=cut

sub pollar_form {
	#-----------------------------------------------------------------------
	#
	# 極形式の表現を返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $r , $npi ) = $self->pollar_values_for_string() ;

	my $z = "$r * ( cos( $npi * PI ) + i * sin( $npi * PI ) )" ;

	return $z ;
}

=head2 exp_form

  print complex( [ 1 , 1 ] )->exp_form() ;                       # 1.41421 * exp( i * ( 1/4 * PI ) )
  print complex( { arg => radian( 60 ) } )->exp_form() ;         # 1 * exp( i * ( 1/3 * PI ) )

=cut

sub exp_form {
	#-----------------------------------------------------------------------
	#
	# 指数形式の表現を返す。 ( オイラー表記 )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $r , $npi ) = $self->pollar_values_for_string() ;

	my $z = "$r * exp( i * ( $npi * PI ) )" ;

	return $z ;
}

sub as_exponent	{ return $_[0]->exp_form() ; }
sub as_euler	{ return $_[0]->exp_form() ; }

=head2 matrix_form

  print complex( [ 1 , 1 ] )->matrix_form() ;                    # [        1 ,       -1 ]
                                                                 # [        1 ,        1 ]

  print complex( { arg => radian( 60 ) } )->matrix_form() ;      # [      1/2 , -0.86603 ]
                                                                 # [  0.86603 ,      1/2 ]

=cut

sub matrix_form {
	#-----------------------------------------------------------------------
	#
	# 行列形式の表現を返す。
	#
	#   分数で表現できるようであれば分数で返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $self->as_array() ;
	my $fx = $x->fraction() ;
	my $fy = $y->fraction() ;

	if ( ! defined $fx or $fx->denominator() >= 1000 ) {
		$fx = $x->round( 5 ) ;
	}
	if ( ! defined $fy or $fy->denominator() >= 1000 ) {
		$fy = $y->round( 5 ) ;
	}

	my $z = sprintf( "[ %8s , %8s ]\n[ %8s , %8s ]" , $fx , ( -1 ) * $fy , $fy , $fx ) ;

	return $z ;
}

sub round {
	#-----------------------------------------------------------------------
	#
	# 四捨五入
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $obj = $self->copy() ;

	foreach ( 0 .. 1 ) {
		$obj->[ $_ ] = $obj->[ $_ ]->round( $dlen ) ;
	}

	return $obj ;
}

sub round_banker {
	#-----------------------------------------------------------------------
	#
	# 銀行家の丸め ( Banker's rounding )
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $obj = $self->copy() ;

	foreach ( 0 .. 1 ) {
		$obj->[ $_ ] = $obj->[ $_ ]->round_banker( $dlen ) ;
	}

	return $obj ;
}

sub round_up {
	#-----------------------------------------------------------------------
	#
	# 切り上げ
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $obj = $self->copy() ;

	foreach ( 0 .. 1 ) {
		$obj->[ $_ ] = $obj->[ $_ ]->round_up( $dlen ) ;
	}

	return $obj ;
}

sub round_down {
	#-----------------------------------------------------------------------
	#
	# 切捨て
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $obj = $self->copy() ;

	foreach ( 0 .. 1 ) {
		$obj->[ $_ ] = $obj->[ $_ ]->round_down( $dlen ) ;
	}

	return $obj ;
}

=head1 'Complex' object - the properties and translations

=cut

#-------------------------------------------------------------------------------
#
# 属性
#
#-------------------------------------------------------------------------------

=head2 real , imag

  print complex( [ 1 , 2 ] )->real() ;               # 1
  print complex( [ 1 , 2 ] )->imag() ;               # 2

=cut

sub real {
	#-----------------------------------------------------------------------
	#
	# 実部
	#
	#-----------------------------------------------------------------------
	return ( $_[0]->as_array() )[0] ;
}

sub imag {
	#-----------------------------------------------------------------------
	#
	# 虚部
	#
	#-----------------------------------------------------------------------
	return ( $_[0]->as_array() )[1] ;
}

sub imaginary	{ return $_[0]->imag() ; }

=head2 trace

  z == x + iy

    == [ x , -y ]
       [ y ,  x ]

  trace( z ) == x * x == 2 * x


  print complex( [ 1 , 2 ] )->trace() ;               # 2

  print complex( { arg => radian( 60 ) } ) ;          # 0.5 + 0.866025403784439 i
  print complex( { arg => radian( 60 ) } )->trace()   # 1

=cut

sub trace {
	#-----------------------------------------------------------------------
	#
	# 対角和 ( trace )
	#
	#   跡とも呼ばれる。ドイツ語では spur ( シュプール ) 。
	#   複素数の行列表現における主対角成分の総和であり、
	#
	#     z == x + iy
	#       == [ x , -y ]
	#          [ y ,  x ]
	#
	#     trace( z ) == 2 * x
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self->[0]->multiply( 2 ) ;
}

=head2 det

Alias : norm

  z == x + iy

    == [ x , -y ] == r * [ cos( t ) , (-1) * sin( t ) ]
       [ y ,  x ]        [ sin( t ) ,        cos( t ) ]

  t == atan2( y , x )
  x == r * cos( t )
  y == r * sin( t )

  -> det( z ) == ( x * x ) - ( -y * y )
              == x^2 + y^2
              == ( r * cos( t ) )^2 + ( r * sin( t ) )^2
              == r^2 * ( ( cos( t ) )^2 + ( ( sin( t ) )^2 )
              == r^2
  

  print complex( [ 1 , 2 ] )->det() ;             # 5

=cut

sub det {
	#-----------------------------------------------------------------------
	#
	# 行列式 ( determinant )
	#
	#   z == x + iy
	#
	#     == [ x , -y ]
	#        [ y ,  x ]
	#
	#     == r * [ cos( theta ) , -1 * sin( theta ) ]
	#            [ sin( theta ) ,      cos( theta ) ]
	#
	#   theta = atan2( y , x )
	#   x == r * cos( theta )
	#   y == r * sin( theta )
	#
	#   以上の定義より、
	#
	#     det( z ) == ( x * x ) - ( -y * y )
	#              == x^2 + y^2
	#              == ( r * cos( theta ) )^2 + ( r * sin( theta ) )^2
	#              == r^2 * ( ( cos( theta ) )^2 + ( sin( theta ) )^2 )
	#              == r^2
	#
	#   また、複素数 z の絶対値は、
	#
	#     abs( z ) == sqrt( det( z ) )
	#              == sqrt( x^2 + y^2 )
	#              == sqrt( ( r * cos( theta ) )^2 + ( r * sin( theta ) )^2 )
	#              == sqrt( r^2 * ( ( cos( theta ) )^2 + ( sin( theta ) )^2 )
	#              == sqrt( r^2 )
	#              == r
	#   となる。
	#
	#
	#   複素数のノルム ( norm ) は、複素共役との積で表され、
	#
	#     z == x + iy
	#     -> norm( z ) == ( x + iy ) * ( x - iy )
	#                  == x^2 + y^2
	#                  == det( z )
	#
	#   となる。
	#
	#
	#   行列式は電気信号におけるパワーに当たる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $self->as_array() ;

	my $det = $x->power( 2 )->add( $y->power( 2 ) ) ;

	return $det ;
}

sub norm	{ return det( @_ ) ; }

=head2 abs

Alias : radius

  z == x + iy
    == r * ( cos( t ) + i * sin( t ) )
    == r * exp( i * t )

  abs( z ) == sqrt( det( z ) ) 
           == sqrt( r^2 )
           == r

  print complex( [ 1 , 2 ] )->det() ;             # 5
  print complex( [ 1 , 2 ] )->abs() ;             # 2.2360679774997896964091736687312762354406
  print complex( [ 1 , 2 ] )->abs() ** 2 ;        # 4.99999999999999999999999999999999999999991789332117598380288872876177584347612836

=cut

sub abs {
	#-----------------------------------------------------------------------
	#
	# 絶対値
	#
	#   abs( z ) == sqrt( det( z ) )
	#            == sqrt( x^2 + y^2 )
	#            == sqrt( ( r * cos( theta ) )^2 + ( r * sin( theta ) )^2 )
	#            == sqrt( r^2 * ( ( cos( theta ) )^2 + ( sin( theta ) )^2 ) )
	#            == sqrt( r^2 )
	#            == abs( r )
	#
	#   複素数 z == x + iy の絶対値は、複素平面上で原点を中心として座標 [ x , y ] を通る円の半径に等しい。
	#
	#   z == x + iy
	#     == r * ( cos( theta ) + i * sin( theta ) )
	#
	#   であることから、
	#
	#     x == r * cos( theta )
	#     y == r * sin( theta )
	#
	#                 x                    y
	#     r == ----------------- == ----------------
	#            cos( theta )         sin( theta )
	#  
	#   でもある。
	#
	#
	#   絶対値は電気信号における振幅に当たる。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $det = $self->det() ;
	return undef	unless ( defined $det ) ;

	my $r = $det->sqrt( $dlen ) ;

	return $r->_regulate() ;
}

sub radius	{ return $_[0]->abs( $_[1] ) ; }

=head2 arg

Alias : theta

  z == x + iy
    == r * ( cos( t ) + i * sin( t ) )
    == r * exp( i * t )

  arg( z ) == t

           == atan( y / x )

                     r * sin( t )
           == atan( -------------- )
	             r * cos( t )

		     y / r
	   == atan( ------- )
	             x / r

           == atan2( ( y / r ) , ( x / r ) )


  print complex( [ 1 , 2 ] )->exp_form() ;     # 2.23607 * exp( i * ( 0.35242 * PI ) )
  print complex( [ 1 , 2 ] )->arg() ;          # 1.10714871779409050301706546017853704007
  print complex( [ 1 , 2 ] )->arg() / pi() ;   # 0.3524163823495667258245989237752594740488

=cut

sub arg {
	#-----------------------------------------------------------------------
	#
	# 偏角
	#
	#   z == x + iy
	#     == r * ( cos( theta ) + i * sin( theta ) )
	#
	#   r == abs( z )
	#
	#   arg( z ) == theta
	#            == atan( y / x )
	#
	#                       r * sin( theta )
	#            == atan( -------------------- )
	#                       r * cos( theta )
	#
	#                       y / r 
	#            == atan( --------- )
	#                       x / r
	#
	#            == atan2( ( y / r ) , ( x / r ) )
	#
	#  予め絶対値で割っておいた方が精度が上がる。
	#  ( arctan2 でも同じことをやっているはずなのだが？？？ )
	#
	#
	#   偏角は電気信号における位相に当たる。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $self->as_array() ;

	if ( my $radius = $self->abs() ) {
		foreach ( $x , $y ) { $_ /= $radius ; }
	}

	my $r = $y->arctan2( $x , $dlen ) ;

	return $r->_regulate() ;
}

sub theta	{ return $_[0]->arg( $_[1] ) ; }

=head2 radian , npi , degree

  print complex( [ 1 , 2 ] )->exp_form() ;        # 2.23607 * exp( i * ( 0.35242 * PI ) )
  print complex( [ 1 , 2 ] )->radian() ;          # 1.10714
  print complex( [ 1 , 2 ] )->npi() ;             # 0.35242
  print complex( [ 1 , 2 ] )->degree() ;          # 63.434

=cut

#
# 偏角を可読性の高い書式で返す。
#
sub radian	{ return $_[0]->theta( defined( $_[1] ) ? $_[1] : 5 ) ; }
sub degree	{ return $_[0]->theta()->multiply( 180 )->divide( pi() , defined ( $_[1] ) ? $_[1] : 3 ) ; }	# 度数法

sub npi {
	#-----------------------------------------------------------------------
	#
	# 偏角を円周率の倍数で表現
	#
	#   分数で表現できるようであれば分数で返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;

	#$dlen = 5	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : 5 ;

	#my $theta = $self->theta()->divide( pi() )->round_down( $dlen + 2 ) ;
	my $theta = $self->theta()->divide( pi() ) ;
	my $f = $theta->fraction() ;
	return $theta->round( $dlen )	unless ( defined $f ) ;
	return $theta->round( $dlen )	if ( $f->denominator() >= 1000 ) ;
	return $f ;
}

=head2 pollar_values

Return the radius and the argument as array.

  print join "\n" , complex( [ 1 , 2 ] )->pollar_values() ;        # 2.2360679774997896964091736687312762354406
                                                                   # 1.1071487177940905030170654601785370400699

=cut

sub pollar_values {
	#-----------------------------------------------------------------------
	#
	# 絶対値と偏角の組を返す。
	#
	#   偏角を求めるには絶対値を求める必要があり、両者が必要な場合には一度に求めた方が効率が良い。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $self->as_array() ;

	my $radius = $self->abs() ;
	if ( $radius > 0 ) {
		foreach ( $x , $y ) { $_ /= $radius ; }
	}

	my $arg = $y->arctan2( $x , $dlen ) ;

	return ( $radius , $arg->_regulate() ) ;
}

=head2 pollar_values_for_string

Return the radius and the argument in short format.

The argument will be converted to the multiplicatoin of PI.

This method will return the "Fraction" or the "Decimal" object as array.
When the "Decimal" object will be return, the precision is set to less equal 5.

  $z = complex( [ 1 , 2 ] ) ;
  print join "\n" , $z->pollar_values_for_string() ;           # 2.23607
                                                               # 0.35242

  $z = complex( { radius => 0.5 , arg => pi() / 4 } ) ;
  print join "\n" , $z->pollar_values_for_string() ;           # 1/2
                                                               # 1/4
                                                                                                        

=cut

sub pollar_values_for_string {
	#-----------------------------------------------------------------------
	#
	# 絶対値と偏角の組を文字列表記に適した値に修正して返す。
	#
	#   偏角は PI の倍数に変換する。
	#   絶対値、偏角共に可能であれば分数に変換する。
	#   小数で返す場合には有効桁数を 5 桁以内とする。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : 5 ;
	$dlen = 5	if ( $dlen > 5 ) ;

	my( $r , $arg ) = $self->pollar_values() ;
	my $npi = $arg->npi() ;

	foreach my $v ( $r , $npi ) {
		if ( my $f = $v->fraction() ) {
			if ( $f->denominator() >= 1000 )	{ $v = $v->round( $dlen ) ; }
			else					{ $v = $f ; }
		}
		else {
			$v = $v->round( $dlen ) ;
		}
	}

	return ( $r , $npi ) ;
}

=head2 conj

  print complex( [ 1 , 2 ] ) ;                     # 1 + 2 i
  print complex( [ 1 , 2 ] )->conj() ;             # 1 - 2 i

  print complex( [ 1 , 1 ] )->exp_form() ;         # 1.41421 * exp( i * ( 1/4 * PI ) )
  print complex( [ 1 , 1 ] )->conj()->exp_form()   # 1.41421 * exp( i * ( -1/4 * PI ) )

If complex number z is a real number, or pure imaginary number, conj( z ) is as follows.

  z == x + i * 0 -> conj( z ) == z
  z == 0 + iy    -> conj( z ) == (-1) * z

conj( z ) is the reflection of z about the real axis, in the complex plane.

  z         == x + iy == r * exp(  i * t )
  conj( z ) == x - iy == r * exp( -i * t ) == r * exp( i * (-t) )

conj( z ) * (-1) is the reflection of z about the imaginary axis, in the complex plane.

  conj( z ) * ( -1 ) == ( x - iy ) * (-1))
                     == -x + iy
                     == r * exp( i * ( t + ( PI / 2 ) ) )

z * (-1) is the reflection of z about the point of origin, in the complex plane.

  z * (-1) == ( x + iy ) * (-1)
           == -x - iy
           == r * exp( i * ( t + PI ) )
           == r * exp( i * ( t - PI ) )
  
conj( z ) and it's argument.

  arg( conj( z ) ) == -t
  -> t == arg( z ) == (-1) * arg( conj( z ) )

The arithmetic operations between complex number z and it's complex conjugate conj( z ) brings some interesting results.

  z + conj( z ) == 2 * x == 2 * real( z )

                           z + conj( z )
    -> x == real( z ) == ---------------
                               2

  z - conj( z ) == 2 * iy == 2 * i * imag( z )

                          z - conj( z )
    -> y == imag( z ) == ---------------
                             2 * i

  z * conj( z ) == ( x + iy ) * ( x - iy )
                == x^2 + y^2
                == det( z )
                == ( abs( z ) )^2
		== r^2

    -> r == abs( z ) == sqrt( det( z ) )
                     == sqrt( z * conj( z ) )

                    x + iy      ( x + iy )^2        z^2           z
  z / conj( z ) == -------- == -------------- == ---------- == ( --- )^2
                    x - iy       x^2 + y^2        det( z )        r

    -> z / r == exp( i * t ) == sqrt( z / conj( z ) )

=cut

sub conj {
	#-----------------------------------------------------------------------
	#
	# 複素共役 ( complex conjugation ; complex conjugate )
	#
	#   複素数の虚部の符号を入れ替えたもの。 ( 数学では z に上線をつけて表現される。 )
	#
	#   複素数 z が実数の場合、
	#
	#     conj( z ) == z
	#
	#   純虚数の場合、
	#
	#     conj( z ) == -1 * z
	#
	#   と言う関係になる。
	#
	#   複素数と複素共役を指数関数で表すと、
	#
	#     z         == x + iy == r * exp( i * theta )
	#     conj( z ) == x - iy == r * exp( ( -1 ) * i * theta )
	#
	#   となり、
	#
	#     x == ( z + conj( z ) ) / 2
	#     y == ( z - conj( z ) ) / ( 2 * i )
	#     r == abs( z ) == sqrt( z * conj( z ) )
	#     theta == -1 * ( arg( conj( z ) )
	#     exp( i * theta ) == z / abs( z ) == exp( i * arg( z ) ) == sqrt( z / conj( z ) )
	#
	#   と表すことができる。
	#
	#   また、
	#
	#     conj( conj( z ) ) == z     ( 対合 )
	#     abs( z )          == abs( conj( z ) )
	#     z * conj( z )     == abs( z )^2
	#     z^( -1 )          == conj( z ) / ( abs( z )^2 )
	#     conj( z + w )     == conj( z ) + conj( w )
	#     conj( z * w )     == conj( z ) * conj( w )
	#     z / w             == conj( z ) / conj( w )
	#
	#   等の関係が成立する。
	#   
	#   以下の 2 つの複素数について、
	#
	#     z ==  x + iy
	#     w == -x + iy
	#
	#     w == -x + iy == ( -1 ) * (  x - iy ) == ( -1 ) * conj( z )
	#     z ==  x + iy == ( -1 ) * ( -x - iy ) == ( -1 ) * conj( w )
	#
	#   となる。
	#   複素数 z とその複素共役 conj( z ) は、複素平面上の実軸に対して線対称な関係を持ち、
	#   z と ( -1 ) * conj( z ) は、複素平面上の虚軸に対して線対称な関係となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy() ;
	$obj->[1] *= ( -1 ) ;

	return $obj ;
}

=head2 is_XXX

  print complex( [ 1 , 1 ] )->is_zero() ;         # 0
  print complex( [ 0 , 0 ] )->is_zero() ;         # 1

  print complex( [ 1 , 1 ] )->is_scalar() ;       # 1
  print complex( [ 1 , 1 ] )->is_integer() ;      # 0
  print complex( [ 1 , 1 ] )->is_decimal() ;      # 0
  print complex( [ 1 , 1 ] )->is_fraction() ;     # 0
  print complex( [ 1 , 1 ] )->is_coplex() ;       # 1
  print complex( [ 1 , 1 ] )->is_vector() ;       # 0
  print complex( [ 1 , 1 ] )->is_matrix() ;       # 0

  print complex( [ 1 , 1 ] )->is_real() ;         # 0
  print complex( [ 0 , 1 ] )->is_real() ;         # 0
  print complex( [ 1 , 0 ] )->is_real() ;         # 1

  print complex( [ 1 , 1 ] )->is_imag() ;         # 1
  print complex( [ 0 , 1 ] )->is_imag() ;         # 1
  print complex( [ 1 , 0 ] )->is_imag() ;         # 0

=cut

sub is_zero { return ( $_[0]->[0]->round( 15 ) == 0 and $_[0]->[1]->round( 15 ) == 0 ) ? 1 : 0 ; }	# z == 0 == 0 + i * 0     ( abs( z ) == 0 )

sub is_scalar		{ return 1 ; }
sub is_integer		{ return 0 ; }
sub is_decimal		{ return 0 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 1 ; }
sub is_vector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 0 ; }

sub is_real	{ return ( $_[0]->[1]->round( 15 ) == 0 ) ? 1 : 0 ; }
sub is_imag	{ return ( $_[0]->[1]->round( 15 ) == 0 ) ? 0 : 1 ; }

=head2 can_XXX

  print complex( [ 1 , 1 ] )->can_integer() ;     # 0
  print complex( [ 1 , 0 ] )->can_integer() ;     # 1
  print complex( [ 0.5 , 0 ] )->can_integer() ;   # 0

  print complex( [ 1 , 1 ] )->can_decimal() ;     # 0
  print complex( [ 1 , 0 ] )->can_decimal() ;     # 1
  print complex( [ 0.5 , 0 ] )->can_decimall() ;  # 1

=cut

sub can_integer	{
	return 0	if ( $_[0]->is_imag() ) ;
	return 1	if ( $_[0]->real()->is_integer() ) ;
	return 0 ;
}

sub can_decimal {
	return 0	if ( $_[0]->is_imag() ) ;
	return 1 ;
}

sub can_scalar		{ return 1 ; }

#-------------------------------------------------------------------------------
#
# 比較
#
#   絶対値と偏角を小数点以下 15 桁の範囲で比較する。
#
#   偏角が異なる場合には大小の比較は「不定」とする。
#   これは、複素平面上の同一象限上の同一線分上の点のみを「比較可能」とすることを意味する。
#
#-------------------------------------------------------------------------------

sub compare {
	#-----------------------------------------------------------------------
	#
	# 比較
	#
	#   return undef	# 比較不能
	#   return  0	if ( $x == $y )
	#   return  1	if ( $x > $y )
	#   return -1	if ( $x < $y )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	return 0	if ( $x->[0] == $y->[0] and $x->[1] == $y->[1] ) ;

	#
	# 双方が実数に変換できる場合には、実数の領域で比較する。
	#
	if ( $x->can_decimal() and $y->can_decimal() ) {
		return $x->decimal()->compare( $y->decimal() ) ;
	}

	#
	# 偏角を比較
	#
	#   偏角が一致しなければ比較不能とする。
	#
	my $t = [ $x->arg( 15 ) , $y->arg( 15 ) ] ;

	return undef	unless ( $t->[0] == $t->[1] ) ;

	#
	# 絶対値を比較
	#
	my $r = [ $x->abs( 15 ) , $y->abs( 15 ) ] ;

	return  1	if ( $r->[0] > $r->[1] ) ;
	return -1	if ( $r->[0] < $r->[1] ) ;
	return  0 ;
}

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 1	if ( $r == 0 ) ;
	return 0 ;
}

sub not_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( != )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 0	if ( $r == 0 ) ;
	return 1 ;
}

sub greater_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( > )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 1	if ( $r > 0 ) ;
	return 0 ;
}

sub greater_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( >= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 1	if ( $r >= 0 ) ;
	return 0 ;
}

sub less_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( < )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 1	if ( $r < 0 ) ;
	return 0 ;
}

sub less_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( <= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return 1	if ( $r <= 0 ) ;
	return 0 ;
}

=head1 'Complex' object - the arithmetic operations

=cut

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------

=head2 add

  z = x[0] + iy[0]
  w = x[1] + iy[1]

  z + w == ( x[0] + x[1] ) + i * ( y[0] + y[1] )


  print complex( [ 1 , 1 ] )->add( complex( [ 2 , 3 ] ) ) ;     # 3 + 4 i
  print complex( [ 1 , 1 ] ) + complex( [ 2 , 3 ] ) ;           # 3 + 4 i

=cut

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	my $obj = $x->copy() ;
	$obj->[0] += $y->[0] ;
	$obj->[1] += $y->[1] ;

	return $obj ;
}

=head2 subtract

  z = x[0] + iy[0]
  w = x[1] + iy[1]

  z - w == ( x[0] - x[1] ) + i * ( y[0] - y[1] )


  print complex( [ 1 , 1 ] )->subtract( complex( [ 2 , 3 ] ) ) ;     # -1 - 2 i
  print complex( [ 1 , 1 ] ) - complex( [ 2 , 3 ] ) ;                # -1 - 2 i

=cut

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y , $x ) ;
	}

	my $obj = $x->copy() ;
	$obj->[0] -= $y->[0] ;
	$obj->[1] -= $y->[1] ;

	return $obj ;
}

=head2 multiply

The complex numbers z and w are defined as follows.

  z == a + bi == [ a , -b ] == r0 * exp( i * t0 )
                 [ b ,  a ]

  w == c + di == [ c , -d ] == r1 * exp( i * t1 )
                 [ d ,  c ]

In othogonal format, 

  z * w == ( a + bi ) * ( c + di )
        == ac + ( ad + bc ) * i + bd * i^2
        == ( ac - bd ) + ( ad + bd ) * i
 
In matrix format,

  z * w == [ a , -b ] * [ c , -d ]
           [ b ,  a ]   [ d ,  c ]

	== [ ac - bd , (-1) * ( ad + bc ) ]
	   [ ad + bc ,          ac - bd   ]

	== ( ac - bd ) + ( ad + bc ) * i

In exponential format,

  z * w == ( r0 * exp( i * t0 ) ) * ( r1 * exp( i * t1 ) )
        == ( r0 * r1 ) * ( exp( i * t0 ) * exp( i * t1 ) ) 
        == ( r0 * r1 ) * exp( i * ( t0 + t1 ) )


The multiplication of complex numbers cause expansion in a spiral ( counter clockwise rotation ), in the complex plane.


  print complex( [ 1 , 1 ] )->multiply( complex( [ 2 , 3 ] ) ) ;       # -1 + 5 i
  print complex( [ 1 , 1 ] ) * complex( [ 2 , 3 ] ) ;                  # -1 + 5 i



  print $z = complex( { radius => 4 , arg => radian( 45 ) } ) ;        # 2.82842712474619 + 2.82842712474619 i
  print $w = complex( { radius => 2 , arg => radian( 90 ) } ) ;        # 0 + 2 i
  print $x = $z * $w ;                                                 # -5.65685424949238 + 5.65685424949238 i

  print $z->exp_form() ;                                               # 4 * exp( i * ( 1/4 * PI ) )
  print $w->exp_form() ;                                               # 2 * exp( i * ( 1/2 * PI ) )
  print $x->exp_form() ;                                               # 8 * exp( i * ( 3/4 * PI ) )

=cut

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算
	#
	#
	#   複素数を虚数単位を変数とする一次多項式とみなすと、
	#
	#     z1 == a + bi == bi + a
	#     z2 == c + di == di + c
	#
	#     z1 * z2 == ( bi + a )( di + c )
	#             == bd * i^2 + ( ad + cd ) * i + ac
	#             == ( ac - bd ) + ( ad + cd ) * i
	#
	#     カラツバ法を用いると、
	#
	#     z1 * z2 == ( bi + a )( di + c )
	#             == bd * i^2 + ( ad + cd ) * i + ac
	#             == bd * i^2 + ( ( ad + bc ) + ( ac + bd ) - ( ac + bd ) ) * i + ac
	#             == bd * i^2 + ( ac + bd - ( a - b )( c - d ) ) * i + ac
	#             == ( ac - bd ) + ( ac + bd - ( a - b )( c - d ) ) * i
	#   となる。
	#
	#
	#   行列を用いて表現すると以下のようになる。
	#
	#     z1 == x1 + iy1 == [ x1 , -y1 ]
	#                       [ y1 ,  x1 ]
	#
	#     z2 == x2 + iy2 == [ x2 , -y2 ]
	#                       [ y2 ,  x2 ]
	#
	#     z1 * z2 == [ x1 , -y1 ] * [ x2 , -y2 ]
	#                [ y1 ,  x1 ]   [ y2 ,  x2 ]
	#
	#             == [ ( x1 * x2 ) - ( y1 * y2 ) , -1 * ( ( x1 * y2 ) + ( x2 * y1 ) ) ]
	#                [ ( x2 * y1 ) + ( x1 * y2 ) ,        ( x1 * x2 ) - ( y1 * y2 )   ]
	#
	#             == ( ( x1 * x2 ) - ( y1 * y2 ) ) + i * ( ( x2 * y1 ) + ( x1 * y2 ) )
	#
	#
	#   極形式では以下のようになる。
	#
	#     z1 == r1 * ( cos( t1 ) + i * sin( t1 ) )
	#     z2 == r2 * ( cos( t2 ) + i * sin( t2 ) )
	#
	#     t1 == arg( z1 ) , r1 == x1 / cos( t1 ) == y1 / sin( t1 )
	#     t2 == arg( z2 ) , r2 == x2 / cos( t2 ) == y2 / sin( t2 )
	#
	#     z1 * z2 == ( r1 * r2 ) * ( cos( t1 + t2 ) + i * sin( t1 + t2 ) )
	#
	#     極形式における複素数の乗算は絶対値の乗算と偏角の加算となって現われる。
	#     これは、乗算が複素平面上での伸張と回転に還元されることを意味している。
	#
	#     直交形式の演算式に照らすと、
	#
	#       z3 == z1 * z2 == x3 + iy3 == r3 * ( cos( t3 ) + i * sin( t3 ) ) 
	#
	#       -> x3 == ( x1 * x2 ) - ( y1 * y2 )
	#             == ( r1 * r2 ) * ( ( cos( t1 ) * cos( t2 ) ) - ( sin( t1 ) * sin( t2 ) ) )
	#             == ( r1 * r2 ) * cos( t1 + t2 )
	#
	#          y3 == ( x2 * y1 ) + ( x1 * y2 )
	#             == ( r1 * r2 ) * ( ( sin( t1 ) * cos( t2 ) ) + ( cos( t1 ) * sin( t2 ) ) )
	#             == ( r1 * r2 ) * sin( t1 + t2 )
	#
	#       -> z3 == z1 * z2 == x3 + iy3 == r3 * ( cos( t3 ) + i * sin( t3 ) )
	#             == ( r1 * r2 ) * ( cos( t1 + t2 ) + i * sin( t1 + t2 ) )
	#
	#     となる。
	#
	#
	#  指数表現では更に直感的な表現となる。
	#
	#     z1 == r1 * exp( i * t1 )
	#     z2 == r2 * exp( i * t2 )
	#
	#     z1 * z2 == ( r1 * exp( i * t1 ) ) * ( r2 * exp( i * t2 ) )
	#             == ( r1 * r2 ) * ( exp( i * t1 ) * exp( i * t2 ) )
	#             == ( r1 * r2 ) * exp( i * ( t1 + t2 ) )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;

	if ( ref( $y ) ) {
		return $y->multiply( $x )	unless ( $y->is_scalar() ) ;
	}

	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	my $obj = __PACKAGE__->new(
		[
			( ( $x->[0] * $y->[0] ) - ( $x->[1] * $y->[1] ) )->round_down( $DECIMAL_PART_LENGTH_LIMIT + 10 ) ,
			( ( $x->[1] * $y->[0] ) + ( $x->[0] * $y->[1] ) )->round_down( $DECIMAL_PART_LENGTH_LIMIT + 10 ) ,
		]
	) ;

	return $obj ;
}

=head2 divide

The complex numbers z and w are defined as follows.

  z == a + bi == [ a , -b ] == r0 * exp( i * t0 )
                 [ b ,  a ]

  w == c + di == [ c , -d ] == r1 * exp( i * t1 )
                 [ d ,  c ]

In othogonal format, 

            a + bi      ( a + bi ) * conj( w )
  z / w == -------- == ------------------------
            c + di      ( c + di ) * conj( w )

                        ( a + bi )( c - di )
	            == ----------------------
		             c^2 + d^2 

			z * conj( w )
	            == ---------------
		          det( w )

In matrix format,

  z / w == [ a , -b ] * ( [ c , -d ] )^(-1)
           [ b ,  a ]     [ d ,  c ]

  w * transpose( w ) == [ c , -d ] * [  c , d ]
                        [ d ,  c ]   [ -d , c ]

		     == [ c^2 + d^2 ,         0 ]
		        [         0 , c^2 + d^2 ]

	             == ( c^2 + d^2 ) * [ 1 , 0 ]
		                        [ 0 , 1 ]

		     == det( w ) * [ 1 , 0 ]
		                   [ 0 , 1 ]
  
                        transpose( w ) 
    -> inverse( w ) == ----------------
                           det( w ) 
  
                    == [  c , d ] / det( w )
		       [ -d , c ]

		        conj( w )
		    == -----------
		        det( w )

                  
    -> z / w == z * inverse( w )

                 z * conj( w )
             == ---------------
	           det( w )


In exponential format,

            ( r0 * exp( i * t0 ) )
  z / w == ------------------------
	    ( r1 * exp( i * t1 ) )

            r0     exp( i * t0 )
        == ---- * ---------------
            r1     exp( i * t1 )

            r0
        == ---- * exp( ( i * t0 ) - ( i * t1 ) )
	    r1

            r0
	== ---- * exp( i * ( t0 - t1 ) ) 
            r1


The division of complex numbers cause reduction in a spiral ( clockwise rotation ), in the complex plane.

  print complex( [ 1 , 1 ] )->divide( complex( [ 2 , 3 ] ) ) ;         # 0.384615384615385 - 0.076923076923077 i
  print complex( [ 1 , 1 ] ) / complex( [ 2 , 3 ] ) ;                  # 0.384615384615385 - 0.076923076923077 i


  print $z = complex( { radius => 4 , arg => radian( 45 ) } ) ;        # 2.82842712474619 + 2.82842712474619 i
  print $w = complex( { radius => 2 , arg => radian( 90 ) } ) ;        # 0 + 2 i
  print $x = $z / $w ;                                                 # 1.414213562373095 - 1.414213562373095 i

  print $z->exp_form() ;                                               # 4 * exp( i * ( 1/4 * PI ) )
  print $w->exp_form() ;                                               # 2 * exp( i * ( 1/2 * PI ) )
  print $x->exp_form() ;                                               # 2 * exp( i * ( -1/4 * PI ) )

=cut

sub divide {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	#   複素数の除算を直交形式で表現すると、以下のような流れになる。
	#
	#     z1 == x1 + iy1
	#     z2 == x2 + iy2
	#
	#                  x1 + iy1
	#     z1 / z2 == ------------
	#                  x2 + iy2
	#
	#       z1        z1 * conj( z2 )
	#     ------ == -------------------
	#       z2        z2 * conj( z2 )
	#
	#                 ( x1 + iy1 ) * ( x2 - iy2 )
	#            == -------------------------------
	#                 ( x2 + iy2 ) * ( x2 - iy2 )
	#
	#                 ( x1 + iy1 ) * ( x2 - iy2 )
	#            == -------------------------------
	#                         x2^2 + y2^2
	#
	#                 z1 * conj( z2 )
	#            == -------------------
	#                    det( z2 )
	#
	#
	#   行列表現から直交形式の演算式を求める。
	#
	#     z1 == x1 + iy1 == [ x1 , -y1 ]
	#                       [ y1 ,  x1 ]
	#
	#     z2 == x2 + iy2 == [ x2 , -y2 ]
	#                       [ y2 ,  x2 ]
	#
	#     行列における除算は逆行列を右から掛けることに等しい。
	#
	#       z1 / z2 == z1 * ( z2 )^( -1 )
	#               == z1 * inverse( z2 )
	#
	#     虚数単位の逆行列が
	#
	#       i == [ 0 , -1 ]
	#            [ 1 ,  0 ]
	#
	#       ( i )^( -1 ) == inverse( i ) == [  0 , 1 ] == transpose( i )
	#                                       [ -1 , 0 ]
	#
	#       i * inverse( i ) == i * transpose( i )
	#
	#                        == [ 0 , -1 ] * [  0 , 1 ]
	#                           [ 1 ,  0 ]   [ -1 , 0 ]
	#
	#                        == [ 1 , 0 ]
	#                           [ 0 , 1 ]
	#
	#                        == E
	#
	#     であることから、虚数単位は直交行列であることがわかる。
	#
	#     z2 とその転置行列の積を求めると、
	#
	#       z2 * transpose( z2 ) == [ x2 , -y2 ] * [  x2 , y2 ]
	#                               [ y2 ,  x2 ]   [ -y2 , x2 ]
	#
	#                            == [ x2^2 + y2^2       , x2 * y2 - x2 * y2 ]
	#                               [ x2 * y2 - x2 * y2 , x2^2 + y2^2       ]
	#
	#                            == [ x2^2 + y2^2  ,           0 ]
	#                               [           0  , x2^2 + y2^2 ]
	#
	#     が得られる。
	#
	#     z2 とその逆行列の関係は、
	#
	#       z2 * inverse( z2 ) == [ 1 , 0 ] == E
	#                             [ 0 , 1 ]
	#
	#     であることから、
	#
	#       z2 * transpose( z2 ) == [ x2^2 + y2^2 ,           0 ] 
	#                               [           0 , x2^2 + y2^2 ]
	#
	#                            == ( x2^2 + y2^2 ) * [ 1 , 0 ]
	#                                                 [ 0 , 1 ]
	#
	#                            == ( x2^2 + y2^2 ) * ( z2 * inverse( z2 ) )
	#
	#       inverse( z2 ) == transpose( z2 ) / ( x2^2 + y2^2 )
	#                     == transpose( z2 ) / det( z2 )
	#
	#                     == [  x2 , y2 ] / det( z2 )
	#                        [ -y2 , x2 ]
	#
	#                     == conj( z2 ) / det( z2 )
	#
	#     で表されることが判る。
	#
	#     以上の内容により、
	#
	#       z1 / z2 == z1 * inverse( z2 )
	#
	#                    z1 * conj( z2 )
	#               == -------------------
	#                       det( z2 )
	#
	#     となり、同じ結果を得る。
	#
	#
	#   直交形式での演算結果を展開すると、
	#
	#     z1 * conj( z2 ) == ( x1 + iy1 ) * ( x2 - iy2 )
	#                     == ( x1 * x2 ) - ( x1 * y2 ) * i + ( x2 * y1 ) * i + ( y1 * y2 )
	#                     == ( x1 * x2 ) + ( y1 * y2 ) + i * ( ( x2 * y1 ) - ( x1 * y2 ) ) 
	#
	#     det( z2 ) == x2^2 + y2^2
	#
	#
	#                  ( ( x1 * x2 ) + ( y1 * y2 ) ) + i * ( ( x2 * y1 ) - ( x1 * y2 ) ) 
	#     z1 / z2 == ----------------------------------------------------------------------
	#                                           x2^2 + y2^2
	#                                   
	#   乗算の演算式は、
	#
	#     z1 * z2 == ( ( x1 * x2 ) - ( y1 * y2 ) ) + i * ( ( x2 * y1 ) + ( y1 * y2 ) )
	#
	#   なので、乗算と除算の違いは、
	#
	#     ・実部と虚部の加減算が入れ替わる。
	#
	#         乗算が z3 == z1 * z2 であるのに対して、除算の分子が z3 == z1 * conj( z2 ) であることによる。
	#
	#     ・演算結果を除数の絶対値で割る必要がある。
	#
	#         z4 == z1 / z2 == z3 / det( z2 ) 
	#
	#   となることが判る。
	#
	#
	#   極形式では以下のようになる。
	#
	#     z1 == x1 + iy1 == r1 * ( cos( t1 ) + i * sin( t1 ) )
	#     z2 == x2 + iy2 == r2 * ( cos( t2 ) + i * sin( t2 ) )
	#
	#     t1 == arg( z1 ) , r1 == x1 / cos( t1 ) == y1 / sin( t1 ) == abs( z1 )
	#     t2 == arg( z2 ) , r2 == x2 / cos( t2 ) == y2 / sin( t2 ) == abs( z2 )
	#
	#       z1        r1 * ( cos( t1 ) + i * sin( t2 ) ) 
	#     ------ == --------------------------------------
	#       z2        r2 * ( cos( t2 ) + i * sin( t2 ) )
	#
	#                 r1      ( cos( t1 ) + i * sin( t1 ) ) * ( cos( t2 ) - i * sin( t2 ) )
	#            == ------ * ----------------------------------------------------------------
	#                 r2      ( cos( t2 ) + i * sin( t2 ) ) * ( cos( t2 ) - i * sin( t2 ) )
	#
	#                 r1
	#            == ------ * ( ( cos( t1 ) * cos( t2 ) + sin( t1 ) * sin( t2 ) ) + i * ( sin( t1 ) * cos( t2 ) - cos( t1 ) * sin( t2 ) ) )
	#                 r2
	#
	#            == ( r1 / r2 ) * ( cos( t1 - t2 ) + i * sin( t1 - t2 ) )
	#
	#     極形式の方が乗算との関係において直感的に理解しやすい形になっている。
	#     ( 除算は、圧縮 ( 収縮 ) と逆回転に還元される。 )
	#
	#
	#     直交形式の演算式の分子に注目すると、
	#
	#       z3 == x3 + iy3
	#
	#       -> x3 == ( x1 * x2 ) + ( y1 * y2 )
	#             == ( r1 * r2 ) * ( cos( t1 ) * cos( t2 ) + sin( t1 ) * sin( t2 ) )
	#             == ( r1 * r2 ) * cos( t1 - t2 )
	#
	#          y3 == ( x2 * y1 ) - ( x1 * y2 )
	#             == ( r1 * r2 ) * ( sin( t1 ) * cos( t2 ) - cos( t1 ) * sin( t2 ) )
	#             == ( r1 * r2 ) * sin( t1 - t2 )
	#       
	#       -> z3 == x3 * iy3
	#             == ( r1 * r2 ) * ( cos( t1 - t2 ) + i * sin( t1 - t2 ) )
	#
	#     分母は、
	#
	#       x2^2 + y2^2 == det( z2 ) == abs( z2 )^2 == r2^2
	#
	#     なので、
	#
	#       z4 == z1 / z2
	#
	#          == z3 / det( z2 )
	#
	#          == ( r1 * r2 ) / r2^2 * ( cos( t1 - t2 ) + i * sin( t1 - t2 ) )
	#
	#          == ( r1 / r2 ) * ( cos( t1 - t2 ) + i * sin( t1 - t2 ) )
	#
	#     となる。
	#
	#
	#   指数表現では極形式よりも更に直感的な表現となる。
	#
	#     z1 == r1 * exp( i * t1 )
	#     z2 == r2 * exp( i * t2 )
	#
	#     z1 / z2 == ( r1 * exp( i * t1 ) ) / ( r2 * exp( i * t2 ) )
	#             == ( r1 / r2 ) * ( exp( i * t1 ) / exp( i * t2 ) ) 
	#             == ( r1 / r2 ) * ( exp( i ) )^( t1 - t2 )
	#             == ( r1 / r2 ) * exp( i * ( t1 - t2 ) )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	if ( $swapped ) {
		( $x , $y ) = ( $y  , $x ) ;
	}

	my $r = undef ;

	if ( $y->can_decimal() ) {
		#
		# 除数が実数の場合
		#
		$r = $x->copy() ;
		$y = $y->decimal() ;
		foreach ( @{ $r } ) { $_ /= $y ; }
	}
	else {
		#
		# 除数が複素数の場合
		#
		$r = $x * $y->conj() ;
		my $ydet = $y->det() ;
		foreach ( @{ $r } ) { $_ /= $ydet ; }
	}

	return $r ;
}

=head2 power

If z is complex number and n is real number,

  z == r * exp( i * t )

  z^n == ( r * exp( i * t ) )^n
      == r^n * ( exp( i * t ) )^n
      == r^n * exp( i * ( ( t * n ) % ( PI * 2 ) ) )


  $z = complex( [ 1 , 1 ] ) ;
  print $z->exp_form() ;                                # 1.41421 * exp( i * ( 1/4 * PI ) )

  print $z->power( 2 ) ;                                # 0 + 2 i
  print $z ** 2 ;                                       # 0 + 2 i
  print $z->power( 2 )->exp_form() ;                    # 2 * exp( i * ( 1/2 * PI ) )
  print $z->power( 8 )->exp_form() ;                    # 16 * exp( i * ( 0 * PI ) )


If x is real number and z is complex number,

  x^z == exp( z * ln( x ) ) 


  print decimal( 2 ) ** $z ;                            # 1.538477802727944 + 1.27792255262727 i
  print decimla( 2 )->power( $z )->exp_form() ;         # 2 * exp( i * ( 0.22064 * PI ) )


If z and w are both complex number,

  z == r * exp( i * t )
  w == x + iy

  z^w == ( r * exp( i * t ) )^w

      == r^w * exp( i * t * w )

      == exp( w * ln( r ) )
       * exp( i * t * w )

      == exp( ( x + iy ) * ln( r ) )
       * exp( i * t * ( x + iy ) ) 

      == exp( x * ln( r ) + iy * ln( r ) )
       * exp( ixt - yt )

      == exp( x * ln( r ) )
       * exp( iy * ln( r ) )
       * exp( ixt )
       * exp( -yt )

      == r^x
       * exp( -yt )
       * exp( iy * ln( r ) + itx )

      == r^x * exp( -yt )
       * exp( i * ( y * ln( r ) + xt ) )

      == z' == r' * exp( i * t' )

      -> r' == r^x * exp( -yt )
         t' == y * ln( r ) + xt


  print $z->power( complex( [ 0 , 1 ] ) ) ;             # 0.428829006294368 + 0.154871752464247 i
  print $z->power( complex( [ 0 , 1 ] ) )->exp_form()   # 0.45594 * exp( i * ( 0.11032 * PI ) )


=cut

sub power {
	#-----------------------------------------------------------------------
	#
	# 冪乗
	#
	#   複素数の実数冪
	#
	#     複素数 z == x + iy において、 [ x , y ] が複素平面における単位円上の座標である場合、
	#
	#       z == x + iy
	#         == cos( theta ) + i * sin( theta )
	#         == e^( i * theta )                                   ( オイラーの公式 )
	#         == exp( i * theta )
	#
	#     となる。
	#
	#     z の冪乗は、
	#
	#       z^n == ( x + iy )^n
	#           == ( cos( theta ) + i * sin( theta ) )^n
	#           == cos( n * theta ) + i * sin( n * theta )         ( ド・モアブルの定理 )
	#
	#       z^n == ( e^( i * theta ) )^n
	#           == e^( i * n * theta )
	#           == exp( i * n * theta )
	#
	#     で表される。 ( ただし、 ( -1 ) * PI < theta <= PI )
	#
	#     任意の複素数は、
	#
	#       z == x + iy
	#         == r * ( cos( theta ) + i * sin( theta ) )
	#         == r * exp( i * theta )
	#
	#     で表されるので、
	#
	#       z^n == ( x + iy )^n
	#           == ( r^n ) * ( cos( n * theta ) + i * ( sin( n * theta ) ) )
	#           == ( r^n ) * exp( i * n * theta )
	#           == ( r^n ) * exp( i * ( ( n * theta ) % 2PI ) )
	#
	#     となる。
	#
	#   
	#   実数の複素数冪
	#
	#     実数の実数冪は、以下のように表現することができる。
	#
	#       x^p == e^( ln( x^p ) )
	#           == e^( p * ln( x ) ) 
	#           == exp( p * ln( x ) )
	#
	#     これと同様に、任意の実数 x と任意の複素数 z について、
	#
	#       x^z == e^( ln( x^z ) )
	#           == e^( z * ln( x ) )
	#           == exp( z * ln( x ) )
	#
	#     とすることができる。
	#
	#
	#   複素数の複素数冪
	#
	#     実数の複素数冪と同様に考えることができる。
	#
	#       z^w == exp( Log( z^w ) )
	#           == exp( w * Log( z ) )
	#
	#       log( z ) は多価関数であるため、ここではその主値を意味する Log( z ) を用いている。
	#
	#     z をオイラー表記で、 w を直行形式で表現して展開すると、
	#
	#       z == r * exp( it )
	#       w == x + iy
	#
	#       -> z^w == ( r * exp( it ) )^w
	#              == r^w * exp( i * t ( x + iy ) )
	#              == exp( w * ln( r ) ) * exp( -yt + ixt )
	#              == exp( ( x + iy ) * ln( r ) ) * exp( -yt + ixt )
	#              == exp( x * ln( r ) + iy * ln( r ) ) * exp( -yt + ixt )
	#              == exp( x * ln( r ) ) * exp( i * y * ln( r ) ) * exp( -yt ) * exp( ixt )
	#              == r^x * exp( -yt ) * exp( i * y * ln( r ) + itx ) 
	#              == r^x * exp( -yt ) * exp( i * ( y * ln( r ) + xt ) )
	#              == r^x * exp( -yt ) * ( cos( y * ln( r ) + xt ) + i * sin( y * ln( r ) + xt ) )
	#
	#              == z' == r' * exp( i * t' )
	#
	#              r' == r^x * exp( -yt )
	#              t' == y * ln( r ) * xt 
	#
	#     となる。
	#
	#-----------------------------------------------------------------------
	my( $z , $pow ) = @_ ;

	$z = __PACKAGE__->new( [ $z ] )		unless ( ref( $z ) eq __PACKAGE__ ) ;
	$pow = __PACKAGE__->new( [ $pow ] )	unless ( ref( $pow ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $z ) ;
	return undef			unless ( defined $pow ) ;

	$pow = $pow->decimal()	if ( $pow->can_decimal() ) ;

	my $obj = undef ;

	if ( $pow->is_decimal() and $pow < 0 ) {
		#
		# 指数が負の実数
		#
		# 指数の絶対値で冪を採り、その逆数を返す。
		#
		return $z->power( $pow->abs() )->inverse() ;
	}
	elsif ( $pow->is_decimal() ) {
		#
		# 複素数の実数冪
		#
		#   z   == r * ( cos( theta ) + i * sin( theta ) )
		#       == r * exp( i * theta )
		#
		#   z^p == ( r^p ) * ( cos( p * theta ) + i * sin( p * theta ) )
		#       == ( r^p ) * exp( i * p * theta ) 
		#
		my $theta = $z->arg() ;	# 偏角
		my $r = $z->abs() ;	# 絶対値

		$obj = __PACKAGE__->new(
			{
				'r'	=> $r->power( $pow )		,
				'theta'	=> $theta->multiply( $pow )	,
			}
		) ;
	}
	else {
		#
		# 複素数の複素数冪
		#
		#   z^p == exp( p * log( z ) )
		#
		#$obj = $z->log()->multiply( $pow )->exp() ;
	
		#
		#   z == r * exp( it )
		#   p == x + iy
		#
		#   z^p == r^x * exp( -yt ) * exp( i * ( y * ln( r ) + xt ) )
		#       == r^x * exp( -yt ) * ( cos( y * ln( r ) + xt ) + i * sin( y * ln( r ) + xt ) )
		#
		$pow = $pow->complex()	unless ( $pow->is_complex() ) ;
		my( $r , $t ) = ( $z->abs() , $z->arg() ) ;
		my( $x , $y ) = $pow->as_array() ;

		my $nr = $r->power( $x ) * ( $y * ( -1 ) * $t )->exp() ;
		my $nt = ( $y * $r->ln() ) + ( $x * $t ) ;

		$obj = $nr * __PACKAGE__->new( [ $nt->_cosine_sine() ] ) ;
	}

	return $obj ;
}

=head2 root

If z is complex number and n is real number,

  z == r * exp( i * t )

  root( z , n ) == ( r * exp( i * t ) )^(1/n)
                == r^(1/n) + ( exp( i * t ) )^(1/n)
                == r^(1/n) + exp( i * ( t / n ) )

This is a root of unity about z^(1/n) , and z^(1/n) has n number of solutions.

In generally, root( z , n ) is defined as follows.

                                             2 * PI * k + t
  root( z , n ) == root( r , n ) * exp( i * ---------------- )        ( k == 0 -> n - 1 )
                                                   n

When k == 0

                                                            t
  Z[0] == ( root( z , n ) )[0] == root( r , n ) * exp( i * --- )
                                                            n

otherwise

                                                            t     2 * PI * k
  Z[k] == ( root( z , n ) )[k] == root( r , n ) * exp( i * --- + ------------ )
                                                            n         n

							    t            2 * PI * k
                               == root( r , n ) * exp( i * --- ) * exp( ------------- )
			                                    n                n

				                   2 * PI * k
			       == Z[0] * exp( i * ------------ )
			                               n


  $z = complex( [ 1 , 0 ] ) ;
  print $z ;                                                    # 1

  print join "\n" , $z->root( 4 ) ;                             # 1
                                                                # 0 + i
                                                                # -1
                                                                # 0 - i
					 
  print join "\n" , map { $_->exp_form() } $z->root( 4 ) ;      # 1 * exp( i * ( 0 * PI ) )
                                                                # 1 * exp( i * ( 1/2 * PI ) )
                                                                # 1 * exp( i * ( 1 * PI ) )
                                                                # 1 * exp( i * ( -1/2 * PI ) )


If z and w are both complex number, root( z , w ) is defined as follows in this module.

   root( z , w ) == z^( inverse( w ) )
                 == exp( inverse( w ) * Log( z ) )

Log( z ) is a principal value about log( z ).

=cut

sub root {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	#   複素数の正の整数根
	#
	#     z == r * e ** ( i * theta )
	#       == r * ( cos( theta ) + i * sin( theta ) )
	#
	#     k == 0 -> n - 1 において、
	#
	#       rr == root( r , n )
	#       t  == ( theta + 2 * k * PI ) / n
	#
	#     とおくと、 z の n 乗根の内の 1 つは、
	#
	#       root( z , n ) == rr * e ** ( i * t )
	#                     == rr * exp( i * t )
	#                     == rr * ( cos( t ) + i * sin( t ) )
	#     となる。
	#
	#     複素数 z の n 乗根は n 個の根を持つ。 ( n 価の関数 )
	#     これら n 個の根は、絶対値が同一で n 種類の偏角を持つ複素数となる。
	#
	#
	#     t[k] == ( theta + 2 * k * PI ) / n とおくと、
	#
	#       t[0] == theta / n
	#       t[1] == t[0] + 2PI / n
	#       t[2] == t[1] + 2PI / n
	#       ............
	#       t[k] == t[k-1] + 2PI / n
	#
	#       ( k == 0 -> n - 1 )
	#
	#     これは、 theta / n と、これを基点として複素平面上を 2 * PI / n ずつ回転した位置に根が現れると言うことを意味している。
	#
	#
	#     k == 0 の時、
	#
	#       t[0] == ( theta + 2 * k * PI ) / n == theta / n
	#       root( z , n ) == root( r , n ) * ( cos( theta / n ) + i * sin( theta / n ) )
	#                     == root( r , n ) * ( cos( t[0] ) + i * sin( t[0] ) )
	#
	#     0 < k < n  の時、三角関数の加法定理より、
	#
	#       sin( a + b ) == sin( a ) * cos( b ) + cos( a ) * sin( b )
	#       sin( a - b ) == sin( a ) * cos( b ) - cos( a ) * sin( b )
	#       cos( a + b ) == cos( a ) * cos( b ) - sin( a ) * sin( b )
	#       cos( a - b ) == cos( a ) * cos( b ) + sin( a ) * sin( b )
	#
	#       sin( t[k] ) == sin( t[k-1] + 2PI/n )
	#                   == sin( t[k-1] ) * cos( 2PI/n ) + cos( t[k-1] ) * sin( 2PI/n )
	#
	#       cos( t[k] ) == cos( t[k-1] + 2PI/n )
	#                   == cos( t[k-1] ) * cos( 2PI/n ) - sin( t[k-1] ) * sin( 2PI/n )
	#
	#       root( z , n , k ) == root( r , n ) * ( cos( t[k] ) + i * sin( t[k] ) )
	#
	#     これにより、三角関数の加法定理を用いて k == 0 -> n - 1 を順に演算することで解を得ることができる。
	#     ただし、三角関数の加法定理を繰り返すと演算誤差が大きくなるという問題がある。
	#
	#
	#     Z[k] == root( z , n , k )  ( k == 0 > n - 1 ) とおき、これを指数表現で置き換えると、
	#
	#       Z[0] == root( r , n ) * ( cos( theta / n ) + i * sin( theta / n ) )
	#
	#                                          theta
	#            == root( r , n ) * exp( i * --------- )
	#                                            n
	#
	#       Z[k] == root( r , n ) * ( cos( t[k] + i * sin( t[k] ) )
	#
	#            == root( r , n ) * exp( i * t[k] )
	#
	#                                            theta        2PI * k
	#            == root( r , n ) * exp( i * ( --------- +  -----------  )
	#                                              n             n
	#
	#                                          theta                  2PI * k
	#            == root( r , n ) * exp( i * --------- ) * exp( i * ----------- )
	#                                            n                       n
	#
	#                                 2PI * k
	#            == Z[0] * exp( i * ----------- )
	#                                    n
	#
	#       ( k == 0 -> n - 1 )
	#
	#     であり、 z の n 乗根が Z[0] を基点とした位相 n の円周群そのものであることが示される。
	#
	#     この時、右辺の指数関数で表現されている箇所は、 1 の原始 n 乗根の集合を表しており、
	#     複素数の冪根の演算が 1 の原始 n 乗根を求める演算に還元されることが示される。
	#
	#
	#  実数の平方根について
	#
	#    正の実数の平方根は、 theta == 0 / 2 == 0  を基点として PI ずつ回転した位置に現われる。
	#    これは、複素平面の X 軸 ( 実軸 ) 上に根を持つことを意味しており、結果は何れも実数となる。
	#
	#    負の実数の平方根は、 theta == PI / 2 を基点として PI ずつ回転した位置に現われる。
	#    これは、複素平面の Y 軸 ( 虚軸 ) 上に根を持つことを意味しており、結果は何れも実部 0 の虚数 ( 純虚数 ) となる。
	#
	#
	#  複素数の複素数冪根
	#
	#    指数に複素数を持つ冪乗は、
	#
	#      z^w == exp( Log( z^w ) )
	#          == exp( w * Log( z ) )
	#
	#    複素数 w の逆数 inverse( w ) もまた複素数であるため、複素指数による冪根は
	#
	#      root( z , w ) == z^( inverse( w ) )
	#                    == exp( inverse( w ) * Log( z ) )
	#
	#    でよい。
	#
	#    log( z ) が多価関数であるため、複素数根も本来は多価関数となるが、主値 Log( z ) に基づく一価の値を返す事とする。
	#
	#-----------------------------------------------------------------------
	my( $x , $n ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;

	$n = new_decimal( $_ )	if ( substr( ref( $n ) , 0 , 9 ) eq 'Math::Big' ) ;
	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	$n = $n->decimal()	if ( $n->is_complex() and $n->can_decimal() ) ;

	my $z = [] ;

	if ( $n->is_complex() ) {
		#
		# 複素数根の場合
		#
		push( @{ $z } , $x->power( $n->inverse() ) ) ;
	}
	elsif ( $n < 0 ) {
		#
		# 指数が負の実数の場合
		#
		# 指数の絶対値で冪根を採り、その逆数を返す。
		#
		foreach ( $x->root( $n->abs() ) ) {
			push( @{ $z } , $_->inverse() ) ;
		}
	}
	elsif ( $n->is_integer() ) {
		#
		# 指数が正の整数の場合
		#
		my $theta = $x->arg() ;		# 偏角
		my $r = $x->abs() ;		# 絶対値

		#
		# 演算
		#
		$r = $r->root( $n ) ;			# 絶対値の根
		my $t = $theta->divide( $n ) ;		# theta / n
		my $z0 = __PACKAGE__->new( { 'radius' => $r , 'theta' => $t } ) ;
		$z = [ $z0->circle_group( $n ) ] ;
	}
	else {
		#
		# 指数が小数や分数の場合
		#
		# 指数を分数に変換して分母での冪と分子での冪根を採る。
		#
		my $f = ( $n->is_fraction ) ? $n->copy() : $n->fraction() ;
		$z = [ $x->power( $f->denominator() )->root( $f->numerator() ) ] ;
	}

	return @{ $z } ;
}

=head2 sqrt

  z == r * exp( i * t ) 
                                           2 * PI * k + t
  sqrt( z ) == Z[k] == r^(1/2) * exp( i * ---------------- )           ( k == 0 , 1 )
                                                 2

  -> Z[0] == sqrt( r ) * exp( i * t/2 )

     Z[1] == sqrt( r ) * exp( i * ( PI + t/2 ) ) 
          == sqrt( r ) * exp( i * t/2 ) * exp( i * PI )
          == Z[0] * (-1)



  $z = complex( [ 2 , 0 ] ) ;

  print join "\n" , $z->sqrt() ;                           # 1.414213562373095
                                                           # -1.414213562373095

  print join "\n" , map { $_->exp_form() } $z->sqrt() ;    # 1.41421 * exp( i * ( 0 * PI ) )
                                                           # 1.41421 * exp( i * ( 1 * PI ) )


  $z = complex( { radius => 4 , arg => radian( 60 ) } ) ;

  print $z ;                                               # 2 + 3.464101615137755 i
  print $z->exp_form() ;                                   # 4 * exp( i * ( 1/3 * PI ) )

  print join "\n" , $z->sqrt() ;                           # 1.732050807568877 + i
                                                           # -1.732050807568877 - i

  print join "\n" , map { $_->exp_form() } $z->sqrt() ;    # 2 * exp( i * ( 1/6 * PI ) )
                                                           # 2 * exp( i * ( -5/6 * PI ) )


=cut

sub sqrt {
	#-----------------------------------------------------------------------
	#
	# 平方根
	#
	#-----------------------------------------------------------------------
	return $_[0]->root( 2 ) ;
}

=head2 inverse

  z == x + iy == r * exp( i * t )

          1 + i * 0          1      * ( x - iy )
  1/z == ----------- == -------------------------
           x + iy        ( x + iy ) * ( x - iy )

                          x - iy 
	             == -----------
		         x^2 + y^2

                         conj( z )
	             == -----------
		         det( z )

			 r * exp( i * (-t) )
                     == ---------------------
		                r^2

                         1
		     == --- * exp( i * (-1) * t )
		         r

  -> z * 1/z == ( r * exp( i * t ) )
              * ( 1/r * exp( i * -t ) )

                 r
             == --- * exp( i * ( t - t ) )
	         r

             == 1



  $z = complex( [ 1 , 1 ] ) ;
  print $z->exp_form() ;                         # 1.41421 * exp( i * ( 1/4 * PI ) )        ( == sqrt(2) * exp( i * PI/4 ) )
  print $z->inverse()->exp_form() ;              # 0.70711 * exp( i * ( -1/4 * PI ) )       ( == 1/sqrt(2) * exp( i * PI/4 * (-1) ) )

=cut

sub inverse {
	#-----------------------------------------------------------------------
	#
	# 逆数
	#
	#   z         == x + iy
	#             == r * ( cos( theta ) + i * sin( theta ) )
	#             == r * exp( i * theta )
	#
	#   conj( z ) == x - iy
	#             == r * ( cos( theta ) - i * sin( theta ) )
	#             == r * exp( i * ( -1 ) * theta )
	#
	#
	#             1 + i * 0
	#   1/z  == -------------
	#              x + iy
	#
	#                  1 * ( x - iy )
	#        == ---------------------------
	#             ( x + iy ) * ( x - iy )
	#
	#                 x - iy
	#        == ------------------
	#             x^2 - ( iy )^2
	#
	#              x - iy
	#        == -------------
	#             x^2 + y^2 
	#
	#             conj( z )
	#        == -------------
	#             det( z )
	#
	#                  r * ( cos( theta ) - i * sin( theta ) ) 
	#        == -----------------------------------------------------
	#             r^2 * ( ( cos( theta ) )^2 + ( sin( theta ) )^2 )
	#
	#            1
	#        == --- * ( cos( theta ) - i * sin( theta ) )
	#            r
	#
	#            1
	#        == --- * ( cos( ( -1 ) * theta ) + i * ( sin( ( -1 ) * theta ) ) )
	#            r
	#
	#            1
	#        == --- * exp( i * ( -1 ) * theta )
	#            r
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;

	$z = __PACKAGE__->new( $z )	unless ( ref( $z ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $z ) ;

	my $r = $z->conj() ;
	my $det = $z->det() ;

	return __PACKAGE__->new( [ 0 , 0 ] )	if ( $det == 0 ) ;

	foreach ( @{ $r } ) { $_ /= $det ; }

	return $r ;
}

=head2 distance

 z == a + bi
 w == c + di

 distance( z , w ) == abs( z - w )
                   == sqrt( ( a - c )^2 + ( b - d )^2 )


 $z = complex( [ 1 , 1 ] ) ;
 $w = complex( [ 2 , 3 ] ) ;

 print $z->distance( $w ) ;                # 2.2360679774997896964091736687312762354406

=cut

sub distance {
	#-----------------------------------------------------------------------
	#
	# 複素平面上の 2 点間の距離
	#
	#   z == x1 + i * y1
	#   w == x2 + i * y2
	#
	#   distance( z , w ) == sqrt( ( x1 - x2 )^2 + ( y1 - y2 )^2 )
	#                     == abs( z - w )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	$x = __PACKAGE__->new( [ $x ] )	unless ( ref( $x ) eq __PACKAGE__ ) ;
	$y = __PACKAGE__->new( [ $y ] )	unless ( ref( $y ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $x ) ;
	return undef			unless ( defined $y ) ;

	return $x->subtract( $y )->abs() ;
}

=head2 exp

Alias : cis

  z == x + iy

  exp( z ) == exp( x + iy )
           == exp( x ) * exp( iy )
           == w

  w == exp( z ) == r * exp( i * t ) 
  -> r == exp( x )
     t == y

In general, the general formula for the natural logarithm does not satisfied for the complex logarithm.

    Log( exp( z ) ) != z

    ( z * w )^x == z^x * w^x          if ( z != 0 and w != 0 and x is integer )
    ( z * w )^x != z^x * w^x          else

    ( exp( z ) )^w != exp( z * w )
      but
    ( exp( z ) )^w == ( exp( z + 2 * PI * n ) )^w
  
However, the following formula generally satisfied even for the complex logarithm.

    exp( z + w ) == exp( z ) * exp( w )



  $z = complex( [ 1 , 2 ] ) ;
  print $z ;                          # 1 + 2 i
  print $z->exp()->exp_form() ;       # 2.71828 * exp( i * ( 0.63662 * PI ) )       ( 2.71828 == exp(1) , 0.63662 * PI == 2 )

=cut

sub exp {
	#-----------------------------------------------------------------------
	#
	# 指数関数
	#
	#   複素数の指数表記が
	#
	#     exp( ix ) == cos( x ) + i * sin( x )
	#
	#   であることから、
	#
	#     exp( ix ) == cis( ix )
	#
	#   とも表記される。 ( cis : "Cosine plus I Sine" の意 )
	#
	#
	#   実数の指数関数
	#
	#                       1
	#     exp( x ) == Σ( ------ * x^n )    ( n = 0 -> ∞ )
	#                       n!
	#
	#   を純虚数 z == iy に適用すると、
	#                                   1                                          1
	#     exp( z ) == Σ( (-1)^n * ----------- * y^(2n) ) + i * Σ( (-1)^n * ------------- * y^(2n+1) )
	#                                ( 2n )!                                   ( 2n+1 )!
	#   となる。
	#
	#   この時、右辺の第 1 項は、 cos( y ) のマクローリン展開式であり、第 2 項は sin( y ) のマクローリン展開に虚数単位を乗じた形になっている。
	#   したがって、
	#
	#     exp( z ) == exp( iy )
	#              == cos( y ) + i * sin( y )
	#
	#   となる。
	#
	#   任意の複素数
	#
	#     z == x + iy
	#       == r * ( cos( theta ) + i * sin( theta ) ) 
	#       == r * exp( i * theta )
	#
	#   を指数関数に掛けると、
	#
	#     exp( z ) == exp( x + iy )
	#              == exp( x ) * exp( iy )                        # オイラー表示
	#              == exp( x ) * ( cos( y ) + i * sin( y ) )      # 極形式
	#              == z'
	#
	#     z' == exp( x ) * ( cos( y ) + i * sin( y ) )
	#        == r' * ( cos( theta' ) + i * sin( theta' ) )
	#        == x' + i * y'
	#
	#     r' == exp( x )
	#     theta' == y
	#
	#     x' == r' * cos( theta' ) == exp( x ) * cos( y )
	#     y' == r' * sin( theta' ) == exp( x ) * sin( y )
	#
	#   が導かれる。
	#
	#
	#   複素指数関数においては、実数における指数法則のいくつかが一般には成り立たない。
	#
	#     Log( exp( z ) ) != z             ..... [1]
	#     ( z * w )^x     != z^x * w^x     ..... [2]
	#     ( exp( z ) )^w  != exp( z * w )  ..... [3]
	#
	#   これは、「一般には」成り立たないということであり、特定の条件下では成立することもある。
	#
	#   [2] のケースは、 z != 0 , w != 0 且つ x が整数の場合には成立する。
	#   [3] のケースは、
	#
	#     ( exp( z ) )^w == ( exp( z + 2PI * n ) )^w
	#
	#   となる整数 n 上の多価関数とみなすことはできる。
	#
	#   以下の指数法則は複素指数関数においても成立する。
	#
	#     exp( z + w ) == exp( z ) * exp( w )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	return __PACKAGE__->new( { 'radius' => $z->real()->exp() , 'theta' => $z->imag() } ) ;
}

sub cis { return $_[0]->exp() ; }

=head2 log

Return the principal value of log( z )

  z == r * exp( i * t )

  log( z ) == log( r * exp( i * t ) )
           == ln( r ) + ln( exp( i * t ) )
           == ln( r ) + ( i * t ) * ln( exp(1) )
           == ln( r ) + ( i * t )
	   == w

  w == log( z ) == ln( r ) + ( i * t )
                == x + iy

  -> x == ln( r )
     y == t

If abs( z ) == 1 , w is pure imaginary complex.

  w == log( z ) == ln( 1 ) + i * t
                == 0 + i * t
                == iy



  $z = complex( [ 1 , 1 ] ) ;
  print $z->exp_form()                # 1.41421 * exp( i * ( 1/4 * PI ) )
  print $z->log() ;                   # 0.346573590279973 + 0.785398163397448 i     ( 0.3465... == ln( sqrt(2) ) , 0.785398... == PI / 4 )

=cut

sub log {
	#-----------------------------------------------------------------------
	#
	# 対数関数
	#
	#   任意の複素数 z を引数とする自然対数の主値 ( principal value ) を返す。
	#
	#   任意の複素数 z の自然対数は、以下のようになる。
	#
	#     z == x + iy
	#       == r * ( cos( theta ) + i * sin( theta ) )
	#       == r * e^( i * theta )
	#
	#     log( z ) == log( r * e^( i * theta ) )
	#              == ln( r ) + ln( e^( i * theta ) )
	#              == ln( r ) + ( i * theta ) * ln( e )
	#              == ln( r ) + ( i * theta )
	#              == z'
	#
	#     z' == ln( r ) + ( i * theta )
	#        == x' + iy'
	#
	#     -> x' == ln( r )
	#        y' == theta
	#
	#   なお、 [ x , y ] が複素平面における単位円上の座標である場合、 r == 1 となり、
	#
	#     x' == ln( 1 ) == 0
	#     -> log( z ) == 0 + i * theta
	#                == iy'
	#
	#   となり、 log( z ) は純虚数となる。
	#
	#
	#   theta は 2 * PI の周期で複数の値を採れるため、複素数の対数関数は多価関数となる。
	#   theta の範囲を ( -1 ) * PI < theta <= PI に採ると log( z ) は単一の値 ( 主値 ) となる。
	#
	#   なお、複素対数の世界では ln という記号は使われないらしい。
	#   log( z ) が複素対数関数を表し、Log( z ) がその主値を返す関数を表すとされている。
	#
	#   任意の複素数 z の主値は、正しくは以下のように表現される。
	#
	#     pv log( z ) == Log( z ) == ln( abs( z ) ) + i * ( Arg( z ) )
	#
	#   この時の Arg( z ) は、 ( -1 ) * PI < Arg( z ) <= PI となる arg( z ) を意味している。
	#
	#
	#   複素対数関数では、
	#
	#     Log( exp( z ) ) == z
	#     Log( z + w ) == Log( z ) + Log( w )
	#
	#   等は、一般には成立しない。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my( $x , $y ) = ( $z->abs()->ln() , $z->arg() ) ;

	return __PACKAGE__->new( [ $x , $y ] ) ;
}

=head2 arg_add , arg_sub

  z == r * exp( i * t )
  
  arg_add( z , t' ) == r * exp( i * ( t + t' ) )
                    == r * exp( i * t ) * exp( i * t' )
                    == z * exp( i * t' )

  arg_sub( z , t' ) == r * exp( i * ( t - t' ) )
                    == r * exp( i * t ) * exp( -i * t' )
                    == z * conj( exp( i * t' ) )



  $z = complex( [ 1 , 1 ] ) ;
  print $z ;                                          # 1 + i
  print $z->arg_add( radian( 45 ) ) ;                 # 0 + 1.414213562373095 i
  print $z->arg_sub( radian( 45 ) ) ;                 # 1.414213562373095

  print $z->exp_form() ;                              # 1.41421 * exp( i * ( 1/4 * PI ) )
  print $z->arg_add( radian( 45 ) )->exp_form() ;     # 1.41421 * exp( i * ( 1/2 * PI ) )
  print $z->arg_sub( radian( 45 ) )->exp_form() ;     # 1.41421 * exp( i * ( 0 * PI ) )

=cut

sub arg_add {
	#-----------------------------------------------------------------------
	#
	# 偏角の加算
	#
	#   任意の複素数
	#
	#     z1 == r1 * exp( i * t1 )
	#     z2 == r2 * exp( i * t2 )
	#
	#   について、
	#
	#     z1 * z2 == ( r1 * exp( i * t1 ) ) * ( r2 * exp( i * t2 ) )
	#             == ( r1 * r2 ) * exp( i * ( t1 + t2 ) )
	#
	#   であり、
	#
	#     arg( z1 * z2 ) ≡ arg( z1 ) + arg( z2 ) ( mod 2PI )
	#
	#   となる。
	#
	#   偏角のみの加算は、 z1 * z2 の演算において r2 == 1 の場合に相当するので、
	#
	#     z1 == r1 * exp( i * t1 )
	#     z2 == exp( i * t )
	#
	#     arg_add( z1 , t ) == r1 * exp( i * ( t1 + t ) )
	#                       == r1 * exp( i * t1 ) * exp( i * t )
	#                       == z1 * exp( i * t )
	#
	#   となる。
	#
	#   複素数オブジェクトの内部表現は直交形式で統一しており、指数表現への変換には比較的大きなコストが必要となる。
	#   複素数の乗算は直交形式で実装されているため、上記の方法では z1 を指数表現へ変換する必要がなく、効率的といえる。
	#   ただし、直交形式での演算は内部的には三角関数の加算となるため、演算誤差が比較的大きくなる可能性がある。
	#
	#-----------------------------------------------------------------------
	my( $z , $t ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta() + $t } ) ;

	return $z->multiply( __PACKAGE__->new( { 'theta' => $t } ) ) ;
}

sub arg_sub {
	#-----------------------------------------------------------------------
	#
	# 偏角の減算
	#
	#   加算の場合と同様に
	#
	#     z1 == r1 * exp( i * t1 )
	#     z2 == r2 * exp( i * t2 )
	#
	#   とおくと、
	#
	#     z1 / z2 == ( r1 * exp( i * t1 ) ) / ( r2 * exp( i * t2 ) )
	#             == ( r1 / r2 ) * exp( i * ( t1 - t2 ) )
	#
	#   であり、
	#
	#     arg( z1 / z2 ) ≡ arg( z1 ) - arg( z2 ) ( mod 2PI )
	#
	#   となる。
	#
	#   偏角のみの減算は、 z1 / z2 の演算において r2 == 1 の場合に相当するので、
	#
	#     arg_sub( z1 , t ) == z1 / exp( i * t )
	#                       == z1 * ( exp( i * t ) )^( -1 )
	#                       == z1 * exp( -i * t )
	#                       == z1 * conj( exp( i * t ) )
	#
	#   となる。
	#
	#   加算の場合と同様、 z1 を指数表現に変換する必要はない。
	#
	#-----------------------------------------------------------------------
	my( $z , $t ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta() - $t } ) ;

	return $z->multiply( __PACKAGE__->new( { 'theta' => $t } )->conj() ) ;
}

=head2 arg_mult , arg_div

  z == r * exp( i * t )
  
  arg_mult( z , n ) == r * exp( i * ( t * n ) )
                    == r * exp( i * ( t * ( n - 1 + 1 ) )
		    == r * exp( i * ( t + t * ( n - 1 ) ) )
                    == r * exp( i * t ) * exp( i * t * ( n - 1 ) )
                    == z * exp( i * t * ( n - 1 ) ) 

  arg_div( z , n )  == r * exp( i * ( t / n ) )
                    == r * exp( i * ( t - ( t - t / n ) )
                    == r * exp( i * t ) / exp( i * ( t - t / n ) )
                    == z / exp( i * ( t - t / n ) )
                    == z * ( exp( i * ( t - t / n ) ) )^(-1)

		                          n - 1
                    == z * exp( -i * t * ------- )
		                            n
                                               n - 1 
		    == z * conj( exp( i * t * ------- ) )
                                                 n

  $z = complex( [ 1 , 1 ] ) ;
  print $z ;                                          # 1 + i
  print $z->arg_mult( 2 ) ;                           # 0 + 1.414213562373095 i
  print $z->arg_div( 2 ) ;                            # 1.306562964876377 + 0.541196100146197 i

  print $z->exp_form() ;                              # 1.41421 * exp( i * ( 1/4 * PI ) )
  print $z->arg_mult( 2 )->exp_form() ;               # 1.41421 * exp( i * ( 1/2 * PI ) )
  print $z->arg_div( 2 )->exp_form() ;                # 1.41421 * exp( i * ( 1/8 * PI ) )

=cut

sub arg_mult {
	#-----------------------------------------------------------------------
	#
	# 偏角の乗算
	#
	#   偏角の乗算は、
	#
	#     z == r * exp( i * t )
	#
	#     z^n == ( r * ex( i * t ) )^n
	#         == r^n * ( exp( i * t ) )^n
	#         == r^n * exp( i * t * n )
	#
	#   より、
	#
	#     arg( z^n ) ≡ n * arg( z ) ( mod 2PI )
	#
	#   であり、
	#
	#     z == r * exp( i * t )
	#
	#     arg_mult( z , n ) == r * exp( i * t * n )
	#
	#                            r^n * exp( i * t * n )
	#                       == --------------------------
	#                                 r^( n - 1 )
	#
	#                                z^n
	#                       == ---------------
	#                            r^( n - 1 )
	#
	#                       == z * ( z / r )^( n - 1 )
	#   となる。
	#
	#   偏角の乗算を n 回の加算とみなすことでも同じ結果が得られる。
	#
	#     z == r * exp( i * t )
	#
	#     arg_mult( z , n ) == r * exp( i * t * n )
	#                       == r * exp( i * ( t + t * ( n - 1 ) ) )
	#                       == r * exp( i * t ) * exp( i * t * ( n - 1 ) )
	#                       == z * exp( i * t * ( n - 1 ) )
	#                       == z * ( exp( i * t ) )^( n - 1 )
	#                       == z * ( z / r )^( n - 1 )
	#
	#   これは、偏角の乗算が z の偏角 t によって生成される
	#
	#     exp( i * t * ( n - 1 ) )
	#
	#   を回転因子とする z の回転となることを示している。
	#
	#
	#   直交表現 z == x + iy を交えると、
	#
	#     r == abs( z ) == sqrt( x^2 + y^2 )
	#
	#     exp( i * t ) == z / r
	#
	#                  == ( r * exp( i * t ) ) / r
	#
	#                            x + iy
	#                  == ---------------------
	#                       sqrt( x^2 + y^2 )
	#
	#
	#     arg_mult( z , n ) == z * ( z / r )^( n - 1 )
	#
	#                                                x + iy
	#                       == ( x + iy ) * ( --------------------- )^( n - 1 )
	#                                           sqrt( x^2 + y^2 )
	#
	#   でもある。
	#
	#   偏角の乗算は以下の三種類の何れでも表現できる。
	#
	#     arg_mult( z , n ) == abs( z ) * exp( i * arg( z ) * n )      .... [1]
	#                       == z * exp( i * arg( z ) * ( n - 1 ) )     .... [2]
	#                       == z * ( z / abs( z ) )^( n - 1 )          .... [3]
	#
	#   それぞれの処理内容を吟味すると、
	#
	#     [1] の場合
	#
	#       abs( z )				直交表現 -> 指数表現
	#       arg( z )				直交表現 -> 指数表現
	#       exp( i * arg( z ) * n )			指数表現 -> 直交表現
	#       abs( z ) * exp( i * arg( z ) * n )	実数と複素数の乗算 ( 直交表現での演算 )
	#
	#     [2] の場合
	#
	#       arg( z )				直交表現 -> 指数表現
	#       exp( i * arg( z ) * ( n - 1 ) )		指数表現 -> 直交表現
	#       z * exp( i * arg( z ) * ( n - 1 ) )	複素数同士の乗算 ( 直交表現での演算 )
	#
	#     [3] の場合
	#
	#       abs( z )				直交表現 -> 指数表現
	#       z / abs( z )				複素数と実数による除算 ( 直交表現での演算 )
	#       ( z / abs( z ) )^( n - 1 )		直交表現 -> 指数表現 -> 偏角の乗算 -> 直交表現
	#       z * ( z / abs( z ) )^( n - 1 )		複素数同士の乗算 ( 直交表現での演算 )
	#
	#   となる。
	#
	#   最も簡潔に記述できるのは [1] だが、処理コストの面では [2] が有利と言える。
	#   また、 [2] の演算が「偏角の乗算」の本質を表現していると言う点でも価値が高い。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( ref( $n ) ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta() * $n } ) ;
	
	my $r = undef ;

	my $t = ( $z->arg() * ( $n - 1 ) ) % ( pi() * 2 ) ;	# t == ( arg( z ) * ( n - 1 ) ) % 2PI
	$r = $z * __PACKAGE__->new( { 'theta' => $t } ) ;	# z * exp( i * t )

	return $r ;
}

sub arg_div {
	#-----------------------------------------------------------------------
	#
	# 偏角の除算
	#
	#   偏角の除算は、
	#
	#     z == r * exp( i * t )
	#
	#     z^(1/n) == ( r * exp( i * t ) )^( 1/n )
	#
	#             == r^( 1/n ) * ( exp( i * t ) )^( 1/n )
	#
	#                                      t
	#             == r^( 1/n ) * exp( i * --- )
	#                                      n
	#   より、
	#
	#     arg( z^( 1/n ) ) ≡ arg( z ) / n ( mod 2PI )
	#
	#   であり、
	#
	#     z == r * exp( i * t )
	#
	#     arg_div( z , n ) == r * exp( i * t / n )
	#                      == r * exp( i * ( t - ( t - t/n ) ) )
	#                      == r * exp( i * t ) / exp( i * ( t - t/n ) )
	#                      == z / exp( i * ( t - t/n ) )
	#                      == z * ( exp( i * ( t - t/n ) ) )^( -1 )
	#                      == z * exp( -i * ( t - t/n ) )
	#
	#                                            n - 1
	#                      == z * exp( -i * t * ------- )
	#                                              n
	#
	#                                                 n - 1
	#                      == z * conj( exp( i * t * ------- ) )
	#                                                   n
	#   となる。
	#
	#   これは、偏角の除算が z の偏角 t によって生成される
	#
	#                   n - 1
	#     exp( i * t * -------- )
	#                     n
	#
	#   を回転因子とする z の逆回転となることを示している。
	#
	#
	#   偏角の除算は以下の三種類の何れでも表現できる。
	#
	#                                               arg( z )
	#     arg_div( z , n ) == abs( z ) * exp( i * ------------ )            .... [1]
	#                                                  n
	#
	#                                                         n - 1
	#                      == z * conj( exp( i * arg( z ) * --------- ) )   .... [2]
	#                                                           n
	#
	#                                          z             n - 1 
	#                      == z * conj( ( ------------ )^( --------- ) )    .... [3]
	#                                       abs( z )           n
	#
	#   偏角の乗算と同様、 [1] が最も簡潔に記述できる一方、 [2] の演算コストが比較的低くなる。
	#   [2] が「偏角の除算」の本質を表現していると言う点も同じ。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( ref( $n ) ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta() / $n } ) ;

	my $c = ( $n - 1 ) / $n ;
	my $t = $z->arg()->multiply( $c ) % ( pi() * 2 ) ;		# t == ( arg( z ) * ( n - 1 )/n ) % 2PI
	my $r = $z * __PACKAGE__->new( { 'theta' => $t } )->conj() ;	# z * conj( exp( i * t ) )

	return $r ;
}

=head2 arg_pow , arg_root

  z == r * exp( i * t )

  arg_pow( z , n )  == r * exp( i * t^n )
                    == r * exp( i * t * t^(n-1) ) 
                    == r * ( exp( i * t ) )^( t^(n-1) )
                    == r * ( exp( i * t ) * ( exp( i * t ) )^( t^(n-1) - 1 ) )
                    == z * ( exp( i * t ) )^( t^(n-1) - 1 )
                    == z * exp( i * t * ( t^(n-1) - 1 ) )
                    == z * exp( i * ( t^n - t ) )

  arg_root( z , n ) == r * exp( i * t^(1/n) )
                    == arg_pow( z , 1/n )
                    == z * exp( i * ( t^(1/n) - t ) )
                    == z * exp( i * ( root( t , n ) - t ) )


=cut

sub arg_pow {
	#-----------------------------------------------------------------------
	#
	# 偏角の冪乗算
	#
	#   任意の複素数 z について偏角の冪乗算を展開し、 z を括り出す。
	#
	#     z == r * exp( i * t )
	#
	#     arg_pow( z , n ) == r * exp( i * t^n )
	#                      == r * exp( i * t * t^( n - 1 ) )
	#                      == r * ( exp( i * t ) )^( t^( n - 1 ) )
	#                      == r * ( exp( i * t ) * ( exp( i * t ) )^( t^( n - 1 ) - 1 ) )
	#                      == z * ( exp( i * t ) )^( t^( n - 1 ) - 1 )
	#                      == z * exp( i * t * ( t^( n - 1 ) - 1 ) )
	#                      == z * exp( i * ( t^n - t ) )
	#
	#   結局のところ、
	#
	#     z == r * exp( i * t )
	#     t == arg( z )
	#
	#     arg_pow( z , n ) == r * exp( i * t^n )
	#                      == z * exp( i * ( t^n - t ) )
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( ref( $n ) ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta() ** $n } ) ;
	
	my $t = $z->arg() ;
	$t = $t->power( $n ) - $t ;
	$t %= ( pi() * 2 ) ;

	my $r = $z * __PACKAGE__->new( { 'theta' => $t } ) ;

	return $r ;
}

sub arg_root {
	#-----------------------------------------------------------------------
	#
	# 偏角の冪根算
	#
	#   任意の複素数 z について偏角の冪根算を展開し、 z を括り出す。
	#
	#     z == r * exp( i * t )
	#
	#     arg_root( z , n ) == r * exp( i * t^( 1/n ) )
	#                       == arg_pow( z  , 1/n )
	#                       == z * exp( i * ( t^( 1/n ) - t ) )
	#                       == z * exp( i * ( root( t , n ) - t ) )
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( ref( $n ) ) ;

	#return __PACKAGE__->new( { 'radius' => $z->radius() , 'theta' => $z->theta()->root( $n ) } ) ;
	
	my $t = $z->arg() ;
	$t = $t->root( $n ) - $t ;
	$t %= ( pi() * 2 ) ;

	my $r = $z * __PACKAGE__->new( { 'theta' => $t } ) ;

	return $r ;
}

=head2 arg_double

By the Weierstrass substitution ( the Tangent half-angle substitution ),

  t == tan( x / 2 )

                        1 + i * t          1 + i * t
  z == exp( i * x ) == ----------- == -------------------
                        1 - i * t      conj( 1 + i * t )

Then,

  z1 == exp( i * x )
  z2 == exp( i * ( x * 2 ) )

  -> t == tan( arg( z1 ) ) == tan( x )

           imag( z1 )
       == ------------
           real( z1 )

  -> w == 1 + i * t


  -> z2 == exp( i * ( x * 2 ) )

                w
        == -----------
	    conj( w )

In general,

  z1 == r * exp( i * x )

  z2 == r * exp( i * ( x * 2 ) ) 

                         w
     == abs( z1 ) * ------------
                     conj( w )

=cut

sub arg_double {
	#-----------------------------------------------------------------------
	#
	# 偏角の二倍算
	#
	#   ワイエルシュトラスの置換に基づき、偏角を二倍した結果を返す。
	#
	#   ワイエルシュトラスの置換 ( Weierstrass substitution ; Tangent Half-angle substitution ) に拠ると、
	#
	#     t == tan( x / 2 )
	#                            1 + i * t 
	#     z == exp( i * x ) == -------------
	#                            1 - i * t
	#
	#   となる。 ( 詳細については MyDecimal クラスの thas メソッドを参照のこと。 )
	#
	#   ここから、
	#
	#     z1 == exp( i * x )
	#     z2 == exp( i * ( x * 2 ) )
	#
	#   とおくと、
	#                                            imag( z1 )
	#     t == tan( arg( z1 ) ) == tan( x ) == --------------
	#                                            real( z1 )
	#     w == 1 + i * t
	#
	#     z2 == exp( i * ( x * 2 ) ) 
	#
	#               w
	#        == -----------
	#            conj( w )
	#
	#   と言う手順で偏角の二倍算が実現できる。
	#
	#
	#   任意の複素数 
	#
	#     z1 == r * exp( i * x )
	#
	#   について一般化すると、
	#
	#
	#     z2 == r * exp( i * ( x * 2 ) )
	#
	#                            w
	#        == abs( z1 ) * ------------
	#                        conj( w )
	#
	#   となる。
	#
	#   ワイエルシュトラスの置換では real( z ) == 0 の場合に演算不能となるが、
	#
	#                              imag( z1 )
	#                     1 + i * ------------
	#         w                    real( z1 )
	#    ----------- == -----------------------
	#     conj( w )                imag( z1 )
	#                     1 - i * ------------
	#                              real( z1 )
	#
	#                    real( z1 ) + i * imag( z1 )
	#                == -----------------------------
	#                    real( z1 ) - i * imag( z1 )
	#
	#     real( z1 ) == 0 より、
	#
	#           w
	#      ----------- == -1
	#       conj( w )
	#
	#     z2 == abs( z1 ) * (-1) 
	#
	#   とすることができる。
	#
	#
	#   三角関数の倍角の定理では演算誤差が比較的大きくなるが、ワイエルシュトラスの置換を用いると、精度よく高速な演算が可能となる。
	#   ( このライブラリの標準実装では、演算結果の実部と虚部に小数点以下 40 桁目以降で演算誤差が生じる程度。 )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;
	return undef	if ( $z->is_zero() ) ;

	my $r = undef ;
	my( $re , $im ) = $z->as_array() ;

	if ( $re == 0 ) {
		$r = $z->abs() * (-1) ;
	}
	else {
		my $w = __PACKAGE__->new( [ 1 , $im / $re ] ) ;
		$r = $z->abs() * ( $w / $w->conj() ) ;
	}

	return $r ;
}

=head2 circle_group

The circle_group method will return complex values, which are separated a circle in the complex plane to n pieces.

  z == x + iy
    == r * exp( i * t )

  Z == circle_group( z , n )

                            2 * PI 
  -> Z[k] == z * exp( i * -------- * k )               ( k == 0 -> n - 1 )
                              n

                                 2 * PI
          == r * exp( i * ( t + -------- * k ) )       ( k == 0 -> n - 1 )
	                           n
When define w as follows,

                    2 * PI              
  w[k] == exp( i * -------- * k )                      ( k == 0 -> n - 1 )
                      n

All of these w[k] are roots of unity, and about all w[k]

  ( w[k] )^n == 1
                                  2 * PI 
  arg( w[k] ) - arg( w[k-1] ) == --------
                                    n

This method is a core method about "root" , "fft" or so on.

=cut

sub circle_group {
	#-----------------------------------------------------------------------
	#
	# 円周群 ( circle group )
	#
	#   円周群は、円を位相 n で分割した扇形 ( 位相 n の部分群 ) の集合のようなもの。
	#
	#   円周群は複素数の通常の積に関して閉じた群をなす。
	#   円周群は 1 の原始 n 乗根で生成される巡回群であり、唯一つの位数 n の部分群を持つ。
	#   有理数体に円周群を添加した代数体は円分体 ( cyclotomic field ) と呼ばれる。
	#   円分体そのものやその部分体を指して円体と呼ばれることもある。
	#   ( cyclotomic は、ギリシャ語の cyclo ( circle ) と tomos ( cut , divide ) を組み合わせた造語。 )
	#
	#
	#   ここでは、複素数 z の偏角 theta を基点として、複素平面上の円を n 個に分割した時に得られる複素数の集合を返すこととする。
	#
	#   Z == circle_group( z , n )   ( k == 0 -> n - 1 ) と定義すると、
	#
	#     r == abs( z )
	#     theta == arg( z )
	#
	#                                        2PI * k
	#     Z[ k ] == r * exp( i * ( theta + ----------- ) )               ( k = 0 -> n - 1 )
	#                                           n
	#
	#                                                 2PI * k
	#            == r * exp( i * theta ) * exp( i * ----------- ) )      ( k = 0 -> n - 1 )
	#                                                    n
	#
	#                              2PI * k
	#            == z * exp( i * ----------- )                           ( k = 0 -> n - 1 ) 
	#                                 n
	#
	#   となる。
	#
	#                        2PI * k
	#   この時、  exp( i * ----------- ) は、複素平面上の単位円を偏角 0 を起点にして n 個に分割した円周群となっている。
	#                           n
	#
	#   これは 1 の n 乗根の集合であり、 1 の原始 n 乗根で生成される巡回群となっている。
	#
	#   ここで、
	#
	#                          2PI * k
	#     w[ k ] == exp( i * ----------- )
	#                             n
	#
	#   とおくと、
	#                          2PI * 0
	#     w[ 0 ] == exp( i * ----------- ) == exp( 0 ) == 1
	#                             n
	#
	#                          2PI * 1
	#     w[ 1 ] == exp( i * ----------- )
	#                             n
	#
	#                          2PI * 2                     2PI       2PI                     2PI                  2PI
	#     w[ 2 ] == exp( i * ----------- ) == exp( i * ( ------- + ------- ) ) == exp( i * ------- ) * exp( i * ------- ) == w[ 1 ] * w[ 1 ]
	#                             n                         n         n                       n                    n
	#
	#                          2PI * 3                     2PI * 2       2PI                     2PI * 2                  2PI
	#     w[ 3 ] == exp( i * ----------- ) == exp( i * ( ----------- + ------- ) ) == exp( i * ----------- ) * exp( i * ------- ) == w[ 2 ] * w[ 1 ]
	#                             n                           n           n                         n                      n
	#
	#     w[ 4 ] == w[ 3 ] * w[ 1 ]
	#
	#     w[ 5 ] == w[ 4 ] * w[ 1 ]
	#
	#     ........
	#
	#     w[ n ] == w[ n - 1 ] * w[ 1 ]
	#
	#
	#   と言う関係になる。
	#
	#   よって、
	#
	#     Z == circle_group( z , n )
	#
	#                         2PI * k 
	#     w[ k ] == exp( i * --------- )                 ( k == 0 -> n - 1 )
	#                            n
	#
	#     Z[ k ] == z * w[ k ]                           ( k == 0 -> 1 ) 
	#            == z * w[ k-1 ] * w[ 1 ]                ( k == 2 -> n - 1 )
	#
	#   となり、偏角の整数倍を複素数の乗算を用いた漸化式で表現することができる。
	#
	#   複素数の乗算は三角関数の加法定理を用いることで比較的迅速に値を求めることができる。
	#   しかし、 k の値が大きくなるにつれて演算誤差が大きくなる傾向があり、実用に耐えなくなる。
	#
	#   このため、偏角の乗算は 2PI/n の倍数から都度求める形を採っている。
	#   これは arg_mult メソッドと同様の処理だが、 w[1] を繰り返し多用する必要があるため、 arg_mult そのものは使っていない。
	#
	#   偏角の乗算は、偏角 t から cos( t ) , sin( t ) を求める処理であり、演算コストは比較的高くなる。
	#   よって、偏角の乗算を実行する頻度を極力減らすことが望ましい。
	#
	#   ここから先は、
	#
	#                         2PI * k
	#     w[ k ] == exp( i * --------- ) == x + iy
	#                            n
	#
	#   に注視して演算コストの削減方法を考える。
	#
	#
	#   ・複素共役
	#
	#     k が 0 < k < n/2 の範囲にある場合、 n の偶奇に関わらず w[ k ] は n/2 < k < n の範囲に複素共役を持つ。
	#     この場合、
	#
	#       w[ k ]     == x + iy
	#
	#       w[ n - k ] == conj( w[ k ] )
	#                  == x - iy
	#
	#     であり、 w[ k ] の探索範囲を 0 < k < n/2 の範囲に削減できる。
	#
	#     複素共役によって求められる値は、複素平面上の第三象限、第四象限に現れる値となる。
	#
	#
	#   ・n が偶数の場合
	#
	#     n が偶数であれば、 0 < k < n/4 の範囲にある w[ k ] は、 n/4 < k < n/2  の範囲に虚軸に対して対称となる値を持つ。
	#     n が偶数であるため、 n/2 が偏角 PI を表す添え字となり、
	#
	#       w[ k ]       == x + iy
	#
	#       w[ n/2 - k ] == -x + iy                      ( n/2 == PI )
	#                    == conj( w[ k ] ) * (-1)
	#
	#     これは第二象限上に現れる値となる。
	#
	#
	#   ・n/2 が偶数の場合
	#
	#     n > 8 の時、 n/2 が偶数であれば、 0 < k < n/8 の範囲にある値は、 n/8 < k < n/4 の範囲に偏角 PI/4 を境にして対象となる値を持つ。
	#     n/2 が偶数であるため、 n/4 が偏角 PI/2 を表す添え字となり、
	#
	#       w[ k ]       == x + iy
	#
	#       w[ n/4 - k ] == y + ix                       ( n/4 == PI/2 )
	#
	#     これは、第一象限の後半の領域に現れる値となる。
	#
	#
	#   ・n が奇数の場合
	#
	#     第二象限上の値は、
	#
	#       n ==  3 -> w[1] == exp( i *  2/3  * PI ) == conj( exp( i * 1/3  * PI ) ) * (-1)
	#
	#       n ==  5 -> w[2] == exp( i *  4/5  * PI ) == conj( exp( i * 1/5  * PI ) ) * (-1)
	#
	#       n ==  7 -> w[2] == exp( i *  4/7  * PI ) == conj( exp( i * 3/7  * PI ) ) * (-1)
	#                  w[3] == exp( i *  6/7  * PI ) == conj( exp( i * 1/7  * PI ) ) * (-1) 
	#
	#       n ==  9 -> w[3] == exp( i *  6/9  * PI ) == conj( exp( i * 3/9  * PI ) ) * (-1)
	#                  w[4] == exp( i *  8/9  * PI ) == conj( exp( i * 1/9  * PI ) ) * (-1)
	#
	#       n == 11 -> w[3] == exp( i *  6/11 * PI ) == conj( exp( i * 5/11 * PI ) ) * (-1)
	#                  w[4] == exp( i *  8/11 * PI ) == conj( exp( i * 3/11 * PI ) ) * (-1)
	#                  w[5] == exp( i * 10/11 * PI ) == conj( exp( i * 1/11 * PI ) ) * (-1)
	#
	#     という規則性を持つ。
	#
	#     また、第一象限の後半に値を持つ場合、
	#
	#       n ==  5 -> w[1] == exp( i * 2/5  * PI ) == imag( exp( i * ( PI/2 - 2/5 * PI ) ) ) + i * real( exp( i * ( PI/2 - 2/5 * PI ) ) )
	#                                               == imag( exp( i * 1/10 * PI ) ) + i * real( exp( i * 1/10 * PI ) )
	#
	#       n ==  7 -> w[1] == exp( i * 2/7  * PI ) == imag( exp( i * ( PI/2 - 2/7 * PI ) ) ) + i * real( exp( i * ( PI/2 - 2/7 * PI ) ) )
	#                                               == imag( exp( i * 3/14 * PI ) ) + i * real( exp( i * 3/14 * PI ) )
	#
	#       n ==  9 -> w[2] == exp( i * 4/9  * PI ) == imag( exp( i * ( PI/2 - 4/9 * PI ) ) ) + i * real( exp( i * ( PI/2 - 4/9 * PI ) ) )
	#                                               == imag( exp( i * 1/18 * PI ) ) + i * real( exp( i * 1/18 * PI ) )
	#
	#       n == 11 -> w[2] == exp( i * 4/11 * PI ) == imag( exp( i * ( PI/2 - 4/11 * PI ) ) ) + i * real( exp( i * ( PI/2 - 4/11 * PI ) ) )
	#                                               == imag( exp( i * 3/22 * PI ) ) + i * real( exp( i * 3/22 * PI ) )
	#
	#     と表現することができる。
	#
	#     同様に、第二象限上の値を求める際に使用した値は、
	#
	#       exp( i * 1/3  * PI ) == imag( exp( i * ( PI/2 - 1/3 * PI ) ) ) + i * real( exp( i * ( PI/2 - 1/3 * PI ) ) )
	#                            == imag( exp( i * 1/6 * PI ) ) + i * real( exp( i * 1/6 * PI ) )
	#                            == exp( i * 2/6 * PI ) 
	#
	#       exp( i * 1/5  * PI ) == imag( exp( i * ( PI/2 - 1/5 * PI ) ) ) + i * real( exp( i * ( PI/2 - 1/5 * PI ) ) )
	#                            == imag( exp( i * 3/10 * PI ) ) + i * real( exp( i * 3/10 * PI ) )
	#                            == exp( i * 2/10 * PI )
	#
	#       exp( i * 1/7  * PI ) == imag( exp( i * ( PI/2 - 1/7 * PI ) ) ) + i * real( exp( i * ( PI/2 - 1/7 * PI ) ) )
	#                            == imag( exp( i * 5/14 * PI ) ) + i * real( exp( i * 5/14 * PI ) )
	#                            == exp( i * 2/14 * PI )
	#
	#       exp( i * 3/7  * PI ) == imag( exp( i * ( PI/2 - 3/7 * PI ) ) ) + i * real( exp( i * ( PI/2 - 3/7 * PI ) ) )
	#                            == imag( exp( i * 1/14 * PI ) ) + i * real( exp( i * 1/14 * PI ) )
	#                            == exp( i * 6/14 * PI )
	#
	#       exp( i * 1/9  * PI ) == imag( exp( i * ( PI/2 - 1/9 * PI ) ) ) + i * real( exp( i * ( PI/2 - 1/9 * PI ) ) )
	#                            == imag( exp( i * 7/18 * PI ) ) + i * real( exp( i * 7/18 * PI ) )
	#                            == exp( i * 2/18 * PI )
	#
	#       exp( i * 3/9  * PI ) == imag( exp( i * ( PI/2 - 3/9 * PI ) ) ) + i * real( exp( i * ( PI/2 - 3/9 * PI ) ) )
	#                            == imag( exp( i * 3/18 * PI ) ) + i * real( exp( i * 3/18 * PI ) )
	#                            == exp( i * 6/18 * PI )
	#
	#       exp( i * 1/11 * PI ) == imag( exp( i * ( PI/2 - 1/11 * PI ) ) ) + i * real( exp( i * ( PI/2 - 1/11 * PI ) ) )
	#                            == imag( exp( i * 9/22 * PI ) ) + i * real( exp( i * 9/22 * PI ) )
	#                            == exp( i * 2/22 * PI )
	#
	#       exp( i * 3/11 * PI ) == imag( exp( i * ( PI/2 - 3/11 * PI ) ) ) + i * real( exp( i * ( PI/2 - 3/11 * PI ) ) )
	#                            == imag( exp( i * 5/22 * PI ) ) + i * real( exp( i * 5/22 * PI ) )
	#                            == exp( i * 6/22 * PI )
	#
	#       exp( i * 5/11 * PI ) == imag( exp( i * ( PI/2 - 5/11 * PI ) ) ) + i * real( exp( i * ( PI/2 - 5/11 * PI ) ) )
	#                            == imag( exp( i * 1/22 * PI ) ) + i * real( exp( i * 1/22 * PI ) )
	#                            == exp( i * 10/22 * PI )
	#
	#     と表現することができる。
	#
	#     つまり、 n が奇数であっても、分割数を 2 倍に増やせばコストの高い処理を第一象限の前半に集中させることができる。
	#
	#   以上の点を踏まえて、偏角の乗算を第一象限の前半に現れる値に集約する方法を考える。
	#
	#   2PI の分割数を 8n で定義すると、 n の偶奇に寄らず、
	#
	#     w[1]   == exp( i * 2PI / 8n ) == exp( i * PI / 4n )
	#
	#     w[0]   == w[1] * 0  == exp( 0 )            ==  1
	#     w[n]   == w[1] * n  == exp( i * PI * 1/4 )
	#     w[2n]  == w[1] * 2n == exp( i * PI * 1/2 ) ==  i
	#     w[4n]  == w[1] * 4n == exp( i * PI * 1/1 ) == -1
	#   
	#   が定義できる。
	#   ( w[3n] , w[5n] , w[6n] , w[7n] , w[8n] も定義できるが、ここでは不要なので割愛する。 )
	#
	#   この時、第二象限上に現れる 2n < k < 4n の範囲の値 w[k] は、第一象限上に現れる 0 < j < 2n の範囲の w[j] を用いて、
	#
	#     w[ k ] == w[ 4n - j ] == conj( w[ j ] ) * (-1)
	#
	#   と定義することができる。
	#
	#   また、第一象限上に現れる値の内、n < k < 2n の範囲の値は、 0 < j < n となる j を用いて、
	#
	#     w[ k ] == w[ 2n - j ] == imag( w[j] ) + i * real( w[j] )
	#
	#   と定義することができる。
	#
	#   n が偶数であれば、第一象限から取り出すべき値と第二象限から取り出すべき値は虚軸に対して完全に対称な値となるため、
	#   刻み幅を 8 として 0 < k < 2n の範囲を探索すればよい。
	#
	#   n が奇数の場合、第一象限から取り出すべき値と第二象限から取り出すべき値は虚軸に対して対称とはならないが、
	#   刻み幅を 4 として扱う数列を 2 倍に増やすことで、探索範囲を 0 < k < 2n に絞ることができる。
	#
	#   探索範囲を 0 < k < 2n に設定することにより、 w[k] の導出に必要な第一象限上の値 w[j] の添え字 j は、
	#
	#      0 < k < n  -> j == k
	#      n < k < 2n -> j == 2n - k
	#
	#   となる。
	#
	#   w[j] 及び w[j] から派生して得られる値を全て埋めると、 0 < arg( w[k] ) < PI の範囲の値 r[k] は、
	#
	#     r[k] == w[ k * 8 ]          ( k == 1 -> int( n / 2 ) )
	#
	#   として確定される。
	#
	#   これに r[k] の複素共役と r[0] を添加することで 1 の n 乗根としての数列 r が得られる。
	#   最後に r の各要素に z を乗じることによって、戻り値としての z の n 乗根が完成する。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;

	return ()	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n || 1 )	unless ( ref( $n ) ) ;
	return ()	unless ( $n->is_integer() ) ;
	return ()	unless ( $n > 0 ) ;
	return ( $z )	if ( $n == 1 ) ;

	$n = $n->value() ;

	my $pi = pi() ;
	my $pi2 = $pi * 2 ;

	#
	# 演算過程で使用する n を 8 * n で初期化し、探索する刻み幅を設定する。
	#
	# 刻み幅は n が奇数ならば 4 とし、偶数ならば 8 とする。
	# これにより、探索範囲を arg( w[k] ) < PI/2 に絞ることができる。
	#
	my $n1 = $n * 8 ;
	my $step = ( ( $n & 1 ) == 1 ) ? 4 : 8 ;

	#
	# PI , PI/2 , PI/4 に当たる添え字
	#
	my $pk  = $n1 / 2 ;		# PI       ( 8n / 2 == 4n )
	my $hpk = $n1 / 4 ;		# PI/2     ( 8n / 4 == 2n )
	my $qpk = $n1 / 8 ;		# PI/4     ( 8n / 8 ==  n )

	#
	# 2PI / 8n に当たる偏角
	#
	my $arg1 = $pi2 / $n1 ;

	#
	# 8n についての円周群 ( root( 8n ) ) を辿りながら必要な箇所を計算する。
	#
	my $cs_qpi = new_decimal( 2 )->sqrt() / 2 ;			# sqrt(2)/2 == 1/sqrt(2)
	my $w = [] ;
	$w->[0] = __PACKAGE__->new( 1 ) ;				# $w->[0] == 1
	$w->[1] = __PACKAGE__->new( { 'arg' => $arg1 } ) ;		# $w->[1] == exp( i * 2PI / 8n )

	$w->[ $pk ]  = __PACKAGE__->new( [ -1 ,  0 ] ) ;		# $w->[ $pk ]  == exp( i * PI )   == -1
	$w->[ $hpk ] = __PACKAGE__->new( [  0 ,  1 ] ) ;		# $w->[ $hpk ] == exp( i * PI/2 ) == i
	$w->[ $qpk ] = __PACKAGE__->new( [ $cs_qpi , $cs_qpi ] ) ;	# $w->[ $qpk ] == exp( i * PI/4 ) == 1/2 * ( sqrt(2) + i * sqrt(2) )

	$w->[ $pk - 1 ]    = $w->[1]->conj() * (-1) ;			# $w->[1] を虚軸で反転させた値。
	$w->[ $pk - $qpk ] = $w->[ $qpk ]->conj() * (-1) ;		# $w->[ $qpk ] を虚軸で反転させた値。 == exp( i * 3/4 * PI ) 

	foreach ( my $k = $step ; $k < $hpk ; $k += $step ) {

		next	if ( defined $w->[ $k ] ) ;

		#
		# k を第一象限の前半に写像した位置を j として定義する。
		#
		#   n  < k < 2n -> k == 2n - j -> j == 2n - k
		#
		my $j = $k ;
		if ( $j > $qpk ) { $j = $hpk - $j ; }	# 第一象限の後半 -> 第一象限の前半

		#
		# w[j] とこれを虚軸で反転させた値。
		#
		#                            2PI
		#   w[j] == w[1] * exp( i * ----- * ( j - 1 ) ) 
		#                            8n
		#
		#   w[ 4n - j ] == conj( w[j] ) * (-1)
		#
		unless ( defined $w->[ $j ] ) {
			#
			# w[j] を偏角の乗算で求める。
			#
			my $t = ( $arg1 * ( $j - 1 ) ) % $pi2 ;
			$w->[ $j ] = $w->[1] * __PACKAGE__->new( { 'arg' => $t } ) ;

			#
			# w[j] を虚軸で反転させた値。
			#
			$w->[ $pk - $j ] = $w->[ $j ]->conj() * (-1) ;
		}

		#
		# 第一象限の後半に位置する値とこれを虚軸で反転させた値。
		#
		#   w[ 2n - j ] == imag( w[j] ) + i * real( w[j] )
		#
		#   w[ 4n - ( 2n - 1 ) ] == w[ 2n + j ]
		#                        == conj( w[ 2n - j ] ) * (-1)
		#
		unless ( defined $w->[ $hpk - $j ] ) {
			$w->[ $hpk - $j ] = __PACKAGE__->new( [ reverse( $w->[ $j ]->as_array() ) ] ) ;
			$w->[ $hpk + $j ] = $w->[ $hpk - $j ]->conj() * (-1) ;
		}
	}

	#
	# n についての円周群としてマップする。
	#
	my $r = [] ;
	$r->[0] = $w->[0] ;

	foreach my $k ( 1 .. int( $n / 2 ) ) {
		$r->[ $k ]      = $w->[ $k * 8 ] ;
		$r->[ $n - $k ] = $r->[ $k ]->conj() ;
	}

	#
	# 戻り値は $r を回転因子として $z を回転した値となる。
	#
	unless ( $z == 1 ) {
		foreach my $k ( 0 .. $#{ $r } ) {
			$r->[ $k ] *= $z ;
		}
	}

	return @{ $r } ;
}

sub circle_group01 {
	#-----------------------------------------------------------------------
	#
	# 円周群 ( circle group )
	#
	#   円周群は、円を位相 n で分割した扇形 ( 位相 n の部分群 ) の集合のようなもの。
	#
	#   円周群は複素数の通常の積に関して閉じた群をなす。
	#   円周群は 1 の原始 n 乗根で生成される巡回群であり、唯一つの位数 n の部分群を持つ。
	#   有理数体に円周群を添加した代数体は円分体 ( cyclotomic field ) と呼ばれる。
	#   円分体そのものやその部分体を指して円体と呼ばれることもある。
	#   ( cyclotomic は、ギリシャ語の cyclo ( circle ) と tomos ( cut , divide ) を組み合わせた造語。 )
	#
	#
	#   ここでは、複素数 z の偏角 theta を基点として、複素平面上の円を n 個に分割した時に得られる複素数の集合を返すこととする。
	#
	#   Z[ k ] = circle_group( z , n )   ( k == 0 -> n - 1 ) と定義すると、
	#
	#     r == abs( z )
	#     theta == arg( z )
	#
	#                                        2PI * k
	#     Z[ k ] == r * exp( i * ( theta + ----------- ) )               ( k = 0 -> n - 1 )
	#                                           n
	#
	#                                                 2PI * k
	#            == r * exp( i * theta ) * exp( i * ----------- ) )      ( k = 0 -> n - 1 )
	#                                                    n
	#
	#                              2PI * k
	#            == z * exp( i * ----------- )                           ( k = 0 -> n - 1 ) 
	#                                 n
	#
	#   となる。
	#
	#                        2PI * k
	#   この時、  exp( i * ----------- ) は、複素平面上の単位円を偏角 0 を起点にして n 個に分割した円周群となっている。
	#                           n
	#
	#   これは 1 の n 乗根の集合であり、 1 の原始 n 乗根で生成される巡回群となっている。
	#
	#   ここで、
	#
	#                          2PI * k
	#     w[ k ] == exp( i * ----------- )
	#                             n
	#
	#   とおくと、
	#                          2PI * 0
	#     w[ 0 ] == exp( i * ----------- ) == exp( 0 ) == 1
	#                             n
	#
	#                          2PI * 1
	#     w[ 1 ] == exp( i * ----------- )
	#                             n
	#
	#                          2PI * 2                     2PI       2PI                     2PI                  2PI
	#     w[ 2 ] == exp( i * ----------- ) == exp( i * ( ------- + ------- ) ) == exp( i * ------- ) * exp( i * ------- ) == w[ 1 ] * w[ 1 ]
	#                             n                         n         n                       n                    n
	#
	#                          2PI * 3                     2PI * 2       2PI                     2PI * 2                  2PI
	#     w[ 3 ] == exp( i * ----------- ) == exp( i * ( ----------- + ------- ) ) == exp( i * ----------- ) * exp( i * ------- ) == w[ 2 ] * w[ 1 ]
	#                             n                           n           n                         n                      n
	#
	#     w[ 4 ] == w[ 3 ] * w[ 1 ]
	#
	#     w[ 5 ] == w[ 4 ] * w[ 1 ]
	#
	#     ........
	#
	#     w[ n ] == w[ n - 1 ] * w[ 1 ]
	#
	#
	#   と言う関係になる。
	#
	#   これは、
	#
	#     ・任意の w[ k ] が、複素単位円上で w[ 1 ] の偏角の乗算を繰り返すことで得られる値であること。
	#     ・また、任意の w[ k ] が w[ k - 1 ] と w[ 1 ] の積で表されること。
	#
	#   を示している。
	#
	#   偏角の乗算は上記のとおり漸化式として実装することができるが、複素数の乗算は三角関数の加法定理に基づいて実装してあるため、 k の値が進むにつれて誤差が大きくなってしまう。
	#   このため、ここでは arg_mult メソッドで用いている手法で実装してある。
	#
	#   arg_mult を直接使っても実用上は問題ないが、 w[ 1 ] の偏角を繰り返し利用するため、コストを低減する目的からこのような実装になっている。
	#
	#
	#   n の偶奇に関わらず、 0 <= arg( w[ k ] ) < PI の範囲の w[ k ] は -PI < arg( w[ k ] ) < 0 の範囲に複素共役を持つ。
	#
	#   当然のことながら、この二つの値の関係は、
	#
	#     w[ k ] == x + iy
	#
	#     w[ n - k ] == conj( w[ k ] )
	#                == x - iy
	#
	#   となる。
	#
	#   n が偶数であれば、 0 <= arg( w[ k ] ) < 1/2 * PI の範囲の w[ k ] には、 1/2 * PI < arg( w[ k ] ) < PI の範囲に虚軸について線対称な値が存在する。
	#
	#   この時、この二つの値の関係は
	#
	#     w[ k ] == x + iy
	#
	#     w[ n/2 - k ] == -x + iy                      ( n/2 == PI )
	#                  == conj( w[ k ] ) * (-1)
	#
	#   となる。
	#
	#   更に、 n/2 が偶数であれば、 0 <= arg( w[ k ] ) < 1/4 * PI の範囲の w[ k ] には、 1/4 * PI < arg( w[ k ] ) < 1/2 * PI の範囲に
	#   原点と偏角 PI/4 の点を結んだ線について線対称となる値が存在する。
	#
	#   この時、この二つの値の関係は
	# 
	#     w[ k ] == x + iy
	#
	#     w[ n/4 - k ] == y + ix                       ( n/4 == PI/2 )
	#
	#   となる。
	#
	#   よって、偏角の乗算で求めるべき値は、
	#
	#     ・n が奇数であれば PI まで
	#     ・n/2 が偶数であれば PI/4 まで
	#     ・n/2 が奇数であれば PI/2 まで
	#
	#   でよく、残りの値は直行表現における x , y の値の変換のみで実装することができる。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return ()	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n || 1 )	unless ( ref( $n ) ) ;
	return ()	unless ( $n->is_integer() ) ;
	return ()	unless ( $n > 0 ) ;
	return ( $z )	if ( $n == 1 ) ;

	my $pi = pi() ;
	my $pi2 = $pi * 2 ;

	#
	# $w を $n 個の要素を持つ配列として初期化。
	#
	my $w = [] ;
	$#{ $w } = ( $n - 1 ) ;

	$w->[0] = __PACKAGE__->new( [ 1 , 0 ] ) ;			# $w->[0] == 1
	$w->[1] = __PACKAGE__->new( { 'arg' => pi() * 2 / $n } ) ;	# $w->[1] == exp( i * 2PI/n ) 

	my $arg1 = $w->[1]->arg() ;					# $w->[1] の偏角
	my $pk = $n->divide( 2 )->integer() ;				# PI 近傍の k

	#
	# 0 <= $w->[ $k ]->arg() <= PI の範囲の値を求める。
	#
	if ( $n->is_odd() ) {
		#
		# $n が奇数の場合。
		#
		#   0 <= $w->[ $k ]->arg() <= $pk の範囲を偏角の乗算で求める。
		#
		foreach my $k ( 2 .. $pk->value() ) {
			unless ( defined $w->[ $k ] ) {
				my $t = ( $arg1 * ( $k - 1 ) ) % $pi2 ;
				$w->[ $k ] = $w->[1] * __PACKAGE__->new( { 'arg' => $t } ) ;
			}
		}
	}
	else {
		#
		# $n が偶数の場合。
		#
		my $hpk = $pk->divide(2)->integer() ;			# PI/2 に当たる k
		my $qpk = $pk->divide(4)->integer() ;			# PI/4 に当たる k

		$w->[ $pk ]      = __PACKAGE__->new( [ -1 , 0 ] ) ;	# $z->[ $k ]->arg() == PI が必ず含まれる。
		$w->[ $pk - 1 ]  = $w->[1]->conj() * (-1) ;		# $z->[1] を虚軸で反転させた値。

		if ( $pk->is_odd() ) {
			#
			# $pk ( == $n/2 ) が奇数の場合。
			#
			foreach my $k ( 1 .. $hpk ) {
				#
				# 0 <= $w->[ $k ]->arg() <= $hpk の範囲を偏角の乗算で求める。
				#
				if ( $k > 1 ) {
					my $t = ( $arg1 * ( $k - 1 ) ) % $pi2 ;
					$w->[ $k ] = $w->[1] * __PACKAGE__->new( { 'arg' => $t } ) ;
				}

				#
				# $hpk < arg <= $pk の範囲の値は、 $z->[ $k ] を虚軸で反転させた値。
				#
				$w->[ $pk - $k ] = $w->[ $k ]->conj() * (-1) ;
			}
		}
		else {
			#
			# $pk ( == $n/2 ) が偶数の場合。
			#
			$w->[ $hpk ] = __PACKAGE__->new( [ 0 , 1 ] ) ;	# 0 + i ( 虚数単位 ) が必ず含まれる。
			foreach my $k ( 1 .. $qpk ) {
				#
				# 0 <= $w->[ $k ]->arg() <= $qpk の範囲を偏角の乗算で求める。
				#
				if ( $k > 1 ) {
					my $t = ( $arg1 * ( $k - 1 ) ) % $pi2 ;
					$w->[ $k ] = $w->[1] * __PACKAGE__->new( { 'arg' => $t } ) ;
				}

				#
				# $qpk < $w->[ $k ]->arg() <= $hpk の範囲の値は座標の入れ替えで求めることができる。
				# ( これは PI/4 を境界として線対称な値となる。)
				#
				my $j = $hpk - $k ;
				$w->[ $j ] = __PACKAGE__->new( [ reverse( $w->[ $k ]->as_array() ) ] ) ;

				#
				# $hpk < $w->[ $k ]->arg() < $pk の範囲の値は $z->[ $k ] , $z->[ $j ] を虚軸で反転させた値。
				#
				foreach my $i ( $k , $j ) {
				        $w->[ $pk - $i ] = $w->[ $i ]->conj() * (-1) ;
			        }
			}
		}
	}

	#
	# -PI < arg < 0 の範囲の値は複素共役を採るだけ。
	#
	foreach my $k ( 1 .. $pk ) {
		unless ( defined $w->[ $n - $k ] ) {
			$w->[ $n - $k ] = $w->[ $k ]->conj() ;
		} 
	}

	#
	# 戻り値は $w を回転因子として $z を回転した値となる。
	#
	my $r = [] ;
	if ( $z->can_decimal() and $z->decimal() == 1 ) {
		$r = $w ;
	}
	else {
		foreach my $k ( 0 .. $#{ $w } ) {
			$r->[ $k ] = $z * $w->[ $k ] ;
		}
	}

	return @{ $r } ;
}

sub circle_group00 {
	#-----------------------------------------------------------------------
	#
	# 円周群 ( circle group )
	#
	#   円周群は、円を位相 n で分割した扇形 ( 位相 n の部分群 ) の集合のようなもの。
	#
	#   円周群は複素数の通常の積に関して閉じた群をなす。
	#   円周群は 1 の原始 n 乗根で生成される巡回群であり、唯一つの位数 n の部分群を持つ。
	#   有理数体に円周群を添加した代数体は円分体 ( cyclotomic field ) と呼ばれる。
	#   円分体そのものやその部分体を指して円体と呼ばれることもある。
	#   ( cyclotomic は、ギリシャ語の cyclo ( circle ) と tomos ( cut , divide ) を組み合わせた造語。 )
	#
	#
	#   ここでは、複素数 z の偏角 theta を基点として、複素平面上の円を n 個に分割した時に得られる複素数の集合を返すこととする。
	#
	#   Z[ k ] = circle_group( z , n )   ( k == 0 -> n - 1 ) と定義すると、
	#
	#     r == abs( z )
	#     theta == arg( z )
	#
	#                                        2PI * k
	#     Z[ k ] == r * exp( i * ( theta + ----------- ) )               ( k = 0 -> n - 1 )
	#                                           n
	#
	#                                                 2PI * k
	#            == r * exp( i * theta ) * exp( i * ----------- ) )      ( k = 0 -> n - 1 )
	#                                                    n
	#
	#                              2PI * k
	#            == z * exp( i * ----------- )                           ( k = 0 -> n - 1 ) 
	#                                 n
	#
	#   となる。
	#
	#                        2PI * k
	#   この時、  exp( i * ----------- ) は、複素平面上の単位円を偏角 0 を起点にして n 個に分割した円周群となっている。
	#                           n
	#
	#   これは 1 の n 乗根の集合であり、 1 の原始 n 乗根で生成される巡回群となっている。
	#
	#   ここで、
	#
	#                          2PI * k
	#     w[ k ] == exp( i * ----------- )
	#                             n
	#
	#   とおくと、
	#                          2PI * 0
	#     w[ 0 ] == exp( i * ----------- ) == exp( 0 ) == 1
	#                             n
	#
	#                          2PI * 1
	#     w[ 1 ] == exp( i * ----------- )
	#                             n
	#
	#                          2PI * 2                     2PI       2PI                     2PI                  2PI
	#     w[ 2 ] == exp( i * ----------- ) == exp( i * ( ------- + ------- ) ) == exp( i * ------- ) * exp( i * ------- ) == w[ 1 ] * w[ 1 ]
	#                             n                         n         n                       n                    n
	#
	#                          2PI * 3                     2PI * 2       2PI                     2PI * 2                  2PI
	#     w[ 3 ] == exp( i * ----------- ) == exp( i * ( ----------- + ------- ) ) == exp( i * ----------- ) * exp( i * ------- ) == w[ 2 ] * w[ 1 ]
	#                             n                           n           n                         n                      n
	#
	#     w[ 4 ] == w[ 3 ] * w[ 1 ]
	#
	#     w[ 5 ] == w[ 4 ] * w[ 1 ]
	#
	#     ........
	#
	#     w[ n ] == w[ n - 1 ] * w[ 1 ]
	#
	#
	#   と言う関係になる。
	#
	#
	#   また、 n が 8 の倍数の場合、 k == 0 -> n/8 の演算過程において、
	#
	#     w[ n/4 - k ] == imag( w[k] ) + i * real( w[k] )                         ... [1]
	#     w[ n/4 + k ] == w[k] * i                                                ... [2]
	#     w[ n/2 - k ] == ( -1 ) * real( w[k] ) + i * imag( w[k] )
	#                  == conj( w[k] * ( -1 ) )                                   ... [3]
	#
	#   を求めることができる。
	#
	#   これらは、
	#
	#     [1] : w[k] を偏角 PI/4 を境界にして線対称な位置に折り返した値
	#     [2] : w[k] を反時計回りに PI/2 回転させた値
	#     [3] : w[k] を偏角 PI/2 ( 虚軸 ) を境界にして線対称な位置に折り返した値
	#
	#   を求める演算となっており、右辺の式は、
	#
	#     [1] : w[k] の実部 ( 余弦 ) と虚部 ( 正弦 ) を交換したもの。
	#     [2] : w[k] に虚数単位を乗じたもの。
	#     [3] : w[k] の実部の符号を反転したもの。 ( == w[k] を偏角 PI だけ回転し、更に複素共役を採ったもの。 )
	#
	#   を意味している。
	#   ここから得られる結果は、
	#
	#     [1] : 1/8 * n < k <= 1/4 * n ( 1/4 * PI < theta <= 1/2 * PI ) の範囲 ( 第 1 象限の後半 )
	#     [2] : 1/4 * n < k <= 3/8 * n ( 1/2 * PI < theta <= 3/4 * PI ) の範囲 ( 第 2 象限の前半 )
	#     [3] : 3/8 * n < k <= 1/2 * n ( 3/4 * PI < theta <=       PI ) の範囲 ( 第 2 象限の後半 )
	#
	#   の値をそれぞれ導くことになる。
	#
	#
	#   n が 4 の倍数の場合も同様に k == 0 -> n/4 の演算過程において、
	#
	#     w[ n/4 + k ] == w[ k ] * i
	#
	#   を求めることができる。
	#   この場合、 w[ k ] が第 1 象限全体の値を、 w[ n/4 + k ] が第 2 象限全体の値を網羅することになる。
	#
	#
	#   n が 8 の倍数の場合には 0 <= theta <= PI/4 の範囲を、 n が 4 の倍数の場合には 0 <= theta <= PI/2 の範囲を、
	#   n/2 が奇数の場合には 0 <= theta <= PI の範囲の値を k 倍角の演算で地道に求める必要がある。
	#
	#   ただし、 2 倍角の演算に関しては、ワイエルシュトラスの置換 ( 詳細については thas メソッドを参照のこと ) を用いて、
	#
	#                                  imag( w[k] )
	#     t == tan( arg( w[k] ) ) == ----------------
	#                                  real( w[k] )
	#
	#     z == 1 + it
	#     w[ 2k ] == ( z / conj( z ) ) * abs( w[k] )
	#             == z / conj( z )
	#
	#   とすることもできる。 ( w[k] は複素単位円上の点の集合なので、全ての k について abs( w[k] ) == 1 となる。 )
	#   これにより、 2 の冪倍角の演算を他の処理に先んじて実行することができる。
	#
	#   この演算では極僅かな演算誤差が発生するものの、演算コストは比較的小さい。
	#   ( このライブラリの実装においては、小数点以下 40 桁目に誤差が出る程度。 )
	#
	#
	#   第 3 象限と第 4 象限の範囲に位置する値については、 k == 1 -> n/2 に対して j == ( -1 ) * k を考えればよい。
	#   これは、 n や n/2 の偶奇に依らず同じ手法を採ることができる。
	#
	#   j == ( -1 ) * k を定義すると、 w[ k ] は w[ 0 ] == complex( [ 1 , 0 ] ) を基点として複素平面上の単位円を反時計回りに辿る点となり、
	#   w[ j ] はこれとは逆に、単位円上を時計回りに辿る点となる。
	#
	#   これは w[ k ] と w[ j ] が実軸に対して互いに線対称な関係となることを意味しており、両者は互いに複素共役の関係となる。
	#   よって、
	#
	#     w[ j ] == w[ ( -1 ) * k ] == conj( w[ k ] )      ( k == 1 -> n/2 )
	#
	#   となる。
	#
	#   一方、 k と j は、法 n の下で以下のような関係を持つ。
	#
	#     j ≡ ( -1 ) * k ( mod n )
	#       ≡ ( n - k ) ( mod n )
	#
	#   よって、
	#
	#     w[ j ] == w[ ( -1 ) * k ] == w[ n - k ]
	#            == conj( w[ k ] )
	#
	#   となる。
	#
	#
	#
	#   このメソッドによって得られる複素数の集合は、冪根の演算やフーリエ変換における回転因子の導出に利用することができる。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;
	return ()	unless ( ref( $z ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n || 1 )	unless ( ref( $n ) ) ;
	return ()	unless ( $n->is_integer() ) ;
	return ()	unless ( $n > 0 ) ;
	return ( $z )	if ( $n == 1 ) ;

	#
	# 複素平面における単位円について偏角 0 ラジアンを基点とする円周群を求める。
	#
	my $npi = pi()->multiply( 2 )->divide( $n ) ;
	my $imag_unit = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $h = $n->divide( 2 ) ;
	my $q = ( $h->is_even() ) ? $h->divide( 2 ) : undef ;
	my $o = undef ;
	$o = $q->divide( 2 )	if ( defined $q and $q->is_even() ) ;

	#
	# w[0] 及び w[1] を準備
	#
	my $w = [
		__PACKAGE__->new( { 'theta' => 0 } )	,
		__PACKAGE__->new( { 'theta' => $npi } )	,
	] ;

	#
	# 2 <= k <= n/2 の範囲の値を求める。
	#
	if ( defined $o ) {
		#
		# n ≡ 0 ( mod 8 ) の場合
		#
		# w[k] ( 0 <= k <= n/8 ) の範囲は偏角の乗算で求める。
		# この時、以下の値も導出する。
		#
		#   w[ n/4 - k ] == imag( w[k] ) + i * real( w[k] )                  ... [1]
		#   w[ n/4 + k ] == w[k] * i                                         ... [2]
		#   w[ n/2 - k ] == ( -1 ) * real( w[k] ) + i * imag( w[k] )         ... [3]
		#
		# [1] は、 k が示す値と PI/4 を境にして線対称となる位置の値であり、 w[k] の実部 ( 余弦 ) と虚部 ( 正弦 ) が入れ替わった値となる。
		# [2] は、 k が示す値を PI/2 だけ反時計回りに回転した値であり、 w[k] に虚数単位 i を掛けることで導出できる。
		# [3] は、 k が示す値と PI/2 を境にして線対称となる位置の値であり、 w[k] の実部の符号が反転しただけの値となる。
		#
		# [2] で生成される w[ n/4 + k ] は、複素平面の原点において w[k] と直交する。
		#
		# [3] で生成される w[ n/2 - k ] は、 w[ n/2 + k ] の複素共役であり、 w[ n/2 + k ] == w[k] * ( -1 ) の関係にある。
		# よって、
		#
		#   w[ n/2 - k ] == ( -1 ) * real( w[k] ) + i * imag( w[k] ) 
		#                == conj( w[k] * ( -1 ) )
		#
		# となる。
		#
		# [1] の値は、 1/8 * n < k <= 1/4 * n ( 1/4 * PI < theta <= 1/2 * PI ) の範囲の値となる。
		# [2] の値は、 1/4 * n < k <= 3/8 * n ( 1/2 * PI < theta <= 3/4 * PI ) の範囲の値となる。
		# [3] の値は、 3/8 * n < k <= 1/2 * n ( 3/4 * PI < theta <=       PI ) の範囲の値となる。
		#
		foreach ( my $k = 0 ; $k <= $o ; $k++ ) {
			foreach my $j ( $k , $q - $k , $q + $k , $h - $k ) {
				unless ( defined $w->[ $j ] ) {
					#
					# w[ k ] 及び w[ k ] と対称な値
					#
					if	( $j == $k )		{ $w->[ $k ] = $w->[ $k - 1 ] * $w->[ 1 ] ; }
					elsif	( $j == ( $q - $k ) )	{ $w->[ $j ] = __PACKAGE__->new( [ reverse( $w->[ $k ]->as_array() ) ] ) ; }
					elsif	( $j == ( $q + $k ) )	{ $w->[ $j ] = $w->[ $k ] * $imag_unit ; }
					elsif	( $j == ( $h - $k ) )	{ $w->[ $j ] = $w->[ $k ]->multiply( '-1' )->conj() ; }
				}

				next	if ( $j == 0 ) ;
				next	if ( defined $w->[ $j * 2 ] ) ;

				#
				# 2 の冪倍角
				#
				my $j1 = $j ;
				my $j2 = $j * 2 ;
				while ( $j2 <= $o ) {
					unless ( defined $w->[ $j2 ] ) {
						$w->[ $j2 ] = $w->[ $j1 ]->arg_double() ;
					}
					$j1 = $j2 ;
					$j2 *= 2 ;
				}
			}
		}
	}
	elsif ( defined $q ) {
		#
		# n ≡ 0 ( mod 4 ) の場合
		#
		# w[k] ( 0 <= k <= n/4 ) の範囲は偏角の乗算で求める。
		# この時、以下の値も導出する。
		#
		#   w[ n/4 + k ] == w[k] * i
		#
		# この値は、 n/4 < k <= n/2 ( PI/2 < theta <= PI ) の範囲の値となる。
		#
		foreach ( my $k = 0 ; $k <= $q ; $k++ ) {
			foreach my $j ( $k , $q + $k ) {
				unless ( defined $w->[ $j ] ) {
					#
					# w[ k ] 及び w[ k ] と対称な値
					#
					if	( $j == $k )	{ $w->[ $k ] = $w->[ $k - 1 ] * $w->[ 1 ] ; }
					else			{ $w->[ $j ] = $w->[ $k ] * $imag_unit ; }
				}

				next	if ( $j == 0 ) ;
				next	if ( defined $w->[ $j * 2 ] ) ;

				#
				# 2 の冪倍角
				#
				my $j1 = $j ;
				my $j2 = $j * 2 ;
				while ( $j2 <= $q ) {
					unless ( defined $w->[ $j2 ] ) {
						$w->[ $j2 ] = $w->[ $j1 ]->arg_double() ;
					}
					$j1 = $j2 ;
					$j2 *= 2 ;
				}
			}	 
		}
	}
	else {
		#
		# 偏角の乗算で求める。
		#
		foreach ( my $k = 0 ; $k <= $h ; $k++ ) {
			unless ( defined $w->[ $k ] ) {
				#
				# w[ k ]
				#
				$w->[ $k ] = $w->[ $k - 1 ] * $w->[ 1 ] ;
			}

			next	if ( $k == 0 ) ;
			next	if ( defined $w->[ $k * 2 ] ) ;

			#
			# 2 の冪倍角
			#
			my $k1 = $k ;
			my $k2 = $k * 2 ;
			while ( $k2 <= $h ) {
				unless ( defined $w->[ $k2 ] ) {
					$w->[ $k2 ] = $w->[ $k1 ]->arg_double() ;
				}
				$k1 = $k2 ;
				$k2 *= 2 ;
			}
		}
	}

	#
	# n/2 < j < n ( -PI < theta < 0 ) の範囲の値を求める。
	# ここは添え字に注意しながら複素共役を採るだけでよい。
	#
	#  w[ n - k ] == conj( w[k] )    ( k == 1 -> n/2 )
	#
	foreach ( my $k = 1 ; $k <= $h ; $k ++ ) {
		$w->[ $n - $k ] = $w->[ $k ]->conj() ;
	}

	#
	# 戻り値は $w を回転因子として $z を回転した値となる。
	#
	my $r = [] ;
	if ( $z->can_decimal() and $z->decimal() == 1 ) {
		$r = $w ;
	}
	else {
		foreach my $k ( 0 .. $#{ $w } ) {
			$r->[ $k ] = $z * $w->[ $k ] ;
		}
	}

	return @{ $r } ;
}

=head1 'Complex' object - trigonometric operations

=cut

#-------------------------------------------------------------------------------
#
# 複素三角関数
#
#-------------------------------------------------------------------------------

=head2 sine , cosine , tangent

By Euler's fomulla, 

  z == r * exp( i * t ) == r * ( cos( t ) + i * sin( t ) )

  -> exp( i * t ) == cos( t ) + i * sin( t )

This fomulla can satisfied for complex value.

 exp( i * z ) == cos( z ) + i * sin( z ) == w

w is also complex value.

Then, 

 w + conj( w ) == exp( i * z ) + conj( exp( i * z ) )
               == ( cos( z ) + i * sin( z ) ) + ( cos( z ) - i * sin( z ) ) 
               == 2 * cos( z )

                   exp( i * z ) + exp( -i * z )      w + conj( w )
   -> cos( z ) == ------------------------------ == ---------------
                                2                         2

 w - conj( w ) == exp( i * z ) - conj( exp( i * z ) )
               == ( cos( z ) + i * sin( z ) ) - ( cos( z ) - i * sin( z ) )
               ==  2 * i * sin( z )

                    exp( i * z ) - exp( -i * z )      w - conj( w )
   -> sin( z ) ==  ------------------------------ == ---------------
                               2 * i                     2 * i

              sin( z )           w - conj( w )
 tan( z ) == ---------- == -----------------------
              cos( z )      i * ( w + conj( w ) )

	                        exp( i * z ) - exp( -i * z )
	                == --------------------------------------
			    i * ( exp( i * z ) + exp( -i * z ) )


trigonometric functions and hyperbolic functoins.

  sin( z ) == sin( x + iy )
           == sin( x ) * cos( iy ) + i * cos( x ) * sin( iy )
           == sin( x ) * cosh( y ) + i * cos( x ) * sinh( y )

  cos( z ) == cos( x + iy )
           == cos( x ) * cos( iy ) - i * sin( x ) * sin( iy )
           == cos( x ) * cosh( y ) - i * sin( x ) * sinh( y )




  $i = complex( [ 0 , 1 ] ) ;                     # 0 + i  ( imaginary unit )
  $z = complex( [ 1 , 1 ] ) ;                     # 1 + i
  $w = ( $i * $z  )->exp() ;                      # $w = exp( i * $z )

  print $z ;                                      # 1 + i
  print $w ;                                      # 0.198766110346413 + 0.309559875653112 i
  print $z->cosine() ;                            # 0.833730025131149 - 0.988897705762865 i
  print $z->sine() ;                              # 1.298457581415977 + 0.634963914784736 i
  print $z->cosine() + $i * $z->sine() ;          # 0.198766110346413 + 0.309559875653112 i  ( == $w )

  Note :

    $w == exp( $i * $z ) == $z->cosine() + $i * $z->sine() ;
    
    however,

      $w->real() == ( $z->cosine()->real() - $z->sine()->imag() ) != $z->cosine()
      $w->imag() == ( $z->cosine()->imag() + $z->sine()->real() ) != $z->sine() 

=cut

sub sine {
	#-----------------------------------------------------------------------
	#
	# 正弦
	#
	#   オイラーの公式に沿った演算を行う。
	#
	#
	#   z == exp( i * t ) == cos( t ) + i * sin( t )
	#
	#                 exp( i * z ) - exp( -i * z ) 
	#   sin( z ) == --------------------------------
	#                            2 * i
	#
	#   双曲線関数との関係
	#
	#     z == x + iy と三角関数の加法定理より、
	#
	#     sin( z ) == sin( x + iy )
	#              == sin( x ) * cos( iy ) + i * cos( x ) * sin( iy )
	#              == sin( x ) * cosh( y ) + i * cos( x ) * sinh( y )
	#
	#     z が実数の場合、 y == 0 より、
	#
	#       cosh( y ) == 1
	#       sinh( y ) == 0
	#       -> sin( z ) == sin( x )
	#
	#     となる。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $r = ( $z->multiply( $i )->exp() - $z->multiply( $i * (-1) )->exp() ) / ( $i * 2 ) ;

	return $r ;
}

sub cosine {
	#-----------------------------------------------------------------------
	#
	# 余弦
	#
	#   オイラーの公式に沿った演算を行う。
	#
	#
	#   z == exp( i * t ) == cos( t ) + i * sin( t )
	#
	#                 exp( i * z ) + exp( -i * z ) 
	#   cos( z ) == --------------------------------
	#                             2
	#
	#
	#   双曲線関数との関係
	#
	#     z == x + iy と三角関数の加法定理より、
	#
	#     cos( z ) == cos( x + iy )
	#              == cos( x ) * cos( iy ) - i * sin( x ) * sin( iy )
	#              == cos( x ) * cosh( y ) - i * sin( x ) * sinh( y )
	#
	#     z が実数の場合、 y == 0 より、
	#
	#       cosh( y ) == 1
	#       sinh( y ) == 0
	#       -> cos( z ) == cos( x )
	#
	#     となる。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $r = ( $z->multiply( $i )->exp() + $z->multiply( $i * (-1) )->exp() ) / 2 ;

	return $r ;
}

sub tangent {
	#-----------------------------------------------------------------------
	#
	# 正接
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $r = $z->sine() / $z->cosine() ;

	return $r ;
}

=head2 arcsine , arccosine , arctan

  w == arcsine( z ) 

    -> sin( arcsine( z ) ) == z == sin( w )
  
                         exp( i * w ) - exp( i * -w )
    -> z == sin( w ) == ------------------------------
                                    2 * i

                           1                             1
                     == ------- * ( exp( i * w ) - -------------- )
		         2 * i                      exp( i * w )

                           1         ( exp( i * w ) )^2 - 1
                     == ------- * ( ------------------------ )
		         2 * i            exp( i * w )

    -> ( exp( i * w ) )^2 - 2i * z * exp( i * w ) - 1 == 0
    -> ( exp( i * w ) )^2 - 2i * z * exp( i * w ) + ( iz )^2 - ( iz )^2 - 1 == 0
    -> ( exp( i * w ) - iz )^2 == ( iz )^2 + 1
                               == 1 - z^2

    -> exp( i * w ) == iz + sqrt( 1 - z^2 )

    -> log( exp( i * w ) ) == i * w == log( iz + sqrt( 1 - z^2 ) )

    -> w == log( iz + sqrt( 1 - z^2 ) ) / i
         == log( iz + sqrt( 1 - z^2 ) ) * i^(-1)
         == log( iz + sqrt( 1 - z^2 ) ) * (-i)
        

  w == arccosine( z )

    -> cos( arccosine( z ) ) == z == cos( w )

                         exp( i * w ) + exp( i * -w )
    -> z == cos( w ) == ------------------------------
                                      2

                         1                            1
                     == --- * ( exp( i * w ) + -------------- )
		         2                      exp( i * w )

                         1       ( exp( i * w ) )^2 + 1
                     == --- * ( ------------------------ )
		         2            exp( i * w )

    -> ( exp( i * w ) )^2 - 2 * z * exp( i * w ) + 1 == 0
    -> ( exp( i * w ) )^2 - 2 * z * exp( i * w ) + z^2 - z^2 + 1 == 0
    -> ( exp( i * w ) - z )^2 == z^2 - 1

    -> exp( i * w ) - z == sqrt( z^2 - 1 )
    -> exp( i * w )     == z + sqrt( z^2 - 1 )

    -> log( exp( i * w ) ) == i * w == log( z + sqrt( z^2 - 1 ) )

    -> w == log( z + sqrt( z^2 - 1 ) ) / i
         == log( z + sqrt( z^2 - 1 ) ) * i^(-1)
         == log( z + sqrt( z^2 - 1 ) ) * (-i)

  w == arctan( z )

    -> tan( arctan( z ) ) == z == tan( w )

                         sin( w )         exp( i * w ) - exp( i * -w )
    -> z == tan( w ) == ---------- == --------------------------------------
                         cos( w )      i * ( exp( i * w ) + exp( i * -w ) )

                                  1
              exp( i * w ) - --------------
	                      exp( i * w )         ( exp( i * w ) )^2 - 1
    -> iz == --------------------------------- == ------------------------
                                   1               ( exp( i * w ) )^2 + 1 
              exp( i * w ) + ---------------
                              exp( i * w )

    -> iz * ( exp( i * w ) )^2 + iz - ( exp( i * w ) )^2 + 1 == 0

    -> ( exp( i * w ) )^2 * ( iz - 1 ) + iz + 1 == 0

                              -iz - 1
    -> ( exp( i * w ) )^2 == ---------
                               iz - 1

                              ( -iz - 1 ) * i     i - z
			  == ----------------- = --------
			       ( iz - 1 ) * i     i + z 

                                                    i - z
   -> log( exp( 2 * i * w ) ) == 2 * i * w == log( ------- )
                                                    i + z

                 1 - z
   -> w == log( ------- ) / ( 2 * i )
                 1 + z 

                 1 - z 
        == log( -------- ) * 1/2 * i^(-1)
	         1 + z

	         i - z
	== log( ------- ) * 1/2 * (-i)
	         i + z
=cut

sub arcsine {
	#-----------------------------------------------------------------------
	#
	# 逆正弦
	#
	#   w == ( sin( z ) )^( -1 )
	#
	#   -> z == sin( w )
	#
	#             exp( i * w ) - exp( i * -w )
	#        == --------------------------------
	#                        2 * i
	#               1                               1
	#        == --------- * ( exp( i * w ) - ---------------- )
	#             2 * i                        exp( i * w )
	#
	#               1           ( exp( i * w ) )^2 - 1
	#        == --------- * ( -------------------------- )
	#             2 * i              exp( i * w )
	#
	#   -> exp( i * w )^2 - 2 * i * z * exp( i * w ) - 1 == 0
	#   -> exp( i * w )^2 - 2 * i * z * exp( i * w ) + ( iz )^2 - ( iz )^2 - 1 == 0
	#   -> ( exp( i * w ) - iz )^2 == ( iz )^2 + 1
	#                              == 1 - z^2
	#   -> exp( i * w ) == iz + sqrt( 1 - z^2 )
	#
	#   -> log( exp( i * w ) ) == i * w
	#                          == log( iz + sqrt( 1 - z^2 ) )
	#   -> w == log( iz + sqrt( 1 - z^2 ) ) / i
	#        == log( iz + sqrt( 1 - z^2 ) ) * i^( -1 )
	#        == log( iz + sqrt( 1 - z^2 ) ) * ( -i )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;
	my $sq = __PACKAGE__->new( 1 )->subtract( $z->power( 2 ) ) ;

	my $w = $z->multiply( $i )->add( $sq )->log() * ( $i * ( -1 ) ) ;

	return $w ;
}

sub arccosine {
	#-----------------------------------------------------------------------
	#
	# 逆余弦
	#
	#   w == ( cos( z ) )^( -1 )
	#
	#   -> z == cos( w )
	#
	#             exp( i * w ) + exp( i * -w )
	#        == --------------------------------
	#                          2
	#            1                            1
	#        == --- * ( exp( i * w ) + ---------------- )
	#            2                       exp( i * w )
	#
	#            1        ( exp( i * w ) )^2 + 1
	#        == --- * ( -------------------------- )
	#            2             exp( i * w )
	#
	#   -> exp( i * w )^2 - 2 * z * exp( i * w ) + 1 == 0
	#   -> exp( i * w )^2 - 2 * z * exp( i * w ) + z^2 - z^2 + 1 == 0
	#   -> ( exp( i * w ) - z )^2 == z^2 - 1
	#   -> exp( i * w ) - z == sqrt( z^2 - 1 )
	#   -> exp( i * w ) == z + sqrt( z^2 - 1 )
	#
	#   -> log( exp( i * w ) ) == i * w == log( z + sqrt( z^2 - 1 ) )
	#   -> w == log( z + sqrt( z^2 - 1 ) ) / i
	#        == log( z + sqrt( z^2 - 1 ) ) * i^( -1 )
	#        == log( z + sqrt( z^2 - 1 ) ) * ( -i )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;
	my $sq = $z->power( 2 )->subtract( 1 ) ;

	my $w = $z->add( $sq )->log() * ( $i * ( -1 ) ) ;

	return $w ;
}

sub arctan {
	#-----------------------------------------------------------------------
	#
	# 複素正接から逆正接を求めて返す。
	#
	#   w == ( tan( z ) )^( -1 )
	#
	#   -> z == tan( w )
	#
	#               exp( i * w ) - exp( i * -w )
	#        == ----------------------------------------
	#             ( exp( i * w ) + exp( i * -w ) ) * i
	#
	#                                    1
	#              exp( i * w ) - ----------------
	#                               exp( i * w )
	#  -> iz == ------------------------------------
	#                                    1
	#              exp( i * w ) + ----------------
	#                               exp( i * w )
	#
	#             ( exp( i * w ) )^2 - 1
	#        == --------------------------
	#             ( exp( i * w ) )^2 + 1
	#
	#
	#  -> iz * ( exp( i * w ) )^2 + iz - ( exp( i * w ) )^2 + 1 == 0
	#
	#  -> ( exp( i * w ) )^2 * ( iz - 1 ) + iz + 1 == 0
	#
	#                             -iz - 1      i
	#  -> ( exp( i * w ) )^2 == ----------- * ---
	#                              iz - 1      i
	#
	#                           z - i       i - z
	#  -> exp( 2 * i * w ) == --------- = ---------
	#                          -z - i       i + z
	#
	#                                                  i - z
	#  -> log( exp( 2 * i * w ) == 2 * i * w == log( --------- )
	#                                                  i + z
	#                 i - z
	#  -> w == log( --------- ) / 2i
	#                 i + z
	#
	#                 i - z
	#       == log( --------- ) * 1/2 * i^(-1)
	#                 i + z
	#
	#                 i - z
	#       == log( --------- ) * 1/2 * ( -i )
	#                 i + z
	#
	#
	#  一見すると実数領域の三角関数が不要に見えるが、複素対数関数は内部で偏角を使用しているため、
	#  複素数の逆正接は実数領域の逆正接抜きには成立しない。
	#
	#  正接からの変換であるため、結果の正負が逆転している( +-PI だけずれている ) ことがある。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $w = ( ( $i - $z ) / ( $i + $z ) )->log() * 0.5 * ( $i * ( -1 ) ) ;

	return $w ;
}

sub arctan2 {
	#-----------------------------------------------------------------------
	#
	# 逆正接
	#
	#   任意の複素数 z の正接は
	#
	#                     z - conj( z )
	#     tan( z ) == -------------------------
	#                   ( z + conj( z ) ) * i
	#
	#   分母の値は
	#
	#     ( z + conj( z ) ) * i == ( ( x + iy ) + ( x - iy ) ) * i
	#                           == 2ix
	#
	#   であり、 arg( z ) == PI/2 or -PI/2 で x == 0 、 tan( z ) == +-∞ となって演算不能となる。
	#   また、 arctan( tan( z ) ) は +-PI だけずれた値を返すことがある。
	#
	#   ここでは、これらの問題を補正した結果を返す事とする。
	#
	#   arctan メソッドとは呼び出し元 ( 入力 ) が異なるので注意が必要。
	#
	#     $z->arctan2() == $z->tangent()->arctan() ;
	#
	#
	#   arctan( z ) の演算は以下の方法でも可。
	#
	#     z == r * exp( i * t )
	#
	#     -> log( z / r ) == log( exp( i * t ) ) == i * t == i * arctan( z )
	#
	#                                  z                 z                        z
	#     -> t == arctan( z ) == log( --- ) / i == log( --- ) * i^( -1 ) == log( --- ) * ( -i )
	#                                  r                 r                        r
	#                        z
	#          == log( ------------ ) * ( -i )
	#                    abs( z )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $i = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $t = undef ;

	if ( ( $z + $z->conj() ) == 0 ) {
		#
		# arctan( tan( z ) ) == arg( z ) == +- PI/2
		#
		# 偏角の正負は z の虚部に等しい。
		#
		$t = pi() / 2 ;
		$t *= ( -1 )	if ( $z->imag() < 0 ) ;
	}
	else {
		#
		# 正接と逆正接を採る。
		#
		# この場合も偏角の正負は z の虚部に合わせる。
		#
		$t = $z->tangent()->arctan()->decimal() ;
		if ( $z->imag() >= 0 ) {
			$t += pi()	if ( $t < 0 ) ;
		}
		elsif ( $t > 0 ) {
			$t -= pi() ;
		}
	}

	return $t ;
}

=head1 'Complex' object - hyperbolic operations

=cut

#-------------------------------------------------------------------------------
#
# 複素双曲線関数
#
#-------------------------------------------------------------------------------

=head2 sinh , cosh , tanh

When a complex value z is defined as follows,

  z == x + iy
    == cos( t ) + i * sin( t )

x , y is

  x == cos( t )
  y == sin( t )

  x^2 + y^2 == ( cos( t ) )^2 + ( sin( t ) )^2 == 1       ( the unit circle in the complex plane. )

The hyperbolic functions sinh and cosh are defined as solutions of the following equation.

  x^2 - y^2 == ( cosh( t ) )^2 - ( sinh( t ) )^2 == 1     ( the hyperbola in the complex plane. )

  -> x == cosh( t )
     y == sinh( t )


sinh , cosh , tanh are defined as follows.

               exp( i * z ) - exp( -i * z )
  sin( z ) == ------------------------------
                          2 * i

                    exp( i^2 * x ) - exp( (-1) * i^2 * x )      exp( -x ) - exp( x )
   -> sin( ix ) == ---------------------------------------- == ---------------------- == i * sinh( x )
                                 2 * i                                  2 * i

   -> sinh( x ) == sin( ix ) * i^(-1)
   
                == -i * sin( ix )

                    exp( x ) - exp( -x )
                == ----------------------
	                     2

               exp( i * z ) + exp( -i * z )
  cos( z ) == ------------------------------
                            2

                     exp( i^2 * x ) + exp( (-1) * i^2 * x )      exp( -x ) + exp( x )
    -> cos( ix ) == ---------------------------------------- == ---------------------- == cosh( x )
                                    2                                     2

    -> cosh( x ) == cos( ix )

                     exp( x ) + exp( -x )
                 == ----------------------
		              2

                sinh( x )
  tanh( x ) == -----------
                cosh( x ) 

                ( exp( x ) - exp( -x ) ) / 2
            == -------------------------------
                ( exp( x ) + exp( -x ) ) / 2

                exp( x ) - exp( -x )
            == ----------------------
                exp( x ) + exp( -x )



trigonometric functions and hyperbolic functoins.

  sin( z ) == sin( x + iy )
           == sin( x ) * cos( iy ) + i * cos( x ) * sin( iy )
           == sin( x ) * cosh( y ) + i * cos( x ) * sinh( y )

  cos( z ) == cos( x + iy )
           == cos( x ) * cos( iy ) - i * sin( x ) * sin( iy )
           == cos( x ) * cosh( y ) - i * sin( x ) * sinh( y )

=cut

sub sinh {
	#-----------------------------------------------------------------------
	#
	# 双曲線正弦 ( hyperbolic sine )
	#
	#
	#                 e^( iz ) - e^( -iz ) 
	#   sin( z ) == ------------------------
	#                        2 * i
	#
	#    z == ix を代入した結果を
	#
	#                   e^( i^2 * x ) - e^( ( -1 ) * i^2 * x )
	#    sin( ix ) == ------------------------------------------
	#                                  2 * i
	#
	#                   e^( -x ) - e^( x )
	#              == ----------------------
	#                        2 * i
	#
	#              == i * sinh( x )
	#
	#    と定義する。
	#
	#    ここから、双曲線正弦は、
	#
	#                     e^( -x ) - e^( x )
	#      sinh( x ) == ----------------------
	#                         2 * i^2 
	#
	#                     e^( x ) - e^( -x )
	#                == ----------------------
	#                             2
	#
	#    と定義される。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $z1 = $z->exp() ;
	my $z2 = $z->multiply( -1 )->exp() ;

	return ( $z1 - $z2 )->divide( 2 ) ;
}

sub cosh {
	#-----------------------------------------------------------------------
	#
	# 双曲線余弦 ( hyperbolic cosine )
	#
	#                    e^( iz ) + e^( -iz ) 
	#   cosine( z ) == ------------------------
	#                            2
	#
	#   z == ix を代入した結果、
	#
	#                     e^( i^2 * x ) + e^( ( -1 ) * i^2 x )
	#   cosine( ix ) == ----------------------------------------
	#                                    2
	#
	#                     e^( -x ) + e^( x )
	#                == ----------------------
	#                            2
	#
	#                == cosh( x )
	#
	#   と定義される。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $z1 = $z->exp() ;
	my $z2 = $z->multiply( -1 )->exp() ;

	return ( $z1 + $z2 )->divide( 2 ) ;
}

sub tanh {
	#-----------------------------------------------------------------------
	#
	# 双曲線正接 ( hyperbolic tangent )
	#
	#
	#                  sinh( x )
	#   tanh( x ) == -------------
	#                  cosh( x )
	#
	#                  ( e^( x ) - e^( -x ) ) / 2
	#             == ------------------------------
	#                  ( e^( x ) + e^( -x ) ) / 2
	#
	#                  e^( x ) - e^( -x )
	#             == ----------------------
	#                  e^( x ) + e^( -x )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $z1 = $z->exp() ;
	my $z2 = $z->multiply( -1 )->exp() ;

	my $r = ( $z1 - $z2 ) / ( $z1 + $z2 ) ;

	return $r ;
}

sub csch {
	#-----------------------------------------------------------------------
	#
	# 双曲線余割 ( hyperbolic cosecant )
	#
	#                     1
	#   csch( x ) == -------------
	#                  sinh( x )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	return $z->sinh()->inverse() ;
}

sub sech {
	#-----------------------------------------------------------------------
	#
	# 双曲線正割 ( hyperbolic secant )
	#
	#                     1
	#   sech( x ) == -------------
	#                  cosh( x )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	return $z->cosh()->inverse() ;
}

sub coth {
	#-----------------------------------------------------------------------
	#
	# 双曲線余接 ( hyperbolic cotangent )
	#
	#                     1
	#   coth( x ) == -------------
	#                  tanh( x )
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	return $z->tanh()->inverse() ;
}

#-------------------------------------------------------------------------------
#
# 特殊な数
#
#-------------------------------------------------------------------------------

sub gamma { return $_[0]->gamma_l() ; }

sub gamma_basic {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   ガンマ関数は自然数における階乗にあたる。
	#
	#   任意の複素数 z についてのガンマ関数は、 real( z ) > 0 と言う条件の下で
	#
	#                                           n! * n^(z-1)
	#     gamma( z ) == lim( -------------------------------------------------- )         ( n == 0 -> ∞ )
	#                         z * ( z + 1 ) * ( z + 2 ) * .... * ( z + n - 1 )
	#
	#   と表現される。
	#
	#   積分で表すと
	#
	#     z = x + iy  ( x > 0 )
	#
	#     gamma( z ) == ∫( exp(-t) * t^(z-1) * dt )
	#                == ∫( exp(-t) * t^(x-1) * cos( y * log(t) ) * dt )
	#                 - i * ∫( exp(-t) * t^(x-1) * sin( y * log(t) ) * dt )
	#
	#   となるらしい。
	#
	#   ここでは、上記の極限を用いた実装を行っているが、収束も遅く精度も非常に悪い。
	#
	#
	#   ガンマ関数の特徴として、
	#   
	#     gamma( n + 1 ) ==  n * gamma(  n )
	#     gamma( 1 + z ) ==  z * gamma(  z )
	#     gamma( 1 - z ) == -z * gamma( -z )
	#
	#   というものがあり、これらを組み合わせることで real( z ) < 0 にも対応できるとのこと。
	#   ただし、z が負の整数に合致する場合には演算不能となる。
	#   ( 負の整数に関する階乗は定義できないということが証明されているらしい。 )
	#
	#   これ以外にも
	#
	#                                             PI
	#     gamma( z ) * gamma( -z )    == - -------------------
	#                                       z * sin( PI * z )
	#
	#                                             PI
	#     gamma( z ) * gamma( 1 - z ) ==    ---------------        ( 相補公式 ; 相反公式 )
	#                                        sin( PI * z )
	#
	#                                           PI * z
	#     abs( ( i * z )! )^2         ==    ----------------
	#                                        sinh( PI * z )
	#
	#                                                PI * z
	#     abs( ( n + i * z )! )       == sqrt( ---------------- ) * Π( s^2 + z^2 )      ( s == 1 -> n )
	#                                           sinh( PI * z )
	#
	#   といった特徴があるとのこと。
	#
	#
	#   z == 1/2 の時の gamma( z ) は、相反公式より、
	#
	#                                                                    PI
	#     gamma( 1/2 ) * gamma( 1 - 1/2 ) == ( gamma( 1/2 ) )^2 == --------------- == PI
	#                                                               sin( PI / 2 )
	#
	#     -> gamma( 1/2 ) == sqrt( PI )
	#
	#   として導かれる。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $r = undef ;
	my $real = $z->real() ;

	if( $real->abs() < 0.5 ) {
		my $pi = pi() ;
		my $one = __PACKAGE__->new( 1 ) ;
		$r = $pi / ( ( $pi * $z )->sine() * ( $one - $z )->gamma_l() ) ;
	}
	else {
		#
		# 分母
		#
		#   denom == z * ( z + 1 ) * .... ( z + n - 1 )
		#
		my $n = 1 ;
		my $denom = $z->copy() ;
		foreach ( 1 .. 2000 ) {
			$denom *= $z + ( ++$n - 1 ) ;
		}

		#
		# 分子
		#
		#   numer == n! * n^( z - 1 )
		#         == ( n - 1 )! * n^z
		#         == ( n - 1 )! * exp( z * ln( n ) )
		#
		$n = new_decimal( $n ) ;
		my $npz = $z->multiply(  $n->ln() )->exp() ;		# n^z == exp( z * ln( n ) ) 
		my $numer = $n->add( -1 )->factorial() * $npz ;

		#
		# 結果
		#
		$r = $numer / $denom ;
	}

	return $r ;
}

sub gamma_l {
	#-----------------------------------------------------------------------
	#
	# ガンマ関数
	#
	#   ランチョス ( Lanczos ) による近似。
	#
	#   ランチョスによる近似は、二種類の定数 g , c[N] を伴って、
	#
	#     gamma( z + 1 ) == sqrt( 2 * PI ) * ( z + g + 1/2 )^( z + 1/2 ) * exp( (-1) * ( z + g + 1/2 ) ) * Ag(z)
	#
	#                          c[k]
	#     Ag(z) == c[0] + Σ( ------- )       ( k == 1 -> N )
	#                          z + k
	#
	#   で表される。
	#
	#   Ag(z) は、本来
	#                                           z                     z * ( z - 1 )
	#     Ag(z) == 1/2 * p[0](g) + p[1](g) * ------- + p[2](g) * ----------------------- + ..... 
	#                                         z + 1               ( z + 1 ) * ( z + 2 )
	#
	#     p[k](g) == Σ( C( 2k + 1 , 2a + 1 ) * sqrt(2)/PI * ( a - 1/2 )! * ( a + g + 1/2 )^( -1 * ( a + 1/2 ) ) * exp( a + g + 1/2 )   ( a == 0 -> k )
	#
	#   で表される定数となるとのこと。
	#
	#   C(i,j) は、チェビシェフ多項式 ( Chebyshev polynomial ) の係数マトリックスの要素であり、
	#
	#     C( 1 , 1 ) == 1
	#     C( 2 , 2 ) == 1
	#     C( i , 1 ) == -1 * C( i - 2 , 1 )                         ( i == 3 , 4 , ..... )
	#     C( i , j ) == 2C( i - 1 , j - 1 )                         ( i == j == 3 , 4 , .... )
	#     C( i , j ) == 2C( i - 1 , j - 1 ) - C( i - 2 , j ) * i    ( i  > j == 2 , 3 , .... )
	#
	#   というものらしい。
	#
	#   ランチョスによる近似はいくつかの亜流があり、この中の一つとして
	#
	#                        ( z + g - 1/2 )^( z - 1/2 )
	#     gamma( z + 1 ) == ----------------------------- * Lg(z)
	#                            exp( z + g - 1/2 )
	#
	#                            c[k]
	#     Lg(z) == c[0] + Σ( ----------- )            ( k == 1 -> N - 1 )
	#                          z + k - 1
	#
	#   というものがある。
	#   ここでは、こちらの方を採用している。
	#
	#   ランチョスによる近似は比較的高速だが、精度は小数点以下 12 桁程度。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;
	return undef	unless ( ref( $z ) eq __PACKAGE__ ) ;

	my $r = undef ;

	if ( $z->real() < 0.5 ) {
		my $pi = pi() ;
		my $one = __PACKAGE__->new( 1 ) ;
		$r = $pi / ( ( $pi * $z )->sine() * ( $one - $z )->gamma_l() ) ;
	}
	else {
		my $g = new_decimal( 9 ) ;
		my $c = [
			 1.000000000000000174663 ,
			 5716.400188274341379136 ,
			-14815.30426768413909044 ,
			 14291.49277657478554025 ,
			-6348.160217641458813289 ,
			 1301.608286058321874105 ,
			-108.1767053514369634679 ,
			 2.605696505611755827729 ,
			-0.7423452510201416151527e-2 ,
			 0.5384136432509564062961e-7 ,
			-0.4023533141268236372067e-8 ,
		] ;

		my $x = __PACKAGE__->new( $c->[0] ) ;
		foreach my $i ( 1 .. $#{ $c } ) {
			$x += __PACKAGE__->new( $c->[ $i ] ) / ( $z + $i - 1 ) ;
		}

		my $pi = pi() ;
		my $t = $z + $g - 0.5 ;
		my $tpz = ( ( $z - 0.5 ) * $t->log() )->exp() ;		# t^( z - 0.5 ) == exp( ( z - 0.5 ) * log( t ) )
		$r = ( $pi * 2 )->sqrt() * $tpz * ( $t * (-1) )->exp() * $x ;
	}

	return $r ;
}

sub zeta {
	#-----------------------------------------------------------------------
	#
	# オイラー積によるゼータ関数
	#
	#                         1
	#   zeta( s ) == Π( ------------ )         ( p == all primes )
	#                     1 - p^(-s)
	#
	#                         1                     1                    1                  p^s
	#   zeta( s ) == Π( ------------ ) == Π( ----------- ) == Π( ----------- ) == Π( --------- )
	#                     1 - p^(-s)                  1               p^s - 1             p^s - 1 
	#                                           1 - -----            ---------
	#                                                p^s                p^s
	#
	#   p^s == exp( s * ln( p ) )
	#
	#   s == x + iy
	#
	#   -> p^s == exp( ( x + iy ) * ln( p ) )
	#          == exp( ( x * ln( p ) ) + i * ( y * ln( p ) ) )
	#          == exp( x' + iy' )
	#          == exp( x' ) * exp( i * y' )
	#          == exp( x' ) * ( cosine( y' ) + i * sine( y' ) )
	#          == exp( x * ln( p ) ) * ( cosine( y * ln( p ) ) + i * sine( y * ln( p ) ) )
	#          == exp( ln( p^x ) ) * ( cosine( y * ln( p ) ) + i * sine( y * ln( p ) ) )
	#          == p^x * ( cosine( y * ln( p ) ) + i * sine( y * ln( p ) ) )
	#          == p^x * exp( i * ( y * ln( p ) ) )
	#
	#   s == r * exp( it )
	#
	#   -> p^s == exp( r * exp( it ) * ln( p ) )
	#          == exp( r * ln( p ) * exp( it ) )
	#          == exp( r * ln( p ) * ( cosine( t ) + i * sine( t ) ) )
	#          == exp( r * ln( p ) * cosine( t ) ) * exp( i * ( r * ln( p ) * sine( t ) ) )
	#
	#   精度、演算効率共にあまり良好とはいえない。
	#
	#-----------------------------------------------------------------------
	my( $s ) = @_ ;
	return undef	unless ( ref( $s ) eq __PACKAGE__ ) ;

	my( $x , $y ) = $s->as_array() ;

	my $numor = __PACKAGE__->new( 1 ) ;
	my $denom = __PACKAGE__->new( 1 ) ;
	my $plimit = new_decimal( 10000 ) ;
	my $c = 0 ;
	foreach my $p ( $plimit->primes() ) {
		my $pln = $p->prime_ln() || $p->ln() ;

		#my $pps = $p->power( $s ) ;
		my $ppx = $p->power( $x ) ;
		my $yd = $y->multiply( $pln ) ;
		my $pps = $ppx * __PACKAGE__->new( [ $yd->_cosine_sine() ] ) ;

		$numor *= $pps ;
		$denom *= ( $pps - 1 ) ;
		#if ( ( ++$c % 10 ) == 0 ) {
		#	printf STDERR ( "%5d : %s\n" ,  $c , $numor / $denom ) ;
		#}
	}
	my $zeta = $numor / $denom ;

	return $zeta->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
}

=head1 'Complex' object - Forurier transform'

=cut

#-------------------------------------------------------------------------------
#
# フーリエ変換 ( Fourier Transform )
#
#-------------------------------------------------------------------------------
sub dft {
	#-----------------------------------------------------------------------
	#
	# 離散フーリエ変換 ( Discrete Fourier Transform )
	#
	#   複素数配列 @z を @Z に変換することを考える。
	#
	#     要素数 n == @z
	#
	#   フーリエ変換は以下の式で表される。
	#
	#     Z[k] == Σ( z[j] * ( exp( ( -1 ) * i * ( 2PI / n ) ) )^( j * k ) ) )           ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#          == Σ( z[j] * ( exp( ( -1 ) * i * ( 2PI / n ) * j * k ) ) )
	#
	#     theta == ( -1 ) * 2PI / n と定義すると、
	#
	#        exp( ( -1 ) * i * ( 2PI / n ) * j * k ) == exp( ( -1 ) * i * ( theta * j * k ) )
	#                                                == w[ j , k ]
	#                                                == w[ k , j ]
	#
	#     となる w[ j , k ] 及び w[ k , j ] と言う複素数を得る。
	#     結果、
	#
	#       Z[k] == Σ( z[j] * w[ j , k ] )            ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#     と言う式で表現できることになる。
	#
	#
	#   逆変換は以下の通り。
	#
	#     z[k] == 1/n * Σ( Z[j] * ( exp( i * 2PI / n ) )^( j * k ) )                    ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#          == 1/n * Σ( Z[j] * ( exp( i * ( 2PI / n ) * j * k )
	#
	#     theta == 2PI / n と定義することで、
	#
	#        exp( i * ( 2PI / n ) * j * k ) == exp( i * ( theta * j * k ) )
	#                                       == w[ j , k ]
	#                                       == w[ k , j ]
	#
	#     となる w[ j , k ] 及び w[ k , j ] と言う複素数を得る。
	#     結果、
	#
	#       z[k] == 1/n * Σ( Z[j] * w[ j , k ] )      ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#     と表現できる。
	#
	#   n は変換の粒度を決定する係数であり、任意の実数を用いることができるものと考えられる。
	#   通常は配列要素数 ( サンプリングデータ数 ) を用いるものと考えられる。
	#
	#   オーダーは O( N^2 ) であり、処理効率は悪い。
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::idft$/ ) ? 1 : 0 ;

	#
	# 配列要素を複素数に変換
	#
	foreach ( @{ $z } ) {
		$_ = __PACKAGE__->new( [ $_ , 0 ] )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $_ ) ;
	}

	#
	# 主処理
	#
	$n = scalar( @{ $z } )	unless ( defined $n ) ;
	my $theta = ( pi() * 2 ) / $n ;
	$theta *= ( -1 )	unless ( $inverse ) ;

	my $w = [] ;
	my $r = [] ;

	foreach ( my $k = 0 ; $k < $n ; $k++ ) {

		my $obj = __PACKAGE__->new( [ 0 , 0 ] ) ;

		foreach ( my $j = 0 ; $j < $n ; $j++ ) {
			#
			# 偏角 t == ( theta * k * j ) となる複素数 w[ k , j ] を生成。
			#
			if ( $k <= $j ) {
				$w->[ $k ]->[ $j ] = __PACKAGE__->new( { 'theta' => ( $theta * $k * $j ) } ) ;
			}
			else {
				$w->[ $k ]->[ $j ] = $w->[ $j ]->[ $k ] ;
			}

			#
			# 積和演算
			#
			$obj += ( $z->[ $j ] * $w->[ $k ]->[ $j ] ) ;
		}

		$r->[ $k ] = $obj ;
	}

	if ( $inverse ) {
		foreach ( @{ $r } ) {
			$_ /= $n ;
		}
	}

	return $r ;
}

sub idft {
	#-----------------------------------------------------------------------
	#
	# 離散フーリエ逆変換 ( Inverse Discrete Fourier Transform )
	#
	#   正変換か逆変換かは dft 内で判別する。 ( 呼び出し元の関数名を見ている。 )
	#
	#-----------------------------------------------------------------------
	return dft( @_ ) ;
}

=head2 fft , ifft

These methods are exported as functions.

"fft" provides an 'Fast Fourier Transform' function.

"ifft" provides an 'Inverse Fast Fourier Transform' function.


The "Discrete Fourier Transform" and the "Inverse Discrete Fourier Transform" are defined as follows.

   z is numeric array, and it has n elements.

   Z == dft( z )

                                             2 * PI
   -> Z[k] == sum( z[j] * ( exp( (-1) * i * -------- ) )^( j * k ) )
                                               n

                                            2 * PI * j * k 
           == sum( z[j] * exp( (-1) * i *  ---------------- ) )           ( k == 0 -> n - 1 , j == 0 -> n - 1 )
                                                  n

   z == idft( Z )

               1                            2 * PI
   -> z[k] == --- * sum( Z[j] * ( exp( i * -------- ) )^( j * k )
               n                              n

               1                            2 * PI * j * k 
           == --- * sum( Z[j] * ( exp( i * ---------------- ) ) )         ( k == 0 -> n - 1 , j == 0 -> n - 1 )
               n                                  n

In "Fast Fourrier Transform" and its inverse function define complex array w, at first.

                    2 * PI
  w[0] == exp( i * -------- * 0 ) == 1
                      n

                    2 * PI
  w[1] == exp( i * -------- * 1 )
                      n

  ..............................

                       2 * PI
  w[n-1] == exp( i * -------- * ( n - 1 ) )
                         n

This complex array w can be defined

  w = [ root( 1 , n ) ]            ( sometime, w[k] is called "twiddle factor". )

Next, redefine "j * k" as follows.

  t == ( j * k * (-1) ) % n        ( for FFT )
  t == ( j * k ) % n               ( for iFFT )

Then, 

                   2 * PI * ( j * k )
  exp( (-1) * i * -------------------- ) == w[t]           # for FFT
                          n

            2 * PI * ( j * k )
  exp( i * -------------------- ) == w[t]                  # for iFFT
                   n




  $z = [ 1 .. 10 ] ;
  $zz = fft( $z ) ;

  print join "\n" , @{ $zz } ;             # 55
                                           # -5 + 15.388417685876267 i
					   # -5 + 6.881909602355868 i
					   # -5 + 3.632712640026804 i
					   # -5 + 1.624598481164532 i
					   # -5
					   # -5 - 1.624598481164532 i
					   # -5 - 3.632712640026804 i
					   # -5 - 6.881909602355868 i
				           # -5 - 15.388417685876267 i

  print join "\n" , @{ ifft( $zz ) } ;     # 1
                                           # 2
					   # 3
					   # 4
					   # 5
					   # 6
					   # 7
					   # 8
					   # 9
					   # 10

=cut

sub fft {
	#-----------------------------------------------------------------------
	#
	# 高速フーリエ変換 ( Fast Fourier Transform )
	#
	#
	#   フーリエ変換において最もコストがかかるのは、 n^2 個の回転因子を生成する箇所となる。
	#   高速フーリエ変換は、必要な回転因子の個数やその生成方法を最適化して高速化を図ると言うアプローチを採る。
	#
	#
	#   フーリエ正変換
	#
	#                                            2PI * j * k
	#     Z[k] == Σ( z[j] * exp( ( -1 ) * i * --------------- ) )            ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#                                                 n
	#     
	#   において、
	#
	#     x == j * k 
	#
	#                                       2PI * x
	#     w( n , x ) == exp( ( -1 ) * i * ----------- )
	#                                          n
	#
	#   と定義すると、
	#                                           2PI * ( x + n )
	#     w( n , x + n ) == exp( ( -1 ) * i * ------------------- )
	#                                                  n
	#
	#                                             2PI * x      2PI * n
	#                    == exp( ( -1 ) * i * ( ---------- + ----------- ) )
	#                                                n            n
	#
	#                                           2PI * x
	#                    == exp( ( -1 ) * i * ----------- ) * exp( ( -1 ) * i * 2PI )
	#                                              n
	#
	#                                           2PI * x
	#                    == exp( ( -1 ) * i * ----------- ) * 1.0
	#                                              n
	#
	#                    == w( n , x )
	#
	#   となる。
	#
	#   つまり、回転因子 w( n , x ) == w( n , j * k ) とは、複素平面における単位円上に偏角 2PI/n 毎に現れる点に他ならない。
	#
	#   x が n の倍数になると w( n , x ) は一巡し、以後同じ数列が生成されることになる。
	#   よって、
	#
	#     x == ( j * k ) % n
	#
	#   と再定義することができる。
	#
	#
	#   フーリエ正変換における w( n , x ) == w( n , j * k ) は、
	#
	#     w( n , x ) == w( n , j * k )
	#                == w( n , ( j * k ) % n )
	#
	#                                       2PI * x 
	#                == exp( ( -1 ) * i * ----------- ) * 1.0
	#                                         n
	#
	#                                2PI * x
	#                == ( exp( i * ----------- ) )^( -1 )
	#                                   n
	#   
	#   であり、これは複素平面上の単位円に関する位相 n の円周群の各要素について、その逆数を採ったものとなる。
	#
	#   任意の複素数 z の逆数の定義は
	#
	#                   conj( z )
	#     z^( -1 ) == -------------
	#                   det( z )
	#
	#   であるため、 z が複素平面上の単位円であれば det( z ) == 1 即ち
	#
	#     z^( -1 ) == conj( z )
	#
	#   となる。
	#   これは、 z == 1 を基点として偏角 ( 2PI * x / n ) を時計回りに辿ったものに等しい。
	#
	#   したがって、 z == 1 を基点とする位相 n の円周群 C を
	#
	#     C = circle_group( z , n )
	#
	#   と定義すると、フーリエ正変換の回転因子 w は、
	#
	#     w == [ C[ 0 ] , C[ n - 1 ] , C[ n - 2 ] , ..... , C[ 1 ] ]
	#     
	#   となる数列として表現できることになる。
	#
	#
	#   フーリエ逆変換の場合は、
	#
	#     w( n , x ) == w( n , j * k )
	#                == w( n , ( j * k ) mod n )
	#
	#                              2PI * x 
	#                == exp( i * ----------- ) * exp( i * 2PI )
	#                                 n
	#
	#                              2PI * x
	#                == exp( i * ----------- ) * 1.0
	#                                 n
	#
	#   であり、これは複素平面上の単位円に関する位相 n の円周群そのものとなる。
	#   これは、 z == 1 を基点として偏角 ( 2PI * x / n ) を反時計回りに辿ったものに等しい。
	#
	#
	#   古典的な FFT では、分割統治法の一種であるバタフライ演算によって実装される。
	#   この方法は n が偶数の時にしか適用できないため、数列に 0 を追加して調整したり、 n == 2k + d に分解して奇数部 d に関しては DFT で補うと言った方法が採られる。
	#   円周群を利用した FFT には n の偶奇による制限はないが、 n が偶数の時、とりわけ n が 8 の倍数の時に演算コストの削減効果が大きくなる。
	#   ( 詳細については circle_group メソッドを参照のこと。 )
	#
	#-----------------------------------------------------------------------
	my( $z , $n ) = @_ ;

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::ifft$/ ) ? 1 : 0 ;

	#
	# 配列要素を複素数に変換
	#
	foreach ( @{ $z } ) {
		$_ = __PACKAGE__->new( [ $_ , 0 ] )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $_ ) ;
	}

	#
	# 初期設定
	#
	$n = new_decimal( scalar( @{ $z } ) )	unless ( defined $n ) ;
	$n = new_decimal( $n )			unless ( ref( $n ) ) ;

	#
	# 回転因子 ( 1 の原始 n 乗根 ) を生成。
	#
	# 正変換の場合は各要素の複素共役を採る。
	#
	my $w = [ __PACKAGE__->new( [ 1 , 0 ] )->circle_group( $n ) ] ;

	unless ( $inverse ) {
		#
		# w[ k ] = conj( w[ k ] ) に当たる処理。
		#
		$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;
	}

	#
	# 変換
	#
	my $r = [] ;
	foreach ( my $k = new_decimal( 0 ) ; $k < $n ; $k++ ) {

		$r->[ $k ] = __PACKAGE__->new( [ 0 , 0 ] ) ;

		foreach ( my $j = new_decimal( 0 ) ; $j < $n ; $j++ ) {
			my $ix = $j->multiply( $k )->modulus( $n ) ;		# ix == ( j * k ) % n
			$r->[ $k ] += ( $z->[ $j ] * $w->[ $ix ] ) ;
		}
	}

	if ( $inverse ) {
		foreach ( @{ $r } ) {
			$_ /= $n ;
		}
	}

	return $r ;
}

sub ifft {
	#-----------------------------------------------------------------------
	#
	# 高速フーリエ逆変換 ( Inverse Fast Fourier Transform )
	#
	#   正変換か逆変換かは fft 内で判別する。 ( 呼び出し元の関数名を見ている。 )
	#
	#-----------------------------------------------------------------------
	return fft( @_ ) ;
}

=head2 rft , irft

"Real FFT" and "Inverse Real FFT"

These methods are exported as functions.

In the Real FFT, it accepts an numeric array, which has real numbers as its elements.
At first, it converts the numeric array to a half size complex array.
Next, run FFT or iFFT against to this complex array.

This solution provides less execution time than FFT and iFFT.

In this solution, the array size will be adjusted to multiple of 4.



  $z = [ 1 .. 10 ] ;
  $zz = rft( $z ) ;

  print join "\n" , @{ $zz } ;             # 55
                                           # -21.892304845413264 + 6.866025403784439 i
					   # -6.5 - 9.526279441628825 i
					   # 5 - 6 i
					   # 5.5 + 2.598076211353316 i
					   # -1.107695154586736 + 5.133974596215561 i
					   # -5
					   # -1.107695154586736 - 5.133974596215561 i
					   # 5.5 - 2.598076211353316 i
					   # 5 + 6 i
					   # -6.5 + 9.526279441628825 i
					   # -21.892304845413264 - 6.866025403784439 i

  print join "\n" , @{ irft( $zz ) } ;     # 1
                                           # 2
					   # 3
					   # 4
					   # 5
					   # 6
					   # 7
					   # 8
					   # 9
					   # 10
					   # 0
					   # 0

=cut

sub rft {
	#-----------------------------------------------------------------------
	#
	# 実数列 FFT ( Real FFT ) 正変換
	#
	#   要素数 n の数列の全ての要素が実数である場合、要素数 1/2 の複素数列に変換してフーリエ変換を行うことができる。
	#
	#   要素数が半減すること、変換の過程で各要素の虚数部が無駄なく利用されることなどから処理効率が向上する。
	#   反面、処理内容はやや複雑になる。
	#
	#   以下、要素数 8 の実数列 x をフーリエ正変換に掛ける過程を示す。
	#
	#     1. 実数列からサイズ 1/2 の複素数列への変換。
	#        実数列の偶数項を実部に、奇数項を虚部に持つ複素数列を生成する。
	#
	#        実数列 x を複素数列 z に変換するものとすると、要素数 n == 8 より、
	#
	#          z[0] == x[0] + i * x[1]
	#          z[1] == x[2] + i * x[3]
	#          z[2] == x[4] + i * x[5]
	#          z[3] == x[6] + i * x[7]
	#
	#      2. 複素数列 z をフーリエ変換に掛け、これを Z とする。
	#
	#         Z = fft( z )
	#
	#      3. フーリエ変換された Z から fft( x ) を復元する。
	#
	#         y == fft( x ) とすると、 y の生成規則は以下のようになる。
	#
	#           y[ 0 ]       == real( Z[0] ) + imag( Z[0] )
	#           y[ n/2 ]     == real( Z[0] ) - imag( Z[0] )
	#
	#           y[ n - n/4 ] == Z[ n/4 ]
	#           y[ n/4 ]     == conj( Z[ n/4 ] )
	#
	#           1 <= k < n/4 について、
	#
	#             y[ k ]        == Z[ k ]               - 1/2 * ( complex( [ 1 , w^k ] ) * ( Z[ k ] - conj( Z[ n/2 - k ] ) ) )
	#             y[ n/2 + k ]  == conj( Z[ n/2 - k ] ) + 1/2 * ( complex( [ 1 , w^k ] ) * ( Z[ k ] - conj( Z[ n/2 - k ] ) ) ) 
	#
	#             y[ n   - k ]  == conj( y[ k ] )
	#             y[ n/2 - k ]  == conj( y[ n/2 + k ] ) 
	#
	#         よって、 n == 8 の場合は以下のようになる。
	#
	#           y[ 0 ] == real( Z[ 0 ] ) + imag( Z[ 0 ] )
	#           y[ 4 ] == real( Z[ 0 ] ) - imag( Z[ 0 ] )
	#
	#           y[ 6 ] == Z[ 2 ]
	#           y[ 2 ] == conj( Z[ 2 ] ) == conj( y[ 6 ] )
	#
	#           y[ 1 ] == Z[ 1 ]         - 1/2 * ( complex( [ 1 , w^1 ] ) * ( Z[ 1 ] - conj( Z[ 3 ] ) ) )
	#           y[ 5 ] == conj( Z[ 3 ] ) + 1/2 * ( complex( [ 1 , w^1 ] ) * ( Z[ 1 ] - conj( Z[ 3 ] ) ) )
	#
	#           y[ 7 ] == conj( y[ 1 ] )
	#           y[ 3 ] == conj( y[ 5 ] )
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	return undef	unless ( ref( $x ) eq 'ARRAY' ) ;

	#
	# 数列の要素数を 4 の倍数に調整。
	#
	while ( ( @{ $x } % 4 ) != 0 ) { push( @{ $x } , 0 ) ; }

	#
	# 変数を初期化。
	#
	my $n = @{ $x } ;
	my $n2 = $n / 2 ;
	my $n4 = $n / 4 ;

	my $w = [ __PACKAGE__->new( 1 )->root( $n ) ] ;			# 1 の n 乗根
	$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;	# 正変換用の係数列

	#
	# 実数列をサイズ 1/2 の複素数列に変換。
	#
	my $xa = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		#
		# 実数列の偶数項を実部に、基数項を虚部に持つ複素数列を生成する。
		#
		my( $re , $im ) = ( $x->[ $i * 2 ] , $x->[ $i * 2 + 1 ] ) ;

		#
		# 数列の要素は実数でなければならない。
		#
		foreach ( $re , $im ) {
			if ( ref( $_ ) ) {
				return undef	unless ( $_->can_decimal() ) ;
				$_ = $_->decimal() ;
			}
		}

		#
		# 複素数列を生成。
		#
		$xa->[ $i ] = __PACKAGE__->new( [ $re , $im ] ) ;
	}

	#
	# 複素数列をフーリエ正変換に掛ける。
	#
	my $xb = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		$xb->[ $i ] = __PACKAGE__->new( 0 ) ;
		foreach my $j ( 0 .. ( $n2 - 1 ) ) {
			#
			# サイズ n 用の回転因子を n/2 用に流用するため、
			# 冪乗数は 2 倍したものを使う。
			#
			my $k = ( $i * $j * 2 ) % $n ;
			$xb->[ $i ] += ( $xa->[ $j ] * $w->[ $k ] ) ;
		}
	}

	#print join( "\n" , @{ $xb } ) , "\n\n" ;

	#
	# fft( x ) へ変換。
	#
	my $one       = __PACKAGE__->new( [ 1 , 0 ] ) ;
	my $imag_unit = __PACKAGE__->new( [ 0 , 1 ] ) ;

	my $r = [] ;
	$r->[ 0 ]        = $xb->[ 0 ]->real() + $xb->[ 0 ]->imag() ;
	$r->[ $n2 ]      = $xb->[ 0 ]->real() - $xb->[ 0 ]->imag() ;

	$r->[ $n - $n4 ] = $xb->[ $n4 ] ;
	$r->[ $n4 ]      = $xb->[ $n4 ]->conj() ;

	foreach my $k ( 1 .. ( $n4 - 1 ) ) {

		my $diff = ( $one + ( $imag_unit * $w->[ $k ] ) ) * ( $xb->[ $k ] - $xb->[ $n2 - $k ]->conj() ) * 0.5 ;

		$r->[ $k ]       = $xb->[ $k ]               - $diff ;
		$r->[ $n2 + $k ] = $xb->[ $n2 - $k ]->conj() + $diff ;

		$r->[ $n  - $k ] = $r->[ $k ]->conj() ;
		$r->[ $n2 - $k ] = $r->[ $n2 + $k ]->conj() ;
	}

	return $r ;
}

sub irft {
	#-----------------------------------------------------------------------
	#
	# 実数列 FFT ( Real FFT ) 逆変換
	#
	#   要素数 n の変換元の数列を y , 変換過程の複素数列を Z として手順を示す。
	#
	#   1.  y -> Z へ変換
	#
	#     Z の要素数は n/2 であるため、 Z の添え字を k とすると、
	#
	#       0 <= k < n/2 
	#
	#     となる。
	#
	#     正変換において、 k == 0 , n/2 については、
	#
	#       y[ 0 ]   == real( Z[0] ) + imag( Z[0] )
	#       y[ n/2 ] == real( Z[0] ) - imag( Z[0] )
	#
	#     よって、
	#
	#       y[ 0 ] + y[ n/2 ] == 2 * real( Z[0] )
	#       y[ 0 ] - y[ n/2 ] == 2 * imag( Z[0] )
	#
	#         -> Z[ 0 ] == real( Z[0 ] ) + i * imag( Z[0] )
	#                   == 1/2 * ( ( y[ 0 ] + y[ n/2 ] ) + i * ( y[ 0 ] - y[ n/2 ] ) ) 
	#
	#     k == n/4 については、
	#
	#       y[ n/4 ] == conj( Z[ n/4 ] ) 
	#
	#         -> Z[ n/4 ] == conj( y[ n/4 ] )
	#
	#     1 <= k < n/4 については、
	#
	#       y[ k ]        == Z[ k ]               - 1/2 * ( complex( [ 1 , w^k ] ) * ( Z[ k ] - conj( Z[ n/2 - k ] ) ) )         .... [1]
	#       y[ n/2 + k ]  == conj( Z[ n/2 - k ] ) + 1/2 * ( complex( [ 1 , w^k ] ) * ( Z[ k ] - conj( Z[ n/2 - k ] ) ) )         .... [2]
	#
	#     より、
	#
	#       y[ k ] + y[ n/2 + k ] == ( Z[ k ] + conj( Z[ n/2 - k ] ) )      .... [3]
	#
	#       y[ k ] - y[ n/2 + k ] == ( Z[ k ] - conj( Z[ n/2 - k ] ) ) - ( complex( [ 1 , w^k ] ) * ( Z[ k ] - conj( Z[ n/2 - k ] ) ) )
	#                             == ( Z[ k ] - conj( Z[ n/2 - k ] ) ) * ( 1 - complex( [ 1 , w^k ] ) )
	#                             == ( Z[ k ] - conj( Z[ n/2 - k ] ) ) * ( -i * w^k )
	#
	#         -> Z[ k ] - conj( Z[ n/2 - k ] ) == ( y[ k ] - y[ n/2 + k ] ) * ( -i * w^k )^(-1)
	#                                          == ( y[ k ] - y[ n/2 + k ] ) * ( i * w^(-k) )        .... [4]
	#
	#
	#       [1] に [4] を代入して、
	#
	#         y[ k ] == Z[ k ] - 1/2 * ( complex( [ 1 , w^k ] ) * ( ( y[ k ] - y[ n/2 + k ] ) * ( i * w^(-k) ) ) )
	#                == Z[ k ] - 1/2 * ( 1 + i * w^k ) * ( i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#                == Z[ k ] - 1/2 * ( i * w^(-k) - 1 ) * ( y[ k ] - y[ n/2 + k ] )
	#                == Z[ k ] + 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#
	#         -> Z[ k ] == y[ k ] - 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#
	#       [2] に [4] を代入して、
	#
	#         y[ n/2 + k ] == conj( Z[ n/2 - k ] ) + 1/2 * ( complex( [ 1 , w^k ] ) * ( y[ k ] - y[ n/2 + k ] ) * ( i * w^(-k) ) )
	#                      == conj( Z[ n/2 - k ] ) + 1/2 * ( 1 + i * w^k ) * ( i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#                      == conj( Z[ n/2 - k ] ) + 1/2 * ( i * w^(-k) - 1 ) * ( y[ k ] - y[ n/2 + k ] )
	#                      == conj( Z[ n/2 - k ] ) - 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#
	#         -> conj( Z[ n/2 - k ] ) == y[ n/2 + k ] + 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#         -> Z[ n/2 - k ] == conj( y[ n/2 + k ] + 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] ) )
	#        
	#     結果をまとめると、
	#
	#       Z[ 0 ]       == 1/2 * ( ( y[ 0 ] + y[ n/2 ] ) + i * ( y[ 0 ] - y[ n/2 ] ) )
	#       Z[ n/4 ]     == conj( y[ n/4 ] )
	#
	#       Z[ k ]       ==       y[ k ]       - 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] )
	#       Z[ n/2 - k ] == conj( y[ n/2 + k ] + 1/2 * ( 1 - i * w^(-k) ) * ( y[ k ] - y[ n/2 + k ] ) )
	#
	#       ( 0 < k < n/4 )
	#
	#     となる。
	#          
	#
	#     n == 8 とすると、 Z の要素数は n/2 == 4 であり、
	#
	#       Z[ 0 ] == 1/2 * complex( [ ( y[ 0 ] + y[ 4 ] ) , ( y[ 0 ] - y[ 4 ] ) ] ) 
	#
	#       Z[ 2 ] == conj( y[ 2 ] )
	#
	#       Z[ 1 ] ==       y[ 1 ] - 1/2 * ( 1 - i * w^(-1) ) * ( y[ 1 ] - y[ 5 ] )
	#       Z[ 3 ] == conj( y[ 5 ] + 1/2 * ( 1 - i * w^(-1) ) * ( y[ 1 ] - y[ 5 ] ) )
	#
	#   2. 複素数列 Z をフーリエ逆変換に掛け、複素数列 z を得る。
	#
	#     z == ifft( Z ) 
	#
	#   3. 複素数列 z を実数列 x へ変換。
	#
	#      複素数列 z の実部を実数列 x の偶数項に、虚部を奇数項に格納する。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	return undef	unless ( ref( $x ) eq 'ARRAY' ) ;

	#
	# 数列の要素数を 4 の倍数に調整。
	#
	while ( ( @{ $x } % 4 ) != 0 ) { push( @{ $x } , 0 ) ; }

	#
	# 数列は複素数列でなければならない。
	#
	foreach ( @{ $x } ) {
		$_ = __PACKAGE__->new( $_ )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef			unless ( defined $_ ) ;
	}

	#
	# 変数を初期化。
	#
	my $n = @{ $x } ;
	my $n2 = $n / 2 ;
	my $n4 = $n / 4 ;

	my $w = [ __PACKAGE__->new( 1 )->root( $n ) ] ;	# 逆変換用なので 1 の n 乗根をそのまま使う。

	#
	# サイズ 1/2 の複素数列に変換。
	#
	my $xa = [] ;
	my $one       = __PACKAGE__->new( [ 1 , 0 ] ) ;
	my $imag_unit = __PACKAGE__->new( [ 0 , 1 ] ) ;

	$xa->[ 0 ]    = ( ( $x->[ 0 ] + $x->[ $n2 ] ) + $imag_unit * ( $x->[ 0 ] - $x->[ $n2 ] ) ) * 0.5 ;
	$xa->[ $n4 ]  = $x->[ $n4 ]->conj() ;

	foreach my $k ( 1 .. ( $n4 - 1 ) ) {

		my $diff = ( $one - ( $imag_unit * $w->[ $k ] ) ) * ( $x->[ $k ] - $x->[ $n2 + $k ] ) * 0.5 ;

		$xa->[ $k ]       = ( $x->[ $k ]               - $diff ) ;
		$xa->[ $n2 - $k ] = ( $x->[ $n2 - $k ]->conj() + $diff )->conj() ;
	}

	#
	# 複素数列をフーリエ逆変換に掛ける。
	#
	my $xb = [] ;
	foreach my $i ( 0 .. ( $n2 - 1 ) ) {
		$xb->[ $i ] = __PACKAGE__->new( 0 ) ;
		foreach my $j ( 0 .. ( $n2 - 1 ) ) {
			#
			# サイズ n 用の回転因子を n/2 用に流用するため、
			# 冪乗数は 2 倍したものを使う。
			#
			my $k = ( $i * $j * 2 ) % $n ;
			$xb->[ $i ] += ( $xa->[ $j ] * $w->[ $k ] ) ;
		}

		#
		# 除算は n/2 を使用。
		#
		$xb->[ $i ] /= $n2 ;
	}

	#
	# 実数列に戻す。
	#
	my $r = [] ;
	foreach my $i ( 0 .. $#{ $xb } ) {
		my( $re , $im ) = $xb->[ $i ]->as_array() ;
		push( @{ $r } , $re->round( 15 ) , $im->round( 15 ) ) ;
	}

	return $r ;
}

=head2 dct , idct

"Discrete Cosine Transform" and "Inverse Discrete Cosine Transform".

These methods are exported as functions.


DCT is defined as follows. ( aka. DCT-II )

   z is a numeric array, and it has n elements.

   Z == dct( z )
                             1                1
   Z[k] == sum( z[j] * cos( --- * PI * ( j + --- ) * k ) )           ( k == 0 -> n - 1 , j == 0 -> n - 1 )
                             n                2

iDCT is defined as follows. ( aka. DCT-III * 2/n )

            2       1                             1                1
   z[k] == --- * ( --- * z[0] + sum( z[j] * cos( --- * PI * ( k + --- ) * j ) ) )       ( k == 0 -> n - 1 , j == 1 -> n - 1 )
            n       2                             n                2

   In inverse fucntion, j must be start from 1.


cos( .... ) also can be created from the twiddle factor w.

  w == [ root( 1 , n * 4 ) ]

  In DCT, 

          1                1                    PI
    cos( --- * PI * ( j + --- ) * k ) == cos( ------- * k * ( 2 * j + 1 ) )
          n                2                   n * 2 

                                               2PI
                                      == cos( ----- * ( k * ( 2j + 1 ) ) )
				               4n

    -> t == ( k * ( 2j + 1 ) ) % 4n 

             2PI
    -> cos( ----- * ( k * 2j + 1 ) ) == real( w[t] )
             4n

  In iDCT,

          1                1                   2PI
    cos( --- * PI * ( k + --- ) * j ) == cos( ----- * ( j * ( 2k + 1 ) ) )
          n                2                   4n

    -> t == ( j * ( 2k + 1 ) ) % 4n

             2PI
    -> cos( ----- * ( j * ( 2k + 1 ) ) ) == real( w[t] )
             4n



  $z = [ 1 .. 10 ] ;
  $zz = dct( $z ) ;

  print join "\n" , @{ $zz } ;             # 55
                                           # -20.180180604866423
					   # 0
					   # -2.161510545519229
					   # 0
					   # -0.707106781186548
					   # 0
					   # -0.285926890355019
					   # 0
					   # -0.080179361148022

  print join "\n" , @{ idct( $zz ) } ;     # 1
                                           # 2
					   # 3
					   # 4
					   # 5
					   # 6
					   # 7
					   # 8
					   # 9
					   # 10

In DCT, numeric array elements, it has even number index, is often becomes to 0.
Then, DCT has been applied to the audio compression technology.

=cut

sub dct {
	#-----------------------------------------------------------------------
	#
	# 離散コサイン変換 ( Discrete Cosine Transform )
	#
	#
	#   変換元の数列を z 、変換後の数列を Z とし、 n を z の要素数とすると、
	#
	#   離散コサイン正変換は、
	#
	#                                  1                1
	#     Z[ k ] == Σ( z[ j ] * cos( --- * PI * ( j + --- ) * k ) )    ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#                                  n                2
	#
	#   離散コサイン逆変換 ( Inverse Discrete Cosine Transform ) は、
	#
	#                2       1                              1                1
	#     Z[ k ] == --- * ( --- * z[0] + Σ( z[ j ] * cos( --- * PI * ( k + --- ) * j ) ) )    ( k == 0 -> n - 1 , j == 1 -> n - 1 )
	#                n       2                              n                2
	#
	#   と定義される。
	#   ( 逆変換の場合、 j が 1 から始まる点に注意が必要。 )
	#
	#   DCT には 8 種類の手法が存在するが、ここで扱っているのは DCT-II ( 正変換 ) と DCT-III ( 逆変換 ) に当たる。
	#   ただし、本来の DCT-III の定義には、係数 2/n が含まれず、逆変換 IDCT は、
	#
	#     IDCT == DCT-III * 2 / n
	#
	#   と定義される。
	#
	#
	#   正変換に含まれる余弦の箇所を変形すると以下のようになる。
	#
	#           1                1                   PI
	#     cos( --- * PI * ( j + --- ) * k ) == cos( ---- * ( k * ( 2j + 1 ) ) )
	#           n                2                   2n
	#
	#                                                2PI
	#                                       == cos( ----- * ( k * ( 2j + 1 ) ) )
	#                                                4n
	#
	#   これを複素数の実部と考えると、実部にこの値を持つ複素数列 w は、
	#
	#     t == ( k * ( 2j + 1 ) ) % 4n
	#
	#     w[ t ] == exp( i * ( 2PI / 4n ) * t )
	#
	#   の集合となる。
	#
	#   j , k が正の整数であることから、 t は法 4n の下での正の整数となり、
	#   w[ t ] は複素単位円を位相 4n で分割した円周群 ( 1 の 4n 乗根の集合 ) の一要素と言うことになる。
	#
	#
	#   以上の内容を踏まえると、
	#
	#   離散コサイン正変換は、
	#
	#     w == circle_group( complex( [ 1 , 0 ] ) , 4n ) == root( complex( [ 1 , 0 ] ) , 4n )
	#
	#     t == ( k * ( 2j + 1 ) ) % 4n
	#
	#     Z[ k ] == Σ( z[ j ] * real( w[ t ] ) )                           ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#   離散コサイン逆変換は、正変換と同じ w を用いて、
	#
	#     t == ( j * ( 2k + 1 ) ) % 4n
	#
	#                2       1
	#     Z[ k ] == --- * ( --- * z[0] + Σ( z[ j ] * real( w[ t ] ) ) )    ( k == 0 -> n - 1 , j == 1 -> n - 1 )
	#                n       2
	#
	#   となる。
	#
	#
	#   離散コサイン正変換を使用すると、データ数列の間引きが可能になり、逆変換で元データの復元が可能になる。
	#   このことから、離散コサイン変換は音声データの圧縮技術に応用されている。
	#   行列を用いて離散コサイン変換を二次元に拡張したものは、 JPEG 等の画像圧縮技術に応用されている。
	#
	#-----------------------------------------------------------------------
	my( $z ) = @_ ;

	return []	unless ( ref( $z ) eq 'ARRAY' ) ;

	my $n = @{ $z } ;

	#
	# 配列要素を複素数に変換
	#
	foreach ( @{ $z } ) {
		$_ = __PACKAGE__->new( [ $_ , 0 ] )	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( defined $_ ) ;
	}

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::idct$/ ) ? 1 : 0 ;

	#
	# 複素単位円を位相 4n で分割した円周群 ( 1 の 4n 乗根の集合 ) を生成。
	#
	my $n4 = $n * 4 ;
	my $w = [ __PACKAGE__->new( [ 1 , 0 ] )->circle_group( $n4 ) ] ;

	#
	# 主処理
	#
	my $r = [] ;
	foreach my $k ( 0 .. ( $n - 1 ) ) {
		my $j0 = ( $inverse ) ? 1 : 0 ;			# 正変換と逆変換では $j の開始点が異なる。
		foreach my $j ( $j0 .. ( $n - 1 ) ) {
			my $t = ( $inverse )
				? $j * ( $k * 2 + 1 )
				: $k * ( $j * 2 + 1 )
			;
			$t %= $n4 ;
			$r->[ $k ] += $z->[ $j ] * $w->[ $t ]->real() ;
		}
	}

	if ( $inverse ) {
		my $c1 = $z->[0] * 0.5 ;
		my $c2 = 2 / $n ;
		foreach ( @{ $r } ) {
			$_ = ( $_ + $c1 ) * $c2 ;
		}
	}

	return $r ;
}

sub idct {
	#-----------------------------------------------------------------------
	#
	# 離散コサイン逆変換 ( Inverse Discrete Cosine Transform )
	#
	#   正変換か逆変換かは dct 内で判別する。 ( 呼び出し元の関数名を見ている。 )
	#
	#-----------------------------------------------------------------------
	return dct( @_ ) ;
}

#===============================================================================
#
# 剰余体 ( Residue Field )
#
#===============================================================================

package Residue ;

#
#   剰余環をうまく利用すると、複素数体に酷似した数体を構成することができる。
#
#   剰余体は、
#
#     w^n     ≡  1 ( mod p )
#     w^(n/2) ≡ -1 ( mod p )
#     w^k    !≡  1 ( mod p )     ( k != n )
#
#   と言う関係を持つ正の整数 w , n , p で構成される。
#
#   p が素数であれば、 w^k は 0 <= w^k < p となる全ての正の整数を網羅する値となり、
#   剰余環は p 個の元からなる剰余体 ( p - 元体 ) をなす。
#
#   複素数体における虚数単位に当たる変数を j とすると、
#
#     j^2 ≡ -1      ( mod p )
#         ≡ w^(n/2) ( mod p )
#
#     -> j ≡ w^(n/4) ( mod p )
#
#   となる。
#
#   複素数体における任意の複素数 z は、
#
#     z         == x + iy == r * exp( i * theta )
#                         == r * i * exp( theta )
#
#     conj( z ) == x - iy == r * exp( -i * theta )
#                         == r * ( exp( i * theta ) )^(-1)
#                         == r * ( exp( theta ) )^(-i)
#                         == r * -i * exp( theta )
#
#     x         == r * cos( theta )
#     y         == r * sin( theta )
#     r         == abs( z ) == sqrt( x^2 + y^2 )
#
#     -PI <= theta <= PI     ( theta == k * 2PI / n )
#
#   のように構成される。
#
#   これを基に剰余体における値を定義すると、
#
#     q         ≡ +a * j + b  ( mod p )
#     conj( q ) ≡ -a * j + b  ( mod p )
#
#   となる。
#
#   剰余体上の 2 変数を
#
#     q ≡ a * j + b       ( mod p )
#     r ≡ c * j + d       ( mod p )
#
#   とすると、
#
#     q + r   ≡ ( a + c ) * j + ( b + d )   ( mod p )
#     q - r   ≡ ( a - c ) * j + ( b - d )   ( mod p )
#
#     q * r   ≡ ac * j^2 + ( ad + bc ) * j + bd   ( mod p )
#             ≡ ( ad + bc ) * j - ( ad - bc )     ( mod p )
#
#     q / r   ≡ q * r^(-1)                                     ( mod p )
#             ≡ q * modinverse( r , p )                        ( mod p )
#             ≡ q * modexp( r , totient( p ) - 1 , p )         ( mod p )
#
#     q^m     ≡ modexp( q , m , p )                            ( mod p )
#             ≡ q * modexp( q , m - 1 , p )                    ( mod p )
#             ≡ ( aj + b ) * modexp( ( aj + b , m - 1 , p )    ( mod p )
#
#     q^(-1)  ≡ modexp( q , 1 * ( totient( p ) - 1 ) , p )     ( mod p )
#     q^(-m)  ≡ modexp( q , m * ( totient( p ) - 1 ) , p )     ( mod p )
#
#
#     q^k ≡ 1 ( mod p ) and d ≡ 1 ( mod k )
#     -> d == kr + 1
#     -> q^d == q^( kr + 1 )
#            == ( q^k )^r * q
#            ≡ q ( mod p )
#
#     q^k ≡ 1 ( mod p ) and uv ≡ 1 ( mod k ) の時、
#     b ≡ a^u ( mod p ) であれば、
#
#        b^v ≡ ( a^u )^v ( mod p )
#            ≡ a^(uv)    ( mod p )
#            ≡ a         ( mod p )
#
#        -> ( b^v )^(1/v) ≡ ( ( a^u )^v )^(1/v)    ( mod p )
#        -> a^(1/v)       ≡ a^u    ( mod p ) 
#
#
#   合同式の性質
#
#     a ≡ a ( mod p )                                           ( 反射律 )
#     a ≡ b ( mod p ) <-> b ≡ a ( mod p )                      ( 対称律 )
#     a ≡ b ( mod p ) and b ≡ c ( mod p ) -> a ≡ c ( mod p )  ( 推移律 )
#
#     a ≡ b ( mod p ) and c ≡ d ( mod p )
#     -> a + c ≡ b + d ( mod p )                                ( 加法 )
#        a - c ≡ b - d ( mod p )                                ( 減法 )
#        ac    ≡ bd    ( mod p )                                ( 乗法 )
#     ka ≡ kb    ( mod p )
#     -> a ≡ b ( mod p )                                        ( 除法 ; ただし gcd( k , p ) == 1 )
#     -> a ≡ b ( mod p / d )                                    ( 除法 ; d == gcd( k , p ) )
#
#     a + k ≡ b ( mod p ) <-> a ≡ b - k ( mod p )              ( 移行 )
#     a - k ≡ b ( mod p ) <-> a ≡ b + k ( mod p )              ( 移行 )
#
#     ka ≡ kb ( mod p )                                         ( 定数倍 )
#     a^m ≡ b^m ( mod p )                                       ( 冪 )
#
#     b == 1^(1/n) and e ≡ f ( mod totient( p ) ) 
#     -> b^e ≡ b^f ( mod p )
#
#     w ≡ 1^(1/p)  ( mod p ) , b ≡ w^k ( mod p ) の時、 e ≡ f ( mod w ) であれば、
#
#       b^e ≡ b^f ( mod p )
#
#

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

use overload
	'""'    => 'as_string'		,
	#'0+'    => 'as_numeric'		,
	'+'	=> 'add'		,
	'-'	=> 'subtract'		,
	'*'	=> 'multiply'		,
	'/'	=> 'divide'		,
	'**'    => 'modexp'		,
	'=='	=> 'equal'		,
	'!='	=> 'not_equal'		,
	'>'	=> 'greater_than'	,
	'>='	=> 'greater_equal'	,
	'<'	=> 'less_than'		,
	'<='	=> 'less_equal'		,
;

my $NWP = [
	'34359738368'		, # n == 2^35
	'360'			, # w == 360
	'285838663483393'	, # p == 2^35 * 8319 + 1
] ;

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------

sub new_decimal		{ return MyDecimal->new( $_[0] ) ;	}
sub new_fraction	{ return Fraction->new( $_[0] ) ;	}

sub new {
	#-----------------------------------------------------------------------
	#
	# 剰余体オブジェクトを生成。
	#
	#   デフォルトでは Decimal オブジェクトで構成された数列を数論変換に掛けるのに
	#   適したパラメーターを用いて体を形成する。
	#
	#-----------------------------------------------------------------------
	my( $self , $value , $n , $param ) = @_ ;
	my( $class ) = ref( $self ) || $self ;


	my $obj = undef ;

	#
	# n , w , p , totient( p ) を確定。
	#
	if ( ! defined $param ) {
		#
		# オブジェクトからの呼び出しであれば、環境を複製する。
		#
		if ( ref( $self ) ) {
			$obj = $self->copy() ;
			$obj->{'val'} = [] ;

			if ( defined $n ) {
				my( $n0 , $w , $p ) = @{ $NWP } ;
				$w = new_decimal( $w ) ;

				my $k = new_decimal( $n0 ) / $n ;
				return undef	unless ( $k->is_integer() ) ;

				$obj->{'w'} = $w->modexp( $k , $p ) ;
			}
		}
	}

	unless ( defined $obj ) {

		my $conf = {
			'n'	=> undef ,
			'w'	=> undef ,
			'p'	=> undef ,
			't'	=> undef ,
			'j'	=> [] ,
			'val'	=> [] ,
		} ;

		if ( defined $param ) {
			#
			# 体を形成するパラメーターが外部から与えられた場合。
			#
			#   totient( p ) の演算にかなり大きなコストがかかる。
			#
			if	( ref( $param ) eq 'ARRAY' )	{ @{ $conf }{ 'n' , 'w' , 'p' } = @{ $param } ; }
			elsif	( ref( $param ) eq 'HASH' )	{ @{ $conf }{ 'n' , 'w' , 'p' } = @{ $param }{ 'n', 'w' , 'p' } ; }
			else					{ return undef ; }

			foreach ( 'n' , 'w' , 'p' ) {
				$conf->{ $_ } = new_decimal( $conf->{ $_ } ) ;
				return undef	unless ( defined $conf->{ $_ } ) ;
			}

			$conf->{'t'} = $conf->{'p'}->totient() ;
		}
		else {
			#
			# デフォルトのパラメーターを使用する。
			#
			#   p は素数に設定されているため、
			#
			#     totient( p ) == p - 1
			#
			#   となる。
			#
			@{ $conf }{ 'n' , 'w' , 'p' } = @{ $NWP } ;

			foreach ( 'n' , 'w' , 'p' ) {
				$conf->{ $_ } = new_decimal( $conf->{ $_ } ) ;
				return undef	unless ( defined $conf->{ $_ } ) ;
			}

			$conf->{'t'} = $conf->{'p'} - 1 ;
		}

		if ( defined $n ) {
			#
			# n の値に合わせて w を調整する。
			#
			$n = new_decimal( $n ) ;
			return undef	unless ( defined $n ) ;
			return undef	unless ( $n < $conf->{'n'} ) ;
			return undef	unless ( ( $n % 4 ) == 0 ) ;

			my $k = $conf->{'n'} / $n ;
			return undef	unless ( $k->is_integer() ) ;

			$conf->{'w'} = $conf->{'w'}->modexp( $k , $conf->{'p'} ) ;
			$conf->{'n'} = $n ;
		}

		return undef	unless ( ( $conf->{'n'} % 4 ) == 0 ) ;

		#
		# 虚数単位に当たる j とその定数倍。
		#
		my( $n , $w , $p ) = @{ $conf }{ 'n' , 'w' , 'p' } ;
		$conf->{'j'}  = [
			$w->modexp( ( $n * 0 ) / 4 , $p )	, # w^0      ( mod p )
			$w->modexp( ( $n * 1 ) / 4 , $p )	, # w^(n/4)  ( mod p )
			$w->modexp( ( $n * 2 ) / 4 , $p )	, # w^(2n/4) ( mod p )
			$w->modexp( ( $n * 3 ) / 4 , $p )	, # w^(3n/4) ( mod p )
		] ;

		#
		# n , w , p が体をなすかどうかを検査。
		#
		#   p が素数であれば、
		#
		#     w^n     ≡  1 ( mod p )
		#     w^(n/2) ≡ -1 ( mod p )
		#
		#   だけで条件を満たす。
		#
		#   p が合成数の場合、
		#
		#     w^k    !≡  1 ( mod p )       ( k != n )
		#
		#   を満たす必要があるが、これを確認するのは非常に困難。
		#
		#   代わりに、
		#
		#     ( w^(n/4) )^2  ≡ -1              ( mod p )
		#     ( w^(3n/4) )^2 ≡ ( w^(-n/4) )^2  ( mod p )
		#                    ≡ -1              ( mod p )
		#
		#   を追加で確認しているが、これで十分と言うわけではない。
		#
		my( $j1 , $j3 ) = @{ $conf->{'j'} }[ 1 , 3 ] ;
		return undef	unless ( $w->modexp(   $n     , $p ) == 1          ) ;	# w^n            ≡  1 ( mod p )
		return undef	unless ( $w->modexp(   $n / 2 , $p ) == ( $p - 1 ) ) ;	# w^(n/2)        ≡ -1 ( mod p )
		return undef	unless ( $j1->modexp(  2      , $p ) == ( $p - 1 ) ) ;	# ( w^(n/4) )^2  ≡ -1 ( mod p )
		return undef	unless ( $j3->modexp(  2      , $p ) == ( $p - 1 ) ) ;	# ( w^(3n/4) )^2 ≡ -1 ( mod p )

		#
		# 新規オブジェクトを生成。
		#
		$obj = bless { %{ $conf } } , $class ;
	}

	#
	# 値を格納
	#
	if ( defined $obj ) {
		if ( defined $value ) {
			my( $r , $j ) ;
			if ( ref( $value ) eq 'ARRAY' )	{ ( $r , $j ) = @{ $value } ; }
			else				{ ( $r , $j ) = ( $value , 0 ) ; }

			foreach ( $r , $j ) {
				$_ = new_decimal( $_ )	;
				return undef	unless ( defined $_ ) ;
			}

			#
			# x == a * j^1 + b
			#
			( $r , $j ) = reverse( ( $r + $j * $obj->{'j'}->[1] )->divmod( $obj->{'j'}->[1] , 0 ) ) ;
			foreach ( $r , $j ) {
				$_ %= $obj->{'p'} ;
			}

			$obj->{'val'} = [ $r , $j ] ;
		}
		else {
			$obj->{'val'} = [ new_decimal( 0 ) , new_decimal( 0 ) ] ;
		}
	}

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# コピーコンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $class ) = ref( $self ) || $self ;

	my $conf = {} ;
	foreach my $k ( keys %{ $self } ) {
		if ( ref( $self->{ $k } ) eq 'ARRAY' ) {
			foreach ( @{ $self->{ $k } } ) {
				push( @{ $conf->{ $k } } , $_->copy() ) ;
			}
		}
		else {
			$conf->{ $k } = $self->{ $k }->copy() ;
		}
	}

	my $obj = bless { %{ $conf } } , $class ;

	return $obj ;
}

#-------------------------------------------------------------------------------
#
# 属性
#
#-------------------------------------------------------------------------------
sub is_scalar		{ return 1 ; }
sub is_decimal		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 0 ; }
sub is_residue		{ return 1 ; }
sub is_vector		{ return 0 ; }
sub is_cvector		{ return 0 ; }
sub is_rvector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 0 ; }

sub can_decimal		{ return 1 ; }
sub can_integer		{ return 1 ; }
sub can_fraction	{ return 0 ; }
sub can_complex		{ return 0 ; }
sub can_vector		{ return 0 ; }
sub can_matrix		{ return 0 ; }
sub can_polynomial	{ return 0 ; }

sub value {
	#-----------------------------------------------------------------------
	#
	# 整数 ( Decimal オブジェクト ) に変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;

	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $x , $y ) = @{ $self->{'val'} } ;
	my( $j , $p ) = @{ $self }{ 'j' , 'p' } ;

	my $r = ( $x + $j->[1] * $y ) ;
	$r %= $p ;

	#if ( $r < 0 )	{ $r = $p - ( ( $r * ( -1 ) ) % $p ) ; }
	#else		{ $r %= $p ; }

	return $r ;
}

sub as_string		{ return $_[0]->value() ; } 
sub decimal		{ return $_[0]->value() ; }
sub integer		{ return $_[0]->value() ; }

sub as_array {
	#-----------------------------------------------------------------------
	#
	# x == a + jb とし、 a , b を返す。
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = [ reverse( $x->value()->divmod( $x->{'j'}->[1] , 0 ) ) ] ;	# r == [ a , b ]

	foreach ( @{ $r } ) {
		$_ %= $x->{'p'} ;
	}

	return @{ $r } ;
}

sub rou {
	#-----------------------------------------------------------------------
	#
	# k 番目の 1 の n 乗根 ( roots of unity ) を返す。
	#
	#   1 の n 乗根は回転因子 ( twiddle factors ) とも呼ばれる。
	#
	#   n , w , p によって構成される剰余体において、 1 の n 乗根は、
	#
	#     w^1  ( mod p )
	#
	#   のことであり、この整数冪
	#
	#     w^k  ( mod p )    ( 0 <= k < n )
	#
	#   全体を含めて 1 の n 乗根や回転因子と呼ぶことがある。
	#
	#   剰余体が正しく構成されていれば、負の整数冪について
	#
	#     w^(-k) ≡ ( w^k )^(-1)                                            ( mod p )
	#            ≡ modinverse( w^k , p )                                   ( mod p )
	#            ≡ modexp( w^k , ( totient( p ) - 1 )         % n , p )    ( mod p )
	#            ≡ modexp( w   , ( k * ( totient( p ) - 1 ) ) % n , p )    ( mod p )
	#
	#   と言う関係が成立する。
	#
	#-----------------------------------------------------------------------
	my( $x , $k ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my( $n , $w , $p ) = @{ $x }{ 'n' , 'w' , 'p' } ;

	$k = 1	unless ( defined $k ) ;
	$k %= $n ;
	$k += $n	if ( $k < 0 ) ;

	return $w->modexp( $k , $p ) ;
}

sub twiddle_factor { return rou( @_ ) ; }
sub w              { return rou( @_ ) ; }

#-------------------------------------------------------------------------------
#
# 比較
#
#-------------------------------------------------------------------------------

sub is_same_field {
	#-----------------------------------------------------------------------
	#
	# 二つのオブジェクトが同じ体上の値かどうかを返す。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		return undef	unless ( ref( $_ ) eq __PACKAGE__ ) ;
	}

	return 0	unless ( $x->{'p'} == $y->{'p'} ) ;
	return 0	unless ( $x->{'w'} == $y->{'w'} ) ;
	return 0	unless ( $x->{'n'} == $y->{'n'} ) ;

	return 1 ;
}

sub compare {
	#-----------------------------------------------------------------------
	#
	# 比較
	#
	#   比較対象が複素数体 ( 実数体や整数体を含む ) であれば整数に変換して比較する。
	#   剰余体上の値同士は比較不能とする。
	#
	#   return undef	# 比較不能
	#   return  0	if ( $x == $y )
	#   return  1	if ( $x > $y )
	#   return -1	if ( $x < $y )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return undef	if ( ref( $y ) eq __PACKAGE__ ) ;

	my $r = $x->copy()->value()->compare( $y ) ;

	$r *= ( -1 )	if ( defined $r and $swapped ) ;

	return $r ;
}

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r == 0 ) ? 1 : 0 ;
}

sub not_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( != )
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y ) ;

	return undef	unless ( defined $r ) ;
	return ( $r == 0 ) ? 0 : 1 ;
}

sub greater_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( > )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y , $swapped ) ;

	return undef	unless ( defined $r ) ;
	return ( $r > 0 ) ? 1 : 0 ;
}

sub greater_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( >= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y , $swapped ) ;

	return undef	unless ( defined $r ) ;
	return ( $r >= 0 ) ? 1 : 0 ;
}

sub less_than {
	#-----------------------------------------------------------------------
	#
	# 比較 ( < )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y , $swapped ) ;

	return undef	unless ( defined $r ) ;
	return ( $r > 0 ) ? 0 : 1 ;
}

sub less_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( >= )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;
	return undef    unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = $x->compare( $y , $swapped ) ;

	return undef	unless ( defined $r ) ;
	return ( $r <= 0 ) ? 1 : 0 ;
}

#-------------------------------------------------------------------------------
#
# 変換
#
#-------------------------------------------------------------------------------

sub adjust_field {
	#-----------------------------------------------------------------------
	#
	# 体を合わせる。
	#
	#   任意の値 x , y について、 x の w が 1^(1/m) , y の w が 1^(1/n) である時、
	#   両者を含む体は、
	#
	#     w == 1^( 1 / lcm( m , n ) )
	#
	#   で構成された体となる。
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	foreach ( $x , $y ) {
		return ()	unless ( ref( $_ ) eq __PACKAGE__ ) ;
	}

	my $nx = $x->{'n'} ;
	my $ny = $x->{'n'} ;

	return ( $x , $y )	if ( $nx == $ny ) ;

	my $n = decimal( $nx )->lcm( $ny ) ;	# 両者の n の公倍数を採る。
	my $r = __PACKAGE__->new( 0 , $n ) ;
	return ()	unless ( defined $r ) ;

	foreach ( $x , $y ) {
		$_ = $r->new( $x->value() ) ;
	}

	return ( $x , $y ) ;
}

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = undef ;

	if ( ref( $y ) eq __PACKAGE__ ) {
		( $x , $y ) = $x->adjust_field( $y ) ;
		return undef	if ( ! defined $x or ! defined $y ) ;

		$r = $x->copy() ;
		foreach my $i ( 0 , 1 ) {
			$r->{'val'}->[ $i ] += $y->{'val'}->[ $i ] ;
			$r->{'val'}->[ $i ] %= $r->{'p'} ;
		}
	}
	else {
		$r = $x->new( $x->value() + $y ) ;
	}

	return $r ;
}

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = undef ;

	if ( ref( $y ) eq __PACKAGE__ ) {
		$y = $y->copy() ;
		foreach my $i ( 0 , 1 ) {
			$y->{'val'}->[ $i ] *= ( -1 ) ;
		}
		$r = $x->add( $y ) ;
	}
	else {
		$r = $x->new( 0 ) ;
		$y = new_decimal( $y )	unless ( ref( $y ) ) ;

		( $x , $y ) = ( $y , $x )	if ( $swapped ) ;

		$r = $r->new( $x->value() - $y->value() ) ;
	}
	return $r ;
}

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算
	#
	#-----------------------------------------------------------------------
	my( $x , $y ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my $r = undef ;

	if ( ref( $y ) eq __PACKAGE__ ) {
		#---------------------------------------------------------------
		#
		# Residue オブジェクト同士の乗算
		#
		#---------------------------------------------------------------
		( $x , $y ) = $x->adjust_field( $y ) ;
		return undef	if ( ! defined $x or ! defined $y ) ;

		$r = $x->new( 0 ) ;

		#
		# x == a + jb
		# y == c + jd
		#
		# x * y == ( a + jb )( c + jd ) ≡ ac + ( ad + bc ) * j + j^2 * bd   ( mod p )
		#                               ≡ ac - bd + ( ad + bc ) * j         ( mod p )
		#
		my $xv = [ @{ $x->{'val'} } ] ;
		my $yv = [ @{ $y->{'val'} } ] ;

		$r->{'val'}->[0] = ( ( $xv->[0] * $yv->[0] ) - ( $xv->[1] * $yv->[1] ) ) % $r->{'p'} ;
		$r->{'val'}->[1] = ( ( $xv->[0] * $yv->[1] ) + ( $xv->[1] * $yv->[0] ) ) % $r->{'p'} ;
	}
	else {
		#---------------------------------------------------------------
		#
		# 定数倍
		#
		#---------------------------------------------------------------

		$r = $x->copy() ;

		foreach ( @{ $r->{'val'} } ) {
			$_ *= $y ;
			$_ %= $r->{'p'} ;
		}
	}

	return $r ;
}

sub divide {
	#-----------------------------------------------------------------------
	#
	# 除算
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $swapped ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	$y = new_decimal( $y )	unless ( ref( $y ) ) ;

	if ( ref( $y ) eq __PACKAGE__ ) {
		( $x , $y ) = $x->adjust_field( $y ) ;
		return undef	if ( ! defined $x or ! defined $y ) ;
	}

	my $r = $x->new( 0 ) ;
	my $p = $r->{'p'} ;
	my $t = $r->{'t'} - 1 ; # totient( p ) - 1

	if ( $swapped ) {
		$r = $r->new( $y->decimal() * $x->decimal()->modexp( $t , $p ) ) ;
	}
	else {
		$r = $r->new( $x->decimal() * $y->decimal()->modexp( $t , $p ) ) ;
	}

	return $r ;
}

sub conj {
	#-----------------------------------------------------------------------
	#
	# 共役
	#
	#   x         == a + jb
	#   conj( x ) == a - jb
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	my( $re , $im ) = $x->as_array() ;

	my $r = $x->new( [ $re , $im * ( -1 ) ] ) ;

	return $r ;
}

sub modexp {
	#-----------------------------------------------------------------------
	#
	# 冪乗 ( 冪剰余 )
	#
	#   x == a + jb
	#   x^n ≡ modexp( x , n , p )              ( mod p )
	#       ≡ ( a + jb )^n                     ( mod p )
	#       ≡ ( a + jb ) * ( a + jb )^(n-1)    ( mod p )
	#
	#   n == 2
	#   -> x^2 ≡ ( a + jb )( a + jb )          ( mod p )
	#          ≡ ( a^2 + 2 * ab * j + ( jb )^2 ( mod p )
	#          ≡ ( a^2 - b^2 + 2ab * j )       ( mod p )
	#
	#-----------------------------------------------------------------------
	my( $x , $n ) = @_ ;

	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( defined $n ) ;
	return undef		unless ( $n->is_integer() ) ;

	my $inverse = 0 ;
	if ( $n < 0 ) {
		$inverse = 1 ;
		$n *= ( -1 ) ;
	}

	my $r = $x->copy() ;

	my $p  = $r->{'p'} ;
	my $xv = $x->value() ;			# Residue -> Decimal
	my $pow = ( $n - 1 ) % $x->{'n'} ;
	my $m = $xv->modexp( $pow , $p ) ;

	foreach my $i ( 0 , 1 ) {
		$r->{'val'}->[ $i ] *= $m ;
		$r->{'val'}->[ $i ] %= $p ;
	}

	$r = $r->inverse()	if ( $inverse ) ;

	return $r ;
}

sub power { return modexp( @_ ) ; }

sub root {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	#   合同式の冪乗が
	#
	#     x ≡ y           ( mod p )
	#     -> x^n ≡ y^n    ( mod p )
	#
	#   であることより、冪根の 1 つは
	#
	#     X ≡ x^n         ( mod p )
	#     -> X^(1/n) ≡ x  ( mod p )
	#
	#   として得ることができる。
	#
	#   複素数と同様、剰余体においても n 個の冪根が定義でき、 X の n 冪根 x が一つ見つかれば、
	#
	#     w ≡ 1^(1/n)     ( mod p )
	#
	#     -> X^(1/n) ≡ x * w^k     ( mod p )      ( k == 0 -> n - 1 )
	#
	#   として n 個の根を採ることができる。
	#
	#   Residue オブジェクトの省略時値は、 n が 2 の冪であり且つ 4 の倍数であることを前提として構成されている。
	#   このため、 n 冪根を求める際にもこの制約を強く受けることになる。
	#
	#   平方根に関しては、
	#
	#     x^(1/2) ≡ x^(2/4)   ( mod p )
	#
	#   であるため、 1 の 4 乗根を介して演算できる。
	#
	#   これ以外の n に関する 1 の n 乗根は一般には定義できないが、
	#
	#   n == 12 における
	#
	#     w^3 == 1^(3/12) == 1^(1/4)
	#     w^6 == 1^(6/12) == 1^(2/4)
	#     w^9 == 1^(9/12) == 1^(3/4)
	#
	#   のように演算が可能な因子は存在する。
	#
	#-----------------------------------------------------------------------
	my( $x , $m ) = @_ ;

	return ()	unless ( ref( $x ) eq __PACKAGE__ ) ;
	return ()	unless ( defined $m ) ;

	#
	# x^(1/m) の 1 つを得る。 ( 冪根は m 個存在する。 )
	#
	my( $re , $im ) = $x->as_array() ;
	my $z = undef ;

	if ( $im == 0 ) {
		#
		# x ≡ a + j * 0   ( mod p )
		# 
		# -> x^(1/m) ≡ a^(1/m)   ( mod p )
		#
		$z = $re->root( $m ) ;
		$z = undef	unless( $z->is_integer() ) ;
	}
	elsif ( $re == 0 ) {
		#
		# x ≡ j * a       ( mod p )
		# j ≡ w^(n/4)     ( mod p )
		#
		# -> x^(1/m) ≡ j^(1/m)  * a^(1/m)      ( mod p )
		#            ≡ w^(n/4m) * a^(1/m)      ( mod p )
		#
		my $n = $x->{'n'} ;
		my $m4 = $m * 4 ;
		my $k = $n / $m4 ;

		if ( $k->is_integer() ) {
			$z = $im->root( $m ) ;
			if ( $z->is_integer() ) {
				$z = $x->new( $z * $x->w( $k ) ) ;
			}
		}
	}
	else {
		#
		# x ≡ a^m    ( mod p )
		#
		# -> x^(1/m) ≡ a ( mod p )
		#
		$z = $x->value()->root( $m ) ;
		$z = undef	unless ( $z->is_integer() ) ;
	}

	#
	# m 個の x^(1/m) を生成。
	#
	my $r = [] ;
	if ( defined $z ) {

		$r->[0] = $z ;

		if ( $m == 2 ) {
			#
			# 平方根の場合、回転因子は w^0 と w^1 の二種類のみ。
			#
			#   w^0 == 1^(0/2) == 1
			#   w^1 == 1^(1/2) == 1^(2/4)
			#
			my $y = $x->new( 0 , 4 ) ;
			push( @{ $r } , $x->new( $z * $y->w( 2 ) ) ) ;
		}
		else {
			#
			# m > 2 の場合
			#
			my $y = $x->new( 0 , $m ) ;
			if ( defined $y ) {
				#
				# 1^(1/m) が定義できれば、全ての根を求めることができる。
				#
				foreach ( my $i = new_decimal( 1 ) ; $i < $m ; $i++ ) {
					push( @{ $r } , $x->new( $z * $y->w( $i ) ) ) ;
				}
			}
			else {
				#
				# 1/^(1/m) が定義できない場合。
				#
				#   f == k/m が通分できれば、 f の分母である denom( f ) を用いて、
				#
				#     1^( 1 / denom( f ) )
				#
				#   を定義できることがある。
				#
				#   この場合、 f の分子 numer( f ) を伴って、
				#
				#     w^k == ( 1^( 1 / denom( f ) ) )^( numer( f ) )
				#         == 1^( numer( f ) / denom( f ) )
				#
				#   を得ることができる。
				#
				# この場合、 x^(1/m) の総数は m よりも少なくなる。
				#
				my $wkc = { '1' => 1 } ;				# 重複検査用の変数
				foreach ( my $i = new_decimal( 1 ) ; $i < $m ; $i++ ) {
					my $f = new_fraction( $i , $m ) ;
					my $y = $x->new( 0 , $f->denom() ) ;
					if ( defined $y ) {
						my $wk = $y->w( $f->numer() ) ;
						unless ( defined $wkc->{ $wk } ) {
							push( @{ $r } , $x->new( $z * $wk ) ) ;
							$wkc->{ $wk } = 1 ;
						}
					}
				}
			}
		}
	}

	return @{ $r } ;
}

sub inverse {
	#-----------------------------------------------------------------------
	#
	# 逆数 ( モジュラー逆数 )
	#
	#   x^(-1) ≡ modexp( x , totient( p ) - 1 , p )  ( mod p )
	#          ≡ x^( totient( p ) - 1 )              ( mod p )
	#
	#-----------------------------------------------------------------------
	my( $x ) = @_ ;
	
	return undef	unless ( ref( $x ) eq __PACKAGE__ ) ;

	return $x->modexp( $x->{'t'} - 1 ) ;
}

=head1 "Vector" object - basic construction.

"Vector" object can support vector and matrix.

  print vector( 1 .. 3 ) ;                            # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print complex_vector( [ 1 , 1 ] , [ 1 , 2 ] ) ;     # [        1.00 + 1.00 i ]
                                                      # [        1.00 + 2.00 i ]

  print matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;             # [              1.00000 ,              2.00000 ]
						      # [              3.00000 ,              4.00000 ]

  print complex_matrix(                               #
    [ [ 1 , 1 ] , [ 1 , 2 ] ] ,                       # [        1.00 + 1.00 i ,        1.00 + 2.00 i ]
    [ [ 2 , 1 ] , [ 2 , 2 ] ] ,                       # [        2.00 + 1.00 i ,        2.00 + 2.00 i ]
  ) ;


=cut

#===============================================================================
#
# ベクトル
#
#===============================================================================

package Vector ;

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

use overload
	'""'    => 'as_string'		,
	#'0+'    => 'as_numeric'		,
	'+'	=> 'add'		,
	'-'	=> 'subtract'		,
	'*'	=> 'multiply'		,
	'/'	=> 'divide'		,
	'**'    => 'power'		,
	'=='	=> 'equal'		,
	'!='	=> 'not_equal'		,
	#'>'	=> 'greater_than'	,
	#'>='	=> 'greater_equal'	,
	#'<'	=> 'less_than'		,
	#'<='	=> 'less_equal'		,
;

#-------------------------------------------------------------------------------
#
# 機能の移管 ( 部分的な継承 )
#
#-------------------------------------------------------------------------------
sub horner_sub	{ return MyDecimal::horner_sub( @_ ) ;	}
sub solve2	{ return MyDecimal::solve2( @_ ) ;	}
sub solve3	{ return MyDecimal::solve3( @_ ) ;	}
sub solve4	{ return MyDecimal::solve4( @_ ) ;	}
sub solven	{ return MyDecimal::solven( @_ ) ;	}

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------

sub new_decimal { return MyDecimal->new( $_[0] ) ; }
sub new_complex { return Complex->new( $_[0] ) ; }

sub new {
	#-----------------------------------------------------------------------
	#
	# ベクトルオブジェクトを生成する。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	my $conf = [] ;

	my @v = ( ref( $args[0] ) eq 'ARRAY' )
		? @{ $args[0] }
		: @args
	;

	foreach my $i ( 0 .. $#v ) {
		my $d  = new_decimal( $v[ $i ] ) ;
		return undef	unless ( defined $d ) ;
		$conf->[ $i ]->[0] = $d ;
	}

	my $obj = bless [ @{ $conf } ] , $class ;

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# コピーコンストラクター
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	my $conf = [] ;
	foreach my $r ( @{ $self } ) {
		push( @{ $conf } , [ @{ $r } ] ) ;
	}

	my $obj = bless [ @{ $conf } ] , $class ;

	return $obj ;
}

sub matrix {
	#-----------------------------------------------------------------------
	#
	# 行列オブジェクトを生成する。
	#
	#   複数の数値配列から行列を生成する。
	#
	#   1 つ以上の配列参照を受け取り、これを行ベクトルに見立てて行列を生成する。
	#   個々の配列参照の要素数は全て一致している必要がある。
	#
	#   $m = matrix( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) ;
	#
	#   -> $m == [ 1 , 2 , 3 ]
	#            [ 4 , 5 , 6 ]
	#
	#-----------------------------------------------------------------------
	my( @args ) = @_ ;

	shift( @args )	unless ( ref( $args[0] ) eq 'ARRAY' ) ;

	my $obj = undef ;
	foreach my $v ( @args ) {
		return undef	unless ( ref( $v ) eq 'ARRAY' ) ;

		my $vec = __PACKAGE__->new( $v )->rvector() ;
		return undef	unless ( defined $vec ) ;

		if ( defined $obj ) {
			return undef	unless ( $vec->cols() == $obj->cols() ) ;
			$obj = $obj->vec2matrix( $vec ) ;
		}
		else {
			$obj = $vec ;
		}

		return undef	unless ( defined $obj ) ;
	}

	return $obj ;
}

sub complex_vector {
	#-----------------------------------------------------------------------
	#
	# 複素ベクトルを生成する。
	#
	#   ベクトルオブジェクトから引数なしで呼び出された場合には、
	#   その成分を複素数オブジェクトに変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;

	if ( @args == 0 ) {
		return undef	unless ( $self->is_vector() ) ;
		return $self->complex_matrix() ;
	}

	my $m = undef ;
	foreach my $v ( @args ) {
		push( @{ $m } , [ $v ] ) ;
	}

	$m = __PACKAGE__->complex_matrix( @{ $m } ) ;

	return $m ;
}

sub complex_matrix {
	#-----------------------------------------------------------------------
	#
	# 複素行列を生成する。
	#
	#   ベクトルオブジェクトや行列オブジェクトから引数なしで呼び出された場合には、
	#   その成分を複素数オブジェクトに変換して返す。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;

	my $m = undef ;

	if ( @args == 0 ) {
		#
		# ベクトルや行列の成分を複素数オブジェクトに変換
		#
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

		$m = $self->copy() ;
		my( $rows , $cols ) = $m->size() ;

		foreach my $i ( 0 .. ( $rows - 1 ) ) {
			foreach my $j ( 0 .. ( $cols - 1 ) ) {
				next		if ( $m->[ $i ]->[ $j ]->is_complex() ) ;
				return undef	unless ( $m->[ $i ]->[ $j ]->can_complex() ) ;
				$m->[ $i ]->[ $j ] = $m->[ $i ]->[ $j ]->complex() ;
			}
		}
	}
	else {
		#
		# コンストラクション
		#
		#   $args[ 0 ] == [ [ x11 , y11 ] , [ x12 , y12 ] , ...... ] ;
		#   $args[ 1 ] == [ [ x21 , y21 ] , [ x22 , y22 ] , ...... ] ;
		#
		#   -> $m == [ x11 + iy11 , x12 + iy12 , ..... ]
		#            [ x21 + iy21 , x22 + iy22 , ..... ]
		#
		#   引数の列数に過不足があった場合には、行列の列数をその最大数で補正し、
		#   足りない箇所を complex( [ 0 , 0 ] ) で埋める。
		#
		$m = [] ;
		my $cmax = 0 ;
		foreach my $i ( 0 .. $#args ) {
			foreach my $j ( 0 .. $#{ $args[ $i ] } ) {
				my $v = new_complex( $args[ $i ]->[ $j ] ) ;
				return undef	unless ( defined $v ) ;
				if ( $cmax < $j ) { $cmax = $j ; }
				$m->[ $i ]->[ $j ] = $v ;
			}
		}

		foreach my $i ( 0 .. $#{ $m } ) {
			foreach my $j ( 0 .. $cmax ) {
				next	if ( defined $m->[ $i ]->[ $j ] ) ;
				$m->[ $i ]->[ $j ] = new_complex( [ 0 , 0 ] ) ;
			}
		}

		$m = __PACKAGE__->matrix( @{ $m } ) ;
	}

	return $m ;
}

=head2 diagonal_matrix

Return new diagonal matrix.

Create from vector object.

  $v = vector( 1 .. 3 ) ;                             # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]
 

  print $v->diagonal_matrix() ;                       # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                      # [              0.00000 ,              2.00000 ,              0.00000 ]
                                                      # [              0.00000 ,              0.00000 ,              3.00000 ]

Create with new values.

  $v = vector( 1 .. 3 ) ;                             # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print $v->diagonal_matrix( 4 , 5 ) ;                # [              4.00000 ,              0.00000 ]
                                                      # [              0.00000 ,              5.00000 ]

  print $v->diagonal_matrix(
    complex( [ 1 , 1 ] )  ,                           # [        1.00 + 1.00 i ,              0.00000 ]
    complex( [ 1 , 2 ] )  ,                           # [              0.00000 ,        1.00 + 2.00 i ]
  ) ;



=cut

sub diagonal_matrix {
	#-----------------------------------------------------------------------
	#
	# 対角行列
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	@args = @{ $args[0] }	if ( ref( $args[0] ) eq 'ARRAY' ) ;

	unless ( @args ) {
		@args = @{ $self->as_array() }	if ( $self->is_vector() ) ;
	}

	return undef	unless ( @args ) ;

	my $m = $self->zero_matrix( [ scalar( @args ) ] ) ;
	foreach my $r ( 0 .. $#args ) {
		$m->[ $r ]->[ $r ] = new_decimal( $args[ $r ] ) ;
	}

	return $m ;
}

=head2 zero_vector , unit_vector , zero_matrix , unit_matrix

  $v = vector( 1 .. 3 ) ;

  print $v->zero_vector() ;                                 # [              0.00000 ]
							    # [              0.00000 ]
                                                            # [              0.00000 ]
                                                 
  print $v->transpose()->zero_vector() ;                    # [              0.00000 ,              0.00000 ,              0.00000 ]

  
  print $v->unit_vector() ;                                 # [              1.00000 ]
							    # [              0.00000 ]
                                                            # [              0.00000 ]
   
  print $v->unit_vector( 2 ) ;                              # [              1.00000 ]
                                                            # [              0.00000 ]
							    #
  print $v->unit_vector( 2 , 0 ) ;                          # [              1.00000 ]
                                                            # [              0.00000 ]

  print $v->unit_vector( 2 , 1 ) ;                          # [              0.00000 ]
                                                            # [              1.00000 ]

 
  $m = matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;                    # 2 x 2 matrix

  print $m->zero_matrix() ;                                 # [              0.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              0.00000 ]

  print $m->zero_matrix( 3 ) ;                              # [              0.00000 ,              0.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              0.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              0.00000 ,              0.00000 ]

  print $m->unit_matrix() ;                                 # [              1.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              1.00000 ]

  print $m->E() ;                                           # [              1.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              1.00000 ]

  print $m->unit_matrix( 3 ) ;                              # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                            # [              0.00000 ,              1.00000 ,              0.00000 ]
							    # [              0.00000 ,              0.00000 ,              1.00000 ]


=cut

#-------------------------------------------------------------------------------
#
# 基本的なベクトルや行列
#
#-------------------------------------------------------------------------------

sub zero_vector {
	#-----------------------------------------------------------------------
	#
	# 零ベクトル
	#
	#   デフォルトでは呼び出し元のオブジェクトと同じサイズのベクトルを返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = [] ;

	if ( $self->is_cvector() ) {
		#
		# 列ベクトル
		#
		$n = $self->rows()	unless ( defined $n ) ;
		foreach ( my $i = 0 ; $i < $n ; $i++ ) {
			$m->[ $i ]->[ 0 ] = new_decimal( 0 ) ;
		}
	}
	elsif ( $self->is_rvector() ) {
		#
		# 行ベクトル
		#
		$n = $self->cols()	unless ( defined $n ) ;
		foreach ( my $i = 0 ; $i < $n ; $i++ ) {
			$m->[ 0 ]->[ $i ] = new_decimal( 0 ) ;
		}
	}

	my $obj = ( @{ $m } ) ? __PACKAGE__->matrix( @{ $m } ) : undef ;

	return $obj ;
}

sub unit_vector {
	#-----------------------------------------------------------------------
	#
	# 単位ベクトル
	#
	#   デフォルトでは呼び出し元のオブジェクトと同じサイズのベクトルを返す。
	#   第 1 引数にサイズが指定されていればそのサイズのベクトルを返す。
	#   第 2 引数に数値が指定されていれば、その添え字の位置の成分を 1 にする。
	#   デフォルトでは最初の成分を 1 にする。
	#
	#-----------------------------------------------------------------------
	my( $self , $sz , $pos ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_vector() ) ;

	my $obj = $self->zero_vector( $sz ) ;
	return undef	unless ( defined $obj ) ;

	$pos = 0	unless ( defined $pos ) ;

	if	( $obj->is_cvector() )	{ $obj->[ $pos ]->[ 0 ] = new_decimal( 1 ) ; }
	elsif	( $obj->is_rvector() )	{ $obj->[ 0 ]->[ $pos ] = new_decimal( 1 ) ; }
	else				{ return undef ; }

	return $obj ;
}

sub zero_matrix {
	#-----------------------------------------------------------------------
	#
	# 零行列
	#
	#   デフォルトでは呼び出し元のオブジェクトのサイズに応じた零行列 ( 正方行列 ) を返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $sz ) = @_ ;

	my $m = [] ;

	unless ( defined $sz ) {
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
		if	( $self->is_cvector() )		{ $sz = [ $self->rows() , 1 ] ;	}
		elsif	( $self->is_rvector() )		{ $sz = [ 1 , $self->cols() ] ;	}
		elsif	( $self->is_square_matrix() )	{ $sz = [ $self->rows() ] ;	}
	}

	unless ( ref( $sz ) ) {
		$sz = [ $sz , $sz ] ;
	}

	if ( defined $sz ) {

		my( $rows , $cols ) = @{ $sz } ;
		return undef	unless ( defined $rows ) ;
		$cols = $rows	unless ( defined $cols ) ;

		foreach my $r ( 0 .. ( $rows - 1 ) ) {
			#
			# 対角成分
			#
			$m->[ $r ]->[ $r ] = new_decimal( 0 )	if ( $r < $cols ) ;

			#
			# 下三角及び対称成分
			#
			foreach my $c ( 0 .. ( $r - 1 ) ) {
				last	if ( $c >= $cols ) ;
				$m->[ $r ]->[ $c ] = new_decimal( 0 ) ;
				$m->[ $c ]->[ $r ] = new_decimal( 0 )	if ( $c < $rows and $r < $cols ) ;
			}

			#
			# 上三角非対称成分
			#
			foreach my $c ( $rows .. ( $cols - 1 ) ) {
				$m->[ $r ]->[ $c ] = new_decimal( 0 ) ;
			}
		}
	}
	else {
		return undef ;
	}

	my $obj = ( @{ $m } ) ? __PACKAGE__->matrix( @{ $m } ) : undef ;
	return $obj ;
}

sub unit_matrix {
	#-----------------------------------------------------------------------
	#
	# 単位行列
	#
	#   デフォルトでは呼び出し元のオブジェクトのサイズに応じた単位行列 ( 正方行列 ) を返す。
	#
	#-----------------------------------------------------------------------
	#my( $self , $sz ) = @_ ;
	#return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = zero_matrix( @_ ) ;
	return undef	unless ( defined $obj ) ;
	return undef	unless ( $obj->is_square_matrix() ) ;

	my $rows = $obj->rows() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		$obj->[ $r ]->[ $r ] = new_decimal( 1 ) ;
	}

	return $obj ;
}

sub E { return unit_matrix( @_ ) ; }

sub imag_unit {
	#-----------------------------------------------------------------------
	#
	# 虚数単位 ( imaginary unit ) を表す行列を返す。
	#
	#-----------------------------------------------------------------------
	my $m = [
		[ 0 , -1 ] ,
		[ 1 ,  0 ] ,
	] ;

	return __PACKAGE__->matrix( @{ $m } ) ;
}

=head2 'Vector' object translation.

=cut

#-------------------------------------------------------------------------------
#
# 変換
#
#-------------------------------------------------------------------------------

sub real_vector {
	#-----------------------------------------------------------------------
	#
	# 複素ベクトル -> 実ベクトル
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_vector() ) ;

	return $self->real_matrix() ;
}

sub real_matrix {
	#-----------------------------------------------------------------------
	#
	# 複素行列 -> 実行列
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	foreach my $r ( @{ $m } ) {
		foreach my $c ( @{ $r } ) {
			return undef	unless ( $c->can_decimal() ) ;
			$c = $c->decimal() ;
		}
	}

	return $m ;
}

=head2 transpose

  $v = vector( 1 .. 3 ) ;

  print $v ;                                          # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print $v->transpose() ;                             # [              1.00000 ,              2.00000 ,              3.00000 ]

  print $v->transpose()->transpose() ;                # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  $m = matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;

  print $m ;                                          # [              1.00000 ,              2.00000 ]
                                                      # [              3.00000 ,              4.00000 ]

  print $m->transpose() ;                             # [              1.00000 ,              3.00000 ]
                                                      # [              2.00000 ,              4.00000 ]

=cut

sub transpose {
	#-----------------------------------------------------------------------
	#
	# 転置
	#
	#   列ベクトル -> 行ベクトル
	#   行ベクトル -> 列ベクトル
	#   行列       -> 転置行列
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $class ) = ref( $m ) || $m ;

	my( $rows , $cols ) = $m->size() ;
	my $t = [] ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		#
		# 対角成分
		#
		$t->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]	if ( defined $m->[ $r ]->[ $r ] ) ;

		#
		# 下三角及び対称成分
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last	if ( $c >= $cols ) ;
			$t->[ $c ]->[ $r ] = $m->[ $r ]->[ $c ] ;
			$t->[ $r ]->[ $c ] = $m->[ $c ]->[ $r ]	if ( defined $m->[ $c ]->[ $r ] ) ;
		}

		#
		# 上三角非対称成分
		#
		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$t->[ $c ]->[ $r ] = $m->[ $r ]->[ $c ] ;
		}
	}

	my $obj = bless [ @{ $t } ] , $class ;

	return $obj ;
}

=head2 rvector

Create row vector from column vector or matrix.


  $v = vector( 1 .. 3 ) ;

  print $v ;                                          # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print $v->rvector() ;                               # [              1.00000 ,              2.00000 ,              3.00000 ]

  print $v->rvector()->rvector()                      # [              1.00000 ,              2.00000 ,              3.00000 ]


  $m = matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;

  print $m ;                                          # [              1.00000 ,              2.00000 ]
                                                      # [              3.00000 ,              4.00000 ]

  print $m->rvector() ;                               # [              1.00000 ,              2.00000 ]

  print $m->rvector( 0 ) ;                            # [              1.00000 ,              2.00000 ]

  print $m->rvector( 1 ) ;                            # [              3.00000 ,              4.00000 ]

=cut

sub rvector {
	#-----------------------------------------------------------------------
	#
	# 列ベクトル -> 行ベクトル
	#
	#   オブジェクトが行列であれば指定された行を行ベクトルとして返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#
	# 行ベクトルであればコピーして返す。
	# 列ベクトルであれば転置して返す。
	#
	return $self->copy()		if ( $self->is_rvector() ) ;
	return $self->transpose()	if ( $self->is_cvector() ) ;

	#
	# 指定された位置の成分を取り出す。 ( $n < 0 も可 )
	#
	$n = 0	unless ( defined $n ) ;
	my $m = ( defined $self->[ $n ] )
		? [ @{ $self->[ $n ] } ]
		: []
	;

	#
	# 列ベクトルを生成し、転置して返す。
	#
	my $obj = ( @{ $m } ) ? __PACKAGE__->new( $m ) : undef ;
	$obj = $obj->transpose()	if ( defined $obj ) ;

	return $obj ;
}

=head2 cvector

Create column vector from row vector or matrix.

Alias : vector


  $v = vector( 1 .. 3 ) ;

  print $v ;                                          # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print $v->cvector() ;                               # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  $v = $v->transpose() ;
  print $v ;                                          # [              1.00000 ,              2.00000 ,              3.00000 ]

  print $v->cvector() ;                               # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]


  print $v->vector() ;                                # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  $m = matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;

  print $m ;                                          # [              1.00000 ,              2.00000 ]
                                                      # [              3.00000 ,              4.00000 ]

  print $m->cvector() ;                               # [              1.00000 ]
                                                      # [              3.00000 ]

  print $m->vector() ;                                # [              1.00000 ]
                                                      # [              3.00000 ]

  print $m->cvector( 0 ) ;                            # [              1.00000 ]
                                                      # [              3.00000 ]

  print $m->cvector( 1 ) ;                            # [              2.00000 ]
                                                      # [              4.00000 ]

=cut

sub cvector {
	#-----------------------------------------------------------------------
	#
	# 行ベクトル -> 列ベクトル
	#
	#   オブジェクトが行列であれば指定された列を列ベクトルとして返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#
	# 列ベクトルであればコピーして返す。
	# 行ベクトルであれば転置して返す。
	#
	return $self->copy()		if ( $self->is_cvector() ) ;
	return $self->transpose()	if ( $self->is_rvector() ) ;

	#
	# 指定された位置の成分を取り出す。 ( $n < 0 も可 )
	#
	#   元の行列を予め転置し、要求された列を行として取り出す。
	#
	my $obj = $self->transpose() ;
	$n = 0	unless ( defined $n ) ;
	my $m = ( defined $obj->[ $n ] )
		? [ @{ $obj->[ $n ] } ]
		: []
	;

	#
	# 列ベクトルを生成して返す。
	#
	$obj = ( @{ $m } ) ? __PACKAGE__->new( $m ) : undef ;

	return $obj ;
}

sub vector { return $_[0]->cvector( $_[1] ) ; }

=head2 vec2array

Return the elements of the vector object as array hash.

  $v = vector( 1 .. 3 ) ;

  print $v ;                                          # [              1.00000 ]
                                                      # [              2.00000 ]
                                                      # [              3.00000 ]

  print join ' '  , @{ $v->vec2array() } ;            # 1 2 3

=cut

sub vec2array {
	#-----------------------------------------------------------------------
	#
	# ベクトルの成分を配列参照で返す。
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_vector() ) ;

	my @r = ( $self->is_cvector() ) ? @{ $self->transpose()->[0] } : @{ $self->[0] } ;

	return [ @r ] ;
}

=head2 vec2matrix

Create a new matrix object from 2 or more vector.

  $v = vector( 1 .. 3 ) ;
  $w = vector( 4 .. 6 ) ;

  print $v->vec2matrix( $w ) ;                       # [              1.00000 ,              4.00000 ]
                                                     # [              2.00000 ,              5.00000 ]
                                                     # [              3.00000 ,              6.00000 ]

  $v = $v->tanspose() ;
  $w = $w->tanspose() ;

  print $v->vec2matrix( $w ) ;                       # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                     # [              4.00000 ,              5.00000 ,              6.00000 ]


Caller object can be a matrix object.

  $m = matrix( [ 1 , 2 ] , [ 3 , 4 ] ) ;
  $v = vector( 6 , 7 ) ;

  print $m ;                                         # [              1.00000 ,              2.00000 ]
                                                     # [              3.00000 ,              4.00000 ]

  print $m->vec2matrix( $v ) ;                       # [              1.00000 ,              2.00000 ,              6.00000 ]
                                                     # [              3.00000 ,              4.00000 ,              7.00000 ]

  print $m->vec2matrix( $v->transpose() ) ;          # [              1.00000 ,              2.00000 ]
                                                     # [              3.00000 ,              4.00000 ]
                                                     # [              6.00000 ,              7.00000 ]

=cut

sub vec2matrix {
	#-----------------------------------------------------------------------
	#
	# 複数のベクトルから行列を生成する。
	#
	#   第 1 引数は行列でも可
	#   処理の過程でサイズの不一致が検出されると、直ちに undef が返る。
	#
	#-----------------------------------------------------------------------
	my( $self , @args ) = ( ref( $_[0] ) eq 'ARRAY' ) ? @{ $_[0] } : @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	@args = @{ $args[0] }	if ( ref( $args[0] ) eq 'ARRAY' ) ;

	my $obj = $self->copy() ;

	foreach my $v ( @args ) {
		#
		# 第 2 引数以降は全てベクトルでなければならない。
		#
		return undef	unless ( $v->is_vector() ) ;

		#
		# 行列化
		#
		if ( $v->is_rvector() ) {
			#
			# 行ベクトルを行列の下端に追加
			#
			return undef	unless ( $obj->cols() == $v->cols() ) ;
			push( @{ $obj } , [ @{ $v->[0] } ] ) ;
		}
		elsif ( $v->is_cvector() ) {
			#
			# 列ベクトルを行列の右端に追加
			#
			return undef	unless ( $obj->rows() == $v->rows() ) ;
			foreach my $i ( 0 .. $#{ $v } ) {
				push( @{ $obj->[ $i ] } , $v->[ $i ]->[0] ) ;
			}
		}
		else {
			return undef ;
		}
	}

	return $obj ;
}

=head2 insert_cvector

  $v = vector( 1 , 2 ) ;
  $u = vector( 3 , 4 ) ;

  print $v->insert_cvector( $u ) ;          # [              3.00000 ,              1.00000 ]
                                            # [              4.00000 ,              2.00000 ]


  $m = matrix( [ 5 , 6 ] , [ 7 , 8 ] ) ;

  prnt $m->insert_cvector( $u ) ;           # [              3.00000 ,              5.00000 ,              6.00000 ]
                                            # [              4.00000 ,              7.00000 ,              8.00000 ]

  prnt $m->insert_cvector( $u , 0 ) ;       # [              3.00000 ,              5.00000 ,              6.00000 ]
                                            # [              4.00000 ,              7.00000 ,              8.00000 ]

  prnt $m->insert_cvector( $u , 1 ) ;       # [              5.00000 ,              3.00000 ,              6.00000 ]
                                            # [              7.00000 ,              4.00000 ,              8.00000 ]

  prnt $m->insert_cvector( $u , 2 ) ;       # [              3.00000 ,              5.00000 ,              6.00000 ]
                                            # [              4.00000 ,              7.00000 ,              8.00000 ]

=cut

sub insert_cvector {
	#-----------------------------------------------------------------------
	#
	# ベクトルや行列に列ベクトルを挿入する。
	#
	#-----------------------------------------------------------------------
	my( $v , $u , $pos ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	return undef	unless ( $u->is_cvector() ) ;
	return undef	unless ( $v->rows() == $u->rows() ) ;

	my $m = $v->copy() ;

	$pos = 0	unless ( defined $pos ) ;
	$pos %= $m->cols() ;

	my $rows = $m->rows() ;
	foreach my $i ( 0 .. ( $rows - 1 ) ) {
		splice( @{ $m->[ $i ] } , $pos , 0 , $u->[ $i ]->[0] ) ;
	}

	return $m ;
}

=head2 insert_rvector

  $v = vector( 1 , 2 )->transpose() ;
  $u = vector( 3 , 4 )->transpose() ;

  print $v->insert_rvector( $u ) ;          # [              1.00000 ,              2.00000 ]
                                            # [              3.00000 ,              4.00000 ]


  $m = matrix( [ 5 , 6 ] , [ 7 , 8 ] ) ;

  prnt $m->insert_rvector( $u ) ;           # [              3.00000 ,              4.00000 ]
                                            # [              5.00000 ,              6.00000 ]
                                            # [              7.00000 ,              8.00000 ]

  prnt $m->insert_rvector( $u , 0 ) ;       # [              3.00000 ,              4.00000 ]
                                            # [              5.00000 ,              6.00000 ]
                                            # [              7.00000 ,              8.00000 ]

  prnt $m->insert_rvector( $u , 1 ) ;       # [              5.00000 ,              6.00000 ]
                                            # [              3.00000 ,              4.00000 ]
                                            # [              7.00000 ,              8.00000 ]

  prnt $m->insert_rvector( $u , 2 ) ;       # [              3.00000 ,              4.00000 ]
                                            # [              5.00000 ,              6.00000 ]
                                            # [              7.00000 ,              8.00000 ]

=cut

sub insert_rvector {
	#-----------------------------------------------------------------------
	#
	# ベクトルや行列に行ベクトルを挿入する。
	#
	#-----------------------------------------------------------------------
	my( $v , $u , $pos ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	return undef	unless ( $u->is_rvector() ) ;
	return undef	unless ( $v->cols() == $u->cols() ) ;

	my $m = $v->copy() ;

	$pos = 0	unless ( defined $pos ) ;
	$pos %= $m->rows() ;

	splice( @{ $m } , $pos , 0 , $u->[0] ) ;

	return $m ;
}

=head2 submatrix

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->submatrix( [ 0 , 0 ] , [ 1 , 1 ] ) ;       # [              1.00000 ,              2.00000 ]
                                                       # [              4.00000 ,              5.00000 ]

  print $m->submatrix( [ 0 , 0 ] , [ 2 , 0 ] ) ;       # [              1.00000 ]
                                                       # [              4.00000 ]
                                                       # [              7.00000 ]
      
  print $m->submatrix( [ -2 , -2 ] , [ -1 , -1 ] ) ;   # [              5.00000 ,              6.00000 ]
						       # [              8.00000 ,              9.00000 ]

=cut

sub submatrix {
	#-----------------------------------------------------------------------
	#
	# 部分行列
	#
	#-----------------------------------------------------------------------
	my( $m , $f , $t ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	croak( "unexpected error!!\n" )	unless ( ref( $f ) eq 'ARRAY' ) ;

	my( $rows , $cols ) = $m->size() ;
	$t = [ $rows - 1 , $cols - 1 ]	unless ( defined $t ) ;
	croak( "unexpected error!!\n" )	unless ( ref( $t ) eq 'ARRAY' ) ;

	foreach ( $f->[0] , $t->[0] ) { $_ += $rows if ( $_ < 0 ) ; }
	foreach ( $f->[1] , $t->[1] ) { $_ += $cols if ( $_ < 0 ) ; }

	my $r = [] ;
	foreach my $i ( $f->[0] .. $t->[0] ) {
		last	unless ( defined $m->[ $i ] ) ;
		my $row = [] ;
		foreach my $j ( $f->[1] .. $t->[1] ) {
			last	unless ( defined $m->[ $i ]->[ $j ] ) ;
			push( @{ $row } , $m->[ $i ]->[ $j ] ) ;
		}
		push( @{ $r } , $row ) ;
	}

	return ( @{ $r } ) ? __PACKAGE__->matrix( @{ $r } ) : undef ;
}

=head2 expand_columns

  $v = vector( 0 .. 2 ) ;
  $u = vector( 4 .. 6 ) ;
  $m = $v->expand_columns( $u ) ;

  print $v ;                                           # [              0.00000 ]
                                                       # [              1.00000 ]
                                                       # [              2.00000 ]
  
  print $u ;                                           # [              4.00000 ]
                                                       # [              5.00000 ]
                                                       # [              6.00000 ]

  print $m ;                                           # [              0.00000 ,              4.00000 ]
                                                       # [              1.00000 ,              5.00000 ]
                                                       # [              2.00000 ,              6.00000 ]

  print $m->expand_columns( $v ) ;                     # [              0.00000 ,              4.00000 ,              0.00000 ]
                                                       # [              1.00000 ,              5.00000 ,              1.00000 ]
                                                       # [              2.00000 ,              6.00000 ,              2.00000 ]

=cut

sub expand_columns {
	#-----------------------------------------------------------------------
	#
	# 二つのベクトル又は行列を受け取り、列方向に結合した結果を返す。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $v->size() ;
	return undef	unless ( $rows == $u->rows() ) ;

	my $m = $v->copy() ;
	foreach my $i ( 0 .. ( $rows - 1 ) ) {
		push( @{ $m->[ $i ] } , @{ $u->[ $i ] } ) ;
	}

	return $m ;
}

=head2 expand_rows

  $v = vector( 0 .. 2 )->transpose() ;
  $u = vector( 4 .. 6 )->transpose() ;
  $m = $v->expand_rows( $u ) ;

  print $v ;                                           # [              0.00000 ,              1.00000 ,              2.00000 ]
  
  print $u ;                                           # [              4.00000 ,              5.00000 ,              6.00000 ]

  print $m ;                                           # [              0.00000 ,              1.00000 ,              2.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]

  print $m->expand_columns( $v ) ;                     # [              0.00000 ,              1.00000 ,              2.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              2.00000 ]

=cut

sub expand_rows {
	#-----------------------------------------------------------------------
	#
	# 二つのベクトル又は行列を受け取り、行方向に結合した結果を返す。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $v->size() ;
	return undef	unless ( $cols == $u->cols() ) ;

	my $m = $v->copy() ;
	push( @{ $m } , @{ $u } ) ;

	return $m ;
}

=head2 reduce_column

  $m = matrix( [ 1 .. 3 ] , [ 4 .. 6 ] , [ 7 .. 9 ] ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->reduce_column() ;                          # [              2.00000 ,              3.00000 ]
                                                       # [              5.00000 ,              6.00000 ]
                                                       # [              8.00000 ,              9.00000 ]

  
  print $m->reduce_column( 1 ) ;                       # [              1.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              9.00000 ]

  print $m->reduce_column( -1 ) ;                      # [              1.00000 ,              2.00000 ]
                                                       # [              4.00000 ,              5.00000 ]
                                                       # [              7.00000 ,              8.00000 ]

  print $m->reduce_column( -5 ) ;                      # [              1.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              9.00000 ]

=cut

sub reduce_column {
	#-----------------------------------------------------------------------
	#
	# 行ベクトルや行列から指定された列を取り除いて返す。
	#
	#-----------------------------------------------------------------------
	my( $m , $pos ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	if ( $m->is_cvector() ) ;

        $pos = 0	unless ( defined $pos ) ;

	$m = $m->copy() ;
	$pos %= $m->cols() ;

	foreach my $row ( @{ $m } ) {
		splice( @{ $row } , $pos , 1 ) ;
	}

	return $m ;
}

=head2 reduce_row

  $m = matrix( [ 1 .. 3 ] , [ 4 .. 6 ] , [ 7 .. 9 ] ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->reduce_row() ;                             # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  
  print $m->reduce_row( 1 ) ;                          # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->reduce_row( -1 ) ;                         # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]


  print $m->reduce_row( -5 ) ;                         # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

=cut

sub reduce_row {
	#-----------------------------------------------------------------------
	#
	# 列ベクトルや行列から指定された行を取り除いて返す。
	#
	#-----------------------------------------------------------------------
	my( $m , $pos ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	if ( $m->is_rvector() ) ;

        $pos = 0	unless ( defined $pos ) ;

	$m = $m->copy() ;
	my $rows = $m->rows() ;
	$pos %= $rows ;

	splice( @{ $m } , $pos , 1 ) ;

	return $m ;
}

=head2 conj

If matrix M is a complex matrix, conj( M ) will return a complex matrix, which has conjugated values.

  $m = complex_matrix(
    [ [ 1 , 1 ] , [ 2 , 2 ] ] ,
    [ [ 3 , 3 ] , [ 4 , 4 ] ]
  ) ;
  
  print $m ;                                           # [        1.00 + 1.00 i ,        2.00 + 2.00 i ]
                                                       # [        3.00 + 3.00 i ,        4.00 + 4.00 i ]


  print $m->conj() ;                                   # [        1.00 - 1.00 i ,        2.00 - 2.00 i ]
                                                       # [        3.00 - 3.00 i ,        4.00 - 4.00 i ]


If matrix M is a real matrix, 

  conj( M ) == M


  $m = matrix(
    [ 1 , 2 ] ,
    [ 3 , 4 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

  print $m->conj() ;                                   # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

=cut

sub conj {
	#-----------------------------------------------------------------------
	#
	# 共役 ( conjugate )
	#
	#   ベクトルや行列の成分を複素共役で置き換えたオブジェクトを返す。
	#
	#   行列 A が実行列であれば、
	#
	#     conj( A ) == A
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef		unless ( ref( $self ) eq __PACKAGE__ ) ;
	return $self->copy()	unless ( $self->is_complex_vm() ) ;

	my $m = $self->copy() ;

	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] and $m->[ $r ]->[ $r ]->is_complex() ) {
			$m->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]->conj() ;
		}
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last	if ( $c >= $cols ) ;
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->conj()		if ( $m->[ $r ]->[ $c ]->is_complex() ) ;
			$m->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ]->conj()		if ( defined $m->[ $c ]->[ $r ] and $m->[ $c ]->[ $r ]->is_complex() ) ;
		}
		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->conj()		if ( $m->[ $r ]->[ $c ]->is_complex() ) ;
		}
	}

	return $m ;
}

=head2 adjoint

The adjoint matrix is also called the conjugate transpose, Hermitian transpose or bedaggered matrix.

Alias : dagger

In complex matrix,

  adjoint( M ) == transpose( conj( M ) ) == conj( transpose( M ) )


  $m = complex_matrix(
    [ [ 1 , 1 ] , [ 2 , 2 ] ] ,
    [ [ 3 , 3 ] , [ 4 , 4 ] ]
  ) ;
  
  print $m ;                                           # [        1.00 + 1.00 i ,        2.00 + 2.00 i ]
                                                       # [        3.00 + 3.00 i ,        4.00 + 4.00 i ]

  print $m->adjoint() ;                                # [        1.00 - 1.00 i ,        3.00 - 3.00 i ]
                                                       # [        2.00 - 2.00 i ,        4.00 - 4.00 i ]

If matrix M is a real matrix,

   adjoint( M ) == transpose( M )  

  $m = matrix(
    [ 1 , 2 ] ,
    [ 3 , 4 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

  print $m->adjoint() ;                                # [              1.00000 ,              3.00000 ]
                                                       # [              2.00000 ,              4.00000 ]


=cut

sub adjoint {
	#-----------------------------------------------------------------------
	#
	# 随伴行列 ( adjoint matrix )
	#
	#   行列の転置を採り、その成分を複素共役で置き換えたオブジェクトを返す。
	#
	#   随伴行列は、エルミート転置 ( Hermitian transpose ) , エルミート共役 ( Hermitian conjugate ) ,
	#   エルミート随伴 ( Hermitian adjoint ) とも呼ばれる。
	#
	#   数学では元の行列を示す記号の右肩にアスタリスク又は大文字の H を伴った記号で表現される。
	#   量子力学ではアスタリスクの代わりにダガー ( † ) が用いられ、このことから随伴行列をダガー行列 ( be-daggered matrix ) と呼ぶことがある。
	#
	#   adjoint( A ) == transpose( conj( A ) )
	#
	#   行列 A が実行列の場合、
	#
	#     adjoint( A ) == transpose( A )
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef				unless ( ref( $self ) eq __PACKAGE__ ) ;
	return $self->copy()->transpose()	unless ( $self->is_complex_vm() ) ;

	my $m = $self->conj() ;
	$m = $m->transpose() ;

	return $m ;
}

sub dagger { return adjoint( @_ ) ; }

=head2 normalize

Normalize columns of matrix.


  $m = matrix(
    [ 1 , 2 ] ,
    [ 3 , 4 ] ,
  ) ;

  print $m->normalize() ;                              # [              0.31623 ,              0.44721 ]
                                                       # [              0.94868 ,              0.89443 ]

  
  print $m->normalize()->cvector( 0 )->norm() ;        # 0.9999999999999999999999999999999999999999
  print $m->normalize()->cvector( 1 )->norm() ;        # 0.9999999999999999999999999999999999999999

=cut

sub normalize {
	#-----------------------------------------------------------------------
	#
	# 正規化 ( normalization ) 
	#
	#   任意の行列又はベクトルを受け取り、ベクトルの二次のノルムが 1 になるようにその成分を変換する。
	#   呼び出し元が行列である場合には、列ベクトルについて正規化を行う。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef				unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	$m = $m->transpose()	if ( $m->is_rvector() ) ;

	my( $rows , $cols ) = $m->size() ;

	foreach my $c ( 0 .. ( $cols - 1 ) ) {
		my $v = $m->cvector( $c ) ;
		my $v_norm = $v->norm() ;
		unless ( $v_norm->round( $DECIMAL_PART_LENGTH_LIMIT * 0.7 ) == 0 ) {
			$v /= $v->norm() ;
			foreach my $r ( 0 .. ( $rows - 1 ) ) {
				$m->[ $r ]->[ $c ] = $v->[ $r ]->[ 0 ] ;
			}
		}
	}
	$m = $m->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	$m = $m->transpose()	if ( $self->is_rvector() ) ;

	return $m ;
}

=head2 diag2vector

Alas : diag2vec

 $m = matrix(
   [ 1 , 2 , 3 ] ,
   [ 4 , 5 , 6 ] ,
   [ 7 , 8 , 9 ] ,
 ) ;

 print $m ;                                            # [              1.00000 ,              2.00000 ,              3.00000 ]
						       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              9.00000 ]

 print $m->diag2vector() ;                             # [              1.00000 ]
                                                       # [              5.00000 ]
                                                       # [              9.00000 ]

=cut

sub diag2vector {
	#-----------------------------------------------------------------------
	#
	# 行列の対角成分を抜き出して列ベクトルとして返す。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_matrix() ) ;

	my $rows = $m->rows() ;
	my $v = $m->cvector( 0 )->zero_vector() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		$v->[ $r ]->[0] = $m->[ $r ]->[ $r ] ;
	}

	return $v ;
}

sub diag2vec { return diag2vector( @_ ) ; }

sub vector2diag {
	#-----------------------------------------------------------------------
	#
	# ベクトル成分を対角に配置した対角行列を返す。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( $v->is_vector() ) ;

	$v = $v->cvector() ;
	my $rows = $v->rows() ;

	my $m = $v->zero_matrix( [ $rows , $rows ] ) ;
	$m = $m->diagonal_matrix( $v->vec2array() ) ;

	return $m ;
}

sub vec2diag { return vector2diag( @_ ) ; }

=head2 diag2array

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
 						       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print join ' ' , @{ $m->diag2array() } ;              # 1 5 9


=cut

sub diag2array {
	#-----------------------------------------------------------------------
	#
	# 行列の対角成分を抜き出して配列参照で返す。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return []	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return []	unless ( $m->is_matrix() ) ;

	my $r = [] ;

	if ( my $v = $m->diag2vector() ) {
		$r = $v->as_array() ;
	}

	return $r ;
}

=head2 diag2matrix

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
						       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->diag2matrix() ;                            # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              5.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              9.00000 ]

=cut

sub diag2matrix {
	#-----------------------------------------------------------------------
	#
	# 行列の対角成分を抜き出して新規の対角行列を返す。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_matrix() ) ;

	my $d = $m->diagonal_matrix( $m->diag2array() ) ;

	return $d ;
}

=head2 householder_trans( $flg , $count )

If A is a matrix, the Householder translatoin will try to translate it,

  A -> Q * R
  B == R * inverse( Q ) == RQ

Q is the orthogonal matrix, R is the upper triangular matrix.

When this translation is repeated many times, A may be translated to the diagonal matrix, the triangular matrix or the tridiagonal matrix.

If $flg == 1, this method will try to return the diagonal matrix.   ( default )
If $flg == 2, this method will try to return the triangular matrix.
If $flg == 3, this method will try to return the tridiagonal matrix.

$count is a number of trial. ( default ; 200 )

If transaltion is succeeded, this method will return translated object and "1" as array.
else it will return the object with "0".

=cut

sub householder_trans {
	#-----------------------------------------------------------------------
	#
	# ハウスホルダー変換 ( Householder Transformation )
	#
	#   ハウスホルダー変換により、
	#
	#     A == QR
	#     B == R * inverse( Q ) == RQ
	#
	#   とした B を返す。
	#
	#   これを繰り返すことにより、三重対角化や対角化が実現される。
	#
	#   有限回の試行で必ず収束するとは限らないが、途中経過であっても用途によっては有益なものと成り得る。
	#   よって、変換後のオブジェクトと、変換が完了しているかどうかを示すステイタスを返すことにする。
	#
	#-----------------------------------------------------------------------
	my( $self , $excond , $count ) = @_ ;
	return ( undef , 0 )	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#
	# $excond == 1 -> 対角化
	# $excond == 2 -> 三角行列化
	# $excond == 3 -> 三重対角化
	#
	$excond = 1	unless ( defined $excond ) ;

	#
	# 試行回数
	#
	$count = 200	unless ( defined $count ) ;

	#
	# 初期設定
	#
	my $obj = $self->copy() ;
	my $rows = $obj->rows() ;
	my $em = $obj->E() ;

	my $success = 0 ;
	my $prev_u = undef ;

	foreach ( 0 .. $count ) {
		#
		# ウィルキンソンの移動法 ( Willkinson's Shift ) に基づく係数を適用。
		# この係数により、収束が早まる．．．．。 ( ハズ )
		#
		my $u = undef ;
		my $spos = $rows - 2 ;
		while ( $spos >= 0 ) {
			#
			# 行列の最終 2 行 2 列を起点として 2 次の正方行列を部分行列として切り出し、
			# その固有値を求める。
			#
			my $smat = $obj->submatrix( [ $spos , $spos ] , [ $spos + 1 , $spos + 1 ] ) ;
			my $e = [ $smat->_eigen_values_sq() ] ;

			#
			# 行列の最終成分に近い値を採用。
			#
			my $lv = $smat->[1]->[1] ;
			if ( ( $lv - $e->[0] )->abs() < ( $lv - $e->[1] )->abs() )	{ $u = $e->[0] ; }
			else								{ $u = $e->[1] ; }

			#
			# 固有値が変化しなくなったら、部分行列を切り出す位置を変更する。
			#
			my $u1 = $u->round( $DECIMAL_PART_LENGTH_LIMIT * 0.7 ) ;
			if ( defined $prev_u and  $u1 == $prev_u )	{ $spos-- ; }
			else						{ $prev_u = $u1 ; last ; }
		}

		#
		# QR 分解した結果と係数を用いて行列を更新。
		#
		if ( defined $u ) { $obj -= $u * $em ; }
		
		my( $q , $r ) = $obj->householder_qr() ;

		if ( ! defined $q or ! defined $r ) {
			$obj += $u * $em ;
			last ;
		}

		$obj = $r * $q ;
				
		if ( defined $u ) { $obj += $u * $em ; }

		#
		# 結果を検証
		#
		my $c = $obj->round( 5 ) ;
		if ( $excond == 2 ) {
			if ( $c->is_triangular_matrix() )	{ $success = 1 ; last ; }
		}
		elsif ( $excond == 3 ) {
			if ( $c->is_tridiagonal_matrix() )	{ $success = 1 ; last ; }
		}
		else {
			if ( $c->is_diagonal_matrix() )		{ $success = 1 ; last ; }
		}

		$obj = $obj->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}

	return ( $obj , $success ) ;
}

=head2 hessenburg_trans

The Hessenburg translation will try to translate matrix A to B, as follows.

  A == [ a11 , a12 , a13   a14 ] -> B == [ b11 , b12 , b13 , b14 ]
       [ a21 , a22 , a23 , a24 ]         [ b21 , b22 , b23 , b24 ]
       [ a31 , a32 , a33 , a34 ]         [   0 , b32 , b33 , b34 ]
       [ a41 , a42 , a43 , a44 ]         [   0 ,   0 , b43 , b44 ]

If the matrix A is a Hermitian matrix ( symmetric matrix ) or Skew-Hermitian matrix ( Skew-symmetric matrix ),
the matrix B may be a tridiagonal matrix.


=cut

sub hessenburg_trans {
	#-----------------------------------------------------------------------
	#
	# ヘッセンベルグ変換
	#
	#   ハウスホルダー変換を利用して、任意の正方行列をヘッセンベルグ行列に変換する。
	#
	#   変換元の行列がエルミート行列 ( 対称行列 ) や歪エルミート行列 ( 交代行列 ) である場合、
	#   結果は三重対角行列となる。
	#
	#   ヘッセンベルグ行列への変換は以下のような変換を指す。
	#
	#     A == [ a11 , a12 , a13   a14 ] -> B == [ b11 , b12 , b13 , b14 ]
	#          [ a21 , a22 , a23 , a24 ]         [ b21 , b22 , b23 , b24 ]
	#          [ a31 , a32 , a33 , a34 ]         [   0 , b32 , b33 , b34 ]
	#          [ a41 , a42 , a43 , a44 ]         [   0 ,   0 , b43 , b44 ]
	#
	#   手順は以下の通り。
	#
	#     1. 行列 A[0] == A とし、左端の列ベクトルから対角成分を除いた部分ベクトルを取り出す。
	#
	#        v[1] == [ a21 ]
	#                [ a31 ]
	#                [ a41 ]
	#
	#     2. ベクトル v の第 2 成分以降を 0 に変換するハウスホルダー行列を生成する。
	#
	#        H[1] == householoder( v[1] )
	#
	#        v[2] == H[1] * v[1] == H[1] * [ a21 ] == [ b21 ]
	#                                      [ a31 ]    [   0 ]
	#                                      [ a41 ]    [   0 ]
	#
	#     3. ハウスホルダー行列 H[1] を A[0] に合わせて調整する。
	#
	#        ハウスホルダー行列はエルミート行列であり、以下のような構造を持つ。
	#
	#          H[1] == [ h11         , h12         , h13 ]
	#                  [ conj( h12 ) , h22         , h23 ]
	#                  [ conj( h13 ) , conj( h23 ) , h33 ]
	#
	#        これを、
	#
	#          H[1] == [ 1 , 0           , 0           , 0   ]
	#                  [ 0 , h11         , h12         , h13 ]
	#                  [ 0 , conj( h12 ) , h22         , h23 ]
	#                  [ 0 , conj( h13 ) , conj( h23 ) , h33 ]
	#
	#        と言う行列に作り直す。
	#
	#        この H[1] もまたエルミート行列であり、逆行列、共役転置行列が自身と等しい行列となる。
	#
	#          H[1] == inverse( H[1] ) == adjoint( H[1] )
	#
	#     4. A[0] を更新
	#
	#       A[1] == inverse( H[1] ) * A[0] * H[1] == H[1] * A[0] * H[1]
	#
	#            == [ A[1][1,1] , A[1][1,2] , A[1][1,3] , A[1][1,4] ]
	#               [ A[1][2,1] , A[1][2,2] , A[1][2,3] , A[1][2,4] ]
	#               [ 0         , A[1][3,2] , A[1][3,3] , A[1][3,4] ]
	#               [ 0         , A[1][4,2] , A[1][4,3] , A[1][4,4] ]
	#
	#     5. 2 列目以降の処理
	#
	#       2 列目では、
	#
	#         v == [ A[1][3,2] ]
	#              [ A[1][4,2] ]
	#
	#         H[2] == householder( v )
	#
	#              == [ h11         , h12 ]
	#                 [ conj( h12 ) , h22 ]
	#
	#        -> H[2] == [ 1 , 0 , 0           , 0   ]
	#                   [ 0 , 1 , 0           , 0   ]
	#                   [ 0 , 0 , h11         , h12 ]
	#                   [ 0 , 0 , conj( h12 ) , h22 ]
	#
	#         A[2] == H[2] * A[1] * H[2]
	#
	#       と言う処理を行う。
	#
	#       3 列目以降も同様の処理を繰り返す。
	#
	#       4 x 4 の正方行列では、 A[2] を求めた時点で変換が完了する。
	#       n x n の正方行列では、 A[ n - 2 ] を求めた時点で完了となる。
	#
	#
	#   変換元の行列がエルミート行列 ( 対称行列 ) や歪エルミート行列 ( 交代行列 ) である場合、
	#   ヘッセンベルグ変換でも三重対角化を行うことが可能だが、もっと効率の良いロジックを組むことができるので、
	#   専用のメソッドを使用することとする。
	#
	#
	#   ヘッセンベルグ変換や三重対角化は、相似変換であり、元の行列と比較してその固有値は変化しない。
	#   ヘッセンベルグ型の行列は QR 法による対角化の収束を速める効果があり、
	#   三重対角化された行列は、ヤコビ法等で用いられるギブンス回転による収束を早める効果をもたらす。
	#   何れも、固有値を迅速に求める方法として有益と言える。
	#
	#   ただし、何れの方法も固有ベクトルを変化させてしまうため、固有ベクトルは別途求めなおす必要がある。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()		unless ( ref( $self ) eq __PACKAGE__ ) ;
	return ()		unless ( $self->is_square_matrix() ) ;

	#
	# エルミート行列や歪エルミート行列であれば、三重対角化を行う。
	#
	return $self->tridiagonalize()	if ( $self->is_hermitian_matrix() ) ;
	return $self->tridiagonalize()	if ( $self->is_skew_hermitian_matrix() ) ;

	#
	# ヘッセンベルグ変換
	#
	my $m = $self->copy() ;
	my $rows = $m->rows() ;

	foreach my $r ( 0 .. ( $rows - 3 ) ) {
		my $v = $m->submatrix( [ $r + 1 , $r ] , [ -1 , $r ] ) ;	# ハウスホルダー行列を生成する列ベクトル
		my $s = $m->submatrix( [ $r , $r ] , [ -1 , -1 ] ) ;		# 変換対象となる部分行列

		#
		# 取り出したベクトルからハウスホルダー行列を生成
		#
		my $h = $v->householder() ;
		while ( $h->rows() < $rows ) {
			$h = $h->insert_cvector( $h->cvector( 0 )->zero_vector() , 0 ) ;		# 左端列に零ベクトルを挿入
			$h = $h->insert_rvector( $h->rvector( 0 )->unit_vector( undef , 0 ) , 0 ) ;	# 上端行に単位ベクトルを挿入
		}

		#
		# 行列を変換
		#
		#   A[k] == H[k] * A[k-1] * H[k]
		#
		$m = $h * $m * $h ;
	}

	return $m ;
}

=head2 tridiagonalize

This method will try to translate a Hermitian matrix ( symmetric matrix ) or a Skew-Hermitian matrix ( Skew-symmetric matrix ) to a tridiagoal matrix.

The Hermitian matrix A will be translated to B, as follows.
 
  A == [ a11         , a12         , a13         , a14 ] -> B == [ b11         , b12         , 0           , 0   ]
       [ conj( a12 ) , a22         , a23         , a24 ]         [ conj( b12 ) , b22         , b23         , 0   ]
       [ conj( a13 ) , conj( a23 ) , a33         , a34 ]         [ 0           , conj( b23 ) , b33         , b34 ]
       [ conj( a14 ) , conj( a24 ) , conj( a43 ) , a44 ]         [ 0           , 0           , conj( b34 ) , b44 ]



  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 2 , 5 , 4 ] ,
    [ 3 , 4 , 6 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              2.00000 ,              5.00000 ,              4.00000 ]
                                                       # [              3.00000 ,              4.00000 ,              6.00000 ]

  print $m->tridiagonalize() ;                         # [              1.00000 ,              3.60555 ,              0.00000 ]
						       # [              3.60555 ,              9.38462 ,              1.07692 ]
						       # [              0.00000 ,              1.07692 ,              1.61538 ]

  $m = complex_matrix(
    [ [ 1 ,  0 ] , [ 2 ,  2 ] , [ 3 , 3 ] ] ,
    [ [ 2 , -2 ] , [ 5 ,  0 ] , [ 4 , 4 ] ] ,
    [ [ 3 , -3 ] , [ 4 , -4 ] , [ 6 , 0 ] ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,        2.00 + 2.00 i ,        3.00 + 3.00 i ]
						       # [        2.00 - 2.00 i ,              5.00000 ,        4.00 + 4.00 i ]
						       # [        3.00 - 3.00 i ,        4.00 - 4.00 i ,              6.00000 ]

  print $m->is_hermitian_matrix() ;                    # 1

  print $m->tridiagonalize() ;                         # [              1.00000 ,        3.61 + 3.61 i ,              0.00000 ]
                                                       # [        3.61 - 3.61 i ,              9.38462 ,        1.08 - 4.00 i ]
                                                       # [              0.00000 ,        1.08 + 4.00 i ,              1.61538 ]

=cut

sub tridiagonalize {
	#-----------------------------------------------------------------------
	#
	# 三重対角化
	#
	#   エルミート行列 ( 対称行列 ) 及び歪エルミート行列 ( 交代行列 ; 歪対称行列 ) を三重対角化して返す。
	#
	#   エルミート行列 A は以下のような構造を持つ。
	#
	#     A == [ a11         , a12         , a13         , a14 ] -> B == [ b11         , b12         , 0           , 0   ]
	#          [ conj( a12 ) , a22         , a23         , a24 ]         [ conj( b12 ) , b22         , b23         , 0   ]
	#          [ conj( a13 ) , conj( a23 ) , a33         , a34 ]         [ 0           , conj( b23 ) , b33         , b34 ]
	#          [ conj( a14 ) , conj( a24 ) , conj( a43 ) , a44 ]         [ 0           , 0           , conj( b34 ) , b44 ]
	#
	#   A の下三角成分から列を抜き出してベクトル化し、ハウスホルダー変換に掛けると以下のようになる。
	#
	#     v == [ conj( a12 ) ] -> householder( v ) * v == [ conj( b12 ) ]
	#          [ conj( a13 ) ]                            [           0 ]
	#          [ conj( a14 ) ]                            [           0 ]
	#
	#   これを利用して対角化する。
	#
	#   処理手順は以下の通り。
	#
	#     1. 行列 A[0] = A とし、下三角成分の左端のベクトルを列ベクトルとして取り出す。
	#
	#        v[1] == [ conj( a12 ) ]
	#                [ conj( a13 ) ] 
	#                [ conj( a14 ) ]
	#
	#     2. v[1] を元にしてハウスホルダー行列を生成する。
	#
	#        H[1] == householder( v[1] )
	#
	#     3. H[1] の左端に零ベクトルを追加し、上端に第 1 成分を 1 とする単位行ベクトルを追加する。
	#
	#        ハウスホルダー行列はエルミート行列なので、以下のようになる。
	#
	#          H[1] == [ h11        , h12         , h13 ]
	#                  [ conj( h12) , h22         , h23 ]
	#                  [ conj( h13) , conj( h22 ) , h33 ]
	#
	#          -> H[1] == [ 1  , 0          , 0           , 0   ]
	#                     [ 0  , h11        , h12         , h13 ]
	#                     [ 0  , conj( h12) , h22         , h23 ]
	#                     [ 0  , conj( h13) , conj( h22 ) , h33 ]
	#
	#     4. A[0] を更新
	#     
	#        A[1] == H[1] * A[0] * H[1]
	#
	#             == [ A[1][1,1]         , A[1][1,2]         , 0                 , 0         ]
	#                [ conj( A[1][1,2] ) , A[1][2,2]         , A[1][2,3]         , A[1][2,4] ]
	#                [ 0                 , conj( A[1][2,3] ) , A[1][3,3]         , A[1][3,4] ]
	#                [ 0                 , conj( A[1][2,4] ) , conj( A[1][3,4] ) , A[1][4,4] ]
	#
	#        ヘッセンベルグ変換との違いは、ハウスホルダー変換によって最も外側の行列成分が共役転置の関係となる点にある。
	#        結果として、 A[1] の導出において、 A[1][1,3] 及び A[1][1,4] の成分が 0 になることが自明となる。
	#      
	#     5. 2 列目の処理
	#
	#        2 列目以降の処理の流れもヘッセンベルグ変換とほぼ同様の処理となる。
	#
	#        ヘッセンベルグ変換との違いは、現在選択している成分を k 行 k 列目とすると、 k - 1 行 k - 1 列目までの成分は
	#        変換による影響を一切受けないと言う点にある。
	#        このため、変換処理の大半を、対角成分 A[k][k,k] を始点とする部分行列の変換に還元することができる。
	#
	#        2 列目の処理で生成すべきハウスホルダー行列は、
	#
	#          H[2] == [ 1  , 0          , 0           ]
	#                  [ 0  , h11        , h12         ]
	#                  [ 0  , conj( h12) , h22         ]
	#
	#        であり、部分行列 B[2] を
	#
	#          B[2] == H[2] * B[1] * H[2]
	#
	#               == H[2] * [ A[1][2,2]         , A[1][2,3]         , A[1][2,4] ] * H[2]
	#                         [ conj( A[1][2,3] ) , A[1][3,3]         , A[1][3,4] ]
	#                         [ conj( A[1][2,4] ) , conj( A[1][3,4] ) , A[1][4,4] ]
	#
	#               == [ B[2][1,2]         , B[2][2,1]       , 0         ]
	#                  [ conj( B[2][2,1] ) , B[2][2,2]       , B[2][2,3] ]
	#                  [ 0                 , conj( B[2][2,3] , B[2][3,3] ]
	#
	#        として得ることになる。
	#
	#        これを A[1] に書き戻すことにより、 A[2] は、
	#
	#          A[2] == [ A[1][1,1]         , A[1][1,2]         , 0                 , 0         ]
	#                  [ conj( A[1][1,2] ) , B[2][1,2]         , B[2][1,2]         , 0         ]
	#                  [ 0                 , conj( B[2][1,2] ) , B[2][2,2]         , B[2][2,3] ]
	#                  [ 0                 , 0                 , conj( B[2][2,3] ) , B[2][3,3] ]
	#
	#               == [ A[2][1,1]         , A[2][1,2]         , 0                 , 0         ]
	#                  [ conj( A[2][1,2] ) , A[2][2,2]         , A[2][2,3]         , 0         ]
	#                  [ 0                 , conj( A[2][2,3] ) , A[2][3,3]         , A[2][3,3] ]
	#                  [ 0                 , 0                 , conj( A[2][3,3] ) , A[2][4,4] ]
	#
	#        となる。
	#
	#        4 x 4 の三重対角化は、これで完了となる。
	#        n x n の三重対角化は、これを n - 2 行 n - 2 列まで繰り返すことによって得られる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()		unless ( ref( $self ) eq __PACKAGE__ ) ;
	return ()		unless ( $self->is_hermitian_matrix() or $self->is_skew_hermitian_matrix() ) ;

	my $m = $self->copy() ;
	my $rows = $m->rows() ;

	foreach my $r ( 0 .. ( $rows - 3 ) ) {
		my $v = $m->submatrix( [ $r + 1 , $r ] , [ -1 , $r ] ) ;	# ハウスホルダー行列を生成する列ベクトル
		my $s = $m->submatrix( [ $r , $r ] , [ -1 , -1 ] ) ;		# 変換対象となる部分行列

		#
		# 取り出したベクトルからハウスホルダー行列を生成
		#
		my $h = $v->householder() ;
		$h = $h->insert_cvector( $h->cvector( 0 )->zero_vector() , 0 ) ;		# 左端列に零ベクトルを挿入
		$h = $h->insert_rvector( $h->rvector( 0 )->unit_vector( undef , 0 ) , 0 ) ;	# 上端行に単位ベクトルを挿入

		#
		# 部分行列をハウスホルダー変換
		#
		$s = $h * $s * $h ;

		#
		# 変換された部分行列を反映
		#
		foreach my $r1 ( $r .. ( $rows - 1 ) ) {
			my $r2 = $r1 - $r ;
			$m->[ $r1 ]->[ $r1 ] = $s->[ $r2 ]->[ $r2 ] ;
			foreach my $c1 ( ( $r + 1 ) .. ( $rows - 1 ) ) {
				my $c2 = $c1 - $r ;
				$m->[ $r1 ]->[ $c1 ] = $s->[ $r2 ]->[ $c2 ] ;
				$m->[ $c1 ]->[ $r1 ] = $s->[ $c2 ]->[ $r2 ] ;
			}
		}
	}

	return $m ;
}

=head2 gram_schmidt

Gram-Schemidt orthogonalization.

=cut

sub gram_schmidt {
	#-----------------------------------------------------------------------
	#
	# グラム・シュミットの正規直交化 ( Gram-Schmidt orthogonalization )
	#
	#   任意の行列 A を受け取り、これを列ベクトルの集合とみなして正規直交化を施す。
	#   結果として得られる列ベクトルを列方向に並べた行列 B を返す。
	#
	#     B == gram_schmidt( A )
	#
	#   A の列ベクトルを A[k] ( k == 1 -> n ) 、 B の列ベクトルを B[k] とする。
	#   また、任意の二つのベクトルの内積を IP( v , u ) で表すこととする。
	#
	#     B[1] == A[1] / norm( A[1] )
	#
	#     B[2] == A[2] - IP( B[1] * A[2] ) * B[1]        .... 直交化
	#     B[2] /= norm( B[2] )                           .... 正規化 ( norm( B[2] ) == 1 にする。)
	#
	#     B[3] == A[3] - ( IP( B[1] , A[3] ) * B[1] ) - ( IP( B[2] * A[3] ) * B[2] )
	#     B[3] /= norm( B[3] )
	#
	#     ...........
	#
	#     B[n] == A[n] - Σ( IP( B[k] , A[n] ) * B[k] )       ( k == 1 -> n - 1 )
	#     B[n] /= norm( B[n] )
	#
	#   となる。
	#
	#   一般化すると、
	#
	#     B[1] == A[1] / norm( A[1] )
	#     B[k] == A[k] - Σ( IP( B[j] , A[k] ) * B[j] )       ( k == 1 -> n , j == 1 -> k - 1 )
	#     B[k] /= norm( B[k] )
	#
	#   となる。
	#
	#   ロジックは単純だが、扱う列ベクトルの数が増えるにつれて処理効率が大幅に低下する。
	#   ( 列ベクトルの数に対して線形処理となるため。 )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()		unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	my $cols = $m->cols() ;

	#
	# B[1] == A[1] / norm( A[1] )
	# B[1] /= norm( B[1] )
	#
	my $v = $m->cvector( 0 ) ;
	my $u = $v / $v->norm() ;
	my $n = $u->copy() ;

	#
	# B[k] == A[k] - Σ( IP( B[j] , A[k] ) * B[j] )      ( k == 1 -> n , j = 1 -> k - 1 )
	#
	foreach my $c ( 1 .. ( $cols - 1 ) ) {
		$v = $m->cvector( $c ) ;				# A[k]
		$u = $v->copy() ;					# B[k]
		foreach my $c1 ( reverse( 0 .. ( $c - 1 ) ) ) {
			my $u0 = $n->cvector( $c1 ) ;			# B[j]
			$u -= $u0->inner_product( $v ) * $u0 ;		# B[k] -= IP( B[j] , A[k] ) * B[j]
		}
		$u = $u / $u->norm() ;					# B[k] /= norm( B[k] )

		$n = $n->expand_columns( $u ) ;
	}

	return $n ;
}

=head1 'Vector' object - special matrix.
=cut

#-------------------------------------------------------------------------------
#
# 特殊な行列
#
#-------------------------------------------------------------------------------

=head2 housholder

Return the Hoseholder matrix.

The hoseholder matrix "H" will translate a some vector "v" to another "u".

Among these matrix H and vector v , u, following relationship is exists.

  v == H * u
  u == H * v

In general, this method take one vector "v", and return the Householder matrix, which can trasnlate it to anothor vector "u".

In this case, if the vector v has two or more non-zero elements, u will be a unit vector multiplied norm( v ).


  $v = vector( 1 , 2 , 3 ) ;
  $h = $v->householder() ;
  $u = $h * $v ;

  print $v ;                                           # [              1.00000 ]
                                                       # [              2.00000 ]
                                                       # [              3.00000 ]

  print $h ;                                           # [              0.26726 ,              0.53452 ,              0.80178 ]
                                                       # [              0.53452 ,              0.61007 ,             -0.58489 ]
                                                       # [              0.80178 ,             -0.58489 ,              0.12267 ]

  print $u ;                                           # [              3.74166 ]
                                                       # [              0.00000 ]
                                                       # [              0.00000 ]

  print $h * $u ;                                      # [              1.00000 ]  ( == $v )
                                                       # [              2.00000 ]
                                                       # [              3.00000 ]

If this method takes 2 vectors v , u and these vectors has following conditions,

   v != u 
   norm( v ) == norm( u )
   adjoint( a ) * b == adjoint( b ) * a

Then,

     w = v - u
     return householder( w )
  
Otherwithe, return undef.

=cut

sub householder {
	#-----------------------------------------------------------------------
	#
	# ハウスホルダー行列を生成する。
	#
	#   ハウスホルダー行列
	#
	#     ハウスホルダー行列は、任意の n 次ベクトル a を原点を通る平面に対して面対称となるベクトル b に写す行列となる。
	#     ( このため、ハウスホルダー変換は鏡映変換や基本直交変換とも呼ばれる。 )
	#
	#
	#     ベクトル a と b は、ハウスホルダー行列を変換行列として互いに鏡映 ( reflection ) な関係にあり、
	#     ハウスホルダー行列を H とすると、 a と b の間には、
	#
	#       a == H * b
	#       b == H * a
	#
	#     と言う関係が成り立つ。
	#
	#     対称面に直角に交わる単位ベクトル ( 単位法線ベクトル ) を u とおくと、 u と a の内積は
	#
	#       inner_product( u , a ) == norm( u ) * norm( a ) * cos( t )
	#                              == 1 * norm( a ) * cos( t )
	#                              == norm( a ) * cos( t )
	#
	#     と表すことができる。
	#
	#     これは a の u 方向の成分を表しており、 a から対称面に直角に交わるように降ろした垂線の長さとなる。
	#     対称面からベクトル a へ延ばした法線ベクトルは、この内積の大きさだけ u を延ばしたベクトルであり、
	#
	#       inner_product( u , a ) * u == adjoint( u ) * a * u
	#
	#     で表現される。
	#
	#     b を基点として b と a を結ぶベクトルを v と定義すると、
	#
	#       v == a - b == 2 * inner_product( u , a ) * u
	#                  == 2 * u * inner_proiduct( u , a )
	#                  == 2 * u * adjoint( u ) * a
	#
	#       -> b == a - 2 * u * adjoint( u ) * a 
	#            == ( E - 2 * u * adjoint( u ) ) * a
	#
	#     となり、ここから
	#
	#       H == E - 2 * u * adjoint( u )
	#         == E - 2 * outer_product( u )
	#         == H(u)
	#
	#     が導かれる。
	#
	#     これは、 a -> b に b -> a に写す変換行列 H が、 a と b を結ぶベクトル v の基底ベクトル u についての関数であることを示している。
	#
	#     既知の値は a , b のみであり、 b -> a を結ぶベクトルは、前述の通り、
	#
	#       v == a - b
	#
	#     で表される。
	#     u は、このベクトルの基底 ( 単位ベクトル ) であるから、
	#
	#                 v
	#       u == -----------
	#             norm( v )
	#
	#     となる。
	#
	#     よって、
	#
	#       H == E - 2 * outer_prodcut( u )
	#
	#         == E - 2 * u * adjoint( u )
	#
	#                         v                      v
	#         == E - 2 * ----------- * adjoint( ----------- )
	#                     norm( v )              norm( v )
	#
	#     norm( v ) は実数なので、
	#
	#                         v                      v
	#       H == E - 2 * ----------- * adjoint( ----------- )
	#                     norm( v )              norm( v )
	#
	#                         v         adjoint( v )
	#         == E - 2 * ----------- * --------------
	#                     norm( v )      norm( v )
	#
	#                      v * adjoint( v )              v * adjoint( v )               outer_product( v )
	#         == E - 2 * ------------------- == E - 2 * ------------------- == E - 2 * --------------------
	#                       norm( v )^2                  adjoint( v ) * v               inner_product( v )
	#
	#         == H(v)
	#
	#     であり、 H が v == a - b についての関数 H(v) として表現されることになる。
	#
	#     この時、 a , b , v には、
	#
	#       v == a - b != 0
	#       -> a != b                                .... [1]
	#
	#       norm( a ) == norm( b )                   .... [2]
	#
	#       adjoint( a ) * b == adjoint( b ) * a     .... [3]
	#
	#     と言う条件が存在する。
	#
	#     [2] は、a と b の大きさ ( 長さ ) が等しいことを要求する。
	#
	#     [1] と [2] を合わせた条件により、 a と b が並行ではないこと、
	#     つまり a と b を適切に平行移動することで、両者の間に 0 ではない角が形成される事が要求される。
	#
	#     これに [3] の条件が加わることで、 a と b を適切に平行移動することによって、
	#     この二つのベクトルの間に二等辺三角形又は平行四辺形が形成されることが要求される。
	#
	#     結果として、これら 3 つの条件が満たされることによって、 a , b の間には単一の平面が定義でき、
	#     この平面と直交する平面 ( 対称面 ) が存在することが保証される。
	#
	#
	#   QR 分解のためのハウスホルダー行列
	#
	#     ハウスホルダー変換による QR 分解では、任意のベクトル a を受け取って、
	#
	#       b == H(v) * a == [ b[1] ]
	#                        [    0 ]
	#                        [ .... ]
	#                        [    0 ]
	#
	#     といった変換を行うような行列 H(v) を生成する必要がある。
	#
	#     先に示した条件 [2] から、
	#
	#       norm( a ) == norm( b )
	#       -> abs( sqrt( Σ( abs( a[j] )^2 ) ) ) == abs( sqrt( abs( b[1] )^2 ) )
	#       -> b[1]^2 == Σ( abs( a[j] )^2 )
	#       -> b[1]   == sqrt( Σ( abs( a[j] )^2 ) )
	#                 == sqrt( norm( a )^2 )
	#
	#     b の第 2 成分以降が全て 0 なので、条件 [5] より、
	#
	#       adjoint( a ) * b == conj( a[1] ) * b[1]
	#       adjoint( b ) * a == conj( b[1] ) * a[1]
	#
	#       -> conj( a[1] ) * b[1] == conj( b[1] ) * a[1]
	#                              == conj( sqrt( norm( a )^2 ) ) * a[1]
	#
	#     である必要がある。
	#
	#     ベクトル a が実ベクトルであれば、
	#
	#       adjoint( a ) * b == conj( a[1] ) * b[1] == a[1] * b[1]
	#       adjoint( b ) * a == conj( b[1] ) * a[1] == b[1] * a[1]
	#
	#     であり、
	#
	#       b[1] == abs( sqrt( norm( a )^2 ) )
	#                 or
	#               abs( sqrt( norm( a )^2 ) ) * ( -1 )
	#
	#     norm( a ) >= 0 なので、
	#
	#       b[1] == norm( a )
	#                 or
	#               norm( a ) * ( -1 )
	#
	#       v == a - b == a - norm( a )
	#                       or
	#                     a + norm( a )
	#
	#     となる。
	#
	#     一方、ベクトル a が複素ベクトルであり、且つ a の第 1 成分が複素数である場合には、条件 [3] が成立しない。
	#     例えば、
	#
	#       a == [ 1 -  i ]
	#            [ 0 + 2i ]
	#            [ 1 + 3i ]
	#
	#       -> norm( a ) == 4
	#
	#       -> b == [ 4 ] or [ -4 ]
	#               [ 0 ]    [  0 ]
	#               [ 0 ]    [  0 ]
	#
	#      b[1] == 4 を採ると、
	#
	#        adjoint( a ) * b == conj( a[1] ) * b[1] == ( 1 + i ) * 4 == 4 + 4i
	#        adjoint( b ) * a == conj( b[1] ) * a[1] == 4 * ( 1 - i ) == 4 - 4i
	#
	#      b[1] == -4 を採ったとしても、
	#
	#        adjoint( a ) * b == conj( a[1] ) * b[1] == ( 1 + i ) * ( -4 ) ==  4 - 4i
	#        adjoint( b ) * a == conj( b[1] ) * a[1] == ( -4 ) * ( 1 - i ) == -4 + 4i
	#
	#     となり、何れも条件を満たさない。
	#
	#
	#     a[1] , b[1] は共に複素数であるため、
	#
	#       a[1] == r1 * exp( i * t1 )
	#       b[1] == r2 * exp( i * t2 )
	#
	#       conj( a[1] ) == r1 * exp( -i * t1 )
	#       conj( b[1] ) == r2 * exp( -i * t2 )
	#
	#       adjoint( a ) * b == conj( a[1] ) * b[1]
	#                        == ( r1 * exp( -i * t1 ) ) * ( r2 * exp( i * t2 ) )
	#                        == r1r2 * exp( i * ( t2 - t1 ) )
	#
	#       adjoint( b ) * a == conj( b[1] ) * a[1]
	#                        == ( r2 * exp( -i * t2 ) ) * ( r1 * exp( i * t1 ) )
	#                        == r1r2 * exp( i * ( t1 - t2 ) )
	#
	#     と表現できる。
	#
	#     この時、先の条件 [3] を満たすには、
	#
	#       adjoint( a ) * b == adjoint( b ) * a
	#       -> r1r2 * exp( i * ( t2 - t1 ) ) == r1r2 * exp( i * ( t1 - t2 ) )
	#
	#     より、
	#
	#       t1 == t2
	#
	#     を満たせばよく、
	#
	#       t2 == t1 == arg( a[1] )
	#
	#     を選ぶことができる。
	#
	#     一方、ベクトル b の二次のノルムは、
	#
	#       norm( b ) == abs( sqrt( Σ( abs( b[k] )^2 ) ) )
	#                 == abs( sqrt( b[1]^2 ) )
	#                 == abs( b[1] )
	#                 == abs( r2 * exp( i * t2 ) )
	#                 == abs( sqrt( r2^2 * ( ( cos( t2 ) )^2 + ( sin( t2 ) )^2 ) ) )
	#                 == abs( r2 )
	#
	#     であり、条件 [4] を満たすものとして、
	#
	#       norm( a ) == norm( b ) == abs( r2 )
	#       -> r2 == norm( a )
	#
	#     を選ぶことができる。
	#
	#     よって、
	#
	#       b[1] == norm( a ) * exp( i * arg( a[1] ) )
	#
	#       v == a - b == a - norm( a ) * exp( i * arg( a[1] ) ) * e
	#
	#                        v * adjoint( v )               outer_product( v )
	#       H(v) == E - 2 * ------------------- == E - 2 * --------------------
	#                        adjoint( v ) * v               inner_product( v )
	#
	#     と表すことができる。
	#
	#     先の例をこれに適用すると、
	#
	#       a == [ 1 -  i ]
	#            [ 0 + 2i ]
	#            [ 1 + 3i ]
	#
	#       norm( a ) == 4
	#
	#       a[1]         == 1 - i == sqrt(2) * exp( i * -PI/4 )
	#       conj( a[1] ) == 1 + i == sqrt(2) * exp( i *  PI/4 )
	#
	#       -> b[1]         == norm( a ) * exp( i * arg( a[1] ) )
	#                       == 4 * exp( i * -PI/4 )
	#          conj( b[1] ) == 4 * exp( i *  PI/4 )
	#
	#     よって、
	#
	#       adjoint( a ) * b == conj( a[1] ) * b[1]
	#                        == ( sqrt(2) * exp( i * PI/4 ) ) * ( 4 * exp( i * -PI/4 ) )
	#                        == 4 * sqrt(2) * exp( i * ( PI/4 - PI/4 ) )
	#                        == 4 * sqrt(2)
	#
	#       adjoint( b ) * a == conj( b[1] ) * b[1]
	#                        == ( 4 * exp( i * PI/4 ) ) * ( sqrt(2) * exp( i * -PI/4 ) )
	#                        == 4 * sqrt(2) * exp( i * ( PI/4 - PI/4 ) )
	#                        == 4 * sqrt(2)
	#
	#     となり、条件 [3] が満たされていることがわかる。
	#
	#
	#     a が実ベクトルの場合、
	#
	#       arg( a[1] ) == 0 or PI
	#       -> exp( i * arg( a[1] ) ) == 1 or -1
	#
	#       -> b[1] == norm( a )
	#                    or
	#                  norm( a ) * ( -1 )
	#
	#       -> v == a - b == a - norm( a ) * e
	#                          or
	#                        a + norm( a ) * e
	#
	#     であり、実ベクトルについても矛盾はない。
	#
	#     ちなみに、
	#
	#       実数の世界だけでベクトル b を求める際には、 b[1] の値が正になるのか負になるのかを一意に決定する事はできなかった。
	#       ( 生成された H(v) は、どちらを採っても機能としては変わらないが、その成分は異なる。 )
	#       しかし、複素数の世界を通して b を求めると、 b[1] の符合が一意に決定されることになる。
	#
	#
	#     以上の内容により、複素ベクトルについて一般化されたハウスホルダー行列の生成式は、
	#
	#       a != b 
	#       norm( a ) == norm( b )
	#       adjoint( a ) * b == adjoint( b ) * a
	#
	#     を条件として、
	#
	#       b[1] == norm( a ) * exp( i * arg( a[1] ) )
	#
	#       v == a - b == a - norm( a ) * exp( i * arg( a[1] ) ) * e
	#
	#                        v * adjoint( v )               outer_product( v )
	#       H(v) == E - 2 * ------------------- == E - 2 * --------------------
	#                        adjoint( v ) * v               inner_product( v )
	#
	#     となる。
	#
	#     なお、任意の複素数 z について、
	#
	#       z == x + iy
	#         == r * exp( i * t ) 
	#         == abs( z ) * exp( i * t )
	#         == abs( sqrt( x^2 + y^2 ) ) * exp( i * t )
	#
	#       -> exp( i * t ) == z / abs( z )
	#
	#                                    x + iy
	#                       == ----------------------------
	#                            abs( sqrt( x^2 + y^2 ) )
	#
	#     であることから、
	#
	#       v == a - b == a - norm( a ) * ( a[1] / abs( a[1] ) ) * e
	#
	#     とすることができる。
	#     これにより、直交表現と指数表現の相互変換に伴う演算コストを削減することができる。
	#
	#-----------------------------------------------------------------------
	my( $x1 , $x2 ) = @_ ;
	return undef	unless ( ref( $x1 ) eq __PACKAGE__ ) ;
	return undef	unless ( $x1->is_cvector() ) ;

	my $dlen = $DECIMAL_PART_LENGTH_LIMIT * 0.7 ;

	my $v = undef ;
	if ( defined $x2 ) {
		#
		# ベクトル a , b が与えられた場合
		#
		#   v == a - b
		#
		#   ただし、
		#
		#     a != b 
		#     norm( a ) == norm( b )
		#     adjoint( a ) * b == adjoint( b ) * a
		#
		#   を満たす必要がある。
		#
		return undef	unless ( ref( $x2 ) eq __PACKAGE__ ) ;
		return undef	unless ( $x2->is_cvector() ) ;

		return undef	if ( $x1 == $x2 ) ;
		return undef	unless ( $x1->norm()->round( $dlen ) != $x2->norm()->round( $dlen ) ) ;
		return undef	unless ( $x1->ip( $x2 )->round( $dlen ) != $x2->ip( $x1 )->round( $dlen ) ) ;

		$v = $x1 - $x2 ;
	}
	else {
		#
		# ベクトル a から v を生成する。
		#
		#   a == transpose( a[1] , a[2] , .... , a[n] )
		#   b == transpose( b[1] ,    0 , .... ,    0 )
		#   e == transpose(    1 ,    0 , .... ,    0 )
		#
		#   b[1] == norm( a ) * exp( i * arg( a[1] ) )
		#        == norm( a ) * ( a[1] / abs( a[1] ) )
		#
		#   v == a - b
		#     == a - ( b[1] * e )
		#     == a - norm( a ) * ( a[1] / abs( a[1] ) ) * e
		#
		my $a1 = $x1->[0]->[0] ;
		#return undef	if ( $a1->abs()->round( $dlen ) == 0 ) ;
		#my $b1 = $x1->norm() * ( $a1 / $a1->abs() ) ;
		my $b1 = $x1->norm() * $a1 ;
		$b1 /= $a1->abs() unless ( $a1->abs()->round( $dlen ) == 0 ) ;
		$v = $x1 - ( $b1 * $x1->unit_vector( undef , 0 ) ) ;
	}

	#
	# ハウスホルダー行列を生成
	#
	#                     v * adjoint( v )                outer_product( v )
	#   H(v) == E - 2 * -------------------- == E - 2 * ----------------------
	#                     adjoint( v ) * v                inner_product( v )
	#
	#   
	#   v の内積は 0 にならないように調整されているはずだが、入力として与えられた a が
	#   既に変換後の形 ( 単位ベクトルの定数倍 ) になっている場合には、
	#
	#     v == a - b == 0
	#     -> inner_product( v ) == 0
	#
	#   が発生することになる。
	#
	#   この場合、 v の直積もまた、
	#
	#     outer_product( v ) == v * adjoint( v ) == 0
	#
	#   となるため、
	#
	#     H(v) == E - 2 * outer_product( v )
	#          == E
	#
	#   とすることで矛盾なく結果を返すことができる。
	#
	my $ip_v = $v->adjoint() * $v ;
	my $h = ( $v * $v->adjoint() * 2 ) ;

	return $h->unit_matrix()	if ( $ip_v->round( 15 ) == 0 ) ;

	$h /= $ip_v ;
	$h = $h->unit_matrix() - $h ;

	return $h ;
}

=head2 givens_matrix( $p , $q ) 

Return the Givens matrix.

The Givens matrix has a following format.

  G[ p , p ] ...... G[ p , q ] == cos ...... sin
      .                 .          .          .
      .                 .          .          .
      .                 .          .          .
  G[ q , p ] ...... G[ q , q ]   -sin ...... cos

If matrix A is a following symmetric matrix,

  A == [ p , q ]
       [ q , r ]

the Givens matrix Q is as follows.

  Q == [  cos(t) , sin(t) ]
       [ -sin(t) , cos(t) ]

then

  transpose( Q ) * A * Q == [ p' , 0 ]
                            [ 0 , r' ]


  $m = matrix(
    [ 1 , 2 ] ,
    [ 2 , 3 ] ,
  ) ;

  $q = $m->givens_matrix( 0 , 1 ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ]
                                                       # [              2.00000 ,              3.00000 ]

  print $q ;                                           # [              0.52573 ,             -0.85065 ]
                                                       # [              0.85065 ,              0.52573 ]

  # the Givens rotation
  print $q->transpose() * $m * $q ;                    # [              4.23607 ,              0.00000 ]
                                                       # [              0.00000 ,             -0.23607 ]

=cut

sub givens_matrix {
	#-----------------------------------------------------------------------
	#
	# ギブンス回転 ( Givens rotation ) に用いる行列を生成する。
	#
	# 
	#   対称行列の非対角成分の座標 [ p , q ] を受け取り、その成分を 0 に変換する行列を生成する。
	#
	#   ギブンス行列は、以下のような形をした行列。
	#
	#     G[ p , p ] ...... G[ p , q ] == cos ...... sin
	#         .                 .          .          .
	#         .                 .          .          .
	#         .                 .          .          .
	#     G[ q , p ] ...... G[ q , q ]   -sin ...... cos
	#
	#   p と q で表されていない成分は、対角が 1 、非対角が 0 となる。
	#
	#   変換対象の行列を A とし、 p と q で表される座標の値を取り出して 2 x 2 行列にしたものを
	#
	#     B == [ A[p,p] , A[p,q] ] == [ p , q ]
	#          [ A[q,p] , A[q,q] ]    [ q , r ]
	#
	#   と定義する。 ( A は対象行列なので A[p,q] == A[q,p] )
	#
	#   2 x 2 のギブンス行列を Q とすると、これは回転行列であり、
	#
	#     Q == [  cos(t) , sin(t) ]
	#          [ -sin(t) , cos(t) ]
	#
	#   と定義される。
	#
	#   cos(t) , sin(t) を直接求める事は容易ではないが、cos(2t) を求めることによってこれらを得ることができる。
	#
	#
	#   1. cos(2t) の導出。
	#
	#     2 x 2 のギブンス行列 Q を
	#
	#       Q == [  cos(t) , sin(t) ] == [  c , s ]
	#            [ -sin(t) , cos(t) ]    [ -s , c ]
	#
	#     と再定義する。
	#
	#     ギブンス行列は、
	#
	#       transpose( Q ) * B * Q == [ p' , 0  ]
	#                                 [ 0  , r' ]
	#
	#     と言う変換を行うための行列であることから、
	#
	#       transpose( Q ) * B * Q == [ c , -s ] * [ p , q ] * [  c , s ] 
	#                                 [ s ,  c ]   [ q , r ]   [ -s , c ]
	#
	#                              == [ cp - sq , cq - sr ] * [  c , s ]
	#                                 [ sp + cq , sq + cr ]   [ -s , c ]
	#
	#                              == [ ( cp - sq )c - ( cq - sr )s , ( cp - sq )s + ( cq - sr )c ]
	#                                 [ ( sp + cq )c - ( sq + cr )s , ( sp + cq )s + ( sq + cr )c ]
	#
	#                              == [ pc^2 - 2sqc + rs^2       ,  qc^2 - qs^2 + scp - src ]
	#                                 [ qc^2 - qs^2 + scp - src  ,  ps^2 + 2scq + rc^2      ]
	#
	#                              == [ pc^2 - 2sqc + rs^2            ,  q( c^2 - s^2 ) + ( p - r )sc ]
	#                                 [ q( c^2 - s^2 ) + ( p - r )sc  ,  ps^2 + 2psc + rc^2           ]
	#
	#                              == [ p' , 0  ]
	#                                 [ 0  , r' ] 
	#
	#     であり、
	#
	#       q( c^2 - s^2 ) + ( p - r )sc
	#       == q( cos(t)^2 - sin(t)^2 ) + ( p - r ) * sin(t) * cos(t)
	#       == 0
	#
	#     を解く事が主眼となる。
	#
	#     三角関数の二倍角の公式
	#
	#       cos(t)^2 - sin(t)^2 == cos(2t)
	#       2 * sin(t) * cos(t) == sin(2t)
	#
	#     より、
	#
	#       q( c^2 - s^2 ) + ( p - r )sc == 0
	#       -> q * ( cos(t)^2 - sin(t)^2 ) + ( p - r ) * sin(t) * cos(t) == 0
	#       -> q * cos(2t)^2 + ( p - r ) * 1/2 * sin(2t) == 0
	#
	#       -> ( p - r ) / 2 * sin(2t) == -q * cos(2t)
	#
	#     sin(x)^2 + cos(x)^2 == 1 より、
	#
	#       ( a * sin(x) )^2 + ( a * cos(x) )^2 == a^2 * ( sin(x)^2 + cos(x)^2 )
	#                                           == a^2
	#
	#     a == p - r , b == -2q , x == 2t として置き換えると、
	#
	#       ( p - r ) * sin(2t) == -2q * cos(2t)
	#       -> a * sin(x) == b * cos(x)
	#
	#     ( a * sin(x) )^2 + ( a * cos(x) )^2 == a^2
	#       -> ( b * cos(x) )^2 + ( a * cos(x) )^2 == a^2
	#       -> ( a^2 + b^2 ) * cos(x)^2 == a^2
	#
	#                                          a^2
	#       -> cos(x) == cos(2t) == sqrt( ------------- )
	#                                       a^2 + b^2 
	#
	#
	#   2. 二倍角の公式を使用した cos(t) , sin(t) の導出。
	#
	#     cos(2t) == cos(t)^2 - sin(t)^2 より、
	#
	#       cos(2t) == cos(t)^2 - ( 1 - cos(t)^2 )
	#               == 2 * cos(t)^2 - 1
	#               == 2 * ( 1 - sin(t)^2 ) - 1
	#               == 1 - 2 * sin(t)^2
	#
	#
	#                            1 + cos(2t) 
	#       -> cos(t) == sqrt( --------------- )
	#                                2
	#
	#                            1 - cos(2t)
	#          sin(t) == sqrt( --------------- )              if ( a * b == ( p - r )/2 * ( -q ) >= 0 )
	#                                2
	#
	#                            1 - cos(2t)
	#          sin(t) == sqrt( --------------- ) * ( -1 )     if ( a * b == ( p - r )/2 * ( -q ) <  0 )
	#                                2
	#
	#     よって、
	#                             a^2                          ( p - r )^2
	#       cos(2t) == sqrt( ------------- ) == sqrt( --------------------------- )
	#                          a^2 + b^2                ( p - r )^2 + ( -2q )^2
	#
	#     として、
	#
	#       ( p - r ) * ( -2q ) >= 0 の時、
	#
	#         Q == [  cos(t) , sin(t) ] == [ sqrt( ( 1 + cos(2t) ) / 2 )           ,  sqrt( ( 1 - cos(2t) ) / 2 ]
	#              [ -sin(t) , cos(t) ]    [ sqrt( ( 1 - cos(2t) ) / 2 ) * ( -1 )  ,  sqrt( ( 1 + cos(2t) ) / 2 ]
	#
	#       それ以外の時、
	#
	#         Q == [  cos(t) , sin(t) ] == [ sqrt( ( 1 + cos(2t) ) / 2 ) ,  sqrt( ( 1 - cos(2t) ) / 2 * ( -1 ) ]
	#              [ -sin(t) , cos(t) ]    [ sqrt( ( 1 - cos(2t) ) / 2 ) ,  sqrt( ( 1 + cos(2t) ) / 2          ]
	#
	#     となる。
	#
	#
	#     二倍角演算のみを利用した cos(t) , sin(t) の導出は、演算コストは非常に低いものの、演算誤差が比較的大きくなる。
	#     特に、一度導出された値を元にして繰り返し演算を施すとその誤差は徐々に大きくなる。
	#     ギブンス行列は繰り返し演算で利用されるものであるため、二倍角の公式のみを利用した演算では精度に問題がある。
	#
	#     cos(2t) から 2t 及び t を求めて演算を行うことで演算誤差が是正される。
	#
	#
	#   3. atan2 により、角度 t を求めて cos(t) , sin(t) を導出する。
	#
	#     pp == p == A[p,p]
	#     pq == q == A[p,q] == A[q,p]
	#     qq == r == A[q,q]
	#
	#     a == pp - qq
	#     b == -2pq
	#
	#                           a^2
	#     cos(2t) == sqrt( ------------- ) より、
	#                        a^2 + b^2 
	#                                                        a^2                      b^2
	#     sin(2t) == sqrt( 1 - cos(2t)^2 ) == sqrt( 1 - ------------- ) == sqrt( ------------- )
	#                                                     a^2 + b^2                a^2 + b^2
	#
	#                  sin(2t)              b^2         b        -2pq         y
	#     tan(2t) == ----------- == sqrt( ------- ) == --- == ----------- == ---
	#                  cos(2t)              a^2         a       pp - qq       x
	#
	#
	#     t == atan2( y , x ) / 2
	#       == atan2( -2pq , pp - qq ) / 2
	#
	#     として、 cos(t) と sin(t) を求める。
	#
	#     x == 0 ( pp == qq ) の時、 atan( y / x ) は不定となるが、 atan2( y , x ) は PI or -PI を返す。
	#     このため、演算が破綻する事はない。
	#
	#     
	#   4. 複素数を介した導出。
	#
	#     atan2 を使用した手順から、複素数を使用して解を求めることもできる。
	#
	#     pp == A[p,p]
	#     pq == A[p,q] == A[q,p]
	#     qq == A[q,q]
	#
	#     x == pp - qq
	#     y == -2pq
	#
	#                           x^2                    x
	#     cos(2t) == sqrt( ------------- ) == ---------------------
	#                        x^2 + x^2          sqrt( x^2 + x^2 )
	#
	#                           y^2                    y
	#     sin(2t) == sqrt( ------------- ) == ---------------------
	#                        x^2 + y^2          sqrt( x^2 + y^2 )
	#
	#                 y        -2pq
	#     tan(2t) == --- == ----------- 
	#                 x       pp - qq
	#
	#     この cos(2t) と sin(2t) は、複素数の実部と虚部そのものの形をしているので、これ以上加工することなく
	#
	#       z == r * ( cos(2t) + i * sin(2t) )
	#         == x + iy
	#         == r * exp( i * 2t )
	#
	#       r == abs( z ) == sqrt( x^2 + y^2 )
	#
	#     と定義できる。
	#
	#     z の指数表現に注目すると、
	#
	#       z == r * exp( i * 2t ) == r * exp( i * t )^2
	#
	#     であり、 cos(t) , sin(t) を実部と虚部に持つ複素数 z' は、
	#
	#
	#       z' == cos(t) + i * sin(t)
	#                                     r * exp( i * 2t )
	#          == exp( i * t ) == sqrt( --------------------- )
	#                                            r
	#          == sqrt( z / r )
	#
	#     となる。
	#
	#     複素数の根を求める際には偏角の演算が必要なため、演算効率は atan2 を使う場合と大差ない。
	#     この演算は複素数の平方根を求める演算であるため 2 つの解が返る。
	#     この時、一方を z' とすると、もう一方は z' * ( -1 ) となる。
	#
	#     ちなみに、ギブンス行列としての性質を持った行列を作るだけであれば、 z' == sqrt( z ) でもよい。
	#
	#     z' == sqrt( z / r ) は、ここから得られる cos(t) , sin(t) を
	#
	#       -1 <= cos(t) <= 1
	#       -1 <= sin(t) <= 1
	#
	#     に限定する効果をもたらしている。 ( z' は複素単位円上の点となる。 )
	#     
	#
	#   以上の処理により、 2 x 2 の回転行列
	#
	#     Q == [  cos(t) , sin(t) ]
	#          [ -sin(t) , cos(t) ]
	#
	#   が得られたので、ここから A を変換するための n x n の回転行列 G を生成する。
	#
	#   まず、 G を A と同サイズの単位行列として初期化する。
	#
	#     G == unit_matrix( A )
	#
	#   次に、 p , q で示される成分を Q の成分で置き換える。
	#
	#     G[ p , p ] == Q[ 0 , 0 ] == cos(t)
	#     G[ p , q ] == Q[ 0 , 1 ] == sin(t)
	#     G[ q , p ] == Q[ 1 , 0 ] == sin(t) * ( -1 )
	#     G[ q , q ] == Q[ 0 , 1 ] == cos(t)
	#
	#   これにより、ギブンス行列 G が生成されたことになる。
	#
	#-----------------------------------------------------------------------
	my( $self , $p , $q ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return undef	if ( ! defined $p or ! defined $q ) ;
	return undef	if ( $p == $q ) ;

	my( $rows , $cols ) = $self->size() ;
	return undef	unless ( $rows == $cols ) ;

	#
	# 動作モード
	#
	#   0 : 二倍角正弦余弦を使用
	#   1 : atan2 を使用
	#   2 : 複素数の根を採る
	#
	my $flg = 2 ;

	#
	# 正弦と余弦を求める。
	#
	my( $s , $c ) ;
	{
		my $m = \@{ $self } ;
		my $pp = $m->[ $p ]->[ $p ] ;
		my $pq = $m->[ $p ]->[ $q ] ;
		my $qq = $m->[ $q ]->[ $q ] ;

		if ( $flg == 1 ) {
			#
			# 指定された成分から二倍角の角度を求める。
			#
			#                     -2 * pq       y
			#   tan( 2 * t ) == ----------- == ---
			#                     pp - qq       x
			#
			#   x == pp - qq
			#   y == pq * ( -2 )
			#   t == atan2( y , x ) / 2
			#
			#   cos = cos(t)
			#   sin = sin(t)
			#
			#   x == pp - qq == 0 で tan( 2 * t ) は不定になるが、
			#   atan2( y , x ) を使用することで 1/2 or -1/2 が返る。
			#
			my $x = $pp - $qq ;
			my $y = $pq * ( -2 ) ;

			my $t = $y->arctan2( $x )->divide( 2 ) ;
			( $c , $s ) = $t->_cosine_sine() ;
		}
		elsif ( $flg == 2 ) {
			#
			# 複素数を介してその平方根の一つを採る。
			#
			#   x == pp - qq
			#   y == pq * ( -2 )
			#   r == sqrt( x^2 + y^2 )
			#
			#   z  == x + iy
			#
			#   z' == sqrt( z / r )
			#      == sqrt( ( x + iy ) / r )
			#      == sqrt( x/r + i * y/r )
			#
			#   ( cos , sin ) == ( real( z' ) , imag( z' ) )
			#
			my $x = $pp - $qq ;
			my $y = $pq * ( -2 ) ;
			my $z = new_complex( [ $x , $y ] ) ;

			my $z_abs = $z->abs() ;
			( $z ) = ( $z / $z_abs )->sqrt()	unless ( $z_abs == 0 ) ;

			( $c , $s ) = $z->as_array() ;
		}
		else {
			#
			# 指定された成分から二倍角の余弦を導き、半角の正弦と余弦を導く。
			# ( 演算誤差が出やすく、繰り返し演算に弱い。 )
			#
			#
			#                               ( pp - qq )^2                              x^2
			#   cos(2t) == sqrt( ------------------------------------- ) == sqrt( ------------- )
			#                      ( pp - qq )^2 + ( pq * ( -2 ) )^2                x^2 + y^2
			#
			#   cos(t) == sqrt( ( 1 + cos(2t) ) / 2 )
			#   sin(t) == sqrt( ( 1 - cos(2t) ) / 2 )
			#
			my $x = $pp - $qq  ;
			my $y = $pq * ( -2 ) ;
			my $sgn = ( ( $x * $y ) < 0 ) ? '-1' : '1' ;

			my $x2 = $x * $x ;
			my $y2 = $y * $y ;

			my $cos2t = $x2->divide( $x2 + $y2 )->sqrt() ;

			$c = ( ( new_decimal( 1 ) + $cos2t ) / 2 )->sqrt() ;
			$s = ( ( new_decimal( 1 ) - $cos2t ) / 2 )->sqrt() * $sgn ;
		}
	}

	#
	# ギブンス行列を生成
	#
	my $g = $self->E() ;

	$g->[ $p ]->[ $p ] = $c ;
	$g->[ $p ]->[ $q ] = $s ;
	$g->[ $q ]->[ $p ] = $s * ( -1 ) ;
	$g->[ $q ]->[ $q ] = $c ;

	return $g ;
}

=head2 hadamard_matrix( $n )

This method will return n-dimension Hadamard matrix.

The Hadamard matrix is a square matrix whose elements are either +1 or -1 and whose rows are mutually orthogonal.

  H[1] == [ 1 ]

  H[2] == [ 1 ,  1 ]
          [ 1 , -1 ]

  H[4] == [ H[2] ,  H[2] ] == [  1 ,  1 ,  1  , 1 ]
          [ H[2] , -H[2] ]    [  1 , -1 ,  1 , -1 ]
                              [  1 ,  1 , -1 , -1 ]
                              [  1 , -1 , -1 ,  1 ]

  H[ 2^k ] == [ H[ 2^( k - 1 ) ] ,  H[ 2^( k - 1 ) ] ]
              [ H[ 2^( k - 1 ) ] , -H[ 2^( k - 1 ) ] ]

           == kronecker_product( H[2] , H[ 2^( k - 1 ) ] )           ( 2 <= k )


Within the Hadamard matrix H[n] ( order n ) and it's transpose matrix has following relationship.

  Transpose( H[n] ) ==  H[n] 

  transpose( H[n] ) * H[n] == n * I[n]

=cut

sub hadamard_matrix {
	#-----------------------------------------------------------------------
	#
	# アダマール行列 ( Hadamard matrix )
	#
	#   アダマール行列は、要素が 1 又は -1 のみで構成され、各行が互いに直交である正方行列。
	#
	#   n 次のアダマール行列は以下のような性質を持つ。
	#
	#     transpose( H ) * H == n * E
	#
	#     det( H ) == ± n^( n / 2 )
	#
	#   行列 M が abs( M[i,j] ) <= 1 であるような n 次複素行列である場合、
	#
	#     abs( det( M ) ) <= n^( n / 2 )
	#
	#   となる。
	#   この時 M が実行列であれば、 M はアダマール行列となる。
	#
	#   アダマール行列の次数は必ず 1 , 2 又は 4 の倍数となる。
	#
	#
	#   シルベスター ( Sylvester ) の生成法
	#
	#     シルベスターは、 n 次のアダマール行列 H が与えられた時、
	#
	#       [ H ,  H ]
	#       [ H , -H ]
	#
	#     が 2n 次のアダマール行列になることを示した。
	#     ここから、
	#
	#       H[1] == [ 1 ]
	#
	#       H[2] == [  1 ,  1 ]
	#               [  1 , -1 ]
	#
	#       H[4] == [ H[2] ,  H[2] ] == [  1 ,  1 ,  1  , 1 ]
	#               [ H[2] , -H[2] ]    [  1 , -1 ,  1 , -1 ]
	#                                   [  1 ,  1 , -1 , -1 ]
	#                                   [  1 , -1 , -1 ,  1 ]
	#
	#       H[ 2^k ] == [ H[ 2^( k - 1 ) ] ,  H[ 2^( k - 1 ) ] ]
	#                   [ H[ 2^( k - 1 ) ] , -H[ 2^( k - 1 ) ] ]
	#
	#                == kronecker_product( H[2] , H[ 2^( k - 1 ) ] )           ( 2 <= k )
	#
	#     つまり、 H[2] と H[2] , H[4] , H[8] , H[16] , .... , H[ 2^( k - 1 ) ] との間で
	#     クロネッカー積を採ることにより、任意の n == 2^k 次のアダマール行列が導かれることになる。 ( ウォルシュ行列 )
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	unless ( defined $n ) {
		if ( $self->is_square_matrix() )	{ $n = $self->rows() ; }
		else					{ return undef ; }
	}

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( defined $n ) ;

	return undef				if ( $n <  1 ) ;
	return __PACKAGE__->new( [ 1 ] )	if ( $n == 1 ) ;
	return undef				unless ( $n->is_even() ) ;

	unless ( $n == 2 ) {
		return undef	unless ( ( $n % 4 ) == 0 ) ;
	}

	#
	# シルベスターの生成法
	#
	#   H[1] == [  1 ]
	#
	#   H[2] == [  1 ,  1 ]
	#           [  1 , -1 ]
	#
	#   H[4] == kroneker_product( H[2] * H[2] )
	#
	#   H[2^k] == kronecker_product( H[2] * H[ 2^( k - 1 ) ] )          ( 2 <= k )
	#
	my $h2 = matrix( [ 1 , 1 ] , [ 1 , -1 ] ) ;
	my $h = $h2->copy() ;

	my $k2 = 2 ;
	while ( $k2 < $n ) {
		$h = $h2->kronecker_product( $h ) ;
		$k2 *= 2 ;
	}

	return $h ;
}

=head1 'Vector' object - stringify and some conversion of elements.
=cut

#-------------------------------------------------------------------------------
#
# 成分の変換 / 文字列化
#
#-------------------------------------------------------------------------------

=head2 as_string

  $m = matrix(
    [ 1 , 2 ] ,
    [ 3 , 4 ] ,
  ) ;

  print $m->as_string() ;                              # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

  print $m ;                                           # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

  $m = matrix( [ 1 ] ) ;

  print $m ;                                           # 1

=cut

sub as_string {
	#-----------------------------------------------------------------------
	#
	# 文字列化
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return ( $self->[0]->[0] )	if ( $self->rows() == 1 and $self->cols() == 1 ) ;

	my $m = $self->copy() ;
	my $s = [] ;
	foreach my $r ( @{ $m } ) {
		my @v ;
		foreach my $c ( @{ $r } ) {
			if	( $c->is_decimal() )	{ $c = $c->round( 5 ) ; }
			elsif	( $c->is_fraction() )	{ $c = ( $c->can_integer() ) ? $c->decimal()->round( 5 ) : $c ; }
			elsif	( $c->can_decimal() )	{ $c = $c->decimal()->round( 5 ) ; }

			if ( $c->is_decimal()) {
				if ( my $dig = $c->decimal_digits() )	{ $c = join( ''  , $c->value() , '0' x ( 5 - $dig ) ) ; }
				else					{ $c = join( '.' , $c->value() , '0' x   5          ) ; }
			}
			elsif ( $c->is_complex() ) {
				if ( $c->imag() >= 0 )	{ $c = sprintf( "%.2f + %.2f i" , $c->real() , $c->imag() ) ;		}
				else			{ $c = sprintf( "%.2f - %.2f i" , $c->real() , $c->imag()->abs() ) ;	}
			}

			push( @v , sprintf( "%20s" , $c ) ) ;
		}
		push( @{ $s } , '[ ' . join( ' , ' , @v ) . ' ]' ) ;
	}

	return join( "\n" , @{ $s } ) . "\n" ;
}

=head2 as_array 

  $m = matrix(
    [ 1 , 2 ] ,
    [ 3 , 4 ] ,
  ) ;

  $ma = $m->as_array() ;

  print join( ' ' , @{ $ma->[0] } ) ;                  # 1 2
  print join( ' ' , @{ $ma->[1] } ) ;                  # 3 4

=cut

sub as_array {
	#-----------------------------------------------------------------------
	#
	# 成分を配列参照で返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self->vec2array()	if ( $self->is_vector() ) ;

	return [ @{ $self } ] ;
}

=head2 scalar

If vector or matrix has only one element, return it else return  undef.

  $m = matrix( [ 1 ] ) ;

  print $m->scalar() ;                                 # 1


  $m = complex_matrix( [ [ 1 , 1 ] ] ) ;

  print $m ;                                           # 1 + i


=cut

sub scalar {
	#-----------------------------------------------------------------------
	#
	# スカラーであれば成分を返す。
	#
	# オブジェクトがスカラーベクトルやスカラー行列であれば非零成分を一つ返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return $self->[0]->[0]->copy()	if ( $self->can_scalar() or $self->is_scalar_matrix() ) ;

	my $r = undef ;
	if ( $self->is_scalar_vector() ) {
		foreach ( @{ $self->vec2array() } ) {
			if ( $_ != 0 ) {
				$r = $_->copy() ;
				last ;
			}
		}
	}

	return $r ;
}

sub decimal {
	#-----------------------------------------------------------------------
	#
	# 可能であれば実数を返す。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->can_decimal() ) ;

	my $d = $self->[0]->[0]->copy() ;

	return $d		if ( $d->is_decimal() ) ;
	return $d->decimal()	if ( $d->can_decimal() ) ;
	return undef ;
}

=head2 fraction

  $m = matrix(
    [ 1 , 1 ] ,
    [ 1 , 1 ] ,
  ) ;

  $m /= 3 ;

  print $m ;                                           # [              0.33333 ,              0.33333 ]
                                                       # [              0.33333 ,              0.33333 ]

  print $m->fraction() ;                               # [                  1/3 ,                  1/3 ]
                                                       # [                  1/3 ,                  1/3 ]

=cut

sub fraction {
	#-----------------------------------------------------------------------
	#
	# 個々の成分を可能な限り分数に変換する。
	#
	#   分子と分母の桁数は 3 桁以内とする。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = \@{ $self } ;
	foreach my $i ( 0 .. $#{ $m } ) {
		foreach my $j ( 0 .. $#{ $m->[ $i ] } ) {

			next	if ( $m->[ $i ]->[ $j ]->is_fraction() ) ;

			my $f = ( $m->[ $i ]->[ $j ]->is_decimal() )
				? $m->[ $i ]->[ $j ]->copy()
				: $m->[ $i ]->[ $j ]->decimal() 
			;

			next	unless ( defined $f ) ;
			next	unless ( $f->is_decimal() ) ;

			$f = $f->fraction() ;
			next	unless ( defined $f ) ;
			next	unless ( $f->is_fraction() ) ;

			if ( $f->numerator() < 1000 and $f->denominator() < 1000 ) {
				$m->[ $i ]->[ $j ] = $f ;
			}
		}
	}

	return $self ;
}

sub complex {
	#-----------------------------------------------------------------------
	#
	# 可能であれば複素数に変換して返す。
	#
	#   2 次の行ベクトル
	#
	#     vec == [ x , y ]
	#
	#     -> z == x + i * y
	#
	#   2 次の列ベクトル
	#
	#     vec == [ x ]
	#            [ y ]
	#
	#     -> z == x + i * y
	#
	#  2 x 2 の行列
	#
	#    matrix == [ x , -y ]
	#              [ y ,  x ]
	#
	#    -> z == x + i * y
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->can_complex() ) ;

	my( $x , $y ) = () ;

	if	( $self->can_scalar() )	{ ( $x , $y ) = ( $self->[0]->[0] , undef ) ;		} # スカラー
	elsif	( $self->is_cvector() )	{ ( $x , $y ) = @{ $self->transpose()->[0] } ;		} # 列ベクトル
	elsif	( $self->is_rvector() )	{ ( $x , $y ) = @{ $self->[0] } ;			} # 行ベクトル
	else				{ ( $x , $y ) = ( $self->[0]->[0] , $self->[1]->[0] ) ;	} # 行列

	unless ( defined $y ) {
		return $x->copy()				if ( $x->is_complex() ) ;
		return new_complex( [ $x ] )			if ( $x->is_decimal() ) ;
		return new_complex( [ $x->decimal() ] )		if ( $x->can_decimal() ) ;
		return undef ;
	}

	foreach ( $x , $y ) {
		unless ( $_->is_decimal() ) {
			$_ = ( $_->can_decimal() ) ? $_->decimal() : undef ;
			return undef	unless ( defined $_ ) ;
		}
	}

	return new_complex( [ $x , $y ] ) ;
}

=head2 round( $prec )

  $m = matrix(
    [ 1 , 1 ] ,
    [ 1 , 1 ] ,
  ) ;

  $m /= 6 ;

  print $m ;                                           # [              0.16667 ,              0.16667 ]
                                                       # [              0.16667 ,              0.16667 ]

  print $m->round( 0 ) ;                               # [              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ]

  print $m->round( 1 ) ;                               # [              0.20000 ,              0.20000 ]
                                                       # [              0.20000 ,              0.20000 ]

=cut

sub round {
	#-----------------------------------------------------------------------
	#
	# 成分を四捨五入する。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			$m->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]->round( $dlen ) ;
		}

		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round( $dlen ) ;
			$m->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ]->round( $dlen )	if ( defined $m->[ $c ]->[ $r ] ) ;
		}

		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round( $dlen ) ;
		}
	}

	return $m ;
}

=head2 round_banker( $prec )

  $m = matrix(
    [ 1 , 1 ] ,
    [ 1 , 1 ] ,
  ) ;

  $m /= 2 ;

  print $m ;                                           # [              0.50000 ,              0.50000 ]
                                                       # [              0.50000 ,              0.50000 ]

  print $m->round( 0 ) ;                               # [              1.00000 ,              1.00000 ]
                                                       # [              1.00000 ,              1.00000 ]

  print $m->round_banker( 0 ) ;                        # [              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ]

=cut

sub round_banker {
	#-----------------------------------------------------------------------
	#
	# 成分を四捨五入する。 ( 銀行家の丸め )
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			$m->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]->round_banker( $dlen ) ;
		}

		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_banker( $dlen ) ;
			$m->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ]->round_banker( $dlen )	if ( defined $m->[ $c ]->[ $r ] ) ;
		}

		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_banker( $dlen ) ;
		}
	}

	return $m ;
}

=head2 round_up( $prec )

  $m = matrix(
    [ 1 , 1 ] ,
    [ 1 , 1 ] ,
  ) ;

  $m /= 6 ;

  print $m ;                                           # [              0.16667 ,              0.16667 ]
                                                       # [              0.16667 ,              0.16667 ]

  print $m->round( 0 ) ;                               # [              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ]

  print $m->round_up( 0 ) ;                            # [              1.00000 ,              1.00000 ]
                                                       # [              1.00000 ,              1.00000 ]

=cut

sub round_up {
	#-----------------------------------------------------------------------
	#
	# 成分を切り上げる。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			$m->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]->round_up( $dlen ) ;
		}

		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_up( $dlen ) ;
			$m->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ]->round_up( $dlen )	if ( defined $m->[ $c ]->[ $r ] ) ;
		}

		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_up( $dlen ) ;
		}
	}

	return $m ;
}

=head2 round_up( $prec )

  $m = matrix(
    [ 1 , 1 ] ,
    [ 1 , 1 ] ,
  ) ;

  $m /= 6 ;

  print $m ;                                           # [              0.16667 ,              0.16667 ]
                                                       # [              0.16667 ,              0.16667 ]

  print $m->round( 1 ) ;                               # [              0.20000 ,              0.20000 ]
                                                       # [              0.20000 ,              0.20000 ]

  print $m->round_down( 1 ) ;                          # [              0.10000 ,              0.10000 ]
                                                       # [              0.10000 ,              0.10000 ]

=cut

sub round_down {
	#-----------------------------------------------------------------------
	#
	# 成分を切り下げる。
	#
	#-----------------------------------------------------------------------
	my( $self , $dlen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			$m->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ]->round_down( $dlen ) ;
		}

		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_down( $dlen ) ;
			$m->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ]->round_down( $dlen )	if ( defined $m->[ $c ]->[ $r ] ) ;
		}

		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ]->round_down( $dlen ) ;
		}
	}

	return $m ;
}

=head1 'Vector' object - the properties.

=cut


#-------------------------------------------------------------------------------
#
# 属性
#
#-------------------------------------------------------------------------------

=head2 rows , cols , size

Return a number of elements, which contains vector or matrix.

  $v = vector( 1 .. 3 ) ;

  print $v ;                                           # [              1.00000 ]
                                                       # [              2.00000 ]
                                                       # [              3.00000 ]

  print $v->rows() ;                                   # 3
  print $v->cols() ;                                   # 1
  print join ' ' , $v->size() ;                        # 3 1

=cut

sub rows	{ return scalar( @{ $_[0] } ) ; }		# 行数
sub cols	{ return scalar( @{ $_[0]->[0] } ) ; }		# 列数 ( 第 1 行で代表する )
sub size	{ return ( $_[0]->rows() , $_[0]->cols() ) ; }	# [ 行数 , 列数 ]

=head2 is_XXX

  $v = vector( 1 .. 3 ) ;

  print $v->is_scalar() ;                              # always 0
  print $v->is_decimal() ;                             # always 0
  print $v->is_fraction() ;                            # always 0
  print $v->is_complex() ;                             # always 0

  print $v->is_cvector() ;                             # 1
  print $v->is_rvector() ;                             # 0
  print $v->transpose()->is_rvector() ;                # 1

  print $v->is_vector() ;                              # 1
  print $v->is_matrix() ;                              # 0

  print $v->is_complex_vector() ;                      # 0
  print $v->is_complex_matrix() ;                      # 0
  print $v->is_complex_vm() ;                          # 0 

  $v *= complex( [ 0 , 1 ] ) ;
  print $v->is_complex_vector() ;                      # 1
  print $v->is_complex_matrix() ;                      # 0
  print $v->is_complex_vm() ;                          # 1   ( if complex vector or complex matrix then 1 )

  $v = vector( 1 , 0 , 0 ) ;
  print $v->is_zero_vector() ;                         # 0
  print $v->is_unit_vector() ;                         # 1
  print $v->is_scalar_vector() ;                       # 1

  print $v->is_zero_matrix() ;                         # 0
  print $v->is_unit_matrix() ;                         # 0
  print $v->is_scalar_matrix() ;                       # 0

=cut

sub is_scalar		{ return 0 ; }
sub is_decimal		{ return 0 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 0 ; }
sub is_cvector		{ return ( $_[0]->cols() == 1 ) ? 1 : 0 ; }				# 列ベクトルかどうか
sub is_rvector		{ return ( $_[0]->rows() == 1 ) ? 1 : 0 ; }				# 行ベクトルかどうか
sub is_polynomial	{ return 0 ; }

sub is_vector {
	#-----------------------------------------------------------------------
	#
	# ベクトルかどうか
	#
	#-----------------------------------------------------------------------
	return 1	if ( $_[0]->is_cvector() or $_[0]->is_rvector() ) ;
	return 0 ;
}

sub is_matrix {
	#-----------------------------------------------------------------------
	#
	# 行列かどうか
	#
	#-----------------------------------------------------------------------
	return 1	if ( $_[0]->rows() > 1 and $_[0]->cols() > 1 ) ;
	return 0 ;
}

sub is_complex_vector {
	#-----------------------------------------------------------------------
	#
	# 複素ベクトルかどうか
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return 0	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return 0	unless ( $v->is_vector() ) ;
	return $v->is_complex_vm() ;
}

sub is_complex_matrix {
	#-----------------------------------------------------------------------
	#
	# 複素行列かどうか
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_matrix() ) ;
	return $m->is_complex_vm() ;
}

sub is_complex_vm {
	#-----------------------------------------------------------------------
	#
	# 複素ベクトル又は複素行列かどうか
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			return 1	if ( $m->[ $r ]->[ $r ]->is_complex() ) ;
		}
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			return 1	if ( $m->[ $r ]->[ $c ]->is_complex() ) ;
			return 1	if ( defined $m->[ $c ]->[ $r ] and $m->[ $c ]->[ $r ]->is_complex() ) ;
		}
		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			return 1	if ( $m->[ $r ]->[ $c ]->is_complex() ) ;
		}
	}

	return 0 ;
}

sub is_zero_vector {
	#-----------------------------------------------------------------------
	#
	# 零ベクトルかどうか
	#
	#   零ベクトルは、ベクトル成分が全て 0 となるベクトル。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return 0	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return 0	unless ( $v->is_vector() ) ;

	$v = $v->rvector() ;
	foreach ( @{ $v->[0] } ) {
		return 0	unless ( $_ == 0 ) ;
	}

	return 1 ;
}

sub is_unit_vector {
	#-----------------------------------------------------------------------
	#
	# 単位ベクトルかどうか
	#
	#   単位ベクトルは、成分のいずれか一つが 1 、その他が全て 0 となるベクトル。
	#
	#   3 次の列ベクトルの場合、
	#
	#     v == [ 1 ] or [ 0 ] or [ 0 ]
	#          [ 0 ]    [ 1 ]    [ 0 ]
	#          [ 0 ]    [ 0 ]    [ 1 ]
	#
	#   の三種類が該当する。
	#
	#   単位ベクトルの全ての組み合わせを対角が全て 1 となるように連結すると単位行列となる。
	#   逆に言うと、単位ベクトルは単位行列のベクトル成分の一つと言うことになる。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return 0	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return 0	unless ( $v->is_vector() ) ;

	$v = $v->rvector() ;
	my $c = 0 ;
	foreach ( @{ $v->[0] } ) {
		return 0	if ( $_ != 0 and $_ != 1 ) ;
		$c += abs($_) ;
		return 0	if ( $c > 1 ) ;
	}

	return 1 ;
}

sub is_scalar_vector {
	#-----------------------------------------------------------------------
	#
	# スカラーベクトルがどうか
	#
	#   スカラーベクトルは単位ベクトルのスカラー倍で表現できるベクトル。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return 0	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return 0	unless ( $v->is_vector() ) ;

	my $nz = 0 ;
	$v = $v->rvector() ;
	foreach ( @{ $v->[0] } ) {
		$nz++	if ( $_ != 0 ) ;
		last	if ( $nz > 1 ) ;
	}

	return ( $nz == 1 ) ? 1 : 0 ;
}

sub is_zero_matrix {
	#-----------------------------------------------------------------------
	#
	# 零行列かどうか
	#
	#   零行列は全ての成分が 0 となる行列。
	#
	#   零行列は正方行列とは限らない。
	#   正方行列である零行列 ( 正方零行列 ) は対角行列の一種。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		if ( defined $m->[ $r ]->[ $r ] ) {
			return 0	unless ( $m->[ $r ]->[ $r ] == 0 ) ;
		}
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last		if ( $c >= $cols ) ;
			return 0	if ( $m->[ $r ]->[ $c ] != 0 ) ;
			return 0	if ( defined $m->[ $c ]->[ $r ] and $m->[ $r ]->[ $c ] != $m->[ $c ]->[ $r ] ) ;
		}

		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			return 0	if ( $m->[ $r ]->[ $c ] != 0 ) ;
		}
	}

	return 1 ;
}

=head2 is_unit_matrix

If a matrix A is like a

  A == [ a11 , a12 , a13 , a14 ] == [ 1 , 0 , 0 , 0 ] 
       [ a21 , a22 , a23 , a24 ]    [ 0 , 1 , 0 , 0 ] 
       [ a31 , a32 , a33 , a34 ]    [ 0 , 0 , 1 , 0 ] 
       [ a41 , a42 , a43 , a44 ]    [ 0 , 0 , 0 , 1 ] 

then return 1 else return 0.

=cut

sub is_unit_matrix {
	#-----------------------------------------------------------------------
	#
	# 単位行列かどうか
	#
	#   単位行列は、対角成分が全て 1 、非対角成分が全て 0 となる正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ 1 , 0 , 0 , 0 ] 
	#          [ a21 , a22 , a23 , a24 ]    [ 0 , 1 , 0 , 0 ] 
	#          [ a31 , a32 , a33 , a34 ]    [ 0 , 0 , 1 , 0 ] 
	#          [ a41 , a42 , a43 , a44 ]    [ 0 , 0 , 0 , 1 ] 
	#
	#   といった構造を持つ。
	#
	#   単位行列は対角行列の一種。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_diagonal_matrix() ) ;	# 単位行列は対角行列でもある。

	#
	# 対角行列である事は確認済みなので、非対角成分が全て 0 であることは自明。
	# 対角成分が 1 のみで構成されていることを確認する。
	#
	my $rmax = $m->rows() - 1 ;
	foreach my $r ( 0 .. $rmax ) {
		return 0	unless ( $m->[ $r ]->[ $r ] == 1 ) ;
	}

	return 1 ;
}

=head2 is_scalar_matrix

If a matrix A is like a

  A == [ a11 , a12 , a13 , a14 ] == [ a11 ,   0 ,   0 ,   0 ] 
       [ a21 , a22 , a23 , a24 ]    [   0 , a11 ,   0 ,   0 ] 
       [ a31 , a32 , a33 , a34 ]    [   0 ,   0 , a11 ,   0 ] 
       [ a41 , a42 , a43 , a44 ]    [   0 ,   0 ,   0 , a11 ] 

then return 1 else return 0.

=cut

sub is_scalar_matrix {
	#-----------------------------------------------------------------------
	#
	# スカラー行列かどうか
	#
	#   スカラー行列は単位行列のスカラー倍で表現できる行列を指す。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_diagonal_matrix() ) ;	# スカラー行列は対角行列でもある。

	my $x = $m->diag2array() ;
	my $r = 1 ;
	foreach ( @{ $x } ) {
		unless ( $_ == $x->[0] ) {
			$r = 0 ;
			last ;
		}
	}

	return $r ;
}

=head2 is_square_matrix

About a matrix $m.

If ( $m->rows() == $m->cols() ) then return 1 else return 0.

=cut

sub is_square_matrix {
	#-----------------------------------------------------------------------
	#
	# 正方行列かどうか
	#
	#-----------------------------------------------------------------------
	return 0	unless ( $_[0]->is_matrix() ) ;
	return 1	if ( $_[0]->rows() == $_[0]->cols() ) ;
	return 0 ;
}

=head2 triangular_matrix_type

Return 0   if a matrix $m is not a triangular matrix.
Return 1   if a matrix $m is a upper triangular matrix.
Return 2   if a matrix $m is a lower triangular matrix.
Return 3   if a matrix $m is a diagonal matrix.


  $m = matrix(
    [ 1 , 2 , 3 ]
    [ 4 , 5 , 6 ]
    [ 7 , 8 , 9 ]
  ) ;

  print $m->triangular_matrix_type() ;                 # 0

  $m = matrix(
    [ 1 , 2 , 3 ]
    [ 0 , 5 , 6 ]
    [ 0 , 0 , 9 ]
  ) ;

  print $m->triangular_matrix_type() ;                 # 1

  $m = matrix(
    [ 1 , 0 , 0 ]
    [ 4 , 5 , 0 ]
    [ 7 , 8 , 9 ]
  ) ;

  print $m->triangular_matrix_type() ;                 # 2

  $m = matrix(
    [ 1 , 0 , 0 ]
    [ 0 , 5 , 0 ]
    [ 0 , 0 , 9 ]
  ) ;

  print $m->triangular_matrix_type() ;                 # 3

=cut

sub triangular_matrix_type {
	#-----------------------------------------------------------------------
	#
	# 三角行列であればその種類を返す。
	#
	#   0 : 三角行列ではない。
	#   1 : 上三角行列
	#   2 : 下三角行列
	#   3 : 対角行列
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rmax = $m->rows() - 1 ;

	my $res = 3 ;

	foreach my $r ( 0 .. $rmax ) {
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			#
			# 対角行列かどうか
			#
			if ( $res == 3 ) {
				if ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ] ) {
					unless	( $m->[ $r ]->[ $c ] == 0 )	{ $res = 0 ; }
				}
				else {
					if	( $m->[ $r ]->[ $c ] == 0 )	{ $res = 1 ; }
					elsif	( $m->[ $c ]->[ $r ] == 0 )	{ $res = 2 ; }
					else					{ $res = 0 ; }
				}
			}

			#
			# 上三角行列かどうか
			#
			if ( $res == 1 ) {
				$res = 0	unless ( $m->[ $r ]->[ $c ] == 0 ) ;
			}

			#
			# 下三角行列かどうか
			#
			if ( $res == 2 ) {
				$res = 0	unless ( $m->[ $c ]->[ $r ] == 0 ) ;
			}

			last	if ( $res < 1 ) ;
		}
		last	if ( $res < 1 ) ;
	}

	return ( $res < 1 ) ? 0 : $res ;
}

=head2 is_diagonal_matrix

If a matrix A is a regular matrix, and it is like a

  A == [ a11 , a12 , a13 , a14 ] == [ a11 ,   0 ,   0 ,   0 ] 
       [ a21 , a22 , a23 , a24 ]    [   0 , a22 ,   0 ,   0 ] 
       [ a31 , a32 , a33 , a34 ]    [   0 ,   0 , a33 ,   0 ] 
       [ a41 , a42 , a43 , a44 ]    [   0 ,   0 ,   0 , a44 ] 

then return 1 else return 0.

If a matrix A is a regular matrix and it is zero matrix or unit matrix, a matrix A is also a diagonal matrix.

=cut

sub is_diagonal_matrix {
	#-----------------------------------------------------------------------
	#
	# 対角行列かどうか
	#
	#   対角行列は、非対角成分が全て 0 である正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a11 ,   0 ,   0 ,   0 ] 
	#          [ a21 , a22 , a23 , a24 ]    [   0 , a22 ,   0 ,   0 ] 
	#          [ a31 , a32 , a33 , a34 ]    [   0 ,   0 , a33 ,   0 ] 
	#          [ a41 , a42 , a43 , a44 ]    [   0 ,   0 ,   0 , a44 ] 
	#
	#   といった構造を持つ。
	#
	#   対角行列は上三角行列であり且つ下三角行列でもある。
	#   また、非対角成分が全て 0 である対称行列でもある。
	#
	#   正方零行列や単位行列も対角行列の一種。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 1	if ( $m->triangular_matrix_type() == 3 ) ;
	return 0 ;
}

=head2 is_hessenburg_matrix

If a matrix A is a regular matrix, and it is like a

  A == [ a11 , a12 , a13 , a14 ] == [  a11 ,  a12 ,  a13 ,  a14 ] 
       [ a21 , a22 , a23 , a24 ]    [  a21 ,  a22 ,  a23 ,  a24 ] 
       [ a31 , a32 , a33 , a34 ]    [    0 ,  a32 ,  a33 ,  a34 ] 
       [ a41 , a42 , a43 , a44 ]    [    0 ,    0 ,  a43 ,  a44 ] 

then return 1 else return 0.

If a matrix H is a Hessenburg matrix, and adjont( H ) is also a Hessenburg matrix,
then the matrix H is a tridiagonal matrix.

=cut

sub is_hessenburg_matrix {
	#-----------------------------------------------------------------------
	#
	# ヘッセンベルグ行列 ( Hessenburg matrix ) かどうか
	#
	#   ヘッセンベルグ行列は下三角成分の二重対角以外の成分が全て 0 であるような正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [  a11 ,  a12 ,  a13 ,  a14 ] 
	#          [ a21 , a22 , a23 , a24 ]    [  a21 ,  a22 ,  a23 ,  a24 ] 
	#          [ a31 , a32 , a33 , a34 ]    [    0 ,  a32 ,  a33 ,  a34 ] 
	#          [ a41 , a42 , a43 , a44 ]    [    0 ,    0 ,  a43 ,  a44 ] 
	#
	#   と言った構造を持つ。
	#
	#   ヘッセンベルグ行列の共役転置行列 ( 転置行列 ) もまたヘッセンベルグ行列となるような行列は、
	#   三重対角行列 ( Tridiagonal matrix ) と呼ばれる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rmax = $m->rows() - 1 ;

	foreach my $r ( 2 .. $rmax ) {
		foreach my $c ( 0 .. ( $r - 2 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == 0 ) ;
		}
	}

	return 1 ;
}

=head2 is_tridiagonal_matrix

If a matrix A is a regular matrix, and it is like a

  A == [ a11 , a12 , a13 , a14 ] == [  a11 ,  a12 ,    0 ,    0 ] 
       [ a21 , a22 , a23 , a24 ]    [  a21 ,  a22 ,  a23 ,    0 ] 
       [ a31 , a32 , a33 , a34 ]    [    0 ,  a32 ,  a33 ,  a34 ] 
       [ a41 , a42 , a43 , a44 ]    [    0 ,    0 ,  a43 ,  a44 ] 

then return 1 else return 0.

=cut

sub is_tridiagonal_matrix {
	#-----------------------------------------------------------------------
	#
	# 三重対角行列かどうか
	#
	#   三重対角行列は、主対角成分を中心とする三つの対角成分を除く成分が全て 0 となる正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a11 , a12 ,   0 ,   0 ] 
	#          [ a21 , a22 , a23 , a24 ]    [ a21 , a22 , a23 ,   0 ] 
	#          [ a31 , a32 , a33 , a34 ]    [   0 , a32 , a33 , a34 ] 
	#          [ a41 , a42 , a43 , a44 ]    [   0 ,   0 , a43 , a44 ] 
	#
	#   といった構造を持つ。
	#
	#   各成分の検査範囲が異なる点を除けば検査方法は対角行列と同じ。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rmax = $m->rows() - 1 ;

	foreach my $r ( 2 .. $rmax ) {
		foreach my $c ( 0 .. ( $r - 2 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ] ) ;
			return 0	unless ( $m->[ $r ]->[ $c ] == 0 ) ;
		}
	}

	return 1 ;
}

=head2 is_triangular_matrix

If the matrix is a triangular matrix, return 1 else return 0.

=cut

sub is_triangular_matrix {
	#-----------------------------------------------------------------------
	#
	# 三角行列かどうか
	#
	#   三角行列には、対角行列、上三角行列、下三角行列が含まれる。
	#   三角行列の固有値はその主対角成分に等しい。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 1	if ( $m->triangular_matrix_type() > 0 ) ;
	return 0 ;
}

=head2 is_upper_triangular_matrix

If the matrix is a upper triangular matrix, return 1 else return 0.

=cut

sub is_upper_triangular_matrix {
	#-----------------------------------------------------------------------
	#
	# 上三角行列かどうか
	#
	#   上三角行列は対角成分の下方の成分が全て 0 となる正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a11 , a12 , a13 , a14 ] 
	#          [ a21 , a22 , a23 , a24 ]    [   0 , a22 , a23 , a24 ] 
	#          [ a31 , a32 , a33 , a34 ]    [   0 ,   0 , a33 , a34 ] 
	#          [ a41 , a42 , a43 , a44 ]    [   0 ,   0 ,   0 , a44 ] 
	#
	#   といった構造を持つ。
	#
	#   対角行列は上三角行列でもあるが、このモジュールではこれらを区別している。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 1	if ( $m->triangular_matrix_type() == 1 ) ;
	return 0 ;
}

sub is_lower_triangular_matrix {
	#-----------------------------------------------------------------------
	#
	# 下三角行列かどうか
	#
	#   下三角行列は対角成分の上方の成分が全て 0 となる正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a11 ,   0 ,   0 ,   0 ] 
	#          [ a21 , a22 , a23 , a24 ]    [ a21 , a22 ,   0 ,   0 ] 
	#          [ a31 , a32 , a33 , a34 ]    [ a31 , a32 , a33 ,   0 ] 
	#          [ a41 , a42 , a43 , a44 ]    [ a41 , a42 , a43 , a44 ] 
	#
	#   といった構造を持つ。
	#
	#   対角行列は下三角行列でもあるが、このモジュールではこれらを区別している。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 1	if ( $m->triangular_matrix_type() == 2 ) ;
	return 0 ;
}

=head2 is_lower_triangular_matrix

If the matrix is a lower triangular matrix, return 1 else return 0.

=cut

sub is_symmetric_matrix {
	#-----------------------------------------------------------------------
	#
	# 対称行列かどうか
	#
	#   対称行列は対角成分を境界として対称な位置にある成分が等しい正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a11 , a12 , a13 , a14 ] 
	#          [ a21 , a22 , a23 , a24 ]    [ a12 , a22 , a23 , a24 ] 
	#          [ a31 , a32 , a33 , a34 ]    [ a13 , a23 , a33 , a34 ] 
	#          [ a41 , a42 , a43 , a44 ]    [ a14 , a24 , a34 , a44 ] 
	#
	#   と言う構造を持つ。
	#
	#   対称行列の概念を複素行列に拡張したものはエルミート行列と呼ばれる。
	#   対称行列やエルミート行列には定値性と呼ばれる区分がある。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rmax = $m->rows() - 1 ;

	foreach my $r ( 0 .. $rmax ) {
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ] ) ;
		}
	}

	return 1 ;
}

=head2 is_hermitian_matrix

Return the matrix is a Hermitian matrix or not.

The Hermitian matrix H is one of the kind of regular matrix, and it has following characteristics.

  H == adjoint( H )
    == transpose( conj( H ) )

Then it's elements are like as

  H == [ h11 , h12 , h13 , h14 ] == [    h11      ,    h12      ,    h13      , h14 ]
       [ h21 , h22 , h23 , h24 ]    [ conj( h12 ) ,    h22      ,    h23      , h24 ]
       [ h31 , h32 , h33 , h34 ]    [ conj( h13 ) , conj( h23 ) ,    h33      , h34 ]
       [ h41 , h42 , h43 , h44 ]    [ conj( h14 ) , conj( h24 ) , conj( h34 ) , h44 ]

    == [    x11      , x12 + iy12 , x13 + iy13 , x14 + iy14 ]
       [ x12 - iy12  ,    x22     , x23 + iy23 , x24 + iy24 ]
       [ x13 - iy13  , x23 - iy23 ,    x33     , x34 + iy34 ]
       [ x14 - iy14  , x24 - iy24 , x34 - iy34 ,    x34     ]

x11 , x22 , x23 , x24 must be a real number.

If all elements are real numbers, and the matrix is Hermitian matrix, it is also a symmetric matrix.

=cut

sub is_hermitian_matrix {
	#-----------------------------------------------------------------------
	#
	# エルミート行列 ( Hermitian matrix ; 自己随伴行列 ) かどうかを返す。
	#
	#   エルミート行列は、実行列における対称行列 ( symmetric matrix ) を複素行列に拡張したもの。
	#
	#   エルミート行列は、随伴行列 ( 共役転置行列 ) が自身と等しくなるような複素正方行列
	#
	#     H == adjoint( H )
	#       == transpose( conj( H ) )
	#
	#   であり、
	#
	#     H == [ h11 , h12 , h13 , h14 ] == [    h11      ,    h12      ,    h13      , h14 ]
	#          [ h21 , h22 , h23 , h24 ]    [ conj( h12 ) ,    h22      ,    h23      , h24 ]
	#          [ h31 , h32 , h33 , h34 ]    [ conj( h13 ) , conj( h23 ) ,    h33      , h34 ]
	#          [ h41 , h42 , h43 , h44 ]    [ conj( h14 ) , conj( h24 ) , conj( h34 ) , h44 ]
	#
	#                                    == [    x11      , x12 + iy12 , x13 + iy13 , x14 + iy14 ]
	#                                       [ x12 - iy12  ,    x22     , x23 + iy23 , x24 + iy24 ]
	#                                       [ x13 - iy13  , x23 - iy23 ,    x33     , x34 + iy34 ]
	#                                       [ x14 - iy14  , x24 - iy24 , x34 - iy34 ,    x34     ]
	#
	#   といった構造を持つ。
	#
	#   定義より、対角成分はその複素共役と一致していなければならず、このため対角成分は必ず実数となる。
	#
	#   エルミート行列は、各成分の虚部の符号を反転させて転置した行列に等しいと言う特徴を持つ。
	#   これに対して、歪エルミート行列は、各成分の実部の符号を反転させて転置したものに等しい行列となる。
	#
	#   エルミート行列の固有値は全て実数となる。
	#   よって、行列式もまた実数となる。
	#
	#   エルミート行列は、実行列における対称行列 ( symmetric matrix ) に相当する。
	#   慣例として、エルミート行列は H で、対称行列は S で表現される。
	#
	#   H == S つまり、行列 H が実行列である場合、
	#
	#     conj( S ) == S
	#     adjoint( S ) == transpose( conj( S ) )
	#                  == transpose( S )
	#                  == S
	#
	#   となる。
	#
	#
	#   エルミート行列の分解
	#
	#     エルミート行列 H は、対角行列 D と適切なユニタリー行列 U を伴って、
	#
	#       H == U * D * adjoint( U )
	#
	#     と分解できる。
	#
	#     この時、 D の対角には H の固有値が、 U の列ベクトルには D の対角成分に対応する固有ベクトルが並ぶ。
	#
	#     U はユニタリー行列なので、
	#
	#       U * adjoint( U ) == E == adjoint( U ) * U
	#       U == inverse( U ) == adjoint( U )
	#
	#
	#   エルミート行列の正規性
	#
	#     エルミート行列 H は、
	#
	#       inner_product( H ) == adjoint( H ) * H == H * adjoint( H )
	#
	#     となることから、正規行列 ( normal matrix ) の一種でもある。
	#
	#     エルミート行列が
	#
	#       H == U * D * adjoint( U )
	#
	#     に分解でき、 D に固有値が、 U に固有ベクトルが現れるのは、エルミート行列が正規行列であることに拠る。
	#
	#     エルミート行列の他にも、ユニタリー行列、歪エルミート行列もまた正規行列。
	#
	#
	#   エルミート行列の定値性
	#
	#     エルミート行列や対称行列には定値性 ( Definitness ) と呼ばれる区分がある。
	#     エルミート行列の定値性は、エルミート行列 A と任意のベクトル x ( ただし x != 0 ) について、
	#
	#       sgn( A ) == sgn( inner_product( x , Ax ) )
	#                == sgn( adjoint( x ) * Ax )
	#
	#     で判断される。 ( sgn は実数の符号を返すものとする。 )
	#
	#     定値性は以下のように定義される。
	#
	#       常に sgn( A ) >  0           -> A >  0   ..... A は正定値   ( positive definite ; 正値 )
	#       常に sgn( A ) >= 0           -> A >= 0   ..... A は半正定値 ( positive semidefinite ) または非負値 ( non-negative definite )
	#       常に sgn( A ) <  0           -> A <  0   ..... A は負定値   ( negative definite )
	#       常に sgn( A ) <= 0           -> A <= 0   ..... A は半負定値 ( negative semidefinite ; 非正値 )
	#       上記のどれにも当てはまらない -> N/A      ..... A は不定値   ( indefinite )
	#
	#
	#     定値性は、エルミート行列 A の固有値が採り得る符号に依存する。
	#
	#       -- 証明 1 --
	#
	#         エルミート行列 A の固有値 λ と固有ベクトル v の関係より、
	#
	#           Av == λv
	#           -> inner_product( v , Av ) == inner_product( v , λv )
	#           -> adjoint( v ) * A * v == adjoint( v ) * λ * v
	#                                   == λ * adjoint( v ) * v
	#                                   == λ * inner_product( v )
	#                                   == λ * ( norm( v ) )^2
	#
	#         行列 A がエルミート行列であることから、固有値 λ は全て実数となる。
	#         また、 v != 0 より、
	#
	#           ( norm( v ) )^2 == Σ( abs( v[k] ) )^2 > 0
	#
	#         となることから、 inner_product( v , Av ) の符号は、 λ の符号のみに依存していることになる。
	#
	#         一方、任意のベクトル x ( x != 0 ) は、 A の全ての固有値の内の 1 つである λ[i] とその固有ベクトル v[i] を用いて
	#
	#           x == Σ( c[i] * v[i] )
	#
	#         と表現でき、
	#
	#           inner_product( x , Ax ) == Σ( λ[i] * ( norm( c[i] * v[i] ) )^2 )
	#
	#         となる。
	#
	#         よって、行列 A の定値性は固有値 λ に依存して決まることが判る。
	#
	#
	#       -- 証明 2 --
	#
	#         エルミート行列が以下のように表されることを利用する。
	#
	#           H == U * D * adjoint( U )
	#           -> D == adjoint( U ) * H * U
	#
	#           U * adjoint( U ) == E == adjoint( U ) * U
	#
	#         x == U * y となるベクトル y を定義すると、
	#
	#           x == U * y
	#           -> adjoint( x ) == adjoint( y ) * adjoint( U )
	#
	#           inner_product( x , Hx ) == adjoint( x ) * H * x
	#                                   == adjoint( y ) * adjoint( U ) * H * U * y
	#                                   == adjoint( y ) * D * y
	#
	#         D は対角成分 d[k,k] に H の固有値を持つ対角行列。
	#         非対角成分は全て 0 であり、 H がエルミート行列であるため d[k,k] は全て実数。
	#
	#         y の成分を y[k] で表現すると、
	#
	#           inner_product( x , Hx ) == adjoint( y ) * D * y
	#                                   == Σ( conj( y[k] ) * d[k,k] * y[k] )
	#                                   == Σ( d[k,k] * y[k] * conj( y[k] ) )          ( k == 1 -> n )
	#         この時、
	#
	#            y[k] * conj( y[k] ) == real( y[k] )^2 + imag( y[k] )^2
	#                                == abs( y[k] )^2
	#                                >  0
	#
	#         であるため、 x と Hx の内積の符号は H の固有値 d[k,k] の符号のみに依存することが示される。
	#
	#
	#       固有ベクトル x と Ax の内積は、
	#
	#         inner_product( x , Ax ) == adjoint( x ) * Ax
	#                                 == norm( adjoint( x ) ) * norm( Av ) * cos( theta )
	#
	#       と表すこともできる。
	#
	#       この時、 theta は、 ベクトル v とベクトル Av が形成する角であり、定値性は cos( theta ) の符号のみに依存することになる。
	#       よって、
	#
	#         -PI/2 <  theta <  PI/2  -> A >  0
	#         -PI/2 <= theta <= PI/2  -> A >= 0
	#          PI/2 <  theta <  3PI/4 -> A <  0
	#          PI/2 <= theta <= 3PI/4 -> A <= 0
	#
	#       となる。
	#
	#
	#       エルミート行列 A が正定値であれば、 行列式 det( A ) > 0 となる。
	#
	#         A > 0
	#         -> det( A ) > 0
	#
	#       エルミート行列 A が正定値であれば、 A は正則 ( 逆行列を持つ ) であり、その逆行列も正定値となる。
	#
	#         A > 0
	#         -> inverse( A ) > 0 and det( inverse( A ) ) > 0
	#
	#       エルミート行列 A が負定値であれば、 A は正則であり、その逆行列も負定値となる。
	#
	#         A < 0
	#         -> inverse( A ) < 0
	#
	#       半正定値行列はその成分を全て平方根に変換することができ、そのような平方根行列 ( 半正定値平方根行列 ) が 1 つだけ存在する。
	#
	#
	#     共分散行列
	#
	#       任意の m x n 行列 X について、
	#
	#         A == X * adjoint( X )
	#
	#       で得られる正方行列 A は、常に半正定値行列となる。
	#       これは共分散行列とも呼ばれる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	return 0				unless ( $m->is_square_matrix() ) ;
	return $m->is_symmetric_matrix()	unless ( $m->is_complex_matrix() ) ;	# 対称行列はエルミート行列

	my $rmax = $m->rows() - 1 ;
	foreach my $r ( 0 .. $rmax ) {
		#
		# 対角成分は実数でなければならない。
		#
		return 0	unless ( $m->[ $r ]->[ $r ]->can_decimal() ) ;

		#
		# 対称関係にある非対角成分は互いに複素共役の関係でなければならない。
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ]->conj() ) ;
		}
	}

	return 1 ;
}

=head2 is_alternative_matrix

Return the matrix is a alternative matrix or not.

The alternative matrix A is one of the kind of regular matrix, and it has following characteristics.

  A == ( -1 ) * transpose( A )

Then it's elements are like as

  A == [ a11 , a12 , a13 , a14 ] == [  a11 ,  a12 ,  a13 ,  a14 ] 
       [ a21 , a22 , a23 , a24 ]    [ -a12 ,  a22 ,  a23 ,  a24 ] 
       [ a31 , a32 , a33 , a34 ]    [ -a13 , -a23 ,  a33 ,  a34 ] 
       [ a41 , a42 , a43 , a44 ]    [ -a14 , -a24 , -a34 ,  a44 ] 

=cut

sub is_alternative_matrix {
	#-----------------------------------------------------------------------
	#
	# 交代行列かどうか
	#
	#   交代行列は、
	#
	#     A == ( -1 ) * transpose( A )
	#
	#   となるような正方行列であり、
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [  a11 ,  a12 ,  a13 ,  a14 ] 
	#          [ a21 , a22 , a23 , a24 ]    [ -a12 ,  a22 ,  a23 ,  a24 ] 
	#          [ a31 , a32 , a33 , a34 ]    [ -a13 , -a23 ,  a33 ,  a34 ] 
	#          [ a41 , a42 , a43 , a44 ]    [ -a14 , -a24 , -a34 ,  a44 ] 
	#
	#   といった構造を持つ。
	#
	#   定義より、対角成分は全て 0 となる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	if ( $m->is_complex_matrix() ) {
		return 0	unless ( $m->real_matrix() ) ;
	}

 	my $rmax = $m->rows() - 1 ;

	foreach my $r ( 0 .. $rmax ) {
		#
		# 対角成分は全て 0 である必要がある。
		#
		return 0	unless ( $m->[ $r ]->[ $r ]->round( 5 ) == 0 ) ;

		#
		# 対称関係にある非対角成分は符号が反転した値である必要がある。
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ] * ( -1 ) ) ;
		}
	}

	return 1 ;
}

=head2 is_skew_hermitian_matrix

Return the matrix is a skew-herimitian matrix or not.

The Skew-Herimitian matrix A is one of the kind of regular matrix, and it has following characteristics.

  A == ( -1 ) * adjoint( A )
    == ( -1 ) * traspose( conj( A ) )

Then it's elements are like as

  A == [ x11 + iy11 , x12 + iy12 , x13 + iy13 , x14 + iy14 ] == [    iy11     ,  x12 + iy12 ,  x13 + iy13 ,  x14 + iy14 ]
       [ x21 + iy21 , x22 + iy22 , x23 + iy23 , x24 + iy24 ]    [ -x12 + iy12 ,    iy22     ,  x23 + iy23 ,  x24 + iy24 ]
       [ x31 + iy31 , x32 + iy32 , x33 + iy33 , x34 + iy34 ]    [ -x13 + iy13 , -x23 + iy23 ,    iy33     ,  x34 + iy34 ]
       [ x41 + iy41 , x42 + iy42 , x43 + iy43 , x44 + iy44 ]    [ -x14 + iy14 , -x24 + iy24 , -x34 + iy34 ,    iy44     ]

The Skew-Herimitian matrix is also called, Anti-Hermitian matrix.

If the all of the elemnets are real numbers, the Skew-Hermitian matrix is also the Alternative matrix.

=cut

sub is_skew_hermitian_matrix {
	#-----------------------------------------------------------------------
	#
	# 歪エルミート行列 ( Skew-Hermitian matrix ) かどうかを返す。
	#
	#   歪エルミート行列は、実行列における交代行列 ( Alternative matrix ) を複素行列に拡張したもの。
	#   随伴行列を採ると符号が反転することから、反エルミート行列 ( Anti-Hermitian matrix ) とも呼ばれる。
	#
	#   歪エルミート行列は、自身の随伴行列との間に
	#
	#     A == ( -1 ) * adjoint( A )
	#       == ( -1 ) * transpose( conj( A ) ) 
	#
	#   の関係を持つ複素正方行列であり、
	#
	#     A == [ x11 + iy11 , x12 + iy12 , x13 + iy13 , x14 + iy14 ] == [    iy11     ,  x12 + iy12 ,  x13 + iy13 ,  x14 + iy14 ]
	#          [ x21 + iy21 , x22 + iy22 , x23 + iy23 , x24 + iy24 ]    [ -x12 + iy12 ,    iy22     ,  x23 + iy23 ,  x24 + iy24 ]
	#          [ x31 + iy31 , x32 + iy32 , x33 + iy33 , x34 + iy34 ]    [ -x13 + iy13 , -x23 + iy23 ,    iy33     ,  x34 + iy34 ]
	#          [ x41 + iy41 , x42 + iy42 , x43 + iy43 , x44 + iy44 ]    [ -x14 + iy14 , -x24 + iy24 , -x34 + iy34 ,    iy44     ]
	#
	#   と言った構造を持つ。
	#
	#   エルミート行列が、各成分の虚部の符号を反転させて転置した行列に等しいと言う特徴を持つのに対して、
	#   歪エルミート行列は、各成分の実部の符号を反転させて転置したものに等しい行列と言うことになる。
	#
	#     A[1,2] ==  x12 + iy12
	#     A[2,1] == ( -1 ) * conj( A[1,2] )
	#            == ( -1 ) * ( x12 - iy12 )
	#            == -x12 + iy12
	#
	#   定義より、対角成分には実部を持つことができず、対角成分は全て 0 又は純虚数となる。
	#
	#   歪エルミート行例は、実行列における交代行列 ( alternative matrix ) に相当する。
	#   このため、交代エルミート行列 ( Alternate Hermitian matrix ) とも呼ばれる。
	#   交代行列は、転置することで成分の符号が反転することから、反対称行列 ( Antisymmetric matrix ) とも呼ばれる。
	#
	#
	#   歪エルミート行列 A は、エルミート行列 H に虚数単位 i を掛けたものに等しい。
	#
	#     A == i * H
	#     -> H == A / i
	#
	#   エルミート行列の行列式が実数となることから、歪エルミート行列の行列式は 0 又は純虚数となる。
	#
	#     det( A ) == det( i * H )
	#              == i * det( H )
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	return 0				unless ( $m->is_square_matrix() ) ;
	return $m->is_alternative_matrix()	unless ( $m->is_complex_matrix() ) ;

	my $rmax = $m->rows() - 1 ;

	foreach my $r ( 0 .. $rmax ) {
		#
		# 対角成分は純虚数でなければならない。
		#
		return 0	unless ( $m->[ $r ]->[ $r ]->real() == 0 ) ;

		#
		# 対称関係にある非対角成分は互いに実部の符号のみが異なっている必要がある。
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $c ]->[ $r ]->conj() * ( -1 ) ) ;
		}
	}

	return 1 ;
}

=head2 is_orthogonal_matrix

Return the matrix is a othogonal matrix or not.

The othogonal matrix A is one of the kind of regular matrix, and it has following characteristics.

  transpose( A ) * A == A * transpose( A ) == E

  -> transpose( A ) == inverse( A ) 

=cut

sub is_orthogonal_matrix {
	#-----------------------------------------------------------------------
	#
	# 直交行列かどうか
	#
	#   直交行列は、
	#
	#     transpose( M ) * M == M * transpose( M ) == E
	#
	#     -> transpose( M ) == inverse( M )
	#
	#   となるような正方行列。
	#
	#   定義より、
	#
	#     det( A ) * det( transpose( A ) ) == det( A ) * det( inverse( A ) )
	#                                      == det( A * inverse( A ) )
	#                                      == det( E )
	#                                      == 1
	#     -> det( A ) == 1 or -1
	#
	#   直交行列 A の行ベクトルを A[i,] , 列ベクトルを A[,j] で表現すると、
	#
	#     inner_product( A[i,] , A[,j] ) == 1    if ( i == j )
	#                                    == 0    if ( i != j )
	#
	#   となる。
	#
	#
	#   直交行列には、代表的なものとして、
	#
	#     回転行列 == [ cos(t) , -sin(t) ]
	#                 [ sin(t) ,  cos(t) ]
	#
	#              -> [ cos(t) , -sin(t) ] * [  cos(t) , sin(t) ]
	#                 [ sin(t) ,  cos(t) ]   [ -sin(t) , cos(t) ]
	#
	#                 == [ cos(t)^2 + sin(t)^2                ,  cos(t) * sin(t) - sin(t) * cos(t) ]
	#                    [ sin(t) * cos(t) - cos(t) * sin(t)  ,  sin(t)^2 + cos(t)^2               ]
	#
	#                 == [ 1 , 0 ]
	#                    [ 0 , 1 ]
	#
	#     置換行列
	#
	#       どの行、どの列をとっても成分の内の 1 つのみが 1 で、その他の成分が 0 となるもの。
	#
	#         P == [ 0 , 1 , 0 ]
	#              [ 1 , 0 , 0 ]
	#              [ 0 , 0 , 1 ]
	#
	#         ->   [ 0 , 1 , 0 ] * [ 0 , 1 , 0 ] == [ 0 + 1 + 0 , 0 + 0 + 0 , 0 + 0 + 0 ] == [ 1 , 0 , 0 ]
	#              [ 1 , 0 , 0 ]   [ 1 , 0 , 0 ]    [ 0 + 0 + 0 , 1 + 0 + 0 , 0 + 0 + 0 ]    [ 0 , 1 , 0 ]
	#              [ 0 , 0 , 1 ]   [ 0 , 0 , 1 ]    [ 0 + 0 + 0 , 0 + 0 + 0 , 0 + 0 + 1 ]    [ 0 , 0 , 1 ]
	#
	#       置換行列を同じサイズの正方行列に左から作用させると行の入れ替え、右から作用させると列の入れ替えとなる。
	#
	#         A == [ a1 , a2 , a3 ]
	#              [ b1 , b2 , b3 ]
	#              [ c1 , c2 , c3 ]
	#
	#         PA == [ 0 , 1 , 0 ] * [ a1 , a2 , a3 ] == [ b1 , b2 , b3 ]
	#               [ 1 , 0 , 0 ]   [ b1 , b2 , b3 ]    [ a1 , a2 , a3 ]
	#               [ 0 , 0 , 1 ]   [ c1 , c2 , c3 ]    [ c1 , c2 , c3 ]
	#
	#         AP == [ a1 , a2 , a3 ] * [ 0 , 1 , 0 ] == [ a2 , a1 , a3 ]
	#               [ b1 , b2 , b3 ]   [ 1 , 0 , 0 ]    [ b2 , b1 , b3 ]
	#               [ c1 , c2 , c3 ]   [ 0 , 0 , 1 ]    [ c2 , c1 , c3 ]
	#
	#
	#     反射行列 ( 単位ベクトルの符号を反転させる行列 )
	#
	#   等がある。
	#
	#   ギブンス行列は回転行列の一種であり、ハウスホルダー行列は反射行列の一種。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return 0	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;
	return 0	if ( $m->is_complex_matrix() ) ;

	my $n = $m * $m->transpose() ;

	return $n->round( 5 )->is_unit_matrix() ;
}

=head2 is_unitary_matrix

Return the matrix is a unitary matrix or not.

The unitary matrix U is one of the kind of regular matrix, and it has following characteristics.

  adjoint( U ) * U == U * adjoint( U ) == E

  -> adjoint( U ) == inverse( U ) 

Then
 
  U * adjoint( U ) == adjoint( U ) * U
                   == U * inverse( U ) 
                   == inverse( U ) * U
                   == E

If the all of the elemnets are real numbers, the unitary matrix is also the orthogonal matrix.

=cut

sub is_unitary_matrix {
	#-----------------------------------------------------------------------
	#
	# ユニタリー行列 ( unitary matrix ) かどうかを返す。
	#
	#   ユニタリー行列は、実行列における直交行列 ( orthogonal matrix ) を複素行列に拡張したもの。
	#
	#   ユニタリー行列とは、
	#
	#     adjont( U ) == inverse( U )
	#
	#   となる行列のこと。
	#
	#   行列 U がユニタリーであれば、
	#
	#     U * adjoint( U ) == adjoint( U ) * U
	#                      == U * inverse( U )
	#                      == inverse( U ) * U
	#                      == E
	#
	#   となる。
	#
	#   ユニタリー行列は、実行列における直交行列 ( orthogonal matrix ) に相当する。
	#   直交行列は慣例として R で表現される。
	#
	#     transpose( R ) == inverse( R )
	#     transpose( R ) * R == R * inverse( R ) == E
	#
	#   ユニタリー行列の固有値の絶対値は 1 になり、全ての固有値は複素平面の単位円上に現れる。
	#   特異値は 1 、行列式の絶対値も 1 になる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	return 0				unless ( $m->is_square_matrix() ) ;
	return $m->is_orthogonal_matrix()	unless ( $m->is_complex_matrix() ) ;

	my $n = $m * $m->adjoint() ;

	return $n->round( 5 )->is_unit_matrix() ;
}

=head2 is_toeplitz_matrix

If a matrix A is a regular matrix, and it is like a

  A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[1] , a[2] , a[3] ] 
       [ a21 , a22 , a23 , a24 ]    [ a[4] , a[0] , a[1] , a[2] ] 
       [ a31 , a32 , a33 , a34 ]    [ a[5] , a[4] , a[0] , a[1] ] 
       [ a41 , a42 , a43 , a44 ]    [ a[6] , a[5] , a[4] , a[0] ] 

then return 1 else return 0.

The elements of the toepritz matrix have a following relationship.

  A[ r , c ] == A[ r + 1 , c + 1 ]           ( r == 1 -> n - 1 ) 

=cut

sub is_toeplitz_matrix {
	#-----------------------------------------------------------------------
	#
	# テプリッツ行列 ( Toeplitz matrix ) かどうか
	#
	#   対角一定行列 ( Diagonal-Constant matrix ) とも言う。 ( Toeplitz は数学者の名前 )
	#
	#   テプリッツ行列は以下のような構造を持つ正方行列を指す。
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[1] , a[2] , a[3] ] 
	#          [ a21 , a22 , a23 , a24 ]    [ a[4] , a[0] , a[1] , a[2] ] 
	#          [ a31 , a32 , a33 , a34 ]    [ a[5] , a[4] , a[0] , a[1] ] 
	#          [ a41 , a42 , a43 , a44 ]    [ a[6] , a[5] , a[4] , a[0] ] 
	#    
	#     n x n 行列 A の成分を A[ r , c ] で表すと、
	#
	#       A[ r , c ] == A[ r + 1 , c + 1 ]        ( r == 1 -> n - 1 )
	#
	#     と言う関係になる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rmax = $m->rows() - 2 ;
	foreach my $r ( 0 .. $rmax ) {
		return 0	unless ( $m->[ $r ]->[ $r ] == $m->[ $r + 1 ]->[ $r + 1 ] ) ;
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $r + 1 ]->[ $c + 1 ] ) ;
			return 0	unless ( $m->[ $c ]->[ $r ] == $m->[ $c + 1 ]->[ $r + 1 ] ) ;
		}
	}

	return 1 ;
}

=head2 is_circulant_matrix

If a matrix A is a regulant matrix, and it is like a

  A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[3] , a[2] , a[1] ] 
       [ a21 , a22 , a23 , a24 ]    [ a[1] , a[0] , a[3] , a[2] ] 
       [ a31 , a32 , a33 , a34 ]    [ a[2] , a[1] , a[0] , a[3] ] 
       [ a41 , a42 , a43 , a44 ]    [ a[3] , a[2] , a[1] , a[0] ] 

then return 1 else return 0.

The circular matrix is one of a kind of the toeplitz matrix.

The elements of the n x n circular matrix have a following relationship.

  A[ r , c ] == A[ r + 1 , ( c + 1 ) % n ]          ( r == 0 -> n - 2 ) 

=cut

sub is_circulant_matrix {
	#-----------------------------------------------------------------------
	#
	# 巡回行列かどうか
	#
	#   巡回行列は以下のような構造を持つ正方行列を指す。
	#
	#     A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[3] , a[2] , a[1] ] 
	#          [ a21 , a22 , a23 , a24 ]    [ a[1] , a[0] , a[3] , a[2] ] 
	#          [ a31 , a32 , a33 , a34 ]    [ a[2] , a[1] , a[0] , a[3] ] 
	#          [ a41 , a42 , a43 , a44 ]    [ a[3] , a[2] , a[1] , a[0] ] 
	#    
	#     n x n 行列 A の成分を A[ r , c ] で表すと、
	#
	#       A[ r , c ] == A[ r + 1 , ( c + 1 ) % n ]        ( r == 0 -> n - 2 )
	#
	#     と言う関係になる。
	#
	#   巡回行列はテプリッツ行列の一種。
	#
	#   巡回行列 A の成分が a[0] .. a[n-1] で構成されている場合、
	#
	#                       2PI
	#     w[j] == exp( i * ----- * j )         ( j == 0 -> n - 1 )
	#                        n
	#
	#   を用いて、固有ベクトル v[j] は、
	#
	#                  1
	#     v[j] == ----------- * transpose( [ 1 , w[j] , w[j]^2 , ...... , w[j]^(n-1) ] )        ( j == 0 -> n - 1 )
	#               sqrt(n)
	#
	#   固有値 λ[j] は、
	#
	#     λ[j] == a[0] + a[n-1] * w[j] + a[n-2] * w[j]^2 + , .... , + a[1] * w[j]^(n-1)        ( j == 0 -> n - 1 )
	#
	#   となるとのこと。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rows = $m->rows() ;
	foreach my $r ( 0 .. ( $rows - 2 ) ) {
		return 0	unless ( $m->[ $r ]->[ $r ] == $m->[ $r + 1 ]->[ $r + 1 ] ) ;
		foreach my $c ( ( $r + 1 ) .. ( $rows - 1 ) ) {
			my $c1 = ( $c + 1 ) % $rows ;
			return 0	unless ( $m->[ $r ]->[ $c ] == $m->[ $r + 1 ]->[ $c1 ] ) ;

			next	if ( $c > ( $rows - 2 ) ) ;

			my $r1 = ( $r + 1 ) % $rows ;
			return 0	unless ( $m->[ $c ]->[ $r ] == $m->[ $c + 1 ]->[ $r1 ] ) ;
		}
	}

	return 1 ;
}

=head2 is_hadamard_matrix

Return the matrix is a Hadamard matrix or not.

=cut

sub is_hadamard_matrix {
	#-----------------------------------------------------------------------
	#
	# アダマール行列かどうか
	#
	#   n 次のアダマール行列 H は、 n x n の正方行列であり、
	#
	#     transpose( H ) * H == n * E
	#
	#   と言う特徴を持つ。
	#
	#   なお、 n は 1 , 2 , 4 の倍数の何れかでなければならず、 H の各成分は 1 又は -1 の何れかとなる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return 0	unless ( $m->is_square_matrix() ) ;

	my $rows = $m->rows() ;

	if ( $rows > 2 ) {
		return 0	unless ( ( $rows % 4 ) == 0 ) ;
	}

	my $n = $m->transpose() * $m ;
	$n = $n->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		return 0	unless ( $m->[ $r ]->[ $r ]->abs() == 1 ) ;
		return 0	unless ( $n->[ $r ]->[ $r ] == $rows ) ;
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			return 0	unless ( $m->[ $r ]->[ $c ]->abs() == 1 ) ;
			return 0	unless ( $m->[ $c ]->[ $r ]->abs() == 1 ) ;

			return 0	unless ( $n->[ $r ]->[ $c ] == 0 ) ;
			return 0	unless ( $n->[ $c ]->[ $r ] == 0 ) ;
		}
	}

	return 1 ;
}

sub can_scalar {
	#-----------------------------------------------------------------------
	#
	# スカラーに変換できるかどうか
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $r , $c ) = $self->size() ;

	return ( $r == 1 and $c == 1 ) ? 1 : 0
}

sub can_decimal	{
	#-----------------------------------------------------------------------
	#
	# 実数に変換できるかどうか
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	return 0	unless ( $self->can_scalar() ) ;
	return 1	if ( $self->[0]->[0]->can_decimal() ) ;
	return 0 ;
}

sub can_complex	{
	#-----------------------------------------------------------------------
	#
	# 複素数に変換可能かどうか
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $r , $c ) = $self->size() ;

	return 1	if ( $self->can_scalar() ) ;			# スカラーは複素数で表現できる。
	return 1	if ( $self->is_cvector() and $r == 2 ) ;	# 2 次の列ベクトル
	return 1	if ( $self->is_rvector() and $c == 2 ) ;	# 2 次の行ベクトル
	return 0	unless ( $r == $c ) ;				# 正方行列でなければ false
	return 0	unless ( $r == 2 ) ;				# 2 次の正方行列でなければ false

	#
	# 複素数の行列形式かどうか
	#
	#   z == x + iy
	#     == [ x , -y ]
	#        [ y ,  x ]
	#
	my( $x1 , $y1 ) = @{ $self->[0] } ;
	my( $y2 , $x2 ) = @{ $self->[1] } ;
	return 1	if ( $x1 == $x2 and $y1 == ( -1 ) * $y2 ) ;
	return 0 ;
}

sub definitness {
	#-----------------------------------------------------------------------
	#
	# 定値性 ( Definitness )
	#
	#   エルミート行列の定値性を返す。
	#
	#   戻り値 : 
	#
	#      2 : 正定値
	#      1 : 半正定値
	#      0 : 不定値
	#     -1 : 半負定値
	#     -2 : 負定値
	#
	#   行列がエルミート行列でなければ undef を返す。
	#   固有値の導出に失敗した場合も undef を返す。
	#
	#   固有値問題を解く必要があるため、負荷はそれなりに高い。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_hermitian_matrix() ) ;

	my $r = undef ;

	#
	# 固有値を取得。
	#
	my $e = ( $m->is_triangular_matrix() )
		? $m->diag2vector()
		: ( $m->eigens() )[0]
	;

	#
	# 定値性を判別
	#
	if ( defined $e ) {

		$e = $e->vec2array() ;

		my $s = { '0' => 0 , '1' => 0 , '-1' => 0 } ;

		foreach my $i ( 0 .. $#{ $e } ) {

			unless ( $e->[ $i ]->can_decimal() ) { $r = 0 ; last ; }

			if	( $e->[ $i ] == 0 )	{ $s->{'0'}++ ; }
			elsif	( $e->[ $i ] >  0 )	{ $s->{'1'}++ ; }
			elsif	( $e->[ $i ] <  0 )	{ $s->{'-1'}++ ; }

			if ( $s->{'1'} > 0 and $s->{'-1'} > 0 ) { $r = 0 ; last ; }
		}

		unless ( defined $r ) {
			if ( $s->{'1'} == 0 and $s->{'-1'} == 0 ) {
				$r = 0 ;
			}
			elsif ( $s->{'1'} > 0 ) {
				if ( $s->{'0'} > 0 )	{ $r = 1 ; }
				else			{ $r = 2 ; }
			}
			elsif ( $s->{'-1'} > 0 ) {
				if ( $s->{'0'} > 0 )	{ $r = -1 ; }
				else			{ $r = -2 ; }
			}
		}
	}

	return $r ;
}

#-------------------------------------------------------------------------------
#
# 比較
#
#-------------------------------------------------------------------------------

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == )
	#
	#   ベクトルや行列の比較。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;

	$u = new_decimal( $u )	unless ( ref( $u ) ) ;
	$u = $u->decimal()	if ( $u->can_decimal() ) ;

	#my $dig = 5 ;	# 数値を丸める単位 ( 小数点以下の桁数 )
	my $dig = $DECIMAL_PART_LENGTH_LIMIT ;	# 数値を丸める単位 ( 小数点以下の桁数 )

	if ( $u->is_decimal() ) {
		if ( $v->can_decimal() ) {
			#
			# 数値同士の比較
			#
			return ( $v->decimal() == $u ) ? 1 : 0 ;
		}
		else {
			#
			# 行列と数値の比較
			#
			my $det = $v->det() ;
			if ( defined $det ) {
				return 1	if ( $det->round( $dig ) == $u->round( $dig ) ) ;
				return 0 ;
			}
			else {
				return 0 ;
			}
		}
	}
	else {
		#
		# 行列としての比較
		#
		my( $rows , $cols ) = $v->size() ;
		return 0	unless ( $rows == $u->rows() ) ;
		return 0	unless ( $cols == $u->cols() ) ;

		foreach my $r ( 0 .. ( $rows - 1 ) ) {
			#
			# 対角成分
			#
			if ( defined $v->[ $r ]->[ $r ] ) {
				return 0	unless ( $v->[ $r ]->[ $r ]->round( $dig ) == $u->[ $r ]->[ $r ]->round( $dig ) ) ;
			}

			#
			# 下三角成分及びこれと対称な成分
			#
			foreach my $c ( 0 .. ( $r - 1 ) ) {
				last	if ( $c >= $cols ) ;
				return 0	unless ( $v->[ $r ]->[ $c ]->round( $dig ) == $u->[ $r ]->[ $c ]->round( $dig ) ) ;

				if ( defined $v->[ $c ]->[ $r ] ) {
					return 0	unless ( $v->[ $c ]->[ $r ]->round( $dig ) == $u->[ $c ]->[ $r ]->round( $dig ) ) ;
				}
			}

			#
			# 対称な成分を持たない上三角成分
			#
			foreach my $c ( $rows .. ( $cols - 1 ) ) {
				return 0	unless ( $v->[ $r ]->[ $c ]->round( $dig ) == $u->[ $r ]->[ $c ]->round( $dig ) ) ;
			}
		}
		return 1 ;
	}

	return undef ;
}

sub not_equal { return ( equal( @_ ) ) ? 0 : 1 ; }

=head1 'Vector' object - calculations.

=cut

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------

=head2 add

The add operation of vector or matrix, 2 objects must have a same size, otherwise this method return undef.

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->add( $m ) ;                                # [              2.00000 ,              4.00000 ,              6.00000 ]
                                                       # [              8.00000 ,             10.00000 ,             12.00000 ]
                                                       # [             14.00000 ,             16.00000 ,             18.00000 ]
						       #
  print $m + $m ;                                      # [              2.00000 ,              4.00000 ,              6.00000 ]
                                                       # [              8.00000 ,             10.00000 ,             12.00000 ]
                                                       # [             14.00000 ,             16.00000 ,             18.00000 ]

=cut

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	#   2 つのベクトル若しくは行列のサイズが異なる場合には undef を返す。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->rows() == $u->rows() ) ;
	return undef	unless ( $v->cols() == $u->cols() ) ;

	my $obj = $v->copy() ;
	my( $rows , $cols ) = $obj->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		#
		# 対角成分
		#
		if ( defined $obj->[ $r ]->[ $r ] ) {
			$obj->[ $r ]->[ $r ] += $u->[ $r ]->[ $r ] ;
		}

		#
		# 下三角成分およびこれと対称な成分
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			last	if ( $c >= $cols ) ;
			$obj->[ $r ]->[ $c ] += $u->[ $r ]->[ $c ] ;
			
			if ( defined $obj->[ $c ]->[ $r ] ) {
				$obj->[ $c ]->[ $r ] += $u->[ $c ]->[ $r ] ;
			}
		}

		#
		# 対称な成分を持たない上三角成分
		#
		foreach my $c ( $rows .. ( $cols - 1 ) ) {
			$obj->[ $r ]->[ $c ] += $u->[ $r ]->[ $c ] ;
		}
	}

	return $obj ;
}

=head2 subtract

The subtract operation of vector or matrix, 2 objects must have a same size, otherwise this method return undef.

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->subtract( $m->unit_matrix() ) ;            # [              0.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              4.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              8.00000 ]

  print $m - $m->unit_matrix() ;                       # [              0.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              4.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              8.00000 ]
=cut

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算
	#
	#-----------------------------------------------------------------------
	my( $v , $u , $swapped ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	if ( $swapped ) {
		( $v , $u ) = ( $u , $v ) ;
	}
	
	$u *= ( -1 ) ;

	return defined( $u ) ? $v->add( $u ) : undef ;
}

=head2 multiply

  $v = vector( 1 .. 3 ) ;
  $u = vector( 4 .. 6 )->transpose() ;

  print $v ;                                           # [              1.00000 ]
                                                       # [              2.00000 ]
                                                       # [              3.00000 ]

  print $u ;                                           # [              4.00000 ,              5.00000 ,              6.00000 ]

  print $v * 2 ;                                       # [              2.00000 ]
                                                       # [              4.00000 ]
                                                       # [              6.00000 ]

  print $v * complex( [ 0 , 1 ] ) ;                    # [        0.00 + 1.00 i ]
                                                       # [        0.00 + 2.00 i ]
                                                       # [        0.00 + 3.00 i ]

  print $v->multiply( $u ) ;                           # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              8.00000 ,             10.00000 ,             12.00000 ]
                                                       # [             12.00000 ,             15.00000 ,             18.00000 ]

  print $v * $u ;                                      # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              8.00000 ,             10.00000 ,             12.00000 ]
                                                       # [             12.00000 ,             15.00000 ,             18.00000 ]

  print $u * $v ;                                      # 32   ( == 4 * 1 + 5 * 2 + 6 * 3 )

=cut

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算
	#
	#   行列の乗算であり、被乗数の列数と乗数の行数が一致している必要がある。
	#
	#-----------------------------------------------------------------------
	my( $self , $m ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $dlen = $DECIMAL_PART_LENGTH_LIMIT * 0.8 ;

	$m = new_decimal( $m )	unless ( ref( $m ) ) ;
	return undef	unless ( defined $m ) ;

	my $obj = undef ;

	if ( $m->is_decimal() or $m->can_decimal() ) {
		#
		# スカラー倍
		#
		$obj = $self->copy() ;

		foreach my $r ( @{ $obj } ) {
			foreach ( @{ $r } ) { $_ = $_->multiply( $m )->round( $dlen ) ; }
		}
	}
	elsif ( $m->is_complex() ) {
		#
		# 複素数倍
		#
		$obj = $self->copy() ;

		foreach my $r ( @{ $obj } ) {
			foreach ( @{ $r } ) { $_ = $m->multiply( $_ )->round( $dlen ) ; }
		}
	}
	else {
		#
		# 行列の積
		#
		#   C == A * B
		#     == C[ r , c ] = Σ( A[ r , k ] * B[ k , c ] )      ( k == 0 -> c )
		#
		return undef	unless ( $self->cols() == $m->rows() ) ;

		my $mat = [] ;
		foreach my $i ( 0 .. ( $self->rows() - 1 ) ) {
			my $row = $self->[ $i ] ;
			foreach my $j ( 0 .. ( $m->cols() - 1 ) ) {
				my $v = new_decimal( 0 ) ;
				foreach my $k ( 0 .. $#{ $row } ) {
					$v += $row->[ $k ] * $m->[ $k ]->[ $j ] ;
				}
				$mat->[ $i ]->[ $j ] = $v->round( $dlen ) ;
			}
		}

		my( $class ) = ref( $self ) || $self ;
		$obj = bless [ @{ $mat } ] , $class ;
	}

	return ( $obj->can_scalar() ) ? $obj->scalar() : $obj ;
}

=head2 power

The power operation can define against only matrix.

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->power( 2 ) ;                               # [             30.00000 ,             36.00000 ,             42.00000 ]
                                                       # [             66.00000 ,             81.00000 ,             96.00000 ]
                                                       # [            102.00000 ,            126.00000 ,            150.00000 ]

  print $m ** 2 ;                                      # [             30.00000 ,             36.00000 ,             42.00000 ]
                                                       # [             66.00000 ,             81.00000 ,             96.00000 ]
                                                       # [            102.00000 ,            126.00000 ,            150.00000 ]

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 2 , 5 , 4 ] ,
    [ 3 , 4 , 6 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              2.00000 ,              5.00000 ,              4.00000 ]
                                                       # [              3.00000 ,              4.00000 ,              6.00000 ]

  print $m ** (-1) ;                                   # [             -2.00000 ,              0.00000 ,              1.00000 ]
                                                       # [              0.00000 ,              0.42857 ,             -0.28571 ]
                                                       # [              1.00000 ,             -0.28571 ,             -0.14286 ]

  print $m->inverse() ;                                # [             -2.00000 ,              0.00000 ,              1.00000 ]
                                                       # [              0.00000 ,              0.42857 ,             -0.28571 ]
                                                       # [              1.00000 ,             -0.28571 ,             -0.14286 ]

  print $m * ( $m ** (-1) ) ;                          # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              1.00000 ]
 
  print $m ** 0 ;                                      # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              1.00000 ]

The inverse matrix can not be always defined.

=cut

sub power {
	#-----------------------------------------------------------------------
	#
	# 冪乗
	#
	#-----------------------------------------------------------------------
	my( $v , $p ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;

	$p = new_decimal( $p )	unless ( ref( $p ) ) ;
	return undef		unless ( $p->is_decimal() ) ;

	unless ( $p->is_integer() ) {
		$p = $p->fraction() ;
		my $r = $v->power( $p->numer() ) ;
		$r = $r->root( $p->denom() )	if ( defined $r ) ;
		return $r ;
	}

	my $r = undef ;

	if ( $p == -1 ) {
		#
		# 逆行列を採る。
		#
		$r = $v->inverse() ;
	}
	elsif ( $p < 0 ) {
		#
		# 冪乗を採って逆行列を採る。
		#
		$r = $v->power( $p * ( -1 ) )->inverse() ;
	}
	elsif ( $p->is_zero() ) {
		#
		# 逆行列が存在する場合にはこれを掛ける。 ( 結果は単位行列になるはず。 )
		#
		#   A^0 == A^( 1 - 1 ) == A * A^( -1 ) == E ( 単位行列 )
		#
		# 単位行列は 'E' または 'I' で表現される。
		#
		if ( my $inv = $v->inverse() ) {
			$r = $v * $inv ;
		}
	}
	elsif ( $v->is_diagonal_matrix() ) {
		#
		# 対角行列の冪乗は、対角成分の冪を採るだけ。
		#
		$r = $v->copy() ;
		my $rows = $r->rows() ;
		foreach my $i ( 0 .. ( $rows - 1 ) ) {
			$v->[ $i ]->[ $i ] = $v->[ $i ]->[ $i ]->power( $p ) ;
		}
	}
	else {
		#
		# 乗数の数だけ自身と掛け合わせる。
		#
		$r = $v->copy() ;
		foreach ( 1 .. ( $p - 1 ) ) {
			$r *= $v ;
		}
	}

	return $r ;
}

sub power_e {
	#-----------------------------------------------------------------------
	#
	# 固有値と固有ベクトルを用いた行列の冪乗
	#
	#-----------------------------------------------------------------------
	my( $m , $p ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	my $r = undef ;

	if ( $m->is_diagonal_matrix() ) {
		#
		# 対角行列の場合
		#
		$r = $m->copy() ;
		my $rows = $r->rows() ;
		foreach my $i ( 0 .. ( $rows - 1 ) ) {
			$r->[ $i ]->[ $i ] = $r->[ $i ]->[ $i ] ** $p ;
		}
	}
	else {
		#
		# 固有値と固有ベクトルを取得
		#
		my( $e , $ev ) = $m->eigens() ;

		return undef	unless ( defined $e ) ;

		#
		# 固有値を対角に持つ対角行列を生成し、冪を採る。
		#
		$e = $e->vec2diag() ** $p ;

		my $rows = $e->rows() ;
		foreach my $i ( 0 .. ( $rows - 1 ) ) {
			$e->[ $i ]->[ $i ] = $e->[ $i ]->[ $i ] ** $p ;
		}

		#
		# B == Q * D^p * inverse( Q )
		#
		# Q は、固有ベクトルを列ベクトルとして持つ行列であり、ユニタリー行列となる。
		# よって、
		#
		#   B == Q * D^p * inverse( Q )
		#     == Q * D^p * adjoint( Q )
		#
		$r = $ev * $e * $ev->adjoint() ;
	}

	return $r ;
}

=head2 divide

About matrix A , B , C is defined as follows.
 
  A == B * C

If C has inverse matrix,

  A / C == B * C * inverse( C )

If B has inverse matrix,

  A / B == inverse( B ) * C

In this method, the division operations is defined using with matrix A and vector x,

  A * x / A == ( A ** -1 ) * A * x
            == x
            == ( A ** -1 ) * b           ( b is also vector )

then return x.

=cut

sub divide {
	#-----------------------------------------------------------------------
	#
	#  除算
	#
	#    除数がスカラーの場合は、行列の各成分を除算する。
	#
	#    行列同士の演算には除算は存在しないが、通常の数値演算において、
	#
	#      x == a * b
	#      x / b == a * b * 1/b == a
	#
	#    であることから、 x / b は b を 1 にするような数 ( 1 /b == b の逆数 ) を掛けることと定義できる。
	#
	#    行列 A == B * C を考えた場合、
	#
	#      A / C == B * C * inverse( C )        # C を単位行列化
	#      A / B == inverse( B ) * B * C        # B を単位行列化
	#
	#    と定義できる。
	#    行列同士の積は可換ではない ( A * B != B * A ) ので、逆数 ( 逆行列 ) を掛ける向きに注意する必要がある。
	#
	#    ここでは、除算を任意の行列 A と ベクトル x の積で現される A * x == b から x を求めることとみなし、
	#
	#      A * x / A == ( A ** -1 ) * A * x
	#                == x
	#                == ( A ** -1 ) * b
	#
	#    となる演算を行う。
	#    これは、連立方程式の解としてのベクトル x を求めることに等しい。
	#
	#    除数となる行列に逆行列が存在しなければ undef を返す。
	#    行列が逆行列を持つためには、少なくともこれが正方行列である必要がある。
	#
	#-----------------------------------------------------------------------
	my( $v , $m , $swapped ) = @_ ;

	if ( $swapped ) {
		( $v , $m ) = ( $v , $m ) ;
	}
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;

	$m = new_decimal( $m )	unless ( ref( $m ) ) ;

	unless ( $m->is_decimal() ) {
		$m = $m->decimal()	if ( $m->can_decimal() ) ;
	}

	my $obj = undef ;

	if ( $m->is_decimal() or $m->is_complex() ) {
		#
		# スカラーでの除算
		#
		$obj = $v->copy() ;
		foreach my $r ( @{ $obj } ) {
			foreach ( @{ $r } ) {
				$_ /= $m ;
				$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
			}
		}
	}
	elsif ( my $inv = $m->inverse() ) {
		#
		# 行列同士の除算 ( 除数の逆数を左から掛ける。 )
		#
		$obj = $inv * $v ;
	}

	return $obj ;
}

=head2 root

The root operation can only be defined, when the matrix A is a positive-semidefinite matrix.

The positive-semidefinite matrix is one of a kind of regular matrix, and it's all eigen values are greater equal 0.

If the matrix A is a diagonal matrix, it's eigen values are same to it's diagoanl elements, otherwise it needs to resolve eigenvalues problem.

In general, the root operation will be able to be a high cost operation.


  $m = vector( 1 .. 3 )->diagonal_matrix() ;

  print $m ;                                           # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              2.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              3.00000 ]

  print $m->root( 2 ) ;                                # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              1.41421 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              1.73205 ]

=cut

sub root {
	#-----------------------------------------------------------------------
	#
	# 行列の冪根
	#
	#   半正定値行列 ( 固有値が全て 0 以上 ) のみをサポートする。
	#
	#-----------------------------------------------------------------------
	my( $m , $p ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;
	return undef	if ( $m->is_complex_matrix() ) ;

	my $r = undef ;

	if ( $m->is_diagonal_matrix() ) {
		#
		# 対角行列の場合
		#
		if ( $m->definitness() >= 1 ) {
			$r = $m->copy() ;
			my $rows = $r->rows() ;
			foreach my $i ( 0 .. ( $rows - 1 ) ) {
				my $v = $r->[ $i ]->[ $i ] ;
				$v = $v->decimal()	unless ( $v->is_decimal() ) ;
				$r->[ $i ]->[ $i ] = $v->root( $p ) ;
			}
		}
	}
	else {
		#
		# 固有値と固有ベクトルを採る。
		#
		my( $e , $ev ) = $m->eigens() ;
		return undef	unless ( defined $e ) ;

		#
		# 固有値を対角成分に持つを対角行列を生成し、対角成分の冪根を採る。
		#
		$e = $e->vec2diag() ;
		if ( $e->definitness() >= 1 ) {
			my $rows = $e->rows() ;
			foreach my $i ( 0 .. ( $rows - 1 ) ) {
				my $v = $e->[ $i ]->[ $i ] ;
				$v = $v->decimal()	unless ( $v->is_decimal() ) ;
				$e->[ $i ]->[ $i ] = $v->root( $p ) ;
			}

			#
			# B == Q * D^p * inverse( Q )
			#   == Q * D^p * adjoint( Q )
			#
			$r = $ev * $e * $ev->adjoint() ;
		}
	}

	return $r ;
}

=head2 inner_product

Return the inner product within two vectors or matrix.

Alias : ip


The inner product with matrix m and n is defined as follows.

  IP( m , n ) == adjoint( m ) * n


=cut

sub inner_product {
	#-----------------------------------------------------------------------
	#
	# 内積 ( inner product )
	#
	#   実ベクトルの内積
	#
	#     2 つの列ベクトル v , u の内積は、
	#
	#       IP( v , u ) == transpose( v ) * u
	#
	#     で表され、ベクトル同士の内積はスカラー値になる。
	#     このことから、内積はスカラー積とも呼ばれる。
	#
	#     内積は、三角関数を用いて
	#
	#       IP( v , u ) == norm( v ) * norm( u ) * cos( theta ) 
	#
	#     で表すこともできる。
	#
	#     theta は v と u の間に形成される角度であり、
	#     norm( u ) * cos( theta ) は、 u から v へ垂線を引いた時の交点までの v の長さ ( 正射影 ) となり、
	#     norm( v ) * cos( theta ) は、 v から u へ垂線を引いた時の交点までの u の長さ ( 正射影 ) となる。
	#
	#     また、単一のベクトル自身の内積を採る場合、
	#
	#       cos( theta ) == cos( 0 )
	#                    == 1
	#
	#     となることから、
	#
	#       IP( v , v ) == transpose( v ) * v
	#                   == norm( v ) * norm( v ) * cos( 0 )
	#                   == ( norm( v ) )^2
	#     となる。
	#
	#     実ベクトルや実行列の内積には、以下のような関係がある。
	#
	#       IP( v , u ) == transpose( v ) * u == transpose( u ) * v
	#       IP( m , n ) == transpose( m ) * n == transpose( n ) * m
	#
	#
	#   複素ベクトルの内積
	#
	#     複素ベクトルの内積は、
	#
	#       IP( v , u ) == adjoint( v ) * u
	#
	#     と定義される。
	#
	#     これにより、単一のベクトル v 自身の内積とノルムは、
	#
	#       v == [ z1 ] == [ a + bi ]
	#            [ z2 ]    [ c + di ]
	#
	#       IP( v , v ) == adjoint( v ) * v
	#                   == [ a - bi , c - di ] * [ a + bi ]
	#                                            [ c + di ]
	#
	#                   == ( a + bi )( a - bi ) + ( c + di )( c - di )
	#                   == a^2 + b^2 + c^2 + d^2
	#                   == abs( z1 )^2 + abs( z2 )^2
	#
	#       norm( v ) == abs( sqrt( IP( v , v ) ) )
	#                 == abs( sqrt( abs( z1 )^2 + abs( z2 )^2 ) )
	#
	#     となり、実ベクトルにおけるノルムと同様、複素ベクトルにおいてもノルムを実数として得ることができる。
	#
	#     複素ベクトル v の成分を指数表現で表すと、より直感的な表現が得られる。
	#     複素共役は複素平面において実軸に対して対称な値となることより、 v , conj( v ) , adjoint( v ) は、
	#
	#       v == [ z1 ]  == [ r1 * exp( i * t1 ) ]
	#            [ z2 ]     [ r2 * exp( i * t2 ) ]
	#
	#       conj( v )    == [ r1 * exp( -i * t1 ) ]
	#                       [ r2 * exp( -i * t2 ) ]
	#
	#       adjoint( v ) == [ r1 * exp( -i * t1 ) , r2 * exp( -i * t2 ) ]
	#
	#     内積とノルムは、
	#
	#       IP( v , v ) == [ r1 * exp( -i * t1 ) , r2 * exp( -i * t2 ) ] * [ r1 * exp( i * t1 ) ]
	#                                                                      [ r2 * exp( i * t2 ) ]
	#
	#                   ==   ( r1^2 * exp( i * t1 ) * exp( -i * t1 ) )
	#                      + ( r2^2 * exp( i * t2 ) * exp( -i * t2 ) )
	#
	#                   ==   r1^2 * exp( i * ( t1 - t1 ) )
	#                      + r2^2 * exp( i * ( t2 - t2 ) )
	#
	#                   == r1^2 + r2^2
	#                   == norm( z1 ) + norm( z2 )
	#                   == det( z1 ) + det( z2 )
	#                   == abs( z1 )^2 + abs( z2 )^2
	#
	#       norm( v ) == abs( sqrt( IP( v , v ) )
	#                 == abs( sqrt( r1^2 + r2^2 ) )
	#                 == abs( sqrt( norm( z1 ) + norm( z2 ) ) )
	#                 == abs( sqrt( det( z1 ) + det( z2 ) ) )
	#                 == abs( sqrt( abs( z1 )^2 + abs( z2 )^2 ) )
	#
	#     となる。
	#
	#     異なるベクトル v , u の内積は、
	#
	#       v == [ a1 + ib1 ] , u = [ x1 + iy1 ]
	#            [ a2 + ib2 ]       [ x2 + iy2 ]
	#
	#       IP( v , u ) == ( a1 - ib1 )( x1 + iy1 ) + ( a2 - ib2 )( x2 + iy2 )
	#                   == ( a1x1 + i * a1y1 - i * b1x1 + b1y1 ) + ( a2x2 + i * a2y2 - i * b2x2 + b2y2 )
	#                   == ( a1x1 + b1y1 + a2x2 + b2y2 ) + i ( a1y1 - b1x1 + a2y2 - b2x2 )
	#                   == x' + iy'
	#
	#     となり、複素スカラー値になる。
	#
	#
	#     複素ベクトルや複素行列における内積 ( 複素内積 ) には、
	#
	#       IP( v , u ) == adjoint( v ) * u == conj( transpose( v ) * conj( u ) ) == conj( adjoint( u ) * v )
	#       IP( m , n ) == adjoint( m ) * n == conj( transpose( m ) * conj( n ) ) == conj( adjoint( n ) * m )
	#   
	#     と言う関係があり、複素ベクトル同士又は複素行列同士の内積は
	#
	#       IP( v , u ) == conj( IP( u , v ) )
	#       IP( m , n ) == conj( IP( n , m ) )
	#
	#     と言う関係になる。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;

	$u = $v->copy()	unless ( defined $u ) ;

	my $r = $v->adjoint() * $u ;

	$r = $r->scalar()	if ( ref( $r ) eq __PACKAGE__ and $r->can_scalar() ) ;
	$r = $r->decimal()	if ( $r->can_decimal() ) ;

	return $r ;
}

sub ip	{ return inner_product( @_ ) ; }

=head2 outner_product

Return the outer product within two vectors or matrix.

Alias : op

The outer product with matrix m and n is defined as follows.

  OP( m , n ) == m * adjoint( n )


The outer product within two vectors is also called "dyadic product".

=cut

sub outer_product {
	#-----------------------------------------------------------------------
	#
	# 直積 ( outer product )
	#
	#   直積は 2 つのベクトルからテンソルを導く演算。
	#   スカラー積 ( 内積 )、ベクトル積 ( 外積 ) に対してテンソル積とも呼ばれる。
	#   テンソル積と言う用語にはもっと広い概念が含まれるため、直積や外部積と言う用語が用いられる。
	#   ベクトル同士のテンソル積は、広義では内積と直積を合わせた概念とされる。
	#
	#   テンソル ( Tensor ) は、線形的な量や幾何概念を一般化したもの。
	#   多次元配列として表現できる類のものを指す。 ( 基底を選ぶ必要はある。 )
	#
	#   スカラーは階数 0 のテンソルであり、ベクトルは階層 1 のテンソル、 3 x 3 の行列は階層 2 のテンソルとなる。
	#
	#   2 つの列ベクトル v , u に対する直積 OP は、以下のように表現される。
	#
	#     OP == v * adjoint( u )
	#
	#   u が実行列であれば、
	#
	#     OP == v * adjoint( u ) == v * tranpose( u )
	#
	#   となる。
	#
	#   ベクトルのサイズが等しければ、結果は n 次の正方行列となる。
	#   この正方行列は常に半正定値行列となる。 ( 固有値は全て 0 以上の正の実数。 )
	#
	#   2 つの列ベクトルの直積は二項積 ( dyadic product ; ダイアド ) と呼ばれることもある。
	#   ( 直積 == ダイアド ではない。 )
	#
	#
	#   2 つのベクトルの直積には、以下のような関係がある。
	#
	#     OP( v , u ) == adjoint( OP( u , v ) )
	#
	#
	#   外積 EP は直積 OP を使用して
	#
	#     EP( v , u ) == OP( v , u ) - OP( u , v )
	#
	#   で表すことができる。
	#
	#   直積は、クロネッカー積の特別な場合と表現されることもあり、クロネッカー積を KP() で表すと、
	#
	#     OP( v , u ) == KP( v , transpose( u ) ) 
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $v , $u ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	if ( defined $v and defined $u ) {
		return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
		return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	}
	elsif ( defined $v ) {
		return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
		$u = $v->copy() ;
		$v = $self->copy() ;
	}
	else {
		$u = $self->copy() ;
		$v = $self->copy() ;
	}

	my $r = $v * $u->adjoint() ;

	return $r ;
}

sub op	{ return outer_product( @_ ) ; }

=head2 cross_product

Return the cross product within two vectors.

Alias : xp


The cross product can only be defined, when the vector size is 1 , 3 or 7.

=cut

sub cross_product {
	#-----------------------------------------------------------------------
	#
	# クロス積 ( cross product )
	#
	#   クロス積はウェッジ積 ( 外積 ) の特殊ケース。
	#
	#   クロス積を定義できるのは 1 , 3 , 7 次元のベクトルのみとされている。
	#   結果はベクトルで返る。
	#
	#   2 つの 3 次元ベクトル v , u とクロス積 XP は以下のように表される。
	#
	#     norm( XP ) == norm( v ) * norm( u ) * sin( theta )
	#
	#   これは v と u が形成する平面に垂直に交わるベクトルとなる。
	#   その大きさは v と u によって形成される平行四辺形の面積に等しい。
	#   このことから、クロス積はベクトル積とも呼ばれる。
	#
	#
	#   クロス積の成分：
	#
	#     2 つの 3 次元ベクトル v , u について、各ベクトルの添え字を 1 , 2 , 3 で表現すると、
	#     外積の各成分は以下のようになる。
	#
	#       XP[1] = v[2] * u[3] - v[3] * u[2]
	#       XP[2] = v[3] * u[1] - v[1] * u[3]
	#       XP[3] = v[1] * u[2] - v[2] * u[1]
	#
	#
	#   行列式を用いた成分の演算：
	#
	#     クロス積の各成分は行列式を使用して表現することもできる。
	#     まず、
	#
	#       XP( v , u ) == [    i ,    j ,    k ]
	#                      [ v[1] , v[2] , v[3] ]
	#                      [ u[1] , u[2] , u[3] ]
	#
	#     とおく。
	#
	#     i , j , k は、それぞれ x 軸、y 軸、z 軸方向の単位ベクトル。
	#     ( なので、これは行列ではなくテンソルってことになるのかな？ )
	#
	#     これを余因子展開すると、
	#
	#       XP( v , u ) == [    i ,    j ,    k ]
	#                      [ v[1] , v[2] , v[3] ]
	#                      [ u[1] , u[2] , u[3] ]
	#
	#                   == det[ v[2] , v[3] ] * i - det[ v[1] , v[3] ] * j + det[ v[1] , v[2] ] * k
	#                         [ u[2] , u[3] ]          [ u[1] , u[3] ]          [ u[1] , u[2] ]
	#
	#                   == ( v[2] * u[3] - v[3] * u[2] ) * i - ( v[1] * u[3] - v[3] * u[1] ) * j + ( v[1] * u[2] - v[1] * v[2] ) * k
	#                   == ( v[2] * u[3] - v[3] * u[2] ) * i + ( v[3] * u[1] - v[1] * u[3] ) * j + ( v[1] * u[2] - v[1] * v[2] ) * k
	#
	#     この時の i , j , k の係数が XP( v , u ) の各成分に等しいことが判る。
	#
	#     i , j , k が単位ベクトルであることから、
	#
	#       XP( v , u ) ==   ( v[2] * u[3] - v[3] * u[2] ) * i
	#                      + ( v[3] * u[1] - v[1] * u[3] ) * j
	#                      + ( v[1] * u[2] - v[1] * v[2] ) * k
	#
	#                   ==   ( v[2] * u[3] - v[3] * u[2] ) * [ 1 ]
	#                                                        [ 0 ]
	#                                                        [ 0 ]
	#
	#                      + ( v[3] * u[1] - v[1] * u[3] ) * [ 0 ]
	#                                                        [ 1 ]
	#                                                        [ 0 ]
	#
	#                      + ( v[1] * u[2] - v[1] * v[2] ) * [ 0 ]
	#                                                        [ 0 ]
	#                                                        [ 1 ]
	#
	#                   == [ ( v[2] * u[3] - v[3] * u[2] ) ]
	#                      [ ( v[3] * u[1] - v[1] * u[3] ) ]
	#                      [ ( v[1] * u[2] - v[1] * v[2] ) ]
	#
	#     となる。
	#
	#-----------------------------------------------------------------------

	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	$v = $v->cvector() ;
	$u = $u->cvector() ;
	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;

	my $r = $v->zero_vector() ;

	my $vm = $v->vec2array() ;
	my $um = $u->vec2array() ;

	my @sz = ( $v->rows() , $u->rows() ) ;

	if ( $sz[0] == 1 and $sz[1] == 1 ) {
		#
		# 1 次元ベクトル同士のクロス積
		#
		$r->[0]->[0] = ( $vm->[0] * $um->[0] ) - ( $vm->[0] * $um->[0] ) ;	# == 0
	}
	elsif ( $sz[0] == 3 and $sz[1] == 3 ) {
		#
		# 3 次元ベクトル同士のクロス積
		#
		#   各ベクトルの添え字を x , y , z で表現すると、
		#
		#   XP[x] = v[y] * u[z] - v[z] * u[y]
		#   XP[y] = v[z] * u[x] - v[x] * u[z]
		#   XP[z] = v[x] * u[y] - v[y] * u[x]
		#
		# となる。
		#
		$r->[0]->[0] = ( $vm->[1] * $um->[2] ) - ( $vm->[2] * $um->[1] ) ;
		$r->[1]->[0] = ( $vm->[2] * $um->[0] ) - ( $vm->[0] * $um->[2] ) ;
		$r->[2]->[0] = ( $vm->[0] * $um->[1] ) - ( $vm->[1] * $um->[0] ) ;
	}
	elsif ( $sz[0] == 7 and $sz[1] == 7 ) {
		#
		# 7 次元ベクトル同士のクロス積
		#
		$r->[0]->[0] =   ( $vm->[1] * $um->[2] ) - ( $vm->[2] * $um->[1] )
		               - ( $vm->[3] * $um->[4] ) + ( $vm->[4] * $um->[3] )
                               - ( $vm->[5] * $um->[6] ) + ( $vm->[6] * $um->[5] )
		;
		$r->[1]->[0] = - ( $vm->[0] * $um->[2] ) + ( $vm->[2] * $um->[0] )
		               - ( $vm->[3] * $um->[5] ) + ( $vm->[4] * $um->[6] )
			       + ( $vm->[5] * $um->[3] ) - ( $vm->[6] * $um->[4] )
		;
		$r->[2]->[0] =   ( $vm->[0] * $um->[1] ) - ( $vm->[1] * $um->[0] )
	                       - ( $vm->[3] * $um->[6] ) - ( $vm->[4] * $um->[5] )
			       + ( $vm->[5] * $um->[4] ) + ( $vm->[6] * $um->[3] )
		;
		$r->[3]->[0] =   ( $vm->[0] * $um->[4] ) + ( $vm->[1] * $um->[5] )
		               + ( $vm->[2] * $um->[6] ) - ( $vm->[4] * $um->[1] )
			       - ( $vm->[5] * $um->[1] ) - ( $vm->[6] * $um->[2] )
		;
		$r->[4]->[0] = - ( $vm->[0] * $um->[3] ) - ( $vm->[1] * $um->[6] )
		               + ( $vm->[2] * $um->[4] ) + ( $vm->[3] * $um->[1] )
			       - ( $vm->[4] * $um->[2] ) + ( $vm->[6] * $um->[0] )
		;
		$r->[5]->[0] =   ( $vm->[0] * $um->[6] ) - ( $vm->[1] * $um->[3] )
		               - ( $vm->[2] * $um->[4] ) + ( $vm->[3] * $um->[1] )
			       + ( $vm->[4] * $um->[2] ) - ( $vm->[6] * $um->[0] )
		;
		$r->[6]->[0] = - ( $vm->[0] * $um->[5] ) + ( $vm->[1] * $um->[4] )
		               - ( $vm->[2] * $um->[3] ) + ( $vm->[3] * $um->[2] )
			       - ( $vm->[4] * $um->[1] ) + ( $vm->[5] * $um->[0] )
		;
	}
	else {
		$r = undef ;
	}

	return $r ;
}

sub xp	{ return cross_product( @_ ) ; }

=head2 wedge_product

Return the wedge product within two vectors.

Alias : wp


The wedge product with vector v and u is defined as follows.

  WP( v , u ) == OP( v , u ) - OP( u , v )

=cut

sub wedge_product {
	#-----------------------------------------------------------------------
	#
	# ウェッジ積 ( wedge product )
	#
	#   ウェッジ積はクロス積を一般化した概念であり、外積 ( exterior product ) とも呼ばれる。
	#   ( ウェッジ積とクロス積を合わせて外積と呼ぶこともある。 )
	#
	#   ウェッジ積と直積の関係：
	#
	#     ウェッジを直積 ( ここでは OP で表す ) との関係で表現すると、以下のようになるとのこと。
	#     ( これはテンソルの世界での話であり、ウェッジ積と呼ばれる。 )
	#
	#       WP == OP( v , u ) - OP( u , v ) == [  0 ,  z , -y ]
	#                                          [ -z ,  0 ,  x ]
	#                                          [  y , -x ,  0 ]
	#
	#     3 次元ベクトルの場合はホッジ ( Hodge ) の作用素によってベクトルに写像されるらしい。(??)
	#     ( '*' はホッジのスター作用素 )
	#
	#       *WP == *( OP( v , u ) - OP( u , v ) ) == [ x ]
	#                                                [ y ]
	#                                                [ z ]
	#
	#     ウェッジ積で表した WP を
	#
	#       *WP == *( [  0 ,  z , -y ] ) == X
	#                 [ -z ,  0 ,  x ]
	#                 [  y , -x ,  0 ]
	#
	#     とおくと、ベクトルへの写像は
	#
	#       *WP == [      X[2,3] ] == [ X[2,3] ]== [ x ]
	#              [ -1 * X[1,3] ]    [ X[3,1] ]   [ y ]
	#              [      X[1,2] ]    [ X[1,2] ]   [ z ]
	#
	#     となる。
	#     ( この辺りの関係を普遍性のあるロジックにできるといいのだが．．．．。 )
	#
	#     ウェッジ積は外積の概念をより広い次元に一般化したもの。
	#
	#     3 次元の外積はウェッジ積の特殊なケースであり、これをクロス積 ( cross product ) と呼ぶ。
	#     クロス積が定義できるのは 0 , 1 , 3 , 7 次元のみとされている。
	#     0 次元のクロス積は概念上のものであり、値を求めることはできないとのこと。
	#     1 次元のクロス積は常に零ベクトルになるらしい。
	#
	#
	#   蛇足：
	#
	#     v = [ p ] と u = [ x ] について、
	#         [ q ]        [ y ]
	#         [ r ]        [ z ]
	#
	#     WP( v , u ) == [  0 , -r ,  q ] * [ x ] == [ qz - ry ]
	#                    [  r ,  0 , -p ]   [ y ]    [ rx - pz ]
	#                    [ -q ,  p ,  0 ]   [ z ]    [ py - qx ]
	#
	#     が成り立つとのこと。
	#     v の成分で構成されている行列は軸性ベクトルや擬ベクトルと呼ばれるものであり、 2 階の反対称テンソルの形をとっている。
	#     この式は、 v から構築した軸性ベクトルと u の積が EP( v , u ) という外積と一致することを示している。
	#
	#     テンソルの世界で考えると、ベクトルは 1 階のテンソルであり、以下のような座標変換式で表される特徴を持つ。
	#
	#       A'[k] == a[kn] * A[n]
	#
	#     擬ベクトルが、「擬」ベクトルと呼ばれるのは、これが以下のような特徴を持つため。
	#
	#       A'[k] == ± a[kn] * A[n]
	#
	#
	#   ウェッジ積には以下のような性質がある。
	#
	#     WP( v , u ) = WP( -1 * u , v )
	#     WP( v , v ) = 0
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	$v = $v->cvector() ;
	$u = $u->cvector() ;
	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;

	my $r = $v->zero_vector() ;

	my $vm = $v->vec2array() ;
	my $um = $u->vec2array() ;

	#
	# 直積の差を返す。
	#
	$r = $v->outer_product( $u ) - $u->outer_product( $v ) ;

	return $r ;
}

sub wp	{ return wedge_product( @_ ) ; }

=head2 exterior_product

If the size of two vectors is 1 , 3 or 7 then return cross product.
Else return wedge product.

Alias : ep

=cut

sub exterior_product {
	#-----------------------------------------------------------------------
	#
	# 外積 ( exterior product )
	#
	#   ベクトルのサイズが 1 , 3 , 7 であればクロス積を、それ以外であればウェッジ積を返す。
	#
	#   内積が三角関数を用いて
	#
	#     IP( v , u ) == norm( v ) * norm( u ) * cos( theta ) 
	#
	#   と表されるのに対して、外積は
	#
	#     EP( v , u ) == norm( v ) * norm( u ) * sin( theta )
	#
	#   と表される。
	#
	#   3 次元のベクトル v , u  を
	#
	#     v == [ v[1] ] , u == [ u[1] ]
	#          [ v[2] ]        [ u[2] ]
	#          [ v[3] ]        [ u[3] ]
	#
	#   とおくと、外積 ( クロス積 ) は、
	#
	#     EP( v , u ) == XP( v , u )
	#
	#                 == [ v[2] * u[3] - v[3] * u[2] ]
	#                    [ v[3] * u[1] - v[1] * u[3] ]
	#                    [ v[1] * u[2] - v[2] * u[1] ]
	#
	#   となる。
	#
	#   この時、 v[3] == u[3] == 0 であれば、
	#
	#     EP( v , u ) == [                         0 ]
	#                    [                         0 ]
	#                    [ v[1] * u[2] - v[2] * u[1] ]
	#
	#   となる。
	#
	#   ここから、 2 次元ベクトルの外積を
	#
	#     v == [ a ] , u == [ c ]
	#          [ b ]        [ d ]
	#
	#     EP( v , u ) == [       0 ] == ( ad - bc ) * [ 0 ]
	#                    [       0 ]                  [ 0 ]
	#                    [ ad - bc ]                  [ 1 ]
	#
	#                 == ad - bc
	#
	#   とみなすことがある。
	#
	#   2 次元ベクトルの外積をウェッジ積で表すと、
	#
	#     v == [ a ] , u == [ c ]
	#          [ b ]        [ d ]
	#     
	#     WP( v , u ) == OP( v , u ) - OP( u , v )
	#
	#                 == ( v * adjoint( u ) ) - ( u * adjont( v ) )
	#
	#                 == ( [ a ] * [ c , d ] ) - ( [ c ] * [ a , b ] )
	#                      [ b ]                   [ d ]
	#
	#                 == [ ac , ad ] - [ ac , bc ]
	#                    [ bc , bd ]   [ ad , bd ]
	#
	#                 == [       0 , ad - bc ]
	#                    [ bc - ad ,       0 ]
	#
	#                 == (-1) * ( ad - bc ) * [  0 , -1 ]
	#                                         [  1 ,  0 ]
	#
	#                 == ( ad - bc ) * (-i)             ( i : 虚数単位 )
	#
	#   となる。
	#
	#   2 次元ベクトルにおける内積と外積は複素数の実部と虚部を写像したものとみなすこともできる。
	#   これにより、 2 つのベクトルがなす角度を
	#
	#     theta = atan2( EP( v, u ) , IP( v , u ) )
	#
	#   として求めることができる。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	$v = $v->cvector() ;
	$u = $u->cvector() ;
	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;

	return $v->cross_product( $u )	if ( $v->rows() =~ /^[137]$/ ) ;
	return $v->wedge_product( $u ) ;
}

sub ep			{ return exterior_product( @_ ) ; }

=head2 dyad

Return the dyadic product.

The dyadic product is the outer product within two vectors. ( not matrix )

  v = [ a1 ] , u = [ b1 ]
      [ a2 ]       [ b2 ]
      [ a3 ]       [ b3 ]

  dyad( v , u ) == v * adjoint( u )

                == [ a1 ] * [ b1 , b2 , b3 ]
		   [ a2 ]
		   [ a3 ]

		== [ a1b1 , a1b2 , a1b3 ]
		   [ a2b1 , a2b2 , a2b3 ]
		   [ a3b1 , a3b2 , a3b3 ]


  $v = vector( 1 , 2 , 3 ) ;
  $u = vector( 4 , 5 , 6 ) ;

  print $v ;                                           # [              1.00000 ]
						       # [              2.00000 ]
					               # [              3.00000 ]

  print $u->adjoint() ;                                # [              4.00000 ,              5.00000 ,              6.00000 ]

  print $v->dyad( $u ) ;                               # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              8.00000 ,             10.00000 ,             12.00000 ]
                                                       # [             12.00000 ,             15.00000 ,             18.00000 ]

=cut

sub dyad {
	#-----------------------------------------------------------------------
	#
	# ダイアド積 ( dyadic product )
	#
	#   ダイアドは 2 つの列ベクトルの直積
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	
	my $r = undef ;

	if ( $v->is_cvector() and $u->is_cvector() ) {
		$r = $v->outer_product( $u ) ;
	}

	return $r ;
}

=head2 scalar_triple_prodcut

Return the scalar triple product.

Alias : stp

  STP( x , y , z ) == IP( x , EP( y , z ) )

=cut

sub scalar_triple_product {
	#-----------------------------------------------------------------------
	#
	# スカラー三重積
	#
	#   ベクトルを x , y , z 、スカラー三重積を STP( x , y , z ) とおくと、
	#
	#     STP( x , y , z ) == IP( x , EP( y , z ) )
	#                      == IP( EP( x , y ) , z )
	#
	#     STP( x , y , z ) == STP( y , z , x ) == STP( z , x , y )
	#
	#   3 次元ベクトル空間では、結果は擬スカラーとなる。
	#   それ以外の場合、外積が 2 階反対称テンソル ( 軸性ベクトル ) で返るため、擬スカラーとはならない。
	#   擬スカラーは見た目はスカラーだが、座標変換の影響を受けて +- の向きを持つ。
	#
	#   行列式でも同じ結果が得られる。
	#
	#     STP( x , y , z ) == det(
	#                             [ x[1] , x[2] , .... , x[n] ] ,
	#                             [ y[1] , y[2] , .... , y[n] ] ,
	#                             [ z[1] , z[2] , .... , z[n] ] ,
	#                         )
	#
	#-----------------------------------------------------------------------
	my( $x , $y , $z ) = @_ ;

	foreach ( $x , $y , $z ) {
		return undef	unless ( ref( $_ ) eq __PACKAGE__ ) ;
		return undef	unless ( $_->is_cvector() ) ;
	}

	return $x->inner_product( $y->exterior_product( $z ) ) ;
}

sub stp			{ return scalar_triple_product( @_ ) ; }

=head2 vector_triple_product

Return the vector triple product.

Alias : vtp

  $v = vector( 1 , 2 , 3 ) ;
  $u = vector( 4 , 5 , 6 ) ;
  $w = vector( 7 , 8 , 9 ) ;

  print $v->vtp( $u , $w ) ;                           # [            -24.00000 ]     ( == EP( $v , EP( $u , $w ) ) )
						       # [             -6.00000 ]
						       # [             12.00000 ]

  print $v->vtp( $v , [ $u , $w ] ) ;                  # [            -24.00000 ]     ( == EP( $v , EP( $u , $w ) ) )
						       # [             -6.00000 ]
						       # [             12.00000 ]

  print $v->vtp( [ $v , $u ] , $w ) ;                  # [             78.00000 ]     ( == EP( EP( $v , $u ) , $w ) )
						       # [              6.00000 ]
						       # [            -66.00000 ]

=cut

sub vector_triple_product {
        #-----------------------------------------------------------------------
	#
	# ベクトル三重積
	#
	#   ベクトルを x , y , z 、ベクトル三重積を VTP( x , y , z ) とおくと、
	#
	#     VTP( x , y , z ) == EP( x , EP( y , z ) )
	#
	#   または
	#
	#     VTP( x , y , z ) == EP( EP( x , y ) , z )
	#
	#   3 次元ベクトル空間では、結果は擬ベクトルとなる。
	#   それ以外の場合は、演算不能。
	#   ( 純粋にテンソルの世界で演算ができれば軸ベクトルを返せるかもしれない。 )
	#
	#   ベクトル三重積は以下のような性質を持つ。
	#
	#     EP( x , EP( y , z ) ) == IP( x , z ) * y - IP( x , y ) * z
	#     EP( EP( x , y ) , z ) == IP( x , z ) * y - IP( y , z ) * x
	#     EP( x , EP( y , z ) ) + EP( y , EP( z , x ) ) + EP( z , EP( x , y ) ) == 0
	#
	#   結合則は成り立たない。
	#
	#     EP( x , EP( y , z ) ) != EP( EP( x , y ) , z )
	#
	#   よって、ここでは
	#
	#     VTP( x , y , z ) == VTP( x , [ y , z ] ) == EP( x , EP( y , z ) )
	#
	#   をデフォルトの動作とし、もう一方の動作を
	#
	#     VTP( [ x , y ] , z ) == EP( EP( x , y ) , z )
	#
	#   として扱う。
	#
        #-----------------------------------------------------------------------
	my( $x , $y , $z ) = @_ ;

	my $r = undef ;

	if ( ref( $x ) eq 'ARRAY' ) {
		#
		# 関数呼び出しで、且つ最初の引数が配列参照である場合。
		#
		$z = $y->copy() ;
		$y = $x->[1]->copy() ;
		$x = $x->[0]->copy() ;

		$r = $x->exterior_product( $y ) ;
		if ( defined $r ) {
			$r = $r->exterior_product( $z ) ;
		}
	}
	elsif ( ref( $y ) eq 'ARRAY' ) {
		#
		# メソッド呼び出しで、第 1 引数が配列参照である場合。
		#
		$x = $y->[0]->copy() ;
		$y = $y->[1]->copy() ;

		$r = $x->exterior_product( $y ) ;
		if ( defined $r ) {
			$r = $r->exterior_product( $z ) ;
		}
	}
	elsif ( ref( $z ) eq 'ARRAY' ) {
		#
		# メソッド呼び出しで、最後の引数が配列参照である場合。
		#
		$x = $y->copy() ;
		$y = $z->[0]->copy() ;
		$z = $z->[1]->copy() ;

		$r = $x->exterior_product( $y->exterior_product( $z ) ) ;
	}
	else {
		#
		# デフォルトの動作
		#
		$r = $x->exterior_product( $y->exterior_product( $z ) ) ;
	}

	return $r ;
}

=head2 kronecker_product

Alias : kp


  A == [ a11 , a12 ] , B == [ b11 , b12 ]
       [ a21 , a22 ]        [ b21 , b22 ]


  kronecker_product( A , B ) == [ a11 * B , a12 * B ]
                                [ a21 * B , a22 * B ]

                             == [ a11 * [ b11 , b12 ] , a12 * [ b11 , b12 ] ]
			        [       [ b21 , b22 ]         [ b21 , b22 ] ]
                                [ a21 * [ b11 , b12 ] , a22 * [ b11 , b12 ] ]
			        [       [ b21 , b22 ]         [ b21 , b22 ] ]

                             == [ a11 * b11 , a11 * b12 , a12 * b11 , a12 * b12 ]
	                        [ a11 * b21 , a11 * b22 , a12 * b21 , a12 * b22 ]
	                        [ a21 * b11 , a21 * b12 , a22 * b11 , a22 * b12 ]
	                        [ a21 * b21 , a21 * b22 , a22 * b21 , a22 * b22 ]

   $m = matrix(
     [ 1 , 2 ] ,
     [ 3 , 4 ] ,
   ) ;

   $n = matrix(
     [ 5 , 6 ] ,
     [ 7 , 8 ] ,
   ) ;

   print $m ;                                          # [              1.00000 ,              2.00000 ]
                                                       # [              3.00000 ,              4.00000 ]

   print $n ;                                          # [              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ]


   print $m->kp( $n ) ;                                # [              5.00000 ,              6.00000 ,             10.00000 ,             12.00000 ]
                                                       # [              7.00000 ,              8.00000 ,             14.00000 ,             16.00000 ]
                                                       # [             15.00000 ,             18.00000 ,             20.00000 ,             24.00000 ]
                                                       # [             21.00000 ,             24.00000 ,             28.00000 ,             32.00000 ]

=cut

sub kronecker_product {
	#-----------------------------------------------------------------------
	#
	# クロネッカー積 ( Kronecker product )
	#
	#   kronecker_product( A , B ) == [ a11 * B , ..... , a1n * B ]
	#                                 [ ......................... ]
	#                                 [ am1 * B , ..... , amn * B ]
	#
	#   任意のサイズの行列 A , B を
	#
	#     A == [ a11 , a12 ] , B == [ b11 , b12 ]
	#          [ a21 , a22 ]        [ b21 , b22 ]
	#
	#   と定義すると、
	#
	#     kronecker_product( A , B ) == [ a11 * B , a12 * B ]
	#                                   [ a21 * B , a22 * B ]
	#
	#                                == [ a11 * b11 , a11 * b12 , a12 * b11 , a12 * b12 ]
	#                                   [ a11 * b21 , a11 * b22 , a12 * b21 , a12 * b22 ]
	#                                   [ a21 * b11 , a21 * b12 , a22 * b11 , a22 * b12 ]
	#                                   [ a21 * b21 , a21 * b22 , a22 * b21 , a22 * b22 ]
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $m , $n ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $n ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	my $x = undef ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		my $y = $n * $m->[ $r ]->[0] ;
		if ( ref( $y ) eq __PACKAGE__ ) {
			foreach my $c ( 1 .. $cols - 1 ) {
				$y = $y->expand_columns( $n * $m->[ $r ]->[ $c ] ) ;
			}
		}
		else {
			$y = [ $y ] ;
			foreach my $c ( 1 .. $cols - 1 ) {
				push( @{ $y } , $n * $m->[ $r ]->[ $c ] ) ;
			}
			$y = __PACKAGE__->new( $y )->rvector() ;
		}

		if ( defined $x ) {
			$x = $x->expand_rows( $y ) ;
		}
		else {
			$x = $y ;
		}
	}

	return $x ;
}

sub kp	{ return kronecker_product( @_ ) ; }

=head2 radian , degree , npi

Return the angle within two vectors.

  $v = vector( 1 , 0 ) ;
  $u = vector( 1 , 1 ) ;

  print $v->radian( $u ) ;                             # 0.7853981633974483096156608458198757210492
  print $v->degree( $u ) ;                             # 45
  print $v->npi( $u ) ;                                # 0.25

=cut

sub radian {
	#-----------------------------------------------------------------------
	#
	# 2 つのベクトルが形成する角度 ( ラジアン ) を返す。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	my $r = $v->cosine_similarity( $u ) ;

	return ( defined $r ) ? $r->arccosine() : undef ;
}

sub degree {
	#-----------------------------------------------------------------------
	#
	# 2 つのベクトルが形成する角度を返す。
	#
	#-----------------------------------------------------------------------
	my $r = radian( @_ ) ;
	return ( defined $r ) ? $r->degree() : undef ;
}

sub npi {
	#-----------------------------------------------------------------------
	#
	# 2 つのベクトルが形成する角度を円周率の倍数で返す。
	#
	#-----------------------------------------------------------------------
	my $r = radian( @_ ) ;
	return ( defined $r ) ? $r->npi() : undef ;
}

=head2 sum , mean , median , min , max , total_product

  $v = vector( 1 , 2 , 3 ) ;

  print $v->sum() ;                                    # 6       ( == 1 + 2 + 3 )
  print $v->mean() ;                                   # 2
  print $v->median() ;                                 # 2
  print $v->min() ;                                    # 1
  print $v->max() ;                                    # 3
  print $v->total_product() ;                          # 6       ( == 1 * 2 * 3 )

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m->sum() ;                                    # 45      ( == 1 + 2 + ... + 8 + 9 )
  print $m->mean() ;                                   # 5
  print $m->median() ;                                 # 5
  print $m->min() ;                                    # 1
  print $m->max() ;                                    # 9
  print $v->total_product() ;                          # 362880  ( == 1 * 2 * 3 * .... * 8 * 9 )


=cut

sub sum {
	#-----------------------------------------------------------------------
	#
	# 成分の総和
	#
	#   総和は、数学では Σ で表される。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $s = new_decimal( 0 ) ;
	foreach my $r ( @{ $self } ) {
		foreach my $c ( @{ $r } ) {
			$s += $c ;
		}
	}

	return $s ;
}

sub mean {
	#-----------------------------------------------------------------------
	#
	# 成分の相加平均 ( 算術平均 )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $n = $self->rows() * $self->cols() ;
	my $r = $self->sum() / $n ;

	return $r->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
}

sub median {
	#-----------------------------------------------------------------------
	#
	# 成分の中央値
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my @v = () ;
	foreach my $r ( @{ $self } ) {
		push( @v , @{ $r } ) ;
	}

	@v = sort { $a <=> $b } @v ;
	my @ix = (
		CORE::int( $#v / 2 )	,
		POSIX::ceil( $#v / 2 )	,
	) ;

	my $r = ( $v[ $ix[0] ] + $v[ $ix[1] ] ) / 2 ;
	return $r->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
}

sub min {
	#-----------------------------------------------------------------------
	#
	# 成分の最小値
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	my $r = undef ;

	if ( $m->is_complex_vm() ) {
		#
		# 複素数は一般に大小を定義できないが、行列式 ( 絶対値の 2 乗 ) で代替する。
		#
		my $e = undef ;
		foreach ( @{ $m } ) {
			$e = ( sort { $a->det() <=> $b->det() } @{ $_ } )[0] ;
			if ( ! defined $r or $r->det() > $e->det() ) {
				$r = $e	;
			}
		}

		$r = $r->complex()	unless ( $r->is_complex() ) ;
	}
	else {
		#
		# 実行列の場合。
		#
		my $e = undef ;
		foreach ( @{ $m } ) {
			$e = ( sort { $a <=> $b } @{ $_ } )[0] ;
			if ( ! defined $r or $r > $e ) {
				$r = $e	;
			}
		}
	}

	return $r ;
}

sub max {
	#-----------------------------------------------------------------------
	#
	# 成分の最大値
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	my $r = undef ;

	if ( $m->is_complex_vm() ) {
		#
		# 複素数は一般に大小を定義できないが、行列式 ( 絶対値の 2 乗 ) で代替する。
		#
		my $e = undef ;
		foreach ( @{ $m } ) {
			$e = ( sort { $b->det() <=> $a->det() } @{ $_ } )[0] ;
			if ( ! defined $r or $r->det() < $e->det() ) {
				$r = $e	;
			}
		}

		$r = $r->complex()	unless ( $r->is_complex() ) ;
	}
	else {
		#
		# 実行列の場合。
		#
		my $e = undef ;
		foreach ( @{ $m } ) {
			$e = ( sort { $b <=> $a } @{ $_ } )[0] ;
			if ( ! defined $r or $r < $e ) {
				$r = $e	;
			}
		}
	}

	return $r ;
}

sub total_product {
	#-----------------------------------------------------------------------
	#
	# 成分の総積
	#
	#   総積は、数学では Π ( 大文字の PI ) で表現される。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	if ( $self->rows() < 1 ) ;
	return undef	if ( $self->cols() < 1 ) ;

	my $p = new_decimal( 1 ) ;
	foreach my $r ( @{ $self } ) {
		foreach my $c ( @{ $r } ) {
			$p *= $c ;
		}
	}

	return $p ;
}

=head2 norm

By default, 'norm' method will return 2-norm ( operator norm ).

  $v = vector( 1 , 2 , 3 ) ;

  print $v->norm() ;                                   # 3.741657386773941385583748732316549301756      ( 2-norm ; operator norm )
  print $v->norm( 3 ) ;                                # 3.3019272488946266838746099524090849568468     ( 3-norm ; operator norm )

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 0 ] ,
  ) ;

  print $m->norm() ;                                   # 13.2014586189486750196675030488904732147817    ( 2-norm ; operator norm )
  print $m->norm( 'FRO' ) ;                            # 14.2828568570856999959987996227345305575323    ( Frobenius norm )

=cut

sub norm {
	#-----------------------------------------------------------------------
	#
	# ベクトルノルム
	#
	#   p 次のノルム ( p - ノルム ) は、ベクトルの各成分を p 乗したものの総和の p 冪根。
	#   2 次のノルム ( 2 - ノルム ) はユークリッドノルムとも呼ばれ、ベクトルにおける絶対値としての意味を持つ。
	#   ∞ ノルムは、ベクトル成分の最大値。
	#
	# 行列のノルム
	#
	#   行列のノルムについては、引数に応じて作用素ノルムまたはフロベニウスノルムを返す。
	#
	#   成分ごとのノルムは enorm メソッドで、シャッテンノルムは schatten_norm メソッドでサポートする。
	#   ( シャッテンノルムの 1 次のノルムとして trace_norm , nuclear_norm も定義してある。 )
	#
	#-----------------------------------------------------------------------
	my( $self , $p ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	$p = 2	unless ( defined $p ) ;

	#
	# 行列ノルム
	#
	if ( $self->is_matrix() ) {
		return $self->fnorm()		if ( $p =~ /^FRO/i ) ;	# フロベニウスノルム
		return $self->onorm( $p ) ;				# 作用素ノルム
	}

	#
	# ベクトルノルム
	#
	my $v = $self->vec2array() ;
	return undef	unless ( @{ $v } ) ;

	my $r = undef ;

	if ( $p =~ /^INF/i ) {
		if ( $self->is_complex_vector() )	{ $r = ( sort { $b->det() <=> $a->det() } @{ $v } )[0] ; }
		else					{ $r = ( sort { $b <=> $a } @{ $v } )[0] ; }
	}
	elsif ( $p =~ /^\d+$/ ) {
		$r = new_decimal( 0 ) ;
		foreach ( @{ $v } ) {
			$r += $_->abs()->power( $p ) ;	# このパッケージでは abs() == fabs()
		}
		$r = $r->root( $p ) ;
	}

	return $r ;
}

sub onorm {
	#-----------------------------------------------------------------------
	#
	# 行列の作用素ノルム ( operator norm )
	#
	#   誘導ノルム ( Induced norm ) とも呼ばれる。
	#
	#   1 次、 2 次、無限大ノルムのみをサポートする。
	#
	#-----------------------------------------------------------------------
	my( $m , $p ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	$p = 2	unless ( defined $p ) ;

	return $m->rnorm()	if ( $p =~ /INF/i ) ;	# 無限大ノルム == 行ベクトルについてのノルム
	return $m->cnorm()	if ( $p == 1 ) ;	# 一次のノルム == 列ベクトルについてのノルム
	return $m->snorm()	if ( $p == 2 ) ;	# 二次のノルム == スペクトルノルム ( ユークリッドノルム )

	return undef ;
}

sub cnorm {
	#-----------------------------------------------------------------------
	#
	# 行列の列に関するノルム
	#
	#   cnorm( A ) == max( Σ[ i == 1 -> m ]( abs( a[i,j] ) ) )
	#              == norm( A , 1 )
	#
	#   行列の列に関するノルムは、行列の誘導ノルム ( Induced norm ) の一種。
	#   誘導ノルムは、作用素ノルム ( Operator norm ) とも呼ばれる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my $cmax = $m->cols() - 1 ;
	my $norm = undef ;

	foreach my $c ( 0 .. $cmax ) {
		my $v = $m->cvector( $c ) ;
		my $s = new_decimal( 0 ) ;
		foreach ( @{ $v->vec2array() } ) {
			$s += $_->abs() ;
		}
		if ( ! defined $norm or $norm < $s ) {
			$norm = $s ;
		}
	}

	return $norm ;
}

sub rnorm {
	#-----------------------------------------------------------------------
	#
	# 行列の行に関するノルム
	#
	#   rnorm( A ) == max( Σ[ j == 1 -> n ]( abs( a[i,j] ) ) )
	#              == norm( A , INF )
	#
	#   行列の行に関するノルムは、行列の無限大ノルム ( Infinity norm ) と呼ばれる。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my $rmax = $m->rows() - 1 ;
	my $norm = undef ;

	foreach my $r ( 0 .. $rmax ) {
		my $v = $m->rvector( $r ) ;
		my $s = new_decimal( 0 ) ;
		foreach ( @{ $v->vec2array() } ) {
			$s += $_->abs() ;
		}
		if ( ! defined $norm or $norm < $s ) {
			$norm = $s ;
		}
	}

	return $norm ;
}

=head2 snorm

Return the spectral norm.

  snorm( A ) == sqrt( max( eigen_values( adjoint( A ) * A ) ) )
             == max( singular_vaues( A ) )
             == norm( A , 2 )                                       # 2-norm

=cut

sub snorm {
	#-----------------------------------------------------------------------
	#
	# 行列のスペクトルノルム ( spectral norm )
	#
	#   snorm( A ) == sqrt( max( eigen_values( adjoint( A ) * A ) ) )
	#              == max( singular_values( A ) ) 
	#              == norm( A , 2 )
	#
	#   スペクトルノルムは、行列 A の最大の特異値であり、
	#   半正定値行列
	#
	#     adjoint( A ) * A
	#
	#   の最大の固有値の平方根と同義。
	#
	#   スペクトルノルムは、行列 A の 2 次の作用素ノルムでもある。
	#
	#   スペクトルノルムを求めるには固有値問題を解く必要があるため、演算コストは高い。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my $norm = undef ;
	foreach my $s ( $m->singular_values() ) {
		if ( ! defined $norm or $norm < $s ) {
			$norm = $s ;
		}
	}

	$norm = $norm->decimal()	if ( defined $norm and $norm->can_decimal() ) ;

	return $norm ;
}

sub enorm {
	#-----------------------------------------------------------------------
	#
	# 行列の成分ごとのノルム ( Entrywise norm )
	#
	#   enorm( A , p ) == norm( vectors( A ) , p )
	#                  == ( Σ[ i == 1 -> m ]( Σ[ j == 1 -> n ]( abs( a[i,j] )^p ) ) )^(1/p)
	#
	#   p == 2 の場合、成分ごとのノルムはフロベニウスノルム ( Frobenius norm ) または
	#   ヒルベルト = シュミットノルム ( Hilbert-Schmidt norm ) と呼ばれ、
	#
	#     enorm( A , 2 ) == sqrt( trace( adjoint( A ) * A ) )
	#                    == sqrt( Σ( singular_values( A )[i] )^2 )
	#
	#   となる。
	#
	#   p == ∞ の時、成分ごとのノルムは最大ノルムと呼ばれ、
	#
	#     enorm( A , INF ) == max( a[i,j] )
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $m , $p ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	$p = 2	unless ( defined $p ) ;

	return $m->max()	if ( $p =~ /INF/i ) ;
	return $m->fnorm()	if ( $p == 2 ) ;

	my $cmax = $m->cols() - 1 ;
	my $v = [] ;

	foreach my $c ( 0 .. $cmax ) {
		my $vnorm = $m->cvector( $c )->norm( $p ) ;
		push( @{ $v } , $vnorm ) ;
	}

	my $norm = undef ;

	if ( $v = __PACKAGE__->new( $v ) ) {
		$norm = $v->norm( $p ) ;
	}

	return $norm ;
}

=head2 fnorm

Return the Frobenius norm.

  fnorm( A ) == sqrt( trace( adjoint( A ) * A ) )
             == sqrt( sum( singular_values( A ) )^2 )

=cut

sub fnorm {
	#-----------------------------------------------------------------------
	#
	# フロベニウスノルム ( Frobenius norm )
	#
	#   ヒルベルト = シュミットノルム ( Hilbert-Schmidt norm ) とも呼ばれる。
	#
	#   fnorm( A ) == sqrt( trace( adjoint( A ) * A ) )
	#              == sqrt( Σ( singular_values( A ) )^2 )
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my $n = $m->adjoint() * $m ;
	my $tr = $n->trace() ;

	my $norm = ( $tr->sqrt() )[0] ;

	return $norm ;
}

=head2 schatten_norm

  shatten_norm( A , p ) == sum( ( singular_values( A )[i] )^p )^(1/p)

  shatten_norm( A , 1 )     == nuclear_norm( A )  == trace_norm( A )
  shatten_norm( A , 2 )     == fnorm( A )                            ( Frobenius norm )
  shatten_norm( A , 'INF' ) == snorm( A )                            ( spectral norm )

=cut

sub schatten_norm {
	#-----------------------------------------------------------------------
	#
	# シャッテンノルム ( Schatten norm )
	#
	#   シャッテン = フォン・ノイマンノルムとも呼ばれる。
	#
	#   shatten_norm( A , p ) == Σ( ( singular_values( A )[i] )^p )^(1/p)
	#
	#   シャッテンノルムは、
	#
	#     p == 1 の時、核型ノルム ( nuclear norm ; トレースノルム ; trace norm )
	#     p == 2 の時、フロベニウスノルム
	#     p == ∞ の時、スペクトルノルム
	#
	#   となる。
	#
	#   核型ノルムは、
	#
	#     shatten_norm( A , 1 ) == trace( sqrt( adjoint( A ) * A ) )
	#                           == Σ( singular_values( A ) )
	#
	#   と表すこともできる。
	#
	#-----------------------------------------------------------------------
	my( $m , $p ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	$p = 2	unless ( defined $p ) ;

	return $m->snorm()	if ( $p =~ /INF/i ) ;
	return $m->fnorm()	if ( $p == 2 ) ;

	my $norm = undef ;

	foreach my $s ( $m->singular_values() ) {
		if ( defined $norm )	{ $norm += $s->power( $p ) ; }
		else			{ $norm  = $s->power( $p ) ; }

	}

	$norm = ( $norm->root( $p ) )[0] ;

	return $norm ;
}

sub trace_norm		{ return schatten_norm( $_[0] , 1 ) ; }
sub nuclear_norm	{ return schatten_norm( $_[0] , 1 ) ; }

=head2 distance

Return the Euclidian distance between two vectors.

  distance( v , u ) == distance( u , v )
                    == norm( v - u )
                    == norm( u - v )

=cut

sub distance {
	#-----------------------------------------------------------------------
	#
	# ユークリッド距離 ( Euclidean distance )
	#
	#   ベクトル成分の差を採り、 2 次のノルムを採る。
	#
	#     d( p , q ) == d( q , p )
	#                == sqrt( Σ( q[i] - p[i] )^2 )
	#                == norm( p - q )
	#                == norm( q - p )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $w = $v->subtract( $u ) ;
	return undef	unless ( defined $w ) ;

	return $w->norm( 2 ) ;
}

=head1 'Vector' object - similarity.

=cut

#-------------------------------------------------------------------------------
#
# ベクトルの類似度 ( 共起性 )
#
#-------------------------------------------------------------------------------

=head2 cosine_similarity

Return the cosine similarity within two vectors.


                                       IP( v , u )
  cosine_similarity( v , u ) == -----------------------
                                 norm( v ) * norm( u )

 
Then,

  IP( v , u ) == adjoint( v ) * u
              == norm( v ) * norm( u ) * cosine_similarity( v , u )
              == norm( v ) * norm( u ) * cos( radian( v , u ) )

In this module,

  $v->radian( $u ) == $v->cosine_similarity( $u )->arccosine() ;


=cut

sub cosine_similarity {
	#-----------------------------------------------------------------------
	#
	# コサイン類似度
	#
	#   ベクトル v , u の類似度を s とすると、
	#
	#                           inner_product( v , u ) 
	#     s == cos( theta ) == ------------------------
	#                           norm( v ) * norm( u )
	# 
	#   で表される。
	#
	#   ベクトル v , u がなす角 ( 上述の theta ) は、
	#
	#     theta == acos( s )
	#
	#   となる。 ( -1 <= s <= 1 , 0 <= theta <= PI )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $r = $v->inner_product( $u ) ;
	return undef	unless ( defined $r ) ;

	$r /= ( $v->norm() * $u->norm() ) ;

	return $r ;
}

=head2 deviation_pattern_simillarity

Return the deviation pattern similarity within two vectors.

  v' == mean_deviation_vector( v ) 
  u' == mean_deviation_vector( u ) 

  deviation_pattern_similarity( v , u ) == cosine_similarity( v' , u' ) 

=cut

sub deviation_pattern_similarity {
	#-----------------------------------------------------------------------
	#
	# 偏差パターン類似度
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	#
	# 平均偏差ベクトルとの差に変換し、コサイン類似度を返す。
	#
	$v -= $v->mean_deviation_vector() ;
	$u -= $u->mean_deviation_vector() ;

	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;
	
	my $r = $v->cosine_similarity( $u ) ;
	
	return $r ;
}

=head2 mean_deviation_vector

  v == [ 1 ]
       [ 2 ]
       [ 3 ]
       [ 4 ]
       [ 5 ]

  m == mean( v ) == 3

  u == mean_deviation_vector( v )

    == [ 1 - m ] == [ -2 ]
       [ 2 - m ]    [ -1 ]
       [ 3 - m ]    [  0 ]
       [ 4 - m ]    [  1 ]
       [ 5 - m ]    [  2 ]




  $v = vector( 1 .. 5 ) ;

  print $v->mean_deviation_vector() ;                  # [             -2.00000 ]
						       # [             -1.00000 ]
                                                       # [              0.00000 ]
                                                       # [              1.00000 ]
                                                       # [              2.00000 ]

=cut

sub mean_deviation_vector {
	#-----------------------------------------------------------------------
	#
	# 平均偏差ベクトル
	#
	#   平均偏差ベクトルは、ベクトル成分の平均値を採り、各成分をこの平均値からの距離に置き換えたものとなる。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( $v->is_cvector() ) ;

	my $vm = $v->vec2array() ;
	return undef	unless ( @{ $vm } ) ;

	my $vmean = $v->sum() / $v->rows() ;
	foreach ( @{ $vm } ) { $_ -= $vmean ; }

	my $r = __PACKAGE__->new( $vm ) ;

	return $r ;
}

=head2 variance

  u = mean_deviation_vector( v )

                    ( norm( u ) )^2
  variance( v ) == -----------------
                      rows( u )

                    IP( u , u )
		== -------------
		     rows( u )

                == covariance( v , v )

=cut

sub variance {
	#-----------------------------------------------------------------------
	#
	# 分散
	#
	#   分散をベクトル演算で表現したもの。
	#
	#   平均偏差ベクトルの絶対値 ( 2 次のノルム ) の二乗を成分数で割ったものとなる。
	#   列ベクトル v が与えられた時、
	#
	#     u = mean_deviation_vector( v ) 
	#     variance( v ) == norm( u ) ** 2 / rows( u )
	#                   == Σ( u[i] ** 2 ) / rows( u )        ( i = 1 -> rows( u ) )
	#                   == inner_product( u , u ) / rows( u )
	#
	#   となる。
	#
	#   分散は、単一のベクトルの平均偏差ベクトルを採り、それ自身の内積を成分数で割ったものであり、
	#   結局のところ、
	#
	#      variance( v ) == covariance( v , v )
	#
	#   と言うことになる。
	#
	#-----------------------------------------------------------------------
	my( $v ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( $v->is_cvector() ) ;

	return $v->covariance( $v ) ;
}

=head2 sd

Return the standard deviation.

  sd( v ) == sqrt( variance( v ) ) >= 0 

=cut

sub sd {
	#------------------------------------------------------------------------
	#
	# 標準偏差 ( Standard Deviation )
	#
	#   標準偏差は「分散の正の平方根」として定義される。
	#
	#------------------------------------------------------------------------
	my( $v ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( $v->is_cvector() ) ;

	return $v->variance()->sqrt() ;
}

=head2 covarians

It must be rows( v ) == rows( u ) 

  v' = mean_deviation_vector( v ) 
  u' = mean_deviation_vector( u ) 

                          IP( v' , u' )
  covariance( v , u ) == ---------------
                           rows( v' )


=cut

sub covariance {
	#-----------------------------------------------------------------------
	#
	# 共分散
	#
	#   共分散をベクトル演算で表現したもの。
	#
	#   共分散は、 2 つのベクトルの平均偏差ベクトルを採り、これらの間で採った内積を成分数で割ったものとなる。
	#   内積を採るため、 2 つのベクトルの成分数は一致している必要がある。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	#
	# 2 つのベクトルを平均偏差ベクトルに変換
	#
	$v = $v->mean_deviation_vector() ;
	$u = $u->mean_deviation_vector() ;

	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;

	my $r = $v->inner_product( $u ) ;
	return undef	unless ( defined $r ) ;

	$r /= $v->rows() ;

	return $r ;
}

=head2 varcov

Return the variance-covariance matrix.

  A == [ 90 , 60 , 90 ] == [ a1 , a2 , a3 ]         ( a1 == vector( A , 0 ) , a2 == vector( A , 1 ) , a3 == vector( A , 2 ) )
       [ 90 , 90 , 30 ]
       [ 60 , 60 , 60 ]
       [ 60 , 60 , 90 ]
       [ 30 , 30 , 30 ]

 r == rows( A )
    
 -> M == A - [ 1 , 1 , 1 , 1 , 1 ] * A * ( 1/r )
             [ 1 , 1 , 1 , 1 , 1 ]
             [ 1 , 1 , 1 , 1 , 1 ]
             [ 1 , 1 , 1 , 1 , 1 ]
             [ 1 , 1 , 1 , 1 , 1 ]

      == [ 90 , 60 , 90 ] - [ 1 , 1 , 1 , 1 , 1 ] * [ 90 , 60 , 90 ] * ( 1/5 )
         [ 90 , 90 , 30 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 90 , 90 , 30 ]
         [ 60 , 60 , 60 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 60 , 60 , 60 ]
         [ 60 , 60 , 90 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 60 , 60 , 90 ]
         [ 30 , 30 , 30 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 30 , 30 , 30 ]
         
      == [ 90 , 60 , 90 ] - [ 66 , 60 , 60 ]
         [ 90 , 90 , 30 ]   [ 66 , 60 , 60 ]
         [ 60 , 60 , 60 ]   [ 66 , 60 , 60 ]
         [ 60 , 60 , 90 ]   [ 66 , 60 , 60 ]
         [ 30 , 30 , 30 ]   [ 66 , 60 , 60 ]

      == [  24 ,   0 ,  30 ]
         [  24 ,  30 , -30 ]
         [  -6 ,   0 ,   0 ]
         [  -6 ,   0 ,  30 ]
         [ -36 , -30 , -30 ]

  V == adjoint( M ) * M * ( 1/r )

    == [ 24 ,  24 ,  -6 ,  -6 , -36 ] * [  24 ,   0 ,  30 ] * ( 1/5 )
       [  0 ,  30 ,   0 ,   0 , -30 ]   [  24 ,  30 , -30 ]
       [ 30 , -30 ,   0 ,  30 , -30 ]   [  -6 ,   0 ,   0 ]
                                        [  -6 ,   0 ,  30 ]
                                        [ -36 , -30 , -30 ]

    == [ 504 , 360 , 180 ] == [ v1 , v2 , v3 ]
       [ 360 , 360 ,   0 ]
       [ 180 ,   0 , 720 ]


    -> diag( V ) == ( 504 , 360 , 720 )

      -> 504 == variance( a1 ) 
         360 == variance( a2 )
         720 == variance( a3 )

    -> v1 == [ 504 ] , v2 == [ 360 ] , v3 == [ 180 ]
             [ 360 ]         [ 360 ]         [   0 ]
	     [ 180 ]         [   0 ]         [ 720 ]

      -> covariance( a1 , a2 ) == v1[2] == v2[1] == 360
      -> covariance( a1 , a3 ) == v1[3] == v3[1] == 180
      -> covariance( a2 , a3 ) == v2[3] == v3[2] ==   0

=cut

sub varcov {
	#-----------------------------------------------------------------------
	#
	# 分散共分散行列 ( Variance-covariance matrix )
	#
	#   複数のベクトルを列ベクトルとして持つ行列を受け取り、分散共分散行列を返す。
	#
	#   受け取る行列を A , 結果を V で表現すると、
	#
	#     A == [ 90 , 60 , 90 ]
	#          [ 90 , 90 , 30 ]
	#          [ 60 , 60 , 60 ]
	#          [ 60 , 60 , 90 ]
	#          [ 30 , 30 , 30 ]
	#
	#     r == rows( A )
	#     
	#     -> M == A - [ 1 , 1 , 1 , 1 , 1 ] * A * ( 1/r )
	#                 [ 1 , 1 , 1 , 1 , 1 ]
	#                 [ 1 , 1 , 1 , 1 , 1 ]
	#                 [ 1 , 1 , 1 , 1 , 1 ]
	#                 [ 1 , 1 , 1 , 1 , 1 ]
	#
	#          == [ 90 , 60 , 90 ] - [ 1 , 1 , 1 , 1 , 1 ] * [ 90 , 60 , 90 ] * ( 1/5 )
	#             [ 90 , 90 , 30 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 90 , 90 , 30 ]
	#             [ 60 , 60 , 60 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 60 , 60 , 60 ]
	#             [ 60 , 60 , 90 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 60 , 60 , 90 ]
	#             [ 30 , 30 , 30 ]   [ 1 , 1 , 1 , 1 , 1 ]   [ 30 , 30 , 30 ]
	#         
	#          == [ 90 , 60 , 90 ] - [ 66 , 60 , 60 ]
	#             [ 90 , 90 , 30 ]   [ 66 , 60 , 60 ]
	#             [ 60 , 60 , 60 ]   [ 66 , 60 , 60 ]
	#             [ 60 , 60 , 90 ]   [ 66 , 60 , 60 ]
	#             [ 30 , 30 , 30 ]   [ 66 , 60 , 60 ]
	#
	#          == [  24 ,   0 ,  30 ]
	#             [  24 ,  30 , -30 ]
	#             [  -6 ,   0 ,   0 ]
	#             [  -6 ,   0 ,  30 ]
	#             [ -36 , -30 , -30 ]
	#
	#    V == adjoint( M ) * M * ( 1/r )
	#
	#      == [ 24 ,  24 ,  -6 ,  -6 , -36 ] * [  24 ,   0 ,  30 ] * ( 1/5 )
	#         [  0 ,  30 ,   0 ,   0 , -30 ]   [  24 ,  30 , -30 ]
	#         [ 30 , -30 ,   0 ,  30 , -30 ]   [  -6 ,   0 ,   0 ]
	#                                          [  -6 ,   0 ,  30 ]
	#                                          [ -36 , -30 , -30 ]
	#
	#      == [ 504 , 360 , 180 ]
	#         [ 360 , 360 ,   0 ]
	#         [ 180 ,   0 , 720 ]
	#
	#   となる。
	#   ( この例では、 M が実行列なので adjoint( M ) == transpose( M ) )
	#
	#   結果として得られた V の対角成分は、各ベクトルの分散を示す数値となる。
	#   非対角成分は、 2 つのベクトルの共分散を示す数値となる。
	#
	#
	#   ベクトル演算における分散 ( variance メソッド ) は、平均偏差ベクトルの 2 次のノルムの二乗を成分数で割った値。
	#   結果は、平均偏差の二乗和を成分数で割ったものとなる。
	#   分散共分散行列 ( varcov メソッド ) の対角成分は、平均偏差の二乗を成分数で割ったものであり、両者は同じ値を返す。
	#   これらの値は、スカラー演算における標本分散 ( sampled variance ) と同じ演算手法となっている。
	#
	#   ベクトル演算における共分散 ( covariance メソッド ) は、平均偏差ベクトルの内積を成分数で割ったものであり、
	#   分散共分散行列 ( varcov メソッド ) の非対角成分に現われる値と一致する。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	my $rows = $m->rows() ;

	my $one = __PACKAGE__->zero_matrix( [ $rows ] ) ;
	foreach my $r ( @{ $one } ) {
		foreach my $c ( @{ $r } ) {
			$c = new_decimal( 1 ) ;
		}
	}

	$m = $m - ( $one * $m ) / $rows ;
	$m = $m->adjoint() * $m  / $rows ;

	return $m ;
}

=head2 peason

Return the Peason product-moment correlation coefficient.

  v' == mean_deviation_vector( v )
  u' == mean_deviation_vector( u )

  peason( v , u ) == cosine_similarity( v' , u' )

                           IP( v' , u' )
                  == -------------------------
		      norm( v' ) * norm( u' )

=cut

sub pearson {
	#-----------------------------------------------------------------------
	#
	# ピアソンの積率相関係数 ( Pearson product-moment correlation coefficient )
	#
	#   ピアソンの相関係数、あるいは単に相関係数とも呼ばれる。
	#   ベクトル演算においては、平均偏差ベクトル同士のコサイン類似度として表される。
	#
	#   ピアソンの相関係数はデータの誤差が正規分布すること、 2 つのベクトルが線形であることを暗黙の前提としている。
	#   ( 暗黙に前提条件が仮定されている == パラメトリック法 )
	#
	#
	#   peason( v , u ) == cosine_similarity( mean_deviation_vector( v ) , mean_deviation_vector( u ) ) 
	#
	#
	#                       innper_product( mean_deviation_vector( v ) , mean_deviation_vector( u ) )
	#                   == ---------------------------------------------------------------------------
	#                        norm( mean_deviation_vector( v ) ) * norm( mean_deviation_vector( u ) ) 
	#
	#
	#                                  Σ( ( v[i] - vm )( u[i] - um ) )
	#                   == -------------------------------------------------------        ( i == 1 -> n )
	#                       sqrt( Σ( v[i] - vm )^2 ) * sqrt( Σ( u[i] - um )^2 )
	#
	#
	#     vm == mean( v[i] )      ( i == 1 -> n )
	#     um == mean( u[i] )      ( i == 1 -> n )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	#
	# 2 つのベクトルを平均偏差ベクトルに変換
	#
	$v = $v->mean_deviation_vector() ;
	$u = $u->mean_deviation_vector() ;

	return undef	unless ( defined $v ) ;
	return undef	unless ( defined $u ) ;

	my $r = $v->cosine_similarity( $u ) ;

	return $r ;
}

=head2 speaman

Return the Speaman's rank correlation coefficient.

=cut

sub spearman {
	#-----------------------------------------------------------------------
	#
	# スピアマンの順位相関係数 ( Speaman's rank correlation coefficient )
	#
	#   ベクトル成分に順位を付け、その順位に基づいてピアソン相関係数を求める。
	#   成分の順位についてピアソンの相関係数を採ると、非線形で正規分布しないデータの相関関係を得る事ができる。
	#   ( 暗黙の前提条件が存在しない == 非パラメトリック法 )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	#
	# ベクトル成分の順位を表すベクトルに変換してピアソン係数を求め、結果を返す。
	#
	my $vm = $v->vec2array() ;
	my $um = $u->vec2array() ;

	my $vix = {} ;
	my $uix = {} ;

	my $i = 0 ;
	foreach ( sort { $a <=> $b } @{ $vm } ) { $vix->{ $_ } = ++$i ; }
	$i = 0 ;
	foreach ( sort { $a <=> $b } @{ $um } ) { $uix->{ $_ } = ++$i ; }
	
	$vm = [ @{ $vix }{ @{ $vm } } ] ;
	$um = [ @{ $uix }{ @{ $um } } ] ;
	
	$v = __PACKAGE__->new( $vm ) ;
	$u = __PACKAGE__->new( $um ) ;

	return $v->peason( $u ) ;
}

=head2 kendall

Return the Kendlall tau rank correlation coefficient.

=cut

sub kendall {
	#-----------------------------------------------------------------------
	#
	# ケンドールの順位相関係数 ( Kendall tau rank correlation coefficient )
	#
	#   ケンドールのタウ ( tau ) とも呼ばれる。
	#
	#   ベクトル成分に順位を付け、その順位に基づいて相関関係を求める。
	#   成分の順位が同じ方向を向いている度合いを測る。
	#   ( 暗黙の前提条件が存在しない == 非パラメトリック法 )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	#
	# ベクトル成分の順位を表す配列に変換。
	#
	my $vm = $v->vec2array() ;
	my $um = $u->vec2array() ;

	my $vix = {} ;
	my $uix = {} ;

	my $i = 0 ;
	foreach ( sort { $a <=> $b } @{ $vm } ) { $vix->{ $_ } = ++$i ; }
	$i = 0 ;
	foreach ( sort { $a <=> $b } @{ $um } ) { $uix->{ $_ } = ++$i ; }

	$vm = [ @{ $vix }{ @{ $vm } } ] ;
	$um = [ @{ $uix }{ @{ $um } } ] ;

	#
	# 係数を求める。
	#
	my $p = new_decimal( 0 ) ;
	my $vs = new_decimal( 0 ) ;
	my $us = new_decimal( 0 ) ;
	foreach ( my $i = 0 ; $i < @{ $vm } ; $i++ ) {
		foreach ( my $j = 0 ; $j < @{ $vm } ; $j++ ) {
	
			next    if ( $i == $j ) ;
			my $vdiff = $vm->[ $i ] - $vm->[ $j ] ;
			my $udiff = $um->[ $i ] - $um->[ $j ] ;

			if ( $vdiff == 0 ) { $vs += 1 ; next ; }
			if ( $udiff == 0 ) { $us += 1 ; next ; }

			$p += ( $vdiff / $vdiff->abs() ) * ( $udiff / $udiff->abs() ) ;
		}
	}

	my $n = new_decimal( $v->rows() ) ;
	$n = $n * ( $n - 1 ) * 0.5 ;		# 任意のベクトル成分を 2 つ取り出した時の組み合わせ可能なペアの総数。

	#
	# $d = sqrt( $n - $vs ) * sqrt( $n - $us ) ;
	# $r = $p / 2 / $d ;
	#
	my $d = $n->subrtact( $vs )->sqrt() * $n->subtract( $us )->sqrt() ;
	my $r = $p->divide( $d->multiply( 2 ) ) ;

	return $r ;
}

=head2 jaccard

Return the Jaccrad index. ( Jaccard coefficient )

This method will return the Tanimoto similarity and distance. ( extended Jaccard index )

                                   IP( v , u )
  jaccard( v , u ) == -------------------------------------
                       norm( v ) + norm( u ) - IP( v , u )

=cut

sub jaccard {
	#-----------------------------------------------------------------------
	#
	# Jaccard 係数 ( ジャカール係数 ; ジャッカード係数 ; Jaccrad Index ; Jaccard coefficient )
	#
	#   ここに挙げているものは Jaccrad 係数を拡張した Tanimoto 係数 ( Tanimoto Similarity and Distance ) と呼ばれるもの。
	#
	#     s == inner_product( v , u ) / ( norm( v ) + norm( u ) - inner_product( v , u ) )
	#
	#   本来、この係数はビットベクター同士の類似性を示すもの。
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $ip = $v->inner_product( $u ) ;
	my $r = $ip->divide( $v->norm() + $u->norm() - $ip ) ;

	return $r ;
}

=head2 dice

Return the dice index. ( Dice coefficient )

                         IP( v , u )
  dice( v , u ) == ----------------------
                    norm( v ) + norm( u )

=cut

sub dice {
	#-----------------------------------------------------------------------
	#
	# ダイス係数 ( Dice Index ; Dice coefficient )
	#
	#   s == inner_product( v , u ) / ( norm( v ) + norm( u ) )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $ip = $v->inner_product( $u ) ;
	my $r = $ip->divide( $v->norm() + $u->norm() ) ;

	return $r ;
}

=head2 simpson

Return the Simpson coefficient.

                                IP( v , u )
  simpson( v , u ) == ------------------------------
                       min( norm( v ) , norm( u ) )

=cut

sub simpson {
	#-----------------------------------------------------------------------
	# 
	# シンプソン係数 ( Simpson Index ; Simpson coefficient ) 
	#
	#   s == inner_product( v , u ) / min( norm( v ) , norm( u ) )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $ip = $v->inner_product( $u ) ;
	my $d = ( sort { $a <=> $b } ( $v->norm() , $u->norm() ) )[0] ;
	my $r = $ip->divide( $d ) ;

	return $r ;
}

=head1 'Vector' object - recommendations.

=cut

#-------------------------------------------------------------------------------
#
# レコメンデーション
#
#-------------------------------------------------------------------------------

=head2 confidence_index

                                IP( v , u )
  confidence_index( v , u ) == -------------
                                 norm( v )

  $v = vector( 1 , 2 , 3 ) ;
  $u = vector( 4 , 5 , 6 ) ;

  print $v->confidence_index( $u ) ;                   # 8.552359741197580309905711388152112689728

=cut

sub confidence_index {
	#-----------------------------------------------------------------------
	#
	# 信頼度
	#
	#   ベクトル v , u に相関関係があると仮定し、それが v によって引き起こされた可能性を返す。
	#
	#     s == inner_product( v , u ) / norm( v )
	#
	#-----------------------------------------------------------------------
	my( $v , $u ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;

	return undef	unless ( $v->is_cvector() ) ;
	return undef	unless ( $u->is_cvector() ) ;

	my $ip = $v->inner_product( $u ) ;
	my $r = $ip->divide( $v->norm() ) ;

	return $r ;
}

=head2 support_index

                             IP( v , u )
  support_index( v , u ) == -------------
                              norm( w )

The vector w is the population, which contains v , u.

  $v = vector( 1 , 2 , 3 ) ;
  $u = vector( 4 , 5 , 6 ) ;
  $w = vector( 1 .. 10 ) ;
  
  print $v->support_index( $u , $w ) ;                 # 1.6308710126004017428385249902696539699792

=cut

sub support_index {
	#-----------------------------------------------------------------------
	#
	# 支持度
	#
	#   ベクトル v , u に相関関係があると仮定し、 v , u を完全に包含する母集団 w における支持度を返す。
	#
	#     s == inner_product( v , u ) / norm( w )
	#
	#   支持度は、母集団 w に対して v , u の類似度がどの程度の影響力を持っているのかを測る指標と言える。
	#   ( 影響力の小さい指標を取り除くために用いられる。 )
	#
	#-----------------------------------------------------------------------
	my( $v , $u , $w ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $w ) eq __PACKAGE__ ) ;

	my $ip = $v->inner_product( $u ) ;
	my $r = $ip->divide( $w->norm() ) ;

	return $r ;
}

=head2 lift_index

                          confidence_index( v , u ) 
  lift_index( v , u ) == ---------------------------
                            norm( u ) / norm( w )

The vector w is the population, which contains v , u.

  $v = vector( 1 , 2 , 3 ) ;
  $u = vector( 4 , 5 , 6 ) ;
  $w = vector( 1 .. 10 ) ;
  
  print $v->lift_index( $u , $w ) ;                    # 19.1236577493502982395010748750899997575509

=cut

sub lift_index {
	#-----------------------------------------------------------------------
	#
	# リフト
	#
	#   信頼度が高い指標について、その指標の改善効果を表す指標。
	#
	#     s == confidence_index( v , u ) / ( norm( u ) / norm( w ) ) 
	#
	#   リフトは、母集団 w において、 v の u に対する信頼度がどの程度の影響力を持っているのかを測る指標と言える。
	#   v を向上することで u が向上すると言う相関関係 ( 信頼度 ) が得られたとしても、 u が既に飽和状態にあれば u の改善は見込めない。
	#   これを測る指標がリフトであり、母集団 w に占める現状の u の割合を分母とし、信頼度を分子において評価する。
	#
	#-----------------------------------------------------------------------
	my( $v , $u , $w ) = @_ ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $u ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $w ) eq __PACKAGE__ ) ;

	my $cix = $v->confidence_index( $u ) ;
	my $r = $cix->divide( $u->norm() / $w->norm() ) ;

	return $r ;
}


=head1 'Vector' object - calculations.
=cut

#-------------------------------------------------------------------------------
#
# 行列の演算
#
#-------------------------------------------------------------------------------

=head2 trace

Against the square matrix A,

  trace( A ) == sum( diag( A ) )
             == sum( eigen_values( A ) ) 

=cut

sub trace {
	#-----------------------------------------------------------------------
	#
	# 対角和 ( trace )
	#
	#   跡とも呼ばれる。ドイツ語では spur ( シュプール ) 。
	#   正方行列の主対角成分の総和。
	#
	#   対角和は固有値の総和に等しい。
	#
	#   n 次正方行列 ( n x n の正方行列 ) を A 、その成分を a[k,k] ( k == 1 -> n ) とおくと、
	#
	#     trace( A ) == Σ( a[k,k] )              ( k == 1 -> n )
	#                == Σ( eigen_values( A ) )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_square_matrix() ) ;

	my $r = new_decimal( 0 ) ;
	foreach my $i ( 0 .. ( $self->rows() - 1 ) ) {
		$r += $self->[ $i ]->[ $i ] ;
	}

	return $r ;
}

=head2 det

Against the square matrix A,

  det( A ) == total_product( eigen_values( A ) )


  det( A ) == det( transpose( A ) )
  det( A ) != det( adjoint( A ) )           if A is a complex matrix.


If A is a triangular matrix,

  det( A ) == total_product( diag( A ) )


If matrix U is a unitary matrix,

  U * adjoint( U ) == U * inverse( U ) == E

  -> det( U * adjoint( U ) ) == det( U ) * det( adjoint( U ) )

  det( adjont( U ) ) == det( conj( U ) )
		     == conj( det( U ) )

  -> det( U * adjoint( U ) ) == det( U ) * det( adjoint( U ) )
                             == det( U ) * det( conj( U ) )
                             == det( U ) * conj( det( U ) )
                             == abs( det( U ) )^2

  det( U * adjoint( U ) ) == det( E ) == 1

  -> abs( det( U ) )^2 == 1
  -> det( U ) == 1 or -1


If matrix H is a Hermitian matrix,

  H == adjoint( H ) == conj( transpose( H ) ) == transpose( conj( H ) )

  det( H ) == det( transpose( conj( H ) ) == det( transpose( H ) )
  det( conj( H ) ) == conj( det( H ) )

  -> det( H ) == conj( det( H ) )

  imag( det( H ) ) == imag( conj( det( H ) ) == 0

   det( H ) is real number.


If matrix A is a Skew-Hermitian matrix,

   A == ( -1 ) * adjoint( A ) == ( -1 ) * conj( transpose( A ) ) == ( -1 ) * transpose( conj( A ) )

   A == ( -1 ) * adjoint( A ) == i * H

   -> det( A ) == det( i * H )
               == i * det( H )


The singular value and determinant.

  singular_values( A ) == sqrt( eigen_values( A * adjoint( A ) ) )


  ( U , S , V ) == svd( A )

  -> abs( det( A ) ) == abs( det( U * S * V ) )
                     == abs( det( U ) * det( S ) * det( V ) )
                     == abs( det( S ) )
                     == total_product( singular_values( A ) )

The other features.

  det( E )              == 1
  det( A * B )          == det( A ) * det( B )
  det( inverse( A ) )   == 1 / det( A )
  det( transpsoe( A ) ) == det( A )
  det( conj( A ) )      == conj( det( A ) )

=cut

sub det {
	#-----------------------------------------------------------------------
	#
	# 行列式 ( determinant )
	#
	#   行列式は、行列の世界における絶対値の役割を果たす。
	#   行列が正方行列でなければ undef を返す。
	#
	#
	#   全ての正方行列において、行列式は固有値の総積に等しい。
	#
	#     n 次正方行列 ( n x n の正方行列 ) を A とおくと、
	#
	#       det( A ) == Π( eigen_values( A ) )
	#
	#     ( Π は総積を表す。 )
	#
	#   任意の正方行列とその転置行列の行列式は等しい。 ( 随伴行列の行列式とは一致しない。 )
	#
	#     det( A ) == det( transpose( A ) )
	#
	#   三角行列の主対角成分には、その固有値が並ぶ。
	#   このため、三角行列の行列式はその主対角成分の総積に等しくなる。
	#
	#     if ( is_triangular_matrix( A ) {
	#        det( A ) == Π( a[k,k] )     ( k == 1 -> n )
	#     }
	#
	#
	#   ユニタリー行列の行列式
	#
	#     ユニタリー行列はその随伴行列 ( 共役転置行列 ) が逆行列に等しい行列。
	#     ユニタリー行列の行列式は 1 または -1 となる。
	#
	#       U * adjoint( U ) == U * inverse( U ) == E
	#
	#       -> det( U * adjoint( U ) ) == det( U ) * det( adjoint( U ) )
	#
	#     任意の正方行列とその転置行列の行列式が等しくなること、複素共役の行列式と行列式の複素共役が等しくなることから、
	#
	#       det( adjoint( U ) ) == det( conj( U ) )
	#                           == conj( det( U ) )
	#
	#       -> det( U * adjoint( U ) ) == det( U ) * det( adjoint( U ) )
	#                                  == det( U ) * det( conj( U ) )
	#                                  == det( U ) * conj( det( U ) )
	#                                  == abs( det( U ) )^2
	#
	#       det( U * adjoint( U ) ) == det( E ) == 1
	#
	#       -> abs( det( U ) )^2 == 1
	#       -> det( U ) == 1 or -1
	#
	#     なお、行列式の絶対値が 1 であることから、ユニタリー行列の固有値は複素平面の単位円上に現れる。 ( 1 の n 乗根 )
	#
	#     任意の実正方行列がユニタリー行列であれば、これは直交行列となり、その転置行列が逆行列と等しくなる。
	#     よって、直交行列の行列式も 1 または -1 となる。
	#
	#       A * adjoint( A ) == A * transpose( A ) == A * inverse( A ) == E
	#
	#       -> det( A ) == 1 or -1 
	#
	#
	#   エルミート行列の行列式
	#
	#     エルミート行列はその随伴行列 ( 共役転置行列 ) と等しい行列。
	#     エルミート行列の行列式は実数となる。
	#
	#       H == adjoint( H ) == conj( transpose( H ) ) == transpose( conj( H ) )
	#
	#       det( H ) == det( transpose( conj( H ) ) == det( transpose( H ) )
	#       det( conj( H ) ) == conj( det( H ) )
	#
	#       -> det( H ) == conj( det( H ) )
	#
	#     det( H ) と conj( det( H ) ) は何れもスカラー値であるため、 det( H ) の虚数部は 0 、つまり det( H ) は実数と言うことになる。
	#
	#
	#   歪エルミート行列と行列式
	#
	#     歪エルミート行列はその随伴行列 ( 共役転置行列 ) の符号を反転したものと等しくなる行列。
	#     歪エルミート行列の行列式は 0 又は純虚数となる。
	#
	#       A == ( -1 ) * adjoint( A ) == ( -1 ) * conj( transpose( A ) ) == ( -1 ) * transpose( conj( A ) )
	#
	#     歪エルミート行列は、その成分を虚数単位で除算するとエルミート行列になる。
	#     よって、
	#
	#       A == ( -1 ) * adjoint( A ) == i * H
	#
	#       -> det( A ) == det( i * H )
	#                   == i * det( H )
	#
	#     となる。
	#     エルミート行列 H の行列式は実数であるため、歪エルミート行列の行列式は 0 又は純虚数となる。
	#
	#
	#   特異値 ( Singular values ) との関係
	#
	#     任意の正方行列 A についての特異値は、
	#
	#       singular_values( A ) == sqrt( eigen_values( A * adjoint( A ) ) )
	#
	#     となる。 ( 特異値は全て正の値を採る。 )
	#
	#     正方行列 A は、特異値分解 ( SVD 分解 ) によって、
	#
	#       ( U , S , V ) == svd( A )
	#
	#     に分解される。 ( U : ユニタリー行列、 S : 実対角行列、 V : ユニタリー行列の随伴行列 )
	#
	#     ここから、 A の行列式と特異値との間に、
	#
	#       abs( det( A ) ) == abs( det( U * S * V ) )
	#                       == abs( det( U ) * det( S ) * det( V ) )
	#                       == abs( det( S ) )
	#                       == Π( singular_values( A ) )
	#
	#     と言う関係が成立する。
	#
	#
	#   トレース ( trace ; 跡 ) との関係
	#
	#     trace( A ) == Σ( a[k,k] )     ( k == 1 -> n )   # トレース
	#     exp( A )   == Σ( A^k / k! )                     # 行列指数関数
	#
	#     A の固有値を λ[i] 、これに対応する固有ベクトルを x[i] で表現すると、
	#
	#       x[i] * exp( A ) == x[i] * Σ( A^k / k! )
	#                       == x[i] * Σ( ( λ[i] )^k / k! )
	#                       == x[i] * exp( λ[i] )
	#
	#     となり、ここから、
	#
	#       det( exp( A ) ) == exp( trace( A ) )
	#
	#     と言う関係が成立する。
	#
	#   その他、行列式には以下のような性質がある。
	#
	#     det( E )              == 1
	#     det( A * B )          == det( A ) * det( B )
	#     det( inverse( A ) )   == 1 / det( A )
	#     det( transpsoe( A ) ) == det( A )
	#     det( conj( A ) )      == conj( det( A ) )
	#
	#-----------------------------------------------------------------------
	my( $m , $use_cofactor ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	$use_cofactor = 0	unless ( defined $use_cofactor ) ;

	$m = $m->copy() ;
	my $rows = $m->rows() ;
	my $r = undef ;

	if ( $rows == 1 ) {
		#
		# 正方行列なので、行数が 1 であれば列数も 1 であり、スカラー値となる。
		#
		$r = $m->[0]->[0] ;
	}
	elsif ( $rows == 2 ) {
		#
		# m == [ a , b ]
		#      [ c , d ]
		#
		# det( m ) == ad - bc
		#
		$r = ( $m->[0]->[0] * $m->[1]->[1] )
		   - ( $m->[0]->[1] * $m->[1]->[0] )
		;
	}
	elsif ( $m->is_diagonal_matrix() or $m->is_triangular_matrix() ) {
		#
		# 対角行列や三角行列の行列式は対角の総乗
		#
		$r = $m->[0]->[0] ;
		foreach my $i ( 1 .. ( $rows - 1 ) ) {
			$r *= $m->[ $i ]->[ $i ] ;
			$r = $r->round_down( $DECIMAL_PART_LENGTH_LIMIT + 10 ) ;
		}
	}
	elsif ( $use_cofactor ) {
		#
		# 余因子展開と再帰処理による演算
		#
		#   0 列に対する余因子展開を繰り返す。
		#
		#   サイズの大きな行列では演算コストが非常に大きくなる。
		#
		$r = new_decimal( 0 )	if ( $rows >= 0 ) ;
		foreach my $i ( 0 .. ( $rows - 1 ) ) {

			my $f = $m->[ $i ]->[ 0 ] ;
			next	if ( $f == 0 ) ;
			$f *= ( ( -1 ) ** $i ) ;	# $f = ( -1 ) ** ( $i + j )

			my $d = $m->cofactor( $i , 0 ) ;
			croak( "failed to get cofactor.\n" )	unless ( defined $d ) ;
			next	if ( $d == 0 ) ;

			my $diff = $f->multiply( $d )->round_down( $DECIMAL_PART_LENGTH_LIMIT + 10 ) ;
			$r += $diff ;
		}
	}
	else {
		#
		# ガウスの消去法の前方消去を使用。
		#
		$r = ( $m->forward_elimination() )[1] ;
	}

	return $r->round_down( $DECIMAL_PART_LENGTH_LIMIT + 10 ) ;
}

=head2 cofactor( $row , $column )

  $m = matrix(
  	[ 1 , 2 , 3 ] ,
  	[ 4 , 5 , 6 ] ,
  	[ 7 , 8 , 9 ] ,
  ) ;

  print $m ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

  print $m->cofactor( 0 , 0 ) ;                        # -3      == det( [ 5 , 6 ] )
                                                       #                 [ 8 , 9 ] 

  print $m->cofactor( 1 , 2 ) ;                        # -6      == det( [ 1 , 2 ] )
                                                       #                 [ 7 , 8 ] 

=cut

sub cofactor {
	#-----------------------------------------------------------------------
	#
	# 余因子 ( cofactor ) / 小行列式 ( minor determinant )
	#
	#   正方行列から i 行目と j 列目を除いた正方行列を生成し、その行列式を返す。
	#
	#   元の行列が正方行列でなければ undef を返す。
	#
	#   任意の m x n 行列から 1 つ以上の行と列を取り除いて生成した正方行列の行列式は小行列式 ( minor determinant ) と呼ばれる。
	#   ( 元の行列は正方行列とは限らない。)
	#   また、同じ番号の行と列を取り除いて得られる行列式は主小行列式 ( principal minor ) とも呼ばれる。
	#   主小行列式を求める際に切り出された部分行列の対角成分は、元の行列上でも対角成分の一部を成している。
	#
	#   余因子は
	#
	#     正方行列から任意の 1 行 1 列を取り除いて得られた小行列式。
	#
	#   あるいは
	#
	#     1 行 1 列を取り除いて得られた小行列式に ( -1 )^( $i + $j ) を乗じたもの。
	#
	#   と定義される。
	#   ( 前者を小行列式 ( minor ) , 後者を余因子 ( cofactor ) として区別する流儀もあるらしい。 )
	#
	#   ここでは前者の値を返す事とする。
	#
	#-----------------------------------------------------------------------
	my( $m , $i , $j ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	return undef	unless ( defined $i ) ;
	return undef	unless ( $i =~ /^\d+$/ ) ;

	$j = $i	unless ( defined $j ) ;

	my $rows = $m->rows() ;
	return undef	if ( $i >= $rows or $j >= $rows ) ;

	#
	# $i を除いた行番号の一覧と $j を除いた列番号の一覧
	#
	my @ix_r = grep { $_ != $i } ( 0 .. ( $rows - 1 ) ) ;
	my @ix_c = grep { $_ != $j } ( 0 .. ( $rows - 1 ) ) ;

	#
	# 配列スライスを使用して $i 行と $j 列を除いた配列参照を作成。
	#
	my $rm = [ @{ $m }[ @ix_r ] ] ;

	foreach ( @{ $rm } ) {
		$_ = [ @{ $_ }[ @ix_c ] ] ;
	}

	return undef	unless ( @{ $rm } ) ;

	#
	# 行列オブジェクトを生成。
	#
	my( $class ) = ref( $m ) || $m ;
	my $r = bless [ @{ $rm } ], $class ;

	#
	# 生成した小行列の行列式を返す。
	#
	return $r->det() ;
}

=head2 principal_minors

Against a square matrix A,

  p = principal_minors( A )

  -> p[0] == cofactor( A , 0 , 0 )
     p[1] == cofactor( A , 1 , 1 )
     p[2] == cofactor( A , 2 , 2 )
     .............................
     p[n] == cofactor( A , n , n )



  $m = matrix(
  	[ 1 , 2 , 3 ] ,
  	[ 4 , 5 , 6 ] ,
  	[ 7 , 8 , 9 ] ,
  ) ;

  print join "\n" , $m->principal_minors() ;           # -3         == $m->cofactor( 0 , 0 )
                                                       # -12        == $m->cofactor( 1 , 1 )
						       # -3         == $m->cofactor( 2 , 2 )

=cut

sub principal_minors {
	#-----------------------------------------------------------------------
	#
	# 主小行列式 ( principal minor )
	#
	#   主小行列式は、
	#
	#     任意の m x n 行列から 1 つ以上の行や列を取り除いて作られた正方行列から、
	#     更に i 行 i 列を取り除いた正方行列を作り、その行列式を採ったもの。
	#
	#   を意味する。
	#
	#   ここでは、正方行列を対象に全ての主小行列式のリストを作成して返す事とする。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	my $rows = $m->rows() ;

	my $r = [] ;
	foreach my $i ( 0 .. ( $rows - 1 ) ) {
		$r->[ $i ] = $m->cofactor( $i , $i ) ;
	}

	return @{ $r } ;
}

=head2 cofactor_expansion

Return the determinant of n x n square matrix.

If 'n' is a too large number, this method will need more and more long time to calculate the result.


If the matrix is a 1 x 1 matrix, it will return a first element.

  A == [ a ]

  cofactor_expansion( A ) == det( A )
                          == a

If the matrix is a 2 x 2 or 3 x 3 matrix, it will return a result of the Sarus's method.

  A == [ a , b ]
       [ c , d ]

  cofactor_expansion( A ) == det( A )
                          == ad - bc


  A == [ a , b , c ] == [ a[1,1] , a[1,2] , a[1,3] ]
       [ d , e , f ]    [ a[2,1] , a[2,2] , a[2,3] ]
       [ g , h , i ]    [ a[3,1] , a[3,2] , a[3,3] ]

  cofactor_expansion( A ) == det( A )

                          == ( aei + bfg + cdh ) - ( ceg + bdi + afh )

                          == (
                                 a[1,1] * a[2,2] * a[3,3] 
			       + a[1,2] * a[2,3] * a[3,1] 
			       + a[1,3] * a[2,1] * a[3,2]
			     )
			   - (
			         a[1,3] * a[2,2] * a[3,1] 
			       + a[1,2] * a[2,1] * a[3,3] 
			       + a[1,1] * a[2,3] * a[3,2]
			     )

The other n x n matrix,

  cofactor_expansion( A ) == det( A )
                          == sum( ( -1 )^( i + j ) * a[i,i] * cofactor( A , i , j ) )          ( i == 1 -> n , j == 1 -> n )

For example, about a 4 x 4 matrix.

  A == [ a11 , a12 , a13 , a14 ]
       [ a21 , a22 , a23 , a24 ]
       [ a31 , a32 , a33 , a34 ]
       [ a41 , a42 , a43 , a44 ]

  de( A ) == a11 * det( [ a22 , a23 , a24 ] )
                        [ a32 , a33 , a34 ]
                        [ a42 , a43 , a44 ]

           - a21 * det( [ a12 , a13 , a14 ] )
                        [ a32 , a33 , a34 ]
                        [ a42 , a43 , a44 ]

           + a31 * det( [ a12 , a13 , a14 ] )
                        [ a22 , a23 , a24 ]
                        [ a42 , a43 , a44 ]

           - a41 * det( [ a12 , a13 , a14 ] )
                        [ a22 , a23 , a24 ]
                        [ a32 , a33 , a34 ] 


  A == [  3 , 1 , 2 , 5 ]
       [ -1 , 1 , 3 , 6 ]
       [  4 , 0 , 2 , 1 ]
       [  5 , 1 , 0 , 4 ]

  det( A ) ==    3 * det( [ 1 , 3 , 6 ] )
                          [ 0 , 2 , 1 ]
		          [ 1 , 0 , 4 ]

            - (-1) * det( [ 1 , 2 , 5 ] )
	                  [ 0 , 2 , 1 ]
			  [ 1 , 0 , 4 ]
  
            +    4 * det( [ 1 , 2 , 5 ] )
	                  [ 1 , 3 , 6 ]
			  [ 1 , 0 , 4 ]

            -    5 * det( [ 1 , 2 , 5 ] )
	                  [ 1 , 3 , 6 ]
			  [ 0 , 2 , 1 ]

          == 3 * ( ( 1 * 2 * 4 ) + ( 3 * 1 * 1 ) + ( 6 * 0 * 0 ) - ( ( 6 * 2 * 1 ) + ( 3 * 0 * 4 ) + ( 1 * 1 * 0 ) ) )
	   + 1 * ( ( 1 * 2 * 4 ) + ( 2 * 1 * 1 ) + ( 5 * 0 * 0 ) - ( ( 5 * 2 * 1 ) + ( 2 * 0 * 4 ) + ( 1 * 1 * 0 ) ) )
	   + 4 * ( ( 1 * 3 * 4 ) + ( 2 * 6 * 1 ) + ( 5 * 1 * 0 ) - ( ( 5 * 3 * 1 ) + ( 2 * 1 * 4 ) + ( 1 * 6 * 0 ) ) )
	   - 5 * ( ( 1 * 3 * 1 ) + ( 2 * 6 * 0 ) + ( 5 * 1 * 2 ) - ( ( 5 * 3 * 0 ) + ( 2 * 1 * 1 ) + ( 1 * 6 * 2 ) ) )

	  == 3 * ( (  8 +  3 +  0 ) - ( 12 +  0 +  0 ) )
	   + 1 * ( (  8 +  2 +  0 ) - ( 10 +  0 +  0 ) )
	   + 4 * ( ( 12 + 12 +  0 ) - ( 15 +  8 +  0 ) )
	   - 5 * ( (  3 +  0 + 10 ) - (  0 +  2 + 12 ) )

	  == 3 * ( -1 )
	   + 1 * (  0 )
	   + 4 * (  1 )
	   - 5 * ( -1 )

          == -3 + 0 + 4 + 5

          == 6


=cut

sub cofactor_expansion {
	#-----------------------------------------------------------------------
	#
	# 余因子展開
	#
	#   行列式を求める手法の一つ。
	#   n 次正方行列について、その小行列式を再帰的に取り出すことによって行列式を求める。
	#
	#   行列のサイズが大きくなるにしたがって演算効率が悪くなる傾向がある。
	#   また、再帰処理を行っているため、行列のサイズが大きくなると Deep recursion を誘発する可能性もある。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	my $rows = $m->rows() ;

	my $r = undef ;
	if ( $rows == 1 ) {
		#---------------------------------------------------------------
		#
		# スカラー
		#
		#---------------------------------------------------------------
		$r = $m->[0]->[0] ;
	}
	elsif ( $rows == 2 ) {
		#---------------------------------------------------------------
		#
		# 二次正方行列
		#
		#   サラスの方法 ( Sarrus's method ; たすきがけ法 ) を用いる。
		#
		#     A == [ a , b ]
		#          [ c , d ]
		#
		#     det( A ) == ad - bc 
		#
		#---------------------------------------------------------------
		$r = ( $m->[0]->[0] * $m->[1]->[1] )
		   - ( $m->[0]->[1] * $m->[1]->[0] )
		;
	}
	elsif ( $rows == 3 ) {
		#---------------------------------------------------------------
		#
		# 三次正方行列
		#
		#   サラスの方法 ( Sarrus's method ; たすきがけ法 ) を用いる。
		#
		#     A == [ a , b , c ] == [ a[1,1] , a[1,2] , a[1,3] ]
		#          [ d , e , f ]    [ a[2,1] , a[2,2] , a[2,3] ]
		#          [ g , h , i ]    [ a[3,1] , a[3,2] , a[3,3] ]
		#
		#     det( A ) == ( aei + bfg + cdh ) - ( ceg + bdi + afh )
		#              == (
		#                     a[1,1] * a[2,2] * a[3,3] 
		#              	    + a[1,2] * a[2,3] * a[3,1] 
		#                   + a[1,3] * a[2,1] * a[3,2]
		#                 )
		#               - (
		#                     a[1,3] * a[2,2] * a[3,1] 
		#                   + a[1,2] * a[2,1] * a[3,3] 
		#                   + a[1,1] * a[2,3] * a[3,2]
		#                 )
		#
		#---------------------------------------------------------------
		$r = (
			  ( $m->[0]->[0] * $m->[1]->[1] * $m->[2]->[2] )	# aei
			+ ( $m->[0]->[1] * $m->[1]->[2] * $m->[2]->[0] )	# bfg
			+ ( $m->[0]->[2] * $m->[1]->[0] * $m->[2]->[1] )	# cdh
		     )
		   - (
			  ( $m->[0]->[2] * $m->[1]->[1] * $m->[2]->[0] )	# ceg
			+ ( $m->[0]->[1] * $m->[1]->[0] * $m->[2]->[2] )	# bdi
			+ ( $m->[0]->[0] * $m->[1]->[2] * $m->[2]->[1] )	# afh
		     )
		;
	}
	else {
		#---------------------------------------------------------------
		#
		# n 次正方行列
		#
		#   det( A ) == Σ( ( -1 )^( i + j ) * a[i,i] * cofactor( A , i , j ) )
		#
		#   余因子を求める際に再帰処理を用いることにより、列番号 j を先頭列に固定することができる。
		#
		#---------------------------------------------------------------
		$r = new_decimal( 0 ) ;

		foreach my $i ( 0 .. ( $rows - 1 ) ) {
			#-----------------------------------------------
			#
			# i 行 1 列を除いた部分行列を作成
			#
			#-----------------------------------------------

			#
			# $i を除いた行番号と 0 を除いた列番号の一覧を作成
			#
			my @ix_r = grep { $_ != $i } ( 0 .. ( $rows - 1 ) ) ;
			my @ix_c = ( 1 .. ( $rows - 1 ) ) ;

			#
			# 配列スライスを使用して $i 行と 0 列を除いた配列参照を作成。
			#
			my $n = [ @{ $m }[ @ix_r ] ] ;

			foreach ( @{ $n } ) {
				$_ = [ @{ $_ }[ @ix_c ] ] ;
			}

			return undef	unless ( @{ $n } ) ;

			#
			# 行列オブジェクトを生成。
			#
			my( $class ) = ref( $m ) || $m ;
			$n = bless [ @{ $n } ], $class ;

			#-----------------------------------------------
			#
			# 余因子の総和を採る。
			#
			#-----------------------------------------------
			my $c = $n->cofactor_expansion() ;
			if ( defined $c ) {
				$c *= $m->[ $i ]->[0] ;
				$c *= ( -1 )	unless ( ( $i % 2 ) == 0 ) ;

				$r += $c ;
			}
			else {
				return undef ;
			}
		}
	}

	return $r ;
}

sub rank {
	#-----------------------------------------------------------------------
	#
	# 階数 ( ランク )
	#
	#  ランクは、 
	#
	#    m x n 行列において一次独立 ( 線形独立 ) な行又は列ベクトルの最大個数
	#
	#  と定義される。
	#
	#  m x m 行列 ( 正方行列 ) A が
	#
	#    A == QR
	#
	#  と分解できる時、
	#
	#    rank( A ) == rank( R )
	#
	#  でもある。 ( LU 分解でも同じことが言える。 )
	#  ただし、有効桁数の採り方によってうまくいかないことがある。
	#
	#
	#  ランクには以下のような特徴がある。
	#
	#    m x n 行列 A について、
	#
	#      rank( A ) == rank( transpose( A ) )			# 転置行列のランク
	#                == max( size( cofactor( A , i , j ) ) )	# 小行列式の最大サイズ
	#                == count( svd( A ) )				# 特異値の数
	#
	#      rank( A ) == 0   if ( zero_matrix( A ) )
	#      rank( A ) != 0   unless ( zero_matrix( A ) )
	#
	#      rank( A ) <= min( m , n )
	#
	#      rank( A ) == min( m , n ) の時、 A はフルランク行列 ( full rank matrix )
	#
	#        A がフルランクの時、
	#          m >= n ならば、 A は行フルランク行列
	#          m <= n ならば、 A は列フルランク行列
	#
	#      rank( A ) < min( m , n ) の時、 A はランク不足 ( rank deficient ; ランク落ち )
	#
	#      rank( A ) == n の時、 A によって写される写像は単射 ( injective function ; injection ) となる。
	#      rank( A ) == m の時、 A によって写される写像は全射 ( surjection, onto mapping/function ) となる。
	#
	#    m x m 行列 ( 正方行列 ) A について、
	#
	#      rank( A ) == m の時、この時に限り A は正則行列であり、逆行列 A^(-1) が存在する。
	#
	#    m x n 行列 A と n x m 行列 B について、
	#
	#      rank( A ) + rank( B ) - m <= rank( AB ) <= min( rank( A ) , rank( B ) )
	#        
	#    m x n 行列 A と n x k 行列 B について、
	#
	#      rank( B ) == n であれば、 rank( AB ) == rank( A )
	#
	#    m x n 行列 A と k x m 行列 B について、
	#
	#      rank( B ) == m であれば、 rank( BA ) == rank( A )
	#
	#
	#    行列 X と Y が共に正則で、行列 A との間に
	#
	#      XAY == [ E , 0 ]
	#             [ 0 , 0 ]
	#
	#    が成立する時、この時に限り、
	#
	#      rank( A ) == rows( E ) == cols( E ) == r        ( E は r x r の単位行列 )
	#
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	
	my $um = ( $m->forward_elimination() )[0] ;
	my $cols = $um->cols() ;

	my $r = 0 ;
	foreach my $c ( 0 .. ( $cols - 1 ) ) {
		$r++	unless ( $um->rvector( $c )->is_zero_vector() ) ;
	}

	return $r ;
}

#-------------------------------------------------------------------------------
#
# 逆行列
#
#-------------------------------------------------------------------------------

=head2 inverse

Return the inverse matrix if exists.

If the matrix A has inverse matrix, at least A is a square matrix.


If the matrix A is a diagonal matrix,

  A == [ a11 , a12 , a13 ] == [ a11 ,   0 ,   0 ]
       [ a21 , a22 , a23 ]    [   0 , a22 ,   0 ]
       [ a31 , a32 , a33 ]    [   0 ,   0 , a33 ]

  inverse( A ) == [ inverse( a11 ) ,              0 ,              0 ]
                  [              0 , inverse( a22 ) ,              0 ]
		  [              0 ,              0 , inverse( a33 ) ]


If the matrix U is a unitary matrix,

  inverse( U ) == adoint( U ) == conj( transpose( U ) )

=cut

sub inverse {
	#-----------------------------------------------------------------------
	#
	# 逆行列
	#
	#   逆行列を求めるにはいくつかの手法がある。
	#
	#   1. ガウスの消去法 ( 掃き出し法 )
	#
	#      比較的規模の小さい行列であれば、ガウスの消去法で十分。
	#
	#      ガウスの消去法は、連立方程式の解法として知られている。
	#      ガウスの消去法で逆行列を求める際には、サイズが同じ単位行列を列方向に追加したものを用意する。
	#      これに対して前方消去と後退代入を適用し、元の行列の範囲を単位行列に変換する。
	#      この処理が完了すると、元は単位行列であった範囲に逆行列が形成される。
	#
	#   2. LF 法
	#
	#      LF 法を用いると、
	#
	#        B[1]   == A                            -> p[1]   == 1/1     * trace( B[1] )
	#        B[2]   == A * ( B[1] - p[1] * E )      -> p[2]   == 1/2     * trace( B[2] )
	#        ..............................................................................
	#        B[n-1] == A * ( B[n-2] - p[n-2] * E )  -> p[n-1] == 1/(n-1) * trace( B[n-1] )
	#        B[n]   == A * ( B[n-1] - p[n-1] * E )  -> p[n]   == 1/n     * trace( B[n] )
	#
	#        inverse( A ) == 1/p[n] * ( B[n-1] - p[n-1] * E )
	#
	#      となる。
	#
	#   3. LU 分解
	#
	#      行列を LU 分解することができれば、ガウスの消去法によって L と U の逆行列を求め、
	#      その乗算によって結果を得ることができる。
	#
	#      行列 A が A == LU と分解できるとすると、
	#
	#        A * inverse( A ) == LU * inverse( A ) == E
	#        ->  inverse( A ) == inverse( LU )
	#                         == inverse( U ) * inverse( L )
	#      となる。
	#
	#      単純な LU 分解は、ガウスの消去法と同じ手順をより多くのコストを掛けて行っているに過ぎず、
	#      演算コストの低減にはつながらない。 ( L や U を再利用できるというメリットはあるかもしれないが。 )
	#
	#      この手法は、コレスキー分解や QR 分解を利用した手法の理論的な支柱になっているということに
	#      その価値があるのかもしれない。
	#
	#
	#   4. コレスキー分解
	#
	#      対称行列の場合はガウスの消去法の前処理としてコレスキー分解を使用することができる。
	#      この場合も、 コレスキー分解から得られた L の転置行列と D のそれぞれの逆行列が必要となる。
	#      D は対角行列であり、その逆行列は対角成分をそれ自身の逆数で置き換えたものとなる。
	#      L は下三角行列であり、その転置は上三角行列 ( U ) となる。
	#
	#      行列 A が対称行列である場合、コレスキー分解によって
	#
	#        A == L * D * adjoint( L )
	#        -> inverse( A ) == inverse( L * D * adjoint( L ) )
	#                        == inverse( adjoint( L ) ) * inverse( D ) * inverse( L )
	#      となる。
	#
	#      巨大な疎行列 ( スパース行列 ) の場合は、不完全コレスキー法が有効な場合がある。
	#
	#
	#   5. QR 分解
	#
	#      QR 分解は行列を直交行列 Q と上三角行列 R に分解する手法。
	#
	#      LU 分解では上三角行列は upper triangular matrix の頭文字 U で表現されるが、
	#      QR 分解では right triangular matrix の頭文字 R で表現される。 ( 両者の意味するところは同じ。)
	#
	#      直交行列 Q の逆行列は転置行列に等しい。
	#
	#        Q * adjoint( Q ) == Q * inverse( Q ) == E
	#
	#      行列を直交行列 Q と上三角行列 R に分解できれば、逆行列を求める演算は以下のようになる。
	#
	#        A * inverse( A ) == QR * inverse( A ) == E
	#        ->  inverse( A ) == inverse( QR )
	#                         == inverse( R ) * inverse( Q )
	#                         == inverse( R ) * adjoint( Q )
	#
	#      R は上三角行列なので、ガウスの消去法における前方消去が既に完了している状態と言える。
	#      ガウスの消去法では前方消去の方がコストが高いため、これ自体も処理コストの低減につながるものと考えられる。
	#
	#-----------------------------------------------------------------------
	my( $m , $opts ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	#return undef	unless ( $m->det() ) ;

	my $obj = undef ;

	if ( $m->is_diagonal_matrix() ) {
		#
		# 対角行列の逆行列は、各対角成分をそれ自身の逆数で置き換えたものとなる。
		#
		$obj = $m->copy() ;
		foreach my $i ( 0 .. ( $m->rows() - 1 ) ) {
			$obj->[ $i ]->[ $i ] = $m->[ $i ]->[ $i ]->inverse() ;
		}
	}
	elsif ( $m->is_symmetric_matrix() ) {
		#
		# 対称行列であればコレスキー分解を試す。
		#
		my $ic = ( defined $opts and ( defined $opts->{'ic'} or defined $opts->{'sparse'} ) )
			? 1
			: 0
		;

		if ( my( $l , $d ) = $m->cholesky( $ic ) ) {
			#
			# 対角行列の逆行列
			#
			foreach my $i ( 0 .. ( $d->rows() - 1 ) ) {
				$d->[ $i ]->[ $i ] = $d->[ $i ]->[ $i ]->inverse() ;
			}

			#
			# 逆行列を生成
			#
			$obj	= $l->adjoint()->gaussian_inverse()
				* $d
				* $l->gaussian_inverse()
			;
		}
	}
	elsif ( $m->is_unitary_matrix() ) {
		#
		# ユニタリー行列であれば随伴行列が逆行列となる。
		# 元の行列が実行列であれば、これは直交行列であり、逆行列は転置行列となる。
		#
		$obj = $m->adjoint() ;
	}

	unless ( defined $obj ) {
		if ( my( $q , $r ) = $m->householder_qr() ) {
			#
			# QR 法が有効であれば、その結果を利用する。
			#
			#   A == QR
			#   -> inverse( A ) == inverse( R ) * inverse( Q )
			#                   == inverse( R ) * adjoint( Q )
			#
			$obj = $r->gaussian_inverse() * $q->adjoint() ;
		}
		else {
			#
			# LF 法
			#
			$obj = $m->lf_inverse() ;
		}

		unless ( defined $obj ) {
			#
			# ガウスの消去法
			#
			$obj = $m->gaussian_inverse() ;
		}
	}

	return $obj ;
}

=head2 pseudo_inverse

Return the pseudo inverse matrix.

The matrix A is or is not a square matrix, the pseudo inverse matrix about A can be defined.

The pseudo inverse matrix has some features.

  A is a m x n matrix.
  P == pseudo_inverse( A )

Then,

  A * P * A == A
  P * A * P == P

  adjoint( A * P ) == A * P
  adjoint( P * A ) == P * A

  pseudo_inverse( P ) == A

  pseudo_inverse( transpsose( A ) )     == transpose( P )
  pseudo_inverse( A * transpsose( A ) ) == transpose( P ) * P

  P == pseudo_inverse( transpose( A ) * A ) * transpose( A )
    == transpose( A ) * pseudo_inverse( A * transpose( A ) )

  A == U * S * transpose( V )
  -> P == V * pseudo_inverse( S ) * transpose( U ) 

=cut

sub pseudo_inverse {
	#-----------------------------------------------------------------------
	#
	# 擬似逆行列 ( pseudo-inverse matrix ; 擬逆行列 )
	#
	#   特異値分解を使用して擬似逆行列を求める。
	#
	#   数学の表記では、逆行列が行列記号の右肩に '-' を付けて表現されるのに対して、
	#   擬似逆行列では右肩に '+' を付けて表現する。
	#
	#   行列 A が正則であれば擬似逆行列は逆行列となる。
	#   A が正則でなくても演算が失敗することはない。
	#
	#   どのような行列からも解を導くことができることから、擬似逆行列は逆行列の概念を一般化したものとなる。
	#   このため、一般化逆行列や一般逆行列とも呼ばれる。
	#
	#
	#   擬似逆行列には以下のような特徴がある。
	#   ( 行列 A に対する擬似逆行列を pinv( A ) で表す。 )
	#
	#     1. 擬似逆行列は広義の可逆元である。
	#
	#        A * pinv( A ) * A == A
	#        pinv( A ) * A * pinv( A ) == pinv( A )
	#
	#     2. 行列とその擬似逆行列との積はエルミート行列 ( 対称行列 ) となる。
	#
	#        adjoint( A * pinv( A ) ) == A * pinv( A )
	#        adjoint( pinv( A ) * A ) == pinv( A ) * A
	#
	#     3. 擬似逆行列の擬似逆行列は元の行列に戻る。
	#
	#        pinv( pinv( A ) ) == A
	#
	#     4. 転置
	#
	#        pinv( transpose( A ) )     == transpose( pinv( A ) )
	#        pinv( A * transpose( A ) ) == transpose( pinv( A ) ) * pinv( A )
	#
	#        pinv( A ) == pinv( transpose( A ) * A ) * transpose( A )
	#                  == transpose( A ) * pinv( A * transpose( A ) )
	#
	#     5. ランク
	#
	#        rank( A ) == rank( B )
	#                  == n -> pinv( A * B )
	#                  == pinv( B ) * pinv( A )
	#
	#        任意の m x n 行列 A に対して、
	#
	#          rank( A ) == m -> pinv( A )
	#                    == transpsoe( A ) * inverse( A * transpose( A ) )
	#          rank( A ) == n -> pinv( A )
	#                    == inverse( transpose( A ) * A ) * transpose( A )
	#
	#     6. 特異値分解との関係
	#
	#        A == U * S * transpose( V )
	#        -> pinv( A ) == V * pinv( S ) * transpose( U )
	#
	#     7. 連立一次方程式 Ax = b に対して、
	#
	#        A が正方正則行列 ( rank( A ) == m == n ) の場合、
	#
	#          x == inv( A ) * b
	#
	#        A が正方正則行列でない ( rank( A ) < m or rank( A ) < n ) 場合、
	#
	#          x == pinv( A ) * b + ( E - pinv( A ) * A ) * k
	#
	#          m > n ( 解に対して式が多い ) 場合には、 pinv( A ) == inv( transpose( A ) * A ) * transpose( A ) と置く。
	#          これは解の誤差を最小にするための処置。
	#
	#          m < n ( 解に対して式の数が不足している ) 場合には、 pinv( A ) == tranpose( A ) * inv( A * transpose( A ) ) と置く。
	#          これは、 norm( x ) を最小にするための処置。
	#
	#     8. スカラー
	#
	#        スカラーに擬似逆行列の概念を適用することもできる。
	#        この場合、逆行列と擬似逆行列では 0 の扱いが異なる。
	#
	#        スカラー 0 の逆行列は不定だが、擬似逆行列は 0 と定義される。
	#        それ以外の値はどちらもその逆数となる。
	#
	#     9. ベクトル
	#
	#        零ベクトルの擬似逆行列は、零ベクトルの転置ベクトルとなる。 ( 行列の向きが入れ替わる。 )
	#        それ以外のベクトルの擬似逆行列は、以下のようになる。
	#
	#          pinv( x ) == inverse( adjoint( x ) * x ) * adjoint( x )
	#
	#        これは、「ベクトルの大きさの二乗で割られた随伴ベクトル ( 転置ベクトル ) 」を意味する。
	#
	#
	#    10. 逆元としての性質
	#
	#        m x n 行列 A の列が線形独立である場合、m >= n であり、 adjoint( A ) * A が可逆となる。
	#        ここから、
	#
	#          pinv( A ) == inverse( adjoint( A ) * A ) * adjoint( A )
	#          -> pinv( A ) * A == En
	#
	#        であり、擬似逆行列は左逆元となる。
	#        En は n 次の単位行列
	#
	#        m x n 行列 A の行が線形独立である場合、m <= n であり、 A * adjoint( A ) が可逆となる。
	#        ここから、
	#
	#          pinv( A ) == adjoint( A ) * inv( A * adjoint( A ) )
	#          -> A * pinv( A ) == Em
	#
	#        であり、擬似逆行列は右逆元となる。
	#        Em は m 次の単位行列
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	#
	# 特異値分解
	#
	my( $u , $s , $v ) = $self->svd() ;

	#
	# 対角行列 $s の成分をそれ自身の逆数で置き換えた後、 $s をその転置行列で置き換える。
	#
	# これは対角行列 $s をその擬似逆行列で置き換えていることになる。
	#
	return undef	unless ( defined $s ) ;
	my $st = $s->copy() ;
	foreach my $i ( 0 .. ( $st->rows() - 1 ) ) {
		next	unless ( defined $st->[ $i ] ) ;
		next	unless ( defined $st->[ $i ]->[ $i ] ) ;
		unless ( $st->[ $i ]->[ $i ] == 0 ) {
			my $v = $st->[ $i ]->[ $i ] ;
			$v = $v->inverse() ;
			$st->[ $i ]->[ $i ] = $v ;
		}
	}
	$st = $st->transpose() ;

	#
	# 擬似逆行列
	#
	my $obj = $v * $st * $u->adjoint() ;
	
	return $obj ;
}

=head2 gaussian_inverse

Return the inverse matrix, using by the Gaussian eliminatoin.

  
  A == [ 1 , 2 , 3 ]
       [ 4 , 5 , 6 ]
       [ 7 , 8 , 0 ]


  -> B == [ 1 , 2 , 3 , 1 , 0 , 0 ]
          [ 4 , 5 , 6 , 0 , 1 , 0 ]
          [ 7 , 8 , 0 , 0 , 0 , 1 ]

  -> C == forward_elimination( B )   == [  1 ,  2 ,  3 ,     1 ,    0 ,    0 ]
                                        [  0 ,  1 ,  2 ,   4/3 , -1/3 ,    0 ]
                                        [  0 ,  0 ,  1 ,  -1/9 ,  2/9 , -1/9 ]

  -> D == backward_substitution( C ) == [  1 ,  0 ,  0 , -16/9 ,  8/9 , -1/9 ]
                                        [  0 ,  1 ,  0 ,  14/9 , -7/9 ,  2/9 ]
					[  0 ,  0 ,  1 ,  -1/9 ,  2/9 , -1/9 ]
 

  inverse( A ) == [ -16/9 ,  8/9 , -1/9 ]
                  [  14/9 , -7/9 ,  2/9 ]
		  [  -1/9 ,  2/9 , -1/9 ]

If the diagonal elements of the left side of matrix C has one or more zero value, then det( A ) == 0 and the matrix A does not have a inverse matrix.

If the left side of matrix D is not a unit matrix, the matrix A does also not have a inverse matrix.

=cut

sub gaussian_inverse {
	#-----------------------------------------------------------------------
	#
	# ガウスの消去法による逆行列
	#
	#   例として、以下の行列の逆行列を求める。
	#
	#     A == [ 1 , 2 , 3 ]
	#          [ 4 , 5 , 6 ]
	#          [ 7 , 8 , 0 ]
	#
	#   まず、 A と同サイズの単位行列で列方向に拡張した B を定義する。
	#
	#     B == [ 1 , 2 , 3 , 1 , 0 , 0 ]
	#          [ 4 , 5 , 6 , 0 , 1 , 0 ]
	#          [ 7 , 8 , 0 , 0 , 0 , 1 ]
	#
	#   これをガウスの消去法に掛けると、以下のような結果が得られる。
	#
	#     gaussian_elimination( B ) == [ 1 , 0 , 0 , -16/9 ,  8/9 , -1/9 ]
	#                                  [ 0 , 1 , 0 ,  14/9 , -7/9 ,  2/9 ]
	#                                  [ 0 , 0 , 1 ,  -1/9 ,  2/9 , -1/9 ]
	#
	#   この行列の右方向に現れている正方行列が A の逆行列であり、
	#
	#     inverse( A ) == A^(-1) == [ -16/9 ,  8/9 , -1/9 ]
	#                               [  14/9 , -7/9 ,  2/9 ]
	#                               [  -1/9 ,  2/9 , -1/9 ]
	#
	#   となる。
	#
	#   なお、
	#
	#     A == [ 1 , 2 , 3 ] -> B == [ 1 , 2 , 3 , 1 , 0 , 0 ]
	#          [ 4 , 5 , 6 ]         [ 4 , 5 , 6 , 0 , 1 , 0 ]
	#          [ 7 , 8 , 9 ]         [ 7 , 8 , 9 , 0 , 0 , 1 ]
	#
	#   をガウスの消去法の前方消去に掛けると、
	#
	#     forward_elimination( B ) == [  1 ,  2 ,  3 ,   1 ,    0 , 0 ]
	#                                 [  0 ,  1 ,  2 , 4/3 , -1/3 , 0 ]
	#                                 [  0 ,  0 ,  0 ,   1 ,   -2 , 1 ]
	#
	#   となり、左側の正方行列の対角に 0 が現れる。
	#   これは、 A の行列式 det( A ) が
	#
	#     det( A ) == 0
	#
	#   になることを示しており、A に逆行列が存在しないことの証となる。
	#
	#   行列式 det( A ) の値は、前方消去の過程で導くことができる。
	#   forward_elimination メソッドは、戻り値として変換後の行列と det( A ) を返すように実装されており、
	#   この値を検査することで逆行列の有無を判断することができる。
	#
	#   ちなみに、 det( A ) == 0 となった上記の B を前方消去した行列 B' を後退代入に掛けると、
	#
	#     backward_substitution( B' ) == [  1 ,  0 , -1 , -5/3 ,  2/3 , 0 ]
	#                                    [  0 ,  1 ,  2 ,  4/3 , -1/3 , 0 ]
	#                                    [  0 ,  0 ,  0 ,    1 ,   -2 , 1 ]
	#
	#   となる。
	#   左側の行列が単位行列になっておらず、右側の行列は逆行列ではない。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_square_matrix() ) ;

	#
	# 元の行列と単位行列を合成した行列を作成。
	#
	my $m = $self->copy()->expand_columns( $self->E() ) ;
	
	#
	# ガウスの消去法に掛ける。
	#
	my $det = undef ;
	( $m , $det ) = $m->forward_elimination() ;	# 前進消去
	return undef	if ( $det == 0 ) ;		# 行列式が 0 であれば逆行列は存在しない。
	$m = $m->backward_substitution() ;		# 後退代入
	
	#
	# ガウスの消去法の結果を左右に分割し、右側の正方行列を返す。
	#
	my $r = $self->zero_matrix() ;			# 元の行列と同サイズの零行列で初期化

	my( $rows , $cols ) = $m->size() ;
	my @c = ( $self->cols() , ( $cols - 1 ) ) ;
	foreach my $i ( 0 .. ( $rows - 1 ) ) {
		$r->[ $i ] = [ @{ $m->[ $i ] }[ $c[0] .. $c[1] ] ] ;
	}

	return $r ;
}

=head2 lf_inverse

Return the inverse matrix, using by LF method.

If the matrix A is a n x n matrix, and it has a inverse matrix,

  n == rows( A )
  B[1]   == A                                 -> p[1] == 1/1        * trace( B[1] )
  B[2]   == A * B[1] - p[1] * E )             -> p[2] == 1/2        * trace( B[2] )
  ..................................................................................
  B[n-1] == A * B[n-2] - p[n-2] * E )         -> p[n-1] == 1/(n-1)  * trace( B[n-1] )
  B[n]   == A * B[n-1] - p[n-1] * E )         -> p[n]   == 1/n      * trace( B[n] )


  inverse( A ) == 1/p[n] * ( B[n-1] - p[n-1] * E )

=cut

sub lf_inverse {
	#-----------------------------------------------------------------------
	#
	# LF 法による逆行列
	#
	#   B[1]   == A                            -> p[1]   == 1/1     * trace( B[1] )
	#   B[2]   == A * ( B[1] - p[1] * E )      -> p[2]   == 1/2     * trace( B[2] )
	#   ..............................................................................
	#   B[n-1] == A * ( B[n-2] - p[n-2] * E )  -> p[n-1] == 1/(n-1) * trace( B[n-1] )
	#   B[n]   == A * ( B[n-1] - p[n-1] * E )  -> p[n]   == 1/n     * trace( B[n] )
	#
	#   inverse( A ) == 1/p[n] * ( B[n-1] - p[n-1] * E )
	#
	#-----------------------------------------------------------------------
	my( $am ) = @_ ;
	return undef	unless ( ref( $am ) eq __PACKAGE__ ) ;
	return undef	unless ( $am->is_square_matrix() ) ;

	my $n = $am->rows() ;

	my $bm = [ $am->copy() ] ;
	my $um = $am->unit_matrix() ;

	my $p = [ $bm->[0]->trace() ] ;

	foreach my $r ( 2 .. $n ) {

		push( @{ $bm } , $am * ( $bm->[-1] - $p->[-1] * $um )	) ;
		push( @{ $p }  , $bm->[-1]->trace() / $r		) ;

		shift( @{ $bm } )	if ( @{ $bm } > 2 ) ;
		shift( @{ $p } )	if ( @{ $p }  > 2 ) ;
	}

	return undef	if ( $p->[1] == 0 ) ;

	my $inv = ( $bm->[0] - $p->[0] * $um ) / $p->[1] ;

	return $inv ;
}

=head1 'Vector' object - decompsition methods.

=cut

#-------------------------------------------------------------------------------
#
# LU 分解
#
#-------------------------------------------------------------------------------

=head2 lu_decomposition

  A == [ a11 , a12 , a13 ] -> LU == [ 1   , 0   , 0   ] * [ u11 , u12 , u13 ]
       [ a21 , a22 , a23 ]          [ l21 , 1   , 0   ]   [ 0   , u22 , u23 ]
       [ a31 , a32 , a33 ]          [ l31 , l32 , 1   ]   [ 0   , 0   , u33 ]



  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  ( $l , $u ) = $m->lu_decomposition() ;

  print $l ;                                           # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              4.00000 ,              1.00000 ,              0.00000 ]
						       # [              7.00000 ,              2.00000 ,              1.00000 ]

  print $u ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              0.00000 ,             -3.00000 ,             -6.00000 ]
						       # [              0.00000 ,              0.00000 ,              0.00000 ]

  print $l * $u ;                                      # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              9.00000 ]



=cut

sub lu_decomposition {
	#-----------------------------------------------------------------------
	#
	# LU 分解 ( LU Decomposition )
	#
	#   A == [ a11 , a12 , a13 ] -> LU == [ 1   , 0   , 0   ] * [ u11 , u12 , u13 ]
	#        [ a21 , a22 , a23 ]          [ l21 , 1   , 0   ]   [ 0   , u22 , u23 ]
	#        [ a31 , a32 , a33 ]          [ l31 , l32 , 1   ]   [ 0   , 0   , u33 ]
	#
	#   A の成分は、 L と U の成分を用いて
	#
	#     A == [ u11       , u12                   , u13                         ]
	#          [ l21 * u11 , l21 * u12 + u22       , l21 * u13 + u23             ]
	#          [ l31 * u11 , l31 * u12 + l32 * u22 , l31 * u13 + l32 * u23 + u33 ]
	#
	#   となる。
	#
	#   A[0] = A とおいて、変換過程を表すと
	#
	#   A[1] == [ u11             , u12                               , u13                                     ]
	#           [ l21 * u11 / u11 , l21 * u12 + u22 - l21 * u12       , l21 * u13 + u23 - l21 * u13             ]
	#           [ l31 * u11 / u11 , l31 * u12 + l32 * u22 - l31 * u12 , l31 * u13 + l32 * u23 + u33 - l31 * u13 ]
	#
	#        == [ u11             , u12                               , u13                                     ]
	#           [ l21             , u22                               , u23                                     ]
	#           [ l31             , l32 * u22                         , l32 * u23 + u33                         ]
	#
	#   A[2] == [ u11 , u12             , u13                         ]
	#           [ l21 , u22             , u23                         ]
	#           [ l31 , l32 * u22 / u22 , l32 * u23 + u33 - l32 * u23 ]
	#
	#        == [ u11 , u12 , u13 ]
	#           [ l21 , u22 , u23 ]
	#           [ l31 , l32 , u33 ]  
	#
	#   と言う流れになる。
	#   これは、左上方から右下方へ部分行列を辿りながら処理することに等しく、精度と効率の面で非常にバランスのよい手法となっている。
	#
	#   変換の過程で u[c,c] == 0 が出現すると演算が破綻するが、ピボット選択による行交換を行うことでこれを回避することができる。
	#
	#
	#
	#   積和演算式での表現
	#
	#     変換元の行列 A は、
	#
	#       A == LU
	#       -> A[r,c] == Σ( L[r,k] * U[k,c] )                     ( k == 1 -> n )
	#
	#     で表すことができる。
	#     これを対角成分で上下に分けて記述すると、
	#
	#       A[r,c] == L[r,c] * U[c,c] + Σ( L[r,k] * U[k,c] )      ( k == 1 -> c - 1 ; r >  c )
	#
	#       A[r,c] == L[r,r] * U[r,c] + Σ( L[r,k] * U[k,c] )      ( k == 1 -> r - 1 ; r <= c )
	#              ==          U[r,c] + Σ( L[r,k] * U[k,c] )      ( k == 1 -> r - 1 ; r <= c )
	#
	#     と表現でき、ここから、
	#
	#     下三角成分は、
	#
	#                   A[r,c] - Σ( L[r,k] * U[k,c] )
	#       L[r,c] == ----------------------------------           ( k == 1 -> c - 1 ; r >  c )
	#                             U[c,c]
	#
	#     上三角成分は、
	#
	#       U[r,c] == A[r,c] - Σ( L[r,k] * U[k,c] )               ( k == 1 -> r - 1 ; r <= c )
	#
	#     となる。
	#
	#     この演算式を基にしたロジックを組むこともできるが、
	#       ・多数の積和演算が使い捨てになる。
	#       ・除算が多く発生する。
	#       ・ピボット選択の制御が複雑になる。
	#     など、演算コストと精度の双方でデメリットが多くなる。
	#
	#
	#   LU 分解による連立一次方程式の解法
	#
	#     Ax == y でベクトル x を求める。
	#
	#       Ax == y
	#       -> LUx == y
	#
	#     Ux == c と言うベクトルになることから、
	#
	#       Lc == y
	#       c == inverse( L ) * y == Ux
	#
	#       -> x == inverse( U ) * inverse( L ) * y
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless( $self->is_square_matrix() ) ;

	my $m = $self->copy() ;
	my $pvtr = [] ;

	my $rows = $m->rows() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		#
		# ピボット選択
		#
		#   対角成分が 0 またはこれに近い値の場合、 L 成分の演算で零除算を発生させてしまう。
		#   このため、現在行の対角成分と同じ列を後続の行で検索し、絶対値最大の値を持つ行と差し替える。
		#
		#   この成分は、元の行列 A の成分を構成する上で何の意味も持っていないため、無視することができる。
		#
		if ( $m->[ $r ]->[ $r ]->round( 15 ) == 0 ) {
			last   if ( $r >= ( $rows - 1 ) ) ;
			my $ix = (
				sort { $m->[ $b ]->[ $r ]->abs() <=> $m->[ $a ]->[ $r ]->abs() }
				( $r + 1 .. ( $rows - 1 ) )
			)[0] ;

			#
			# 行交換を行い、ピボット選択の実績を記録
			#
			unless ( $r == $ix ) {
				( $m->[ $r ] , $m->[ $ix ] ) = ( $m->[ $ix ] , $m->[ $r ] ) ;
				unshift( @{ $pvtr } , [ $r , $ix ] ) ;
			}
		}

		#
		# 現在選択している対角成分の列方向に非零成分が存在しない場合、
		# この行と列を使用した分解は既に完了していることになる。
		#
		next    if ( $m->[ $r ]->[ $r ]->round( 15 ) == 0 ) ;

		#
		# 現在選択している対角成分を基点とする部分行列を変換する。
		#
		foreach my $r1 ( ( $r + 1 ) .. ( $rows - 1 ) ) {
			#
			# 部分行列の左端成分
			#
			#   A[ r1 , r ] /= A[ r , r ]                  ( r1 == r + 1 -> n )
			#
			$m->[ $r1 ]->[ $r ] /= $m->[ $r ]->[ $r ] ;

			#
			# その他の成分 ( 行ベクトルの右方向の成分 ) 
			#
			#   A[ r1 , c ] -= A[ r1 , r ] * A[ r , c ]    ( r1 == r + 1 -> n , c == r + 1 -> n )
			#
			foreach my $c ( ( $r + 1 ) .. ( $rows - 1 ) ) {
				$m->[ $r1 ]->[ $c ] -= $m->[ $r1 ]->[ $r ] * $m->[ $r ]->[ $c ] ;
			}
		}
	}

	#
	# ピボット選択によって交換された行を戻す。
	#
	foreach my $p ( @{ $pvtr } ) {
		( $m->[ $p->[0] ] , $m->[ $p->[1] ] ) = ( $m->[ $p->[1] ] , $m->[ $p->[0] ] ) ;
	}

	#
	# L と U に分離
	#
	my $lm = $m->unit_matrix() ;
	my $um = $m->zero_matrix() ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		#
		# 対角成分は U に格納
		#
		$um->[ $r ]->[ $r ] = $m->[ $r ]->[ $r ] ;

		#
		# 上下の成分を振り分ける。
		#
		foreach my $c ( 0 .. ( $r - 1 ) ) {
			$lm->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;	# B[r,c] は下三角成分
			$um->[ $c ]->[ $r ] = $m->[ $c ]->[ $r ] ;	# B[c,r] ( B[r,c] の対称成分 ) は上三角成分
		}
	}

	return ( $lm , $um ) ;
}

sub lu_decomp { return lu_decomposition( @_ ) ; }

=head2 ldu_decomposition

  A == [ a11 , a12 , a13 ] -> LDU == [ 1   , 0   , 0   ] * [ d11 , 0   , 0   ] * [ 0   , u12 , u13 ]
       [ a21 , a22 , a23 ]           [ l21 , 1   , 0   ]   [ 0   , d22 , 0   ]   [ 0   , 0   , u23 ]
       [ a31 , a32 , a33 ]           [ l31 , l32 , 1   ]   [ 0   , 0   , d33 ]   [ 0   , 0   , 0   ]

If det( A ) == 0, the LDU decomposition will be failed.


  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 0 ] ,
  ) ;

  ( $l , $d , $u ) = $m->ldu_decomposition() ;

  print $l ;                                           # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              4.00000 ,              1.00000 ,              0.00000 ]
						       # [              7.00000 ,              2.00000 ,              1.00000 ]

  print $d ;                                           # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,             -3.00000 ,              0.00000 ]
						       # [              0.00000 ,              0.00000 ,             -9.00000 ]

  print $u ;                                           # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              2.00000 ]
						       # [              0.00000 ,              0.00000 ,              1.00000 ]

  print $l * $d * $u ;                                 # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              0.00000 ]


=cut

sub ldu_decomposition {
	#-----------------------------------------------------------------------
	#
	# LDU 分解
	#
	#  A == LDU
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless( $self->is_square_matrix() ) ;

	#
	# LU 分解
	#
	my( $lm , $um ) = $self->lu_decomposition() ;
	return ()	unless ( defined $lm ) ;
	return ()	unless ( defined $um ) ;

	#
	# U の対角から D を生成
	#
	my $dm = $um->diag2matrix() ;

	#
	# U の対角を 1 にする。 ( 行ごとに対角成分で行全体を除算 )
	#
	my $um_rows = $um->rows() ;
	foreach my $r ( 0 .. ( $um_rows - 1 ) ) {
		my $d = $um->[ $r ]->[ $r ] ;
		foreach my $c ( $r .. ( $um_rows - 1 ) ) {
			$um->[ $r ]->[ $c ] /= $d ;
		}
	}

	foreach ( $lm , $dm , $um ) {
		$_ = $_->round( 15 ) ;
	}

	return ( $lm , $dm , $um ) ;
}

sub ldu_decomp { return ldu_decomposition( @_ ) ; }

sub doolittle {
	#-----------------------------------------------------------------------
	#
	# ドゥーリトル法 ( Doolittle method ) による LU 分解
	#
	#   LU 分解は LU decomposition 又は LU factorization と呼ばれるものであり、
	#   行列を下三角行列 L と上三角行列 U に分解する手法。
	#
	#     下三角行列 : lower triangular matrix
	#     上三角行列 : upper triangular matrix
	#  
	#   サイズの大きい行列ではガウスの消去法よりも効率的とされている。
	#
	#   LU 分解にはドゥーリトル法やクラウト法がある。
	#   前者は L の対角成分を 1 にして演算を行う手法であり、後者は U の対角成分を 1 にして処理する。
	#
	#   2 次の正方行列でドゥーリトル法を適用すると以下のようになる。
	#
	#     [ a , b ] -> [   1 ,  0 ] * [ a ,           b ]
	#     [ c , d ]    [ c/a ,  1 ]   [ 0 , d - c/a * b ]
	#  
	#   行列が正定値対称行列であれば、コレスキー法 ( Cholesky method ) も使用できる。
	#   コレスキー法では、
	#
	#     A == L * U == adjoint( U ) * U となる。
	#
	#
	#   n x n の正方行列を A を分解する場合、ドゥーリトル法により、
	#
	#     A == L * U 
	#     -> ( L , U ) == doolittle( A )
	#
	#   を得る。
	#
	#   A の行番号を r == 0 -> n - 1 , 列番号を c == 0 -> n - 1 と定義する。
	#   下三角成分 L[r,c] と上三角成分 U[r,c] は、以下の演算によって導出される。
	#   なお、対角成分は L に含まれるものとする。
	#
	#     r > c の時、下三角成分 L[r,c] と上三角成分 U[r,c] は、
	#
	#                   A[r,c] - Σ( L[r,k] * U[k,c] )
	#       L[r,c] == ----------------------------------         ( k == 0 -> c - 1 )
	#                            U[c,c]
	#
	#       U[r,c] == 0
	#
	#
	#     r == c の時、 L と U の対角成分は、
	#
	#       L[r,c] == L[r,r] == 1
	#
	#       U[r,c] == U[r,r] == A[r,c] - Σ( L[r,k] * U[k,c] )   ( k == 0 -> c - 1 )
	#
	#
	#     r < c の時、下三角成分 L[r,c] と上三角成分 U[r,c] は、
	#
	#       L[r,c] == 0
	#
	#       U[r,c] == A[r,c] - Σ( L[r,k] * U[k,c] )             ( k == 0 -> c - 1 )
	#
	#   となる。
	#
	#
	#   LU 分解を行う際、 U の対角成分に 0 や 0 に極めて近い値が現れると演算が不可能になったり、演算誤差が発生することになる。
	#   これを回避するためにはピボット選択を用いる必要がある。
	#   ドゥーリトル法でのピボット選択は列の交換であり、処理が完了した段階で元の列配列に戻す必要がある。
	#
	#   多次元配列で構成された行列では、行の交換は容易だが列の交換はそうではない。
	#
	#   ここでは、ピボット選択は実装していない。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless( $self->is_square_matrix() ) ;

	my $m = $self->copy() ;		# 変換元の行列
	my $lm = $m->unit_matrix() ;	# 変換元と同サイズの単位行列
	my $um = $m->zero_matrix() ;	# 変換元と同サイズの零行列

	my( $rows , $cols ) = $m->size() ;

	#
	# ドゥーリトル法は列単位の処理
	#
	foreach my $c ( 0 .. ( $cols - 1 ) ) {
		foreach my $r ( 0 .. ( $rows - 1 ) ) {
			if ( $r <= $c ) {
				#
				# U 成分 ( 上三角行列 )
				#
				#   U[r,c] = A[r,c] - Σ( L[r,k] * U[k,c] )              ( k == 0 -> c - 1 )
				#
				$um->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
				foreach my $k ( 0 .. ( $r - 1 ) ) {
					$um->[ $r ]->[ $c ] -= $lm->[ $r ]->[ $k ] * $um->[ $k ]->[ $c ] ;
				}
			}
			else {
				#
				# L 成分 ( 下三角行列 )
				#
				#               A[r,c] - Σ( L[r,k] * U[k,c] )
				#   L[r,c] == ----------------------------------        ( k == 0 -> c - 1 )
				#                         U[c,c]
				#
				#   k == 0 -> c - 1
				#
				$lm->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
				foreach my $k ( 0 .. ( $c - 1 ) ) {
					$lm->[ $r ]->[ $c ] -= $lm->[ $r ]->[ $k ] * $um->[ $k ]->[ $c ] ;
				}
				$lm->[ $r ]->[ $c ] /= $um->[ $c ]->[ $c ] ;
			}
		}
	}

	return ( $lm , $um ) ;
}

sub crout {
	#-----------------------------------------------------------------------
	#
	# クラウト法 ( Crout method ) による LU 分解
	#
	#   処理内容はドゥーリトル法と大差はない。
	#   対角成分を U に含めるため、対角成分での除算が U の側で発生する。
	#
	#   n x n の正方行列を A を分解する場合、クラウト法により、
	#
	#     A == L * U 
	#     -> ( L , U ) == crout( A )
	#
	#   を得る。
	#
	#   A の行番号を r == 0 -> n - 1 , 列番号を c == 0 -> n - 1 と定義する。
	#   下三角成分 L[r,c] と上三角成分 U[r,c] は、以下の演算によって導出される。
	#   なお、対角成分は U に含まれるものとする。
	#
	#     r > c の時、下三角成分 L[r,c] と上三角成分 U[r,c] は、
	#
	#       L[r,c] == A[r,c] - Σ( L[r,k] * U[k,c] )                       ( k == 0 -> c - 1 )
	#
	#       U[r,c] == 0
	#
	#     r == c の時、L と U の対角成分は、
	#
	#       L[r,c] == A[r,c] - Σ( L[r,k] * U[k,c] )                       ( k == 0 -> c - 1 )
	#
	#       U[r,c] == U[r,r] == 1
	#
	#     r < c の時、下三角成分 L[r,c] と上三角成分 U[r,c] は、
	#
	#       L[r,c] == 0
	#
	#                             A[r,c] - Σ( L[r,k] * U[k,c] )
	#       U[r,c] == U[r,r] == ----------------------------------         ( k == 0 -> c - 1 )
	#                                      L[r,r]
	#
	#   となる。
	#
	#   ピボット選択は実装していない。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless( $self->is_square_matrix() ) ;

	my $m = $self->copy() ;		# 変換元の行列
	my $lm = $m->zero_matrix() ;	# 変換元と同サイズの零行列
	my $um = $m->unit_matrix() ;	# 変換元と同サイズの単位行列

	my( $rows , $cols ) = $m->size() ;

	#
	# クラウト法は行単位の処理
	#
	my $pivots = {} ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		foreach my $c ( 0 .. ( $cols - 1 ) ) {
			if ( $r >= $c ) {
				#
				# L 成分 ( 下三角行列 )
				#
				#   L[r,c] = A[r,c] - Σ( L[r,k] * U[k,c] )
				#
				#   k == 0 -> c -1
				#
				$lm->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
				foreach my $k ( 0 .. ( $c - 1 ) ) {
					$lm->[ $r ]->[ $c ]	-= $lm->[ $r ]->[ $k ]
								*  $um->[ $k ]->[ $c ]
					;
				}
			}
			else {
				#
				# U 成分 ( 上三角行列 )
				#
				#   U[r,c] = ( A[r,c] - Σ( L[r,k] * U[k,c] ) ) / L[r,r] 
				#
				#   k == 0 -> r -1
				#
				$um->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
				foreach my $k ( 0 .. ( $r - 1 ) ) {
					$um->[ $r ]->[ $c ]	-= $lm->[ $r ]->[ $k ]
								*  $um->[ $k ]->[ $c ]
					;
				}
				$um->[ $r ]->[ $c ] /= $lm->[ $r ]->[ $r ] ;
			}
		}
	}

	return ( $lm , $um ) ;
}

sub cholesky_0 {
	#-----------------------------------------------------------------------
	#
	# コレスキー法 ( Cholesky method ) による LU 分解
	#
	#
	#   正定値対称行列にのみ適用可能。
	#
	#   コレスキー法では、
	#
	#     A == L * U == adjoint( U ) * U
	#
	#   となる。
	#
	#
	#   n x n の正方行列を A を分解する場合、コレスキー法により、
	#
	#     A == L * U == L * adjoint( L )
	#     -> ( L , U ) == cholesky_0( A )
	#
	#   を得る。
	#
	#   A の行番号を r == 0 -> n - 1 , 列番号を c == 0 -> n - 1 と定義する。
	#   L と U は互いに転置の関係にあるため、主処理では U を求めることとする。
	#
	#   上三角成分 U[r,c] は、以下の演算で求められる。
	#
	#     r == c の時、対角成分 U[r,c] == U[r,r] は、
	#
	#       U[r,c] == U[r,r]
	#              == ( A[r,r] - Σ( ( U[k,r] )^2 ) )^( 1/2 )
	#              == sqrt( A[r,r] - Σ( ( U[k,r] )^2 ) )                 ( k == 0 -> r - 1 )
	#
	#     r > c の時、上三角成分 U[r,c] について、
	#
	#       U[r,c] == 0
	#
	#     r < c の時、上三角成分 U[r,c] について、
	#
	#                   A[r,c] - Σ( U[k,c] * U[k,r] )
	#       U[r,c] == ----------------------------------                  ( k == 0 -> r - 1 )
	#                            U[r,r]
	#
	#   となる。
	#
	#   戻り値は、 ( adjoint( U ) , U ) となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return ()	unless( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless( $self->is_symmetric_matrix() ) ;

	my $m = $self->copy() ;		# 変換元の行列
	my $um = $m->zero_matrix() ;	# 変換元と同サイズの零行列

	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		foreach my $c ( 0 .. ( $cols - 1 ) ) {
			if ( $r == $c ) {
				#
				# U[r,r] = ( A[r,r] - Σ( ( U[k,r] )^2 ) )^( 1/2 )
				#
				# k == 0 -> r - 1
				#
				foreach my $k ( 0 .. ( $r - 1 ) ) {
					$um->[ $r ]->[ $r ] += ( $um->[ $k ]->[ $r ] ** 2 ) ;
				}
				$um->[ $r ]->[ $r ] = ( $m->[ $r ]->[ $r ] - $um->[ $r ]->[ $r ] )->sqrt() ;
			}
			elsif ( $r < $c ) {
				#
				# U[r,c] = ( A[r,c] - Σ( U[k,c] * U[k,r] ) ) / U[r,r]
				#
				# k == 0 -> r -1
				#
				$um->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
				foreach my $k ( 0 .. ( $r - 1 ) ) {
					$um->[ $r ]->[ $c ] -= ( $um->[ $k ]->[ $c ] * $um->[ $k ]->[ $r ] ) ;
				}
				return ()	if ( $um->[ $r ]->[ $r ] == 0 ) ;	# 零除算が発生する場合には undef を返す。
				$um->[ $r ]->[ $c ] /= $um->[ $r ]->[ $r ] ;
			}
		}
	}

	my $lm = $um->adjoint() ;

	return ( $lm , $um ) ;
}

sub cholesky {
	#-----------------------------------------------------------------------
	#
	# 修正コレスキー法 ( Modified Cholesky method )
	#
	#   正定値対称行列にのみ適用可能。
	#
	#   コレスキー法では、
	#
	#     A == L * U == adjoint( U ) * U
	#
	#   となるが、この場合 L に無理数が現れ、演算誤差が発生しやすくなる。
	#
	#   これを修正したものが修正コレスキー法であり、修正コレスキー法では、
	#
	#     A == LDU == LD * adjoint( L )
	#
	#   となるように演算を行う。 ( D は対角行列 )
	#
	#
	#   n x n の正方行列 A を分解する場合、コレスキー法により、
	#
	#     A == L * D * U == L * D * adjoint( L )
	#     -> ( L , D ) == cholesky( A )
	#
	#   を得る。
	#
	#   A の行番号を r == 0 -> n - 1 , 列番号を c == 0 -> n - 1 と定義する。
	#   L と U は互いに転置の関係にあるため、主処理では L と D を求めることとする。
	#
	#   下三角成分 L[r,c] と対角成分 D[r,c] == D[r,r] は、以下の演算で求められる。
	#
	#     r == 0 -> n - 1 のループをまわす際、 L[r,c] を先に処理する。
	#
	#     c <= r の時
	#
	#       L[r,c] = A[r,c] - Σ( L[r,k] * L[c,k] * D[k,k] )        ( k == 0 -> c - 1 )
	#
	#     c > r の時
	#
	#       L[r,c] == 0
	#
	#     この時、 D は常に
	#
	#       D[r,r] = 1 / L[r,r] 
	#
	#    となる。
	#
	#
	#   不完全コレスキー法 ( Incomplete Cholesky method ; IC 法 )
	#
	#     不完全コレスキー法は、大規模な疎行列を扱うためのもの。
	#     コレスキー法や修正コレスキー法で大規模な行列を扱うと処理コストが非常に高くなる。
	#     行列の非対角成分のほとんどが 0 であることが予め判っている行列 ( 疎行列 ) であれば、
	#     元の成分 0 に対応する L の成分を 0 で近似することで演算コストを抑えることができる。
	#
	#     これは、上記の演算において、
	#
	#       c <= r の時、
	#
	#         A[r,c] == 0 であれば、
	#
	#           L[r,c] == 0
	#
	#         A[r,c] != 0 であれば、
	#
	#           L[r,c] = A[r,c] - Σ( L[r,k] * L[c,k] * D[k,k] )        ( k == 0 -> c - 1 )
	#
	#     とすることで得られる。
	#
	#     不完全コレスキー法では、あくまでも近似値を求めることしかできないが、
	#     物理学の領域では疎行列が現れることが多いことから、この手法にも利用価値があるとのこと。
	#
	#
	#   戻り値は、 ( L , D ) となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $opts ) = @_ ;
	return ()	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return ()	unless ( $self->is_symmetric_matrix() ) ;

	#
	# 不完全コレスキー法を使用するかどうか。
	#
	my $ic = 0 ;
	if ( ref( $opts ) eq 'HASH' and defined $opts->{'ic'} ) {
		$ic = 1 ;
	}

	#
	# L[ r , c ] * D[ r , r ] == 1
	# -> D[ r , r ] = 1 / L[ r , r ]
	#
	# となるように演算を行う。
	#
	my $m = $self->copy() ;		# 変換元の行列
	my $lm = $m->zero_matrix() ;	# 変換元と同サイズの零行列
	my $dm = $m->zero_matrix() ;	# 変換元と同サイズの零行列

	return ()	if ( $m->[0]->[0] == 0 ) ;

	$lm->[0]->[0] = $m->[0]->[0] ;			# L[0,0] = m[0,0]
	$dm->[0]->[0] = $m->[0]->[0]->inverse() ;	# D[0,0] = 1 / m[0,0]

	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		#
		# L ( 下三角行列 )
		#
		#   L[r,c] = A[r,c] - Σ( L[r,k] * L[c,k] * D[k,k] )
		#
		#   k == 0 -> c - 1
		#
		foreach my $c ( 0 .. $r ) {
			if ( $ic == 1 ) {
				#
				# 不完全コレスキー法
				#
				# 本来は fabs( m[r,c] ) == 0 でスキップする。
				# ( このモジュールでは fabs == abs )
				#
				next	if ( $m->[ $r ]->[ $c ]->round( 5 )->abs() == 0 ) ;
			}

			$lm->[ $r ]->[ $c ] = $m->[ $r ]->[ $c ] ;
			foreach my $k ( 0 .. ( $c - 1 ) ) {
				$lm->[ $r ]->[ $c ]	-= $lm->[ $r ]->[ $k ]
							*  $lm->[ $c ]->[ $k ]
							*  $dm->[ $k ]->[ $k ]
			}
		}

		#
		# D ( 対角行列 )
		#
		#   D[r,r] = 1 / L[r,r]
		#
		return ()	if ( $lm->[ $r ]->[ $r ] == 0 ) ;
		$dm->[ $r ]->[ $r ] = $lm->[ $r ]->[ $r ]->inverse() ;		# D[ r , r ] /= ( 1 / L[ r , r ] )
	}

	return ( $lm , $dm ) ;
}

#-------------------------------------------------------------------------------
#
# QR 分解
#
#-------------------------------------------------------------------------------

=head2 householder_qr

  ( Q , R ) == househoder_qr( A ) 

  -> A == Q * R


  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;


  ( $q , $r ) = $m->householder_qr() ;

  print $q ;                                           # [              0.12309 ,              0.90453 ,             -0.40825 ]
                                                       # [              0.49237 ,              0.30151 ,              0.81650 ]
						       # [              0.86164 ,             -0.30151 ,             -0.40825 ]

  print $r ;                                           # [              8.12404 ,              9.60114 ,             11.07823 ]
                                                       # [              0.00000 ,              0.90453 ,              1.80907 ]
						       # [              0.00000 ,              0.00000 ,              0.00000 ]

  print $q * $r ;                                      # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              9.00000 ]

=cut

sub householder_qr {
	#-----------------------------------------------------------------------
	#
	# ハウスホルダー変換 ( 鏡映変換 ; reflection ) による QR 変換 ( QR 分解 )
	#
	#   戻り値は、( Q , R ) となる配列。
	#
	#   元の行列を A とすると、直交行列 Q と上三角行列 R は、
	#
	#     A == QR
	#
	#   の関係になる。
	#
	#   Q は、
	#
	#     Q = A * R ** ( -1 )
	#
	#   で得ることができる。
	#
	#   Q はハウスホルダー行列の総積の逆行列であり、ハウスホルダー行列 H[n] を使用して表現すると以下のような関係になる。
	#   ( n は A の行数 ( 正方行列なので列数も同じ ) とする。 )
	#
	#     Q == ( H[n-1] * H[n-2] .... * H[2] * H[1] ) ** ( -1 )
	#
	#     Q は直交行列なので、
	#
	#     Q == ( H[n-1] * H[n-2] .... * H[2] * H[1] ) ** ( -1 )
	#       == H[1] * H[2] .... * H[n-2] * H[n-1]
	#
	#   と簡略化できる。
	#
	#   ここでは、ハウスホルダー行列 H を求めた後 A を一気に更新するという処理を繰り返しているが、
	#   H を求める過程で A の成分を直接更新するような実装も可能とされている。
	#
	#   H を求める過程で変換を掛ける方が処理効率は上がるようだが、ロジックが見えづらくなるため、
	#   H を求めた後で更新する方式を採っている。
	#   ( この方がオブジェクトによる表現がシンプルになるような気がする。 )
	#
	# ----------------------------------------------------------------------
	my( $m , $opts ) = @_ ;
	return ()	unless ( ref( $m ) eq __PACKAGE__ ) ;

	$m = $m->copy() ;
	my( $rows , $cols ) = $m->size() ;

	return ()	unless ( $rows == $cols ) ;

	my $q = undef ;

	foreach my $c ( 0 .. ( $cols - 2 ) ) {
		#
		# 処理対象となる部分行列を取り出す。
		#
		my $mat = $m->submatrix( [ $c , $c ] , [ $rows - 1 , $cols - 1 ] ) ;

		#
		# 左端の列 ( 元の $c 列 ) をベクトルとして取り出す。
		#
		my $vec = $mat->vector( 0 ) ;
		
		#
		# ハウスホルダー行列を生成
		#
		my $h = $vec->householder() ;
		return ()	unless ( defined $h ) ;

		#
		# $h のサイズを調整
		#
		# 元の行列とサイズが一致するまで $h を拡張する。
		# 拡張に際しては、より左上方に行や列を追加する。
		# 追加する行や列の対角成分を 1 に設定し、非対角成分は全て 0 に設定する。
		#
		while ( $h->cols() < $cols ) {
			#
			# $h の先頭列に零ベクトルを列ベクトルとして挿入
			#
			my $zcv = $h->cvector( 0 )->zero_vector() ;
			$h = $h->insert_cvector( $zcv , 0 ) ;

			#
			# $h の先頭行に単位ベクトルを行ベクトルとして挿入
			#
			my $urv = $h->rvector( 0 )->unit_vector( undef , 0 ) ;
			$h = $h->insert_rvector( $urv , 0 ) ;
		}

		#
		# ハウスホルダー行列を左から掛ける。
		#
		$m = $h * $m ;
		
		#
		# Q を更新
		#
		if ( defined $q )       { $q *= $h ;    }
		else                    { $q = $h ;     }
		
	}

	return ( $q , $m ) ;
}

sub householder_q {
	#-----------------------------------------------------------------------
	#
	# ハウスホルダー分解を行い、直交行列 Q を返す。
	#
	#-----------------------------------------------------------------------
	my $qr = [ $_[0]->householder_qr() ] ;
	return ( @{ $qr } and defined $qr->[0] ) ? $qr->[0] : undef ;
}

sub householder_r {
	#-----------------------------------------------------------------------
	#
	# ハウスホルダー分解を行い、上三角行列 R を返す。
	#
	#-----------------------------------------------------------------------
	my $qr = [ $_[0]->householder_qr() ] ;
	return ( @{ $qr } and defined $qr->[1] ) ? $qr->[1] : undef ;
}

#-------------------------------------------------------------------------------
#
# 特異値分解
#
#-------------------------------------------------------------------------------

=head2 svd

The singular value decomposition

  ( U , S , V ) == svd( A )

  A == U * S * adjoint( V ) 

If det( A ) == 0, this method will fail.

Against m x n matrix A, define square matrix M and N, at first.

  M == adjoint( A ) * A
  N == A * adjoint( A )

Next, defined U and V as follows.

  U == eigen_vectors( M )
  V == eigen_vectors( N )

Next, define diagonal matrix S,

  A == U * S * adjoint( V )
  -> A * U == U * S
  -> S == adjoint( U ) * A * V

If S is not a diagonal matrix, redefine S and U, as follows.

  S = sqrt( vec2diag( eigen_values( N ) ) )

  A == U * S * adjoint( V )
  -> U == A * V * pseudo_inverse( S )




  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 0 ] ,
  ) ;

  ( $u , $s , $v ) = $m->svd() ;

  print $u ;                                           # [              0.23036 ,              0.88886 ,             -0.39607 ]
                                                       # [              0.60728 ,             -0.44934 ,             -0.65521 ]
						       # [              0.76036 ,              0.08960 ,              0.64330 ]

  print $s ;                                           # [             13.20146 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,             -0.37605 ,              0.00000 ]
						       # [              0.00000 ,              0.00000 ,             -5.43876 ]

  print $v ;                                           # [              0.60463 ,              0.74817 ,             -0.27326 ]
                                                       # [              0.72568 ,             -0.65886 ,             -0.19824 ]
						       # [              0.32836 ,              0.07843 ,              0.94129 ]

  print $u * $s * $v->adjoint() ;                      # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
						       # [              7.00000 ,              8.00000 ,              0.00000 ]


=cut

sub svd {
	#-----------------------------------------------------------------------
	#
	# 特異値分解 ( singular value decomposition )
	#
	#
	#   特異値分解においては、任意の行列 A に対して
	#
	#     M == adjoint( A ) * A
	#
	#   を考える。
	#   この M は常に半正定値行列 ( 固有値が全て 0 以上となる対称正方行列 ) となる。
	#   ( A が正方行列ですらなかったとしても。)
	#
	#   同様に、
	#
	#     N == A * adjoint( A )
	#
	#   なる N も半正定値行列となる。
	#
	#   この時、 N の固有ベクトルを列ベクトルに持つ行列 V と、 A の固有値の絶対値を対角に持つ対角行列 S を定義すると、
	#
	#     A == U * S * adjoint( V )
	#     S == adjoint( U ) * A * V
	#
	#   と表すことができる。
	#   U は、 A の固有ベクトルを列ベクトルに持つ正方行列。
	#
	#   S の成分 ( 対角成分 ) は全て正なので、その平方根を対角に持つ S2 を定義すると、
	#
	#     S == S2 * S2
	#
	#   に変換できる。
	#
	#   よって、
	#
	#     A == U * S * adjoint( V )
	#       == U * S * adjoint( V )
	#       == U * S2 * S2 * adjoint( V )
	#       == U * S2 * adjoint( V * S2 )
	#
	#   この時、 A が半正定値行列であれば、 U == V となり、
	#
	#     A == ( V * S2 ) * adjoint( V * S2 )
	#
	#   となる。
	#
	#   逆に言えば、
	#
	#     U = eigen_vectors( M ) == eigen_vectors( tranpose( A ) * A )
	#     V = eigen_vectors( N ) == eigen_vectors( A * tranpose( A ) )
	#
	#   の結果が U == V であれば、
	#
	#     A == U * S * adjoint( V )
	#       == U * S * adjoint( U )
	#     -> A * U == U * S
	#
	#   であり、固有値と固有ベクトルを同時に得ることができるということになる。
	#
	#   特異値分解では、結果として得られた U と V を比較するだけで A が半正定値行列か否かを判定することができる上、
	#   A が半正定値行列でなかったとしても演算が破綻することがないというメリットがある。
	#
	#
	#   特異値分解は一般には以下のような式で表される。
	#   ( ここでの Σ は総和ではなく、行列 S を表す。 )
	#
	#     A == U * Σ * adjoint( V )
	#
	#   ここでは、 U == $u , Σ == $s , V == $v とし、この三つを配列で返すこととする。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = $self->copy() ;
	my $tr = $obj->adjoint() ;
	my $m = $obj * $tr ;
	my $n = $tr * $obj ;

	#my( $eu , $u ) = $m->jacobi_eigen() ;
	#my( $ev , $v ) = $n->jacobi_eigen() ;
	my( $eu , $u ) = $m->eigens() ;
	my( $ev , $v ) = $n->eigens() ;

	foreach ( $eu , $ev ) {
		if ( ref( $_ ) eq __PACKAGE__ and $_->is_vector() ) {
			$_ = $_->vec2diag() ;
		}
	}

	#
	# A == U * S * adjoint( V )
	# -> S == adjoint( U ) * A * V
	#
	my $s = undef ;
	if ( defined $u and defined $v ) {
		$s = $u->adjoint() * $obj * $v ;
	}

	#
	# $s が期待した結果でなければ $n を元にして $u , $s , $v を生成する。
	#
	if ( ! defined $s or ! $s->is_diagonal_matrix() ) {
		#
		# $v が返っていない場合には $n と同サイズの単位行列とする。
		# ( おそらく $n は固有ベクトルそのものを成分に持つ対角行列。 )
		#
		$v = $n->E()	unless ( defined $v ) ;
		
		#
		# $s の対角成分を作成
		#
		#   対角行列 $ev をコピーし、対角成分をその平方根または 0 で置き換える。
		#
		return ()	unless ( defined $ev ) ;
		$s = $ev->copy() ;
		foreach my $i ( 0 .. ( $s->rows() - 1 ) ) {
			my $val = $s->[ $i ]->[ $i ] ;
			if ( $val->round( 5 ) == 0 )	{ $val = new_decimal( 0 ) ; }
			else				{ $val = ( $val->sqrt() )[0] ; }
			$s->[ $i ]->[ $i ] = $val ;
		}

		#
		# $s の擬似逆行列 $si を作成
		#
		# $si は $s の対角成分をそれ自身の逆数で置き換えたもの。
		# $s が正方行列であれば $si はその逆行列となる。
		#
		my $si = $s->copy() ;
		foreach my $i ( 0 .. ( $si->rows() - 1 ) ) {
			next	unless ( defined $si->[ $i ] ) ;
			next	unless ( defined $si->[ $i ]->[ $i ] ) ;
			next	if ( $si->[ $i ]->[ $i ] == 0 ) ;
			my $val = $si->[ $i ]->[ $i ] ;
			$val = $val->inverse() ;
			$si->[ $i ]->[ $i ] = $val ;
		}

		#
		# $u を生成
		#
		#   A == U * S * adjoint( V )
		#   -> U == A * V * inverse( S )
		#
		$u = $obj * $v * $si ;
	}

	return ( $u , $s , $v ) ;
}

=head2 'Vector' object eigens.

=cut

#-------------------------------------------------------------------------------
#
# 固有値、固有ベクトル
#
#-------------------------------------------------------------------------------

=head2 eigens

Return eigen values and eigen vectors.

If failed to calculate, this method will return empty array.


for example.

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 0 ] ,
  ) ;

  ( $e , $vec ) = $m->eigens() ;

  print $e ;                                           # [             12.12289 ]
                                                       # [             -5.73451 ]
                                                       # [             -0.38838 ]

  print $vec ;                                         # [              0.29982 ,              0.27625 ,             -0.74707 ]
                                                       # [              0.70747 ,              0.38843 ,              0.65820 ]
                                                       # [              0.63999 ,             -0.87910 ,             -0.09306 ]

In this case, the Vector object $e has three eigen values as its' elements.

The Vector object $vec is a square matrix, and it has three eigen vectors as its' column vectors.

The first vector of $vec is a eigen vector of the first elelment of $e.

  $ev = $e->vec2array() ;

  print $ev->[0] * $vec->vector( 0 ) ;                 # [              3.63474 ]     ( == 12.12289 * [ 0.29982 ] )
                                                       # [              8.57661 ]                     [ 0.70747 ]
                                                       # [              7.75855 ]                     [ 0.63999 ]

  print $m * $vec->vector( 0 ) ;                       # [              3.63474 ]     ( == [ 1 , 2 , 3 ] * [ 0,29982 ] )
                                                       # [              8.57661 ]          [ 4 , 5 , 6 ]   [ 0.70747 ]
                                                       # [              7.75855 ]          [ 7 , 8 , 0 ]   [ 0.63999 ]

  print $ev->[1] * $vec->vector( 1 ) ;                 # [             -1.58418 ]
                                                       # [             -2.22743 ]
                                                       # [              5.04118 ]

  print $m * $vec->vector( 1 ) ;                       # [             -1.58418 ]
                                                       # [             -2.22743 ]
                                                       # [              5.04118 ]

  print $ev->[2] * $vec->vector( 2 ) ;                 # [              0.29015 ]
                                                       # [             -0.25563 ]
                                                       # [              0.03614 ]

  print $m * $vec->vector( 2 ) ;                       # [              0.29015 ]
                                                       # [             -0.25563 ]
                                                       # [              0.03614 ]

The total product of eigen values equals to the determinant of the matrix.

  print $m->det() ;                                    # 27
  print $e->totoal_product() ;                         # 27
  

If the matrix A is a triangular matrix, the eigen values are equal to the diagonal elements of the matrix A.

  A == [ a11 , a12 , a13 ]
       [   0 , a22 , a23 ]
       [   0 ,   0 , a33 ]

  eigen_values( A ) == ( a11 , a22 , a33 )

  det( A ) == a11 * a22 * a33


If the matrix A is a circulant matrix, 

  ( ev , vec ) = eigens( A )             ( ev : eigen values , vec : eigen vectors )

  ev[j] == a[0]   * w[j]^0
         + a[n-1] * w[j]^1
	 + a[n-2] * w[j]^2
	 + ...............
	 + a[1]   * w[j]^(n-1)

                1
  vec[j] == --------- * transpose( [ 1 , w[j] , w[j]^2 , ...... , w[j]^(n-1) ] )        ( j == 0 -> n - 1 )
	     sqrt(n)

                          2 * PI
  ( w[j] )^k == exp( i * -------- * ( ( j * k ) % n ) )            ( j == 0 -> n - 1 , k == 0 - > n - 1 )
                            n



  A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[3] , a[2] , a[1] ] 
       [ a21 , a22 , a23 , a24 ]    [ a[1] , a[0] , a[3] , a[2] ] 
       [ a31 , a32 , a33 , a34 ]    [ a[2] , a[1] , a[0] , a[3] ] 
       [ a41 , a42 , a43 , a44 ]    [ a[3] , a[2] , a[1] , a[0] ] 

                                     2 * PI
  -> w[0] == ( w[0] )^1 == exp( i * -------- * ( 0 * 1 ) % 4 ) == exp( 0 ) == 1
                                       4

     ev[0] == a[0] * w[0]^0
            + a[3] * w[0]^1
	    + a[2] * w[0]^2
	    + a[1] * w[0]^3

	   == a[0] + a[3] + a[2] + a[1]

     vec[0] == 1/2 * [ 1 ]
                     [ 1 ]
		     [ 1 ]
		     [ 1 ]

	                             2 * PI
  -> w[1] == ( w[1] )^1 == exp( i * -------- * ( 1 * 1 ) % 4 ) == exp( i * PI/2 ) == i
                                       4

     ev[1] == a[0] * w[1]^0
            + a[3] * w[1]^1
	    + a[2] * w[1]^2
	    + a[1] * w[1]^3

	   == a[0] + ( a[3] * i ) - a[2] + ( a[1] * -i )
           == ( a[0] - a[2] ) + i * ( a[3] - a[1] )

     vec[1] == 1/2 * [ i ]
                     [ i ]
		     [ i ]
		     [ i ]
	                             2 * PI
  -> w[2] == ( w[2] )^1 == exp( i * -------- * ( 2 * 1 ) % 4 ) == exp( i * PI ) == -1
                                       4

     ev[2] == a[0] * w[2]^0
            + a[3] * w[2]^1
	    + a[2] * w[2]^2
	    + a[1] * w[2]^3

	   == a[0] - a[3] + a[2] - a[1]
           == ( a[0] + a[2] ) - ( a[3] + a[1] )

     vec[1] == -1/2 * [ 1 ]
                      [ 1 ]
		      [ 1 ]
		      [ 1 ]
	                             2 * PI
  -> w[3] == ( w[3] )^1 == exp( i * -------- * ( 3 * 1 ) % 4 ) == exp( i * 3/2 * PI ) == exp( i * -PI/2 ) == -i
                                       4

     ev[3] == a[0] * w[3]^0
            + a[3] * w[3]^1
	    + a[2] * w[3]^2
	    + a[1] * w[3]^3

	   == a[0] - ( a[3] * i ) - a[2] - ( a[1] * i )
           == ( a[0] - a[2] ) - i * ( a[3] + a[1] )

     vec[1] == -1/2 * [ i ]
                      [ i ]
		      [ i ]
		      [ i ]


Against the other n x n matrix, this method may try to apply the DKA method ( Durand-Kerner-Aberth method ) and LF method ( Leverrier-Faddeev method ).
And against the 3 x 3 matrix, also apply the Cardano method.


=cut

sub eigens {
	#-----------------------------------------------------------------------
	#
	# 行列の固有値 ( eigen value ) と固有ベクトル ( eigen vectors ) を求める。
	#
	#
	#   固有値とは、
	#
	#     Ax == λx  ( x != 0 )
	#
	#   として定義されるスカラー値 λ のことであり、 x は固有ベクトルと呼ばれる。
	#
	#   固有値は、
	#
	#     det( A - λE ) == 0
	#
	#   から導かれる多項式 ( 固有多項式 ) の解として導かれる。
	#
	#   固有値には重解や虚数解もあり得る。
	#
	# 
	#   固有値には以下のような特徴がある。
	#
	#     行列式は固有値の総積に等しい。
	#
	#       det( A ) == Π( eigen_values( A ) )
	#
	#     n x n 行列 A が三角行列であれば、固有値は A の主対角成分に等しい。
	#
	#       eigen_values( A ) == a[k,k]              ( k == 1 -> n )
	#
	#     エルミート行列 ( 対称行列 ) の固有値は全て実数となる。
	#
	#
	#   対称行列において、固有値が全て正であるものを正定値行列、全て 0 以上であるものを半正定値行列と呼ぶ。
	#   また、固有値が全て負の場合には負定値行列と呼ばれる。
	#
	#
	#   固有多項式 ( 特性多項式 )
	#
	#     固有多項式を左辺に持つ方程式は、 n x n の正方行列 A , 固有値 t , 任意のベクトル v , 単位行列 I を用いて、
	#
	#       ( tI - A ) * v == 0     ( v != 0 )
	#       -> det( tI - A ) == 0
	#
	#     と表現され、固有値は固有方程式の解として現れる。
	#
	#       A == [ 3 , -2 ]
	#            [ 1 ,  0 ]
	#
	#       -> tI - A == [ t - 3 , 2     ]
	#                    [ -1    , t - 0 ]
	#
	#       -> det( tI - A ) == ( t - 3 ) * t - 2 * ( -1 )
	#                         == t^2 - 3t + 2
	#                         == ( t - 1 )( t - 2 )
	#
	#       -> t == 1 and 2
	#
	#     二次の正方行列 A の固有方程式は、
	#
	#       det( A - λE ) == 0
	#
	#       -> det( [ a , b ] - [ λ ,  0 ] ) == det( [ a - λ ,      b ] ) == 0
	#               [ c , d ]   [  0 , λ ]           [      c , d - λ ]
	#
	#       -> ( a - λ )( d - λ ) - bc == 0
	#       -> λ^2 - ( a + d ) * λ + ad - bc == 0
	#       -> λ^2 - trace( A ) * λ + det( A ) == 0
	#
	#     と表現される。
	#     
	#     これに平方完成を適用して λ を求めると、
	#
	#       λ == ( trace( A ) ± sqrt( trace( A )^2 - 4 * det( A ) ) ) / 2
	#
	#     となり、この計算式によって固有値を求めることができる。
	#
	#
	#     n x n の正方行列に対する固有方程式を一般化すると、
	#
	#       det( tI - A ) == ( t - λ[1] ) * ( t - λ[2] ) * ..... * ( t - λ[n-1] ) * ( t - λ[n] ) == 0
	#
	#     となり、固有値 λ[k] ( k == 1 -> n ) は、この解として現れる。
	#     この時、λ[k] は重解を含む n 個の複素数値となる。 ( 代数学の基本定理 )
	#
	#
	#     二次行列 A から導出された固有多項式 p(λ) に A 自身を代入すると、
	#
	#       A^2 - trace( A ) * A + det( A ) * E == 0  ( 右辺は零行列 )
	#
	#     という方程式が得られる。
	#     これは、ケーリー・ハミルトンの定理と呼ばれている。
	#
	#
	#   対角化による固有値の導出
	#
	#     三次、四次の固有方程式にも固有値を求める公式 ( と言うよりも手順 ) が存在するが、その内容は非常に複雑なものとなる。
	#     五次以上の固有方程式には代数的な解法は存在しないとされており、固有方程式から固有値を求めることは一般には非常に困難な作業となる。
	#
	#     ただし、三角行列の行列式は主対角成分の総積に等しいことから、 A が三角行列であれば、
	#
	#       det( A ) == Π( a[k,k] ) == Π( λ[k] )    ( k == 1 -> n )
	#
	#     であり、三角行列の主対角成分はその固有値そのものとなる。
	#     このため、正方行列が対角化可能であれば、任意のサイズの正方行列の固有値を求めることができる。
	#
	#     対角化の手法としては、ガウスの消去法 ( 掃き出し法 ) における前進消去、ヤコビ法、 QR 法などが用いられる。
	#     ガウスの消去法では、固有ベクトルの導出に特化した後退代入の処理を行うことで固有ベクトルを求めることができる。
	#     ヤコビ法や QR 法の場合、演算過程で使用した変換行列を適切に管理することで固有値を求めると同時に固有ベクトルを得ることができる。
	#     ( ヤコビ法や QR 法で得られた固有値を後退代入に掛けてもよい。 )
	#
	#     比較的サイズが小さい正方行列に対しては、ガウスの消去法が有効だが、サイズが大きくなるにつれて効率が悪くなる。
	#     サイズの大きな行列に対しては QR 法が最も効率的だが、演算誤差はそれなりに大きくなる。
	#
	#   LF 法及び DKA 法による固有値、固有ベクトルの導出
	#
	#     LF 法を利用すると、任意の高次正方行列から固有多項式を導くことができる。
	#
	#     五次以上の n 次方程式には代数的な解法は存在しないとされているが、解析的な手法で解く事はできる。
	#     DKA 法は、ニュートン法を応用した数値解析による近似計算法であり、高次方程式を解く解法として非常に有用なものとなっている。
	#
	#     DKA 法を用いるには、演算の開始点となる初期値が必要となるが、固有方程式を解く場合には、元の行列の非対角成分を利用して初期値を求めることができる。
	#     ( ゲルシュゴリンの定理 )
	#
	#     固有値が確定した後、固有ベクトルを求めるには再び LF 法を利用することができる。
	#     LF 法によって固有多項式の係数を求める過程で、ある特定の変換行列が生成される。
	#     この変換行列を係数とする固有値についての n 次方程式を解くことで個々の固有値に対応する固有ベクトルが得られる。
	#
	#     他の一般的な手法では、固有値や固有ベクトルの導出において変則的な演算が必要になったり、固有ベクトルが零ベクトルとなった時の例外処理が必要になることがあるが、
	#     LF 法を基にした演算では求める値を安定的に得ることができる。
	#
	#     LF 法、 DKA 法、ゲルシュゴリンの定理を用いた導出は、固有値と固有ベクトルの導出において完全に閉じた体系を成しており、
	#     比較的簡潔で且つ洗練された手法となっている。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return ()	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return ()	unless ( $m->is_square_matrix() ) ;
	#return ()	if ( $m->det() == 0 ) ;

	$m = $m->copy() ;

	my $rows = $m->rows() ;
	my $eigen = [] ;
	my $ev = [] ;

	if ( $m->is_triangular_matrix() ) {
		#---------------------------------------------------------------
		#
		# 三角行列の固有値は対角成分そのもの
		#
		#---------------------------------------------------------------
		$eigen = $m->diag2array() ;
		$ev = $m->eigen_vectors_LF( $eigen ) ;
	}
	elsif ( $rows == 2 ) {
		#---------------------------------------------------------------
		#
		# 二次の正方行列の場合
		#
		#---------------------------------------------------------------
		$eigen = [ $m->_eigen_values_sq() ] ;
		$ev = $m->eigen_vectors_LF( $eigen ) ;
	}
	elsif ( $rows == 3 ) {
		#---------------------------------------------------------------
		#
		# 三次の正方行列の場合
		#
		#---------------------------------------------------------------
		$eigen = [ $m->_eigen_values_sarrus() ] ;
		$ev = $m->eigen_vectors_LF( $eigen ) ;
	}
	elsif ( $m->is_circulant_matrix() ) {
		#---------------------------------------------------------------
		#
		# 巡回行列の場合
		#
		#     A == [ a11 , a12 , a13 , a14 ] == [ a[0] , a[3] , a[2] , a[1] ] 
		#          [ a21 , a22 , a23 , a24 ]    [ a[1] , a[0] , a[3] , a[2] ] 
		#          [ a31 , a32 , a33 , a34 ]    [ a[2] , a[1] , a[0] , a[3] ] 
		#          [ a41 , a42 , a43 , a44 ]    [ a[3] , a[2] , a[1] , a[0] ] 
		#    
		#   巡回行列 A の成分は a[0] .. a[n-1] で尽くされる。
		#   この時、
		#
		#                       2PI
		#     w[j] == exp( i * ----- * j )         ( j == 0 -> n - 1 )
		#                        n
		#
		#   を用いて、固有値 λ[j] は、
		#
		#     λ[j] == a[0] + a[n-1] * w[j] + a[n-2] * w[j]^2 + , .... , + a[1] * w[j]^(n-1)        ( j == 0 -> n - 1 )
		#
		#           == Σ( a[i] * ( w[j] )^i )                                                      ( i == 0 -> n - 1 ; j == 0 -> n - 1 )
		#
		#   で表される。
		#
		#   w[j] の冪乗 w[j]^k は、 r == 2PI / n として、
		#
		#     w[j]^k == ( exp( i * r * j ) )^k
		#            == ( ( exp( i * r ) )^j )^k
		#            == ( exp( i * r ) )^( j * k )
		#            == exp( i * r * ( j * k ) ) 
		#            == exp( i * r * ( ( j * k ) % n ) ) 
		#
		#                         2PI
		#            == exp( i * ----- * ( ( j * k ) % n ) )
		#                          n
		#
		#   となり、巡回行列の固有値問題がフーリエ変換の一種として表現できることになる。
		#
		#   同様に固有ベクトルは、上記 w[j] を用いて
		#
		#                  1
		#     v[j] == ----------- * transpose( [ 1 , w[j] , w[j]^2 , ...... , w[j]^(n-1) ] )        ( j == 0 -> n - 1 )
		#               sqrt(n)
		#
		#   で表される。
		#
		#---------------------------------------------------------------
		my $w = [ new_complex( [ 1 , 0 ] )->circle_group( $rows ) ] ;

		my $v = $m->rvector( 0 )->as_array() ;	# v[j] == ( a[0] , a[n-1] , a[n-2] , .... , a[2] , a[1] ) ;

		my $sqn = new_decimal( $rows )->sqrt() ;
		my $vec_zero = $m->cvector( 0 )->zero_vector() ;

		foreach my $j ( 0 .. ( $rows - 1 ) ) {
			$eigen->[ $j ] = new_decimal( 0 ) ;
			my $vec = $vec_zero->copy() ;

			foreach my $c ( 0 .. ( $rows - 1 ) ) {

				my $k = ( $j * $c ) % $rows ;

				#
				# 固有値
				#
				$eigen->[ $j ] += $v->[ $c ] * $w->[ $k ] ;

				#
				# 固有ベクトルの成分
				#
				$vec->[ $c ]->[0] = $w->[ $k ] / $sqn ;
			}

			$ev->[ $j ] = $vec ;
		}
	}
	else {
		#---------------------------------------------------------------
		#
		# DKA 法を用いる。
		#
		#---------------------------------------------------------------
		
		if ( $m->is_hermitian_matrix() ) {
			#
			# エルミート行列の場合
			#
			#   三重対角化して DKA 法に掛けることで固有値を得る。
			#   固有ベクトルは LF 法で再計算する。
			#
			$eigen = $m->tridiagonalize()->eigen_values_DKA() ;
			$ev = $m->eigen_vectors_LF( $eigen )	if ( defined $eigen ) ;
		}
		else {
			#
			# 直接 DKA 法に掛ける。
			#
			( $eigen , $ev ) = $m->eigens_DKA() ;
		}
	}

	#
	# 固有値を格納した配列をベクトルに変換
	#
	if ( defined $eigen and ref( $eigen ) eq 'ARRAY' ) {
		$eigen = __PACKAGE__->new( $eigen ) ;
	}

	#
	# 固有ベクトルを格納した配列を行列に変換
	#
	if ( defined $ev and ref( $ev ) eq 'ARRAY' ) {
		$ev = vec2matrix( $ev )	;
	}

	return ( $eigen , $ev ) ;
}

sub tdma {
	#-----------------------------------------------------------------------
	#
	# 三重対角行列アルゴリズム ( TriDiagonal-Matrix Argorithm )
	#
	#   三重対角行列 A 及び A と行数が同じベクトル x , d について、
	#   機知の A , d と未知の x に
	#
	#     A * x == d
	#
	#   が成り立つ時の未知のベクトル x を求める解法。
	#
	#
	#   A == [   a[1] , - b[1] ,      0 ] 
	#        [ - c[2] ,   a[2] , - b[2] ]
	#        [      0 , - c[3] ,   a[3] ]
	#
	#   A * x == [   a[1] , - b[1] ,      0 ] * [ x[1] ] == [ d[1] ]
	#            [ - c[2] ,   a[2] , - b[2] ]   [ x[2] ]    [ d[2] ]
	#            [      0 , - c[3] ,   a[3] ]   [ x[3] ]    [ d[3] ]
	#
	#   A の行ベクトル A[1] == [ a[1] , - b[1] , 0 ] と x の積より、
	#
	#     A[1] * x == a[1] * x[1] - b[1] * x[2] + 0 * x[3] == d[1]
	#
	#     -> a[1] * x[1] == b[1] * x[2] + d[1]
	#
	#                 b[1]            d[1]
	#     -> x[1] == ------ * x[2] + ------
	#                 a[1]            a[1]
	#
	#   これを
	#
	#              b[1]            d[1]
	#     x[1] == ------ * x[2] + ------ == P[1] * x[2] + Q[1]    .... [1]
	#              a[1]            a[1]
	#
	#   とおく。
	#
	#   同様に、
	#
	#     A[2] * x == d[2]
	#
	#     -> a[2] * x[2] == b[2] * x[3] + c[2] * x[1] + d[2]
	#
	#   これに [1] を反映して、
	#
	#     a[2] * x[2] == b[2] * x[3] + c[2] * ( P[1] * x[2] + Q[1] ) + d[2]
	#
	#     -> ( a[2] - c[2] * P[1] ) * x[2] == b[2] * x[3] + c[2] * Q[1] + d[2]
	#
	#                        b[2]                      d[2] + c[2] * Q[1]
	#     -> x[2] == ---------------------- * x[3] + ---------------------- == P[2] * x[3] + Q[2]
	#                  a[2] - c[2] * P[1]              a[2] - c[2] * P[1]
	#   
	#   同じく、
	#
	#     A[3] * x == d[3]
	#
	#     -> a[3] * x[3] == c[3] * x[2] + d[3]
	#                    == c[3] * ( P[2] * x[3] + Q[2] ) + d[3]
	#
	#     -> ( a[3] - c[3] * P[2] ) * x[3] == c[3] * Q[2] + d[3]
	#
	#                  d[3] + c[3] * Q[2]
	#     -> x[3] == --------------------- == Q[3]
	#                  a[3] - c[3] * P[2]
	#
	#   整理すると、
	#   
	#     A * x == [   a[1] , - b[1] ,      0 ] * [ x[1] ] == [ d[1] ]
	#              [ - c[2] ,   a[2] , - b[2] ]   [ x[2] ]    [ d[2] ]
	#              [      0 , - c[3] ,   a[3] ]   [ x[3] ]    [ d[3] ]
	#
	#     P[1] == b[1] / a[1]
	#     Q[1] == d[1] / a[1]
	#
	#                       b[i]
	#     P[i] == ------------------------         ( i == 2 -> n )
 	#               a[i] - c[i] * P[i-1]
	#
	#               d[i] + c[i] * Q[i-1]
	#     Q[i] == ------------------------         ( i == 2 -> n )
	#               a[i] - c[i] * P[i-1]
	#
	#     x[3] == Q[3]
	#     x[2] == P[2] * x[3] + Q[2]
	#     x[1] == P[1] * x[2] + Q[1]
	#
	#   となる。
	#
	#   この流れを一般化すると、
	#
	#     a[i] * x[i] == b[i] * x[i+1] + c[i] * x[i-1] + d[i]
	#
	#     P[1] == b[1] / a[1]
	#     Q[1] == d[1] / a[1]
	#
	#                       b[i]
	#     P[i] == ------------------------
 	#               a[i] - c[i] * P[i-1]
	#
	#               d[i] + c[i] * Q[i-1]
	#     Q[i] == ------------------------
	#               a[i] - c[i] * P[i-1]
	#
	#     x[n] == Q[n]
	#     x[i] == P[i] * x[i+1] + Q[i]
	#
	#   となる。
	#
	#-----------------------------------------------------------------------
	my( $m , $d ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_tridiagonal_matrix() ) ;

	if ( ! defined $d ) {
		$d = $m->cvector( 0 )->unit_vector()->as_array() ;
	}
	else {
		my $ref = ref( $d ) ;
		if ( ! $ref ) {
			$d = $m->cvector( 0 )->unit_vector() * $d ;
			$d = $d->as_array() ;
		}
		elsif ( $ref eq __PACKAGE__ ) {
			return undef	unless ( $d->is_vector() ) ;
			$d = $d->as_array() ;
		}
		else {
			if ( $d->can_decimal() ) {
				$d = $m->cvector( 0 )->unit_vector() * $d->decimal() ;
				$d = $d->as_array() ;
			}
			elsif ( $d->is_complex() ) {
				$d = $m->cvector( 0 )->unit_vector() * $d ;
				$d = $d->as_array() ;
			}
			else {
				return undef ;
			}
		}
	}

	my $rmax = $m->rows() - 1 ;
	my $v = $m->cvector( 0 )->zero_matrix() ;

	my $p = [] ;
	my $q = [] ;

	foreach my $r ( 0 .. $rmax ) {
		#
		# $k = { a => a[i] , b => b[i] , c => c[i] }
		#
		my $k = {
			'a' => $m->[ $r ]->[ $r ]	,
			'b' => new_decimal( 0 )		,
			'c' => new_decimal( 0 )		,
		} ;

		$k->{'b'} = $m->[ $r ]->[ $r + 1 ] * ( -1 )	if ( $r < $rmax ) ;
		$k->{'c'} = $m->[ $r ]->[ $r - 1 ] * ( -1 )	if ( $r > 0 ) ;

		#
		# P[1] == b[1] / a[1]
		# Q[1] == d[1] / a[1]
		#
		#                   b[i]
		# P[i] == ------------------------
		#           a[i] - c[i] * P[i-1]
		#
		#           d[i] + c[i] * Q[i-1]
		# Q[i] == ------------------------
		#           a[i] - c[i] * P[i-1]
		#
		#
		if ( $r == 0 ) {
			$p->[ $r ] = $k->{'b'} / $k->{'a'} ;
			$q->[ $r ] = $d->[ $r ] / $k->{'a'} ;
		}
		else {
			my $denom = ( $k->{'a'} - $k->{'c'} ) * $p->[ $r - 1 ] ;
			$p->[ $r ] = $k->{'b'} / $denom ;
			$q->[ $r ] = ( $d->[ $r ] + $k->{'c'} * $q->[ $r - 1 ] ) / $denom ;
		}
	}

	#
	# x[n] == Q[n]
	# x[i] == P[i] * x[i+1] + Q[i]
	#
	foreach my $r ( reverse( 0 .. $rmax ) ) {
		if ( $r == $rmax )	{ $v->[ $r ]->[0] = $q->[ $r ] ; next ; }
		else			{ $v->[ $r ]->[0] = $p->[ $r ] * $v->[ $r + 1 ]->[0] + $q->[ $r ] ; }
	}

	return $v ;
}

=head2 singular_values

Return the singular values.

  singular_values( A ) == sqrt( eigen_values( A  * adjoint( A ) ) )

The singular values are the one, that is extended the concept of eigenvalues to m x n matrix.

If the matrix A is a n x n regular matrix,

  singular_values( A ) == abs( eigen_values( A ) )

If the matrix A is a n x n positive-semidefinite hermitian matrix,

  singular_values( A ) == eigen_values( A ) 

=cut

sub singular_values {
	#-----------------------------------------------------------------------
	#
	# 特異値 ( Singular values )
	#
	#   特異値は、固有値の概念をより一般に拡張したものと言える。
	#
	#   任意の m x n 行列 A について、特異値は、
	#
	#     singular_values( A ) == sqrt( eigen_values( A * adjoint( A ) ) )
	#     
	#   と定義される。 ( 正の平方根のみを採る。 )
	#
	#
	#   行列 A * adjoint( A ) は、 m x m のエルミート行列 ( 対称行列 ) となり、半正定値行列となる。
	#   行列 adjoint( A ) * A は、 n x n のエルミート行列 ( 対称行列 ) となり、半正定値行列となる。
	#   半正定値行列であるため、これらの行列には半正定値平方根行列が唯一つ存在する。
	#
	#   また、これらの行列の固有値は全て非負の実数となる。
	#
	#     eigen_values( A * adjoint( A ) ) >= 0
	#     eigen_values( adjoint( A ) * A ) >= 0
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my $e = ( ( $m * $m->adjoint() )->eigens() )[0] ;
	$e = $e->vec2array() 	if ( defined $e ) ;

	foreach ( @{ $e } ) {
		$_ = ( $_->sqrt() )[0] ;
	}

	return ( @{ $e } ) ? @{ $e } : () ;
}

sub jacobi_eigen {
	#-----------------------------------------------------------------------
	#
	# ヤコビ法を用いて固有値と固有ベクトルを求める。
	#
	#
	#   ヤコビ法は、ギブンス回転を繰り返し適用することによって固有ベクトルや固有値を求める反復法の一種。
	#
	#   ヤコビ法を適用できるのはエルミート行列 ( 対称行列 ) のみ。
	#
	#   手順は以下のとおり。
	#
	#     1. 非対角成分の中で絶対値最大の値を持つ成分の座標 [ p , q ] を取り出す。
	#        ヤコビ法が適用できるのは対称行列のみなので、絶対値最大の値を探索する範囲は
	#        対角成分の左側もしくは右側のどちらか一方でよい。
	#
	#     2. 求めた座標を元にしてギブンス行列を生成する。
	#
	#        G == givens_matrix( A , p , q )
	#
	#     3. 以下の行列演算を行う。
	#
	#        A == inverse( G ) * A * G
	#          == adjoint( G ) * A * G
	#
	#   ギブンス行列 G はユニタリー行列 ( 直交行列 ; QR 法における Q の役割 ) であるため、その逆行列は随伴行列 ( 転置行列 ) に等しい。
	#
	#
	#   対称行列 A にヤコビ法を n 回繰り返した結果を A[n] とし、その時に使用されたギブンス行列を G[n] とすると、
	#   固有値は A[n] の非対角成分が全て 0 に収束した時の対角成分として現われる。
	#   固有ベクトルは、
	#
	#     U[n] == G[1] * G[2] * ..... * G[n-1] * G[n]
	#
	#   となる行列 U[n] ( ギブンス行列の総積 ) 上の列ベクトルとして現われる。
	#   A[n] 上に現われる固有値とそれに対応する U[n] 上の固有ベクトルは同じ列位置に現われる。
	#
	#
	#   ヤコビ法は常に行列全体の相似変換を繰り返すため、収束は非常に遅い。
	#   エルミート行列を予め三重対角化するなどの処置により収束を速める事はできるが、
	#   これによって求められるのは固有値のみであり、ヤコビ法によって得られた固有ベクトルは、元の行列との関連性を失ってしまう。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->is_hermitian_matrix() ) ;

	#my $try_count = 100 ;
	my $try_count = 50 ;
	my $obj = $self->copy() ;
	my $ev = undef ;

	my $rows = $obj->rows() ;

	foreach ( 1 .. $try_count ) {
		#
		# 非対角成分で絶対値最大となる座標を特定する。
		# 対称行列を扱っているので、行当たりの検索範囲は対角の手前まででよい。
		#
		# つまり、
		#
		#   A[p,q] == max( abs( A[r,c] ) )    ( r == 1 -> n , c == 1 -> r - 1 )
		#
		# となる p , q を求めるということ。
		#
		my( $p , $q ) ;
		my $max = undef ;
		foreach my $r ( 0 .. ( $rows - 1 ) ) {
			foreach my $c ( 0 .. ( $r - 1 ) ) {
				my $v = $obj->[ $r ]->[ $c ]->abs()->round_down( 5 ) ;
				if ( ! defined $max or $v > $max ) {
					$max = $v ;
					( $p , $q ) = ( $r , $c ) ;
				}
			}
		}
		last	unless ( defined $max ) ;
		last	if ( $max->round_down( 5 ) == 0 ) ;
		last	if ( ! defined $p or ! defined $q ) ;
	 
		#
		# ギブンス回転を施す。
		#
		#   G = givens_matrix( A , p , q )
		#   A = adjoint( G ) * A * G
		#
		if ( my $g = $obj->givens_matrix( $p , $q ) ) {
			$obj = $g->adjoint() * $obj * $g ;
			if ( ! defined $ev )	{ $ev = $g->copy() ; }
			else			{ $ev *= $g ; }
		}

		$obj = $obj->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}

	#return ()	unless ( $obj->is_diagonal_matrix() ) ;

	#
	# $obj は、固有値を成分とする対角行列。
	# $ev は、 $obj に対応する固有ベクトルを列ベクトルとして並べた行列。
	#
	return ( $obj , $ev ) ;
}

sub power_eigen_vector {
	#-----------------------------------------------------------------------
	#
	# 冪乗法 ( power method ) による固有ベクトル算出。
	#
	#   反復法 ( power iteration method ) とも言う。
	#
	#   n x n の行列 A に対して、適当な初期ベクトル x[0] を基点として固有ベクトルを求める。
	#
	#   x[0] をサイズ n の単位ベクトルとして初期化し、
	#
	#     x[k] == A * x[k-1]
	#     x[k] /= norm( x[k] )
	#
	#   を繰り返すことにより、x[k] が固有ベクトルに収束していく。
	#
	#   ここで返るベクトルは、絶対値最大の固有値に対応する固有ベクトルとなる。
	#
	#   ただし、収束は非常に遅い。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $try_count = 100 ;

	my $m = $self->copy() ;

	my $vec = $m->cvector()->unit_vector() ;
	my $vec_prev = undef ;

	foreach ( 1 .. $try_count ) {
		$vec_prev = $vec->copy() ;
		$vec = $m * $vec ;
		last	if ( $vec == $vec_prev ) ;
		$vec /= $vec->norm() ;
	}

	return $vec ;
}

sub inverse_iteration {
	#-----------------------------------------------------------------------
	#
	# 逆反復法 ( inverse iteration method ) による固有ベクトル算出。
	#
	#   逆冪乗法 ( inverse power method ) とも言う。
	#
	#   n x n の行列 A に対して、適当な初期ベクトル x[0] を基点として固有ベクトルを求める。
	#
	#   x[0] をサイズ n の単位ベクトルとして初期化し、
	#
	#     x[k] == inverse( A ) * x[k-1]
	#     x[k] /= norm( x[k] )
	#
	#   を繰り返すことにより、x[k] が固有ベクトルに収束していく。
	#
	#   ここで返るベクトルは、絶対値最小の固有値に対応する固有ベクトルとなる。
	#
	#   また、機知の固有値 ( 又はその近似値 ) の一つ λ を伴って
	#
	#     B == A - λI
	#     x[k] == inverse( B ) * x[k-1]
	#     x[k] /= norm( x[k] )
	#
	#   を繰り返すと、 λ に対応する固有ベクトルを得ることができる。
	#
	#   ただし、収束は非常に遅い。
	#
	#-----------------------------------------------------------------------
	my( $self , $eigen ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $try_count = 100 ;

	my $m = $self->copy() ;
	if ( defined $eigen ) {
		$m = $m - $m->unit_matrix() * $eigen ;
	}

	#
	# 逆行列の近似値を採る
	#
	my( $q , $r ) = $m->householder_qr() ;
	return undef	if ( ! defined $q or ! defined $r ) ;

	my $inv = $r->inverse() * $q->inverse() ;

	#
	# 求めるベクトルを初期化
	#
	my $vec = $m->cvector()->unit_vector() ;
	my $vec_prev = undef ;

	#
	# 演算
	#
	foreach ( 1 .. $try_count ) {
		$vec_prev = $vec->copy() ;
		$vec = ( $inv * $vec )->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		last	if ( $vec == $vec_prev ) ;
		$vec /= $vec->norm() ;
	}

	return $vec ;
}

sub eigen_value {
	#-----------------------------------------------------------------------
	#
	# 固有ベクトル -> 固有値
	#
	#   正方行列 A とその固有ベクトル v が与えられた時、
	#
	#     Av == λv
	#
	#   両辺について v との間で内積を採ると、
	#
	#     IP( Av , v ) == IP( λv , v )
	#                  == λ * IP( v , v )
	#                  == λ * adjoint( v ) * v
	#                  == λ * norm( v )^2 
	#
	#                IP( Av , v )        adjoint( Av ) * v           transpose( Av ) * conj( v )
	#     -> λ == ---------------- == ------------------------ == -------------------------------
	#                norm( v )^2         adjoint( v ) * v                adjoint( v ) * v
	#     
	#   となる。
	#
	#   norm( v ) は、 v の 2 次のノルムであり、
	#
	#             transpose( Av ) * conj( v )
	#     λ == ------------------------------          ( k == 1 -> n )
	#                  Σ( ( v[k] )^2 )
	#
	#   と表すこともできる。
	#
	#   ただし、演算誤差は非常に大きい。
	#
	#-----------------------------------------------------------------------
	my( $m , $v ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $v ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;
	return undef	unless ( $v->is_vector() ) ;

	$v = $v->cvector()	if ( $v->is_rvector() ) ;
	my $u = $m * $v ;

	#
	# vn2 == ( norm( v ) )^2
	#
	my $vn2 = new_decimal( 0 ) ;
	foreach ( @{ $v->as_array() } ) {
		$vn2 += $_->power( 2 ) ;
	}

	#
	# 固有値
	#
	my $t = $u->inner_product( $v ) / $vn2 ;

	return $t ;
}

sub eigen_values {
	#-----------------------------------------------------------------------
	#
	# 固有ベクトル -> 固有値
	#
	#   全ての固有ベクトルを列ベクトルとして持つ行列を受け取り、
	#   それに対応する固有値を列ベクトルとして返す。
	#
	#   D == inverse( P ) * A * P
	#   eigens( A ) == diag2array( D )
	#
	#-----------------------------------------------------------------------
	my( $m , $ev ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( ref( $ev ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;
	return undef	unless ( $ev->is_square_matrix() ) ;
	return undef	unless ( $m->rows() == $ev->rows() ) ;

	my $d = $ev->inverse() * $m * $ev ;
	$d = $d->diag2vector() ;

	return $d ;
}

sub eigen_vector {
	#-----------------------------------------------------------------------
	#
	# 固有値 -> 固有ベクトル
	#
	#   正方行列 A と、その固有値の内の 1 つを受け取り、その固有値に対応した固有ベクトルを返す。
	#
	#   固有値から固有ベクトルを求める定石に近い実装をしているが、煩雑且つ一種恣意的な処理を行う必要があり、
	#   プログラムロジックの見通しが非常に悪い。
	#   また、一度に一つの固有ベクトルを求めることしかできないため、利便性に欠ける。
	#
	#
	#   A * x == λ * x
	#   -> ( A - λI ) * x == 0
	#
	#   B == ( A - λI ) とおき、
	#
	#     C == forward_elimination( B )
	#
	#   となる C を定義すると C の対角には一つ以上の 0 が現れる。
	#   ( x != 0 より det( B ) == 0 であり、 C の対角には必ず 0 が含まれるはず。 )
	#
	#   前進消去において、全ての対角を 1 又は 0 に収束させる直前の状態を
	#
	#     C == [ c11 , c12 , c13 , c14 ]
	#          [   0 , c22 , c23 , c24 ]
	#          [   0 ,   0 , c33 , c34 ]
	#          [   0 ,   0 ,   0 , c44 ]
	#
	#   とすると、 c11 , c22 , c33 , c44 の内の少なくとも一つが 0 若しくは 0 に非常に近い値となる。
	#
	#   この時、
	#
	#     x == [ x1 ]
	#          [ x2 ]
	#          [ x3 ]
	#          [ x4 ]
	#
	#     C * x == [ c11 , c12 , c13 , c14 ] * [ x1 ] == [ 0 ]
	#              [   0 , c22 , c23 , c24 ]   [ x2 ]    [ 0 ]
	#              [   0 ,   0 , c33 , c34 ]   [ x3 ]    [ 0 ]
	#              [   0 ,   0 ,   0 , c44 ]   [ x4 ]    [ 0 ]
	#
	#     -> c11 * x1 + c12 * x2 + c13 * x3 + c14 * x4 == 0
	#                   c22 * x2 + c23 * x3 + c24 * x4 == 0
	#                              c33 * x3 + c34 * x4 == 0
	#                                         c44 * x4 == 0
	#
	#   と言う連立方程式が得られる。
	#
	#   この係数を取り出して以下のような行列を生成する。
	#
	#     F == [ c11 , c12 , c13 , -1 * c14 ]
	#          [   0 , c22 , c23 , -1 * c24 ]
	#          [   0 ,   0 , c33 , -1 * c34 ]
	#          [   0 ,   0 ,   0 , -1 * c44 ]
	#
	#   こうして作成した行列 F から n - 1 行分の部分行列を取り出し、掃き出し法の後退代入に掛ける。
	#   以下、 c44 == 0 として記述する。
	#
	#     F[0] == F
	#     F[1] == backward_substitution( submatrix( F[0] , [ 0 , 0 ] , [ -2 , -1 ] ) )
	#
	#   F[1] の対角が 1 になるように各行を調整した上で最終成分を 1 とする行ベクトルを末尾に追加する。
	#
	#     F[1] == expand_rows( F[1] , unit_vector( rvector( F[1] ) , undef , -1 ) )
	#     F[1][-1,-1] == 1
	#
	#   F[1] の最右端のベクトルを取り出して正規化する。
	#
	#     v == normalize( cvector( F[1] , -1 ) )
	#
	#-----------------------------------------------------------------------
	my( $m , $e ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	$m = $m->copy() ;
	my $rmax = $m->rows() - 1 ;

	#
	# 対角成分から固有値を減算。
	#
	foreach my $r ( 0 .. $rmax ) {
		$m->[ $r ]->[ $r ] -= $e ;
	}

	#
	# 前方消去に掛け、対角を 1 ステップ前の状態に戻すと共に右端列ベクトル成分に -1 を掛ける。
	#
	my $d = undef ;
	( $m , $d ) = ( $m->forward_elimination() )[0,2] ;
	$d = $d->vec2array() ;
	foreach my $r ( 0 .. $rmax ) {
		foreach ( @{ $m->[ $r ] } ) {
			$_ *= $d->[ $r ] ;
		}
		$m->[ $r ]->[-1] *= ( -1 ) ;
	}

	$m = $m->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	#
	# 一行間引き、間引いた行番号を抑えておく。
	#
	my $excl_row = undef ;
	my $n = undef ;
	foreach my $r ( 0 .. $rmax ) {
		if ( $m->[ $r ]->[ $r ]->round( 5 ) == 0 ) {
			$excl_row = $r ;
			if	( $r == $rmax ) { $n = $m->submatrix( [ 0 , 0 ] , [ -2 , -1 ] ) ; }
			elsif	( $r == 0 )	{ $n = $m->submatrix( [ 1 , 0 ] , [ -1 , -1 ] ) ; }
			else {
				$n = $m->submatrix( [ 0 , 0 ] , [ $r - 1 , -1 ] ) ;
				$n = $n->expand_rows( $m->submatrix( [ $r + 1 , 0 ] , [ -1 , -1 ] ) ) ;
			}
			last ;
		}
	}

	#
	# 適当な行が見つからなければ、最終行を間引く。
	#
	unless ( defined $n ) {
		$excl_row = $rmax ;
		$n = $m->submatrix( [ 0 , 0 ] , [ -2 , -1 ] ) ;
	}

	#
	# 後退代入に掛け、対角が 1 になるように調整する。
	#
	$n = $n->backward_substitution() ;

	foreach my $r ( 0 .. ( $n->rows() - 1 ) ) {
		my $d = $n->[ $r ]->[ $r ] ;
		unless ( $d == 0 ) {
			foreach my $c ( 0 .. ( $n->cols() - 1 ) ) {
				$n->[ $r ]->[ $c ] /= $d ;
			}
		}
	}

	#
	# 間引いた行をその行に適した単位行ベクトルとして書き戻し、右端の列ベクトルを取り出して正規化する。
	#
	if ( $excl_row == $rmax ) {
		$n = $n->expand_rows( $n->rvector()->unit_vector( undef , -1 ) ) ;
	}
	else {
		$n = $n->insert_rvector( $n->rvector()->unit_vector( undef , $excl_row ) , $excl_row ) ;
	}

	my $v = $n->cvector( -1 )->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	$v = $v->normalize() ;
	$v = $v->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	return $v ;
}

sub eigen_vectors {
	#-----------------------------------------------------------------------
	#
	# 固有値 -> 固有ベクトル
	#
	#   正方行列 A の全ての固有値を受け取り、これに対応する固有ベクトルを列ベクトルに持つ行列を返す。
	#
	#   引数として与える固有値は、列ベクトル、行ベクトル、対角行列の何れの形式でも良い。
	#
	#
	#   行列 A の固有値を t[k] とすると、
	#
	#     ( A - t[1] * E ) * ( A - t[2] * E ) * .... * ( A - t[k] * E ) == 0
	#
	#   が成立し、 t[k] に対応する固有ベクトルの候補は、
	#
	#     B[k] == Π( A - t[j] * E )         ( j == 1 -> n , j != k ) 
	#
	#   で得られる行列 B[k] の列ベクトル成分となって現れる。
	#
	#   B[k] の列ベクトル成分を B[k][i] とすると、固有値 t[k] に対応する固有ベクトル v[k] は、
	#
	#     norm( v[k] ) == norm( B[k][i] ) != 0
	#
	#   を満たしていれば良い。
	#
	#   こうして得られた v[k] を正規化し、列ベクトルとして結合した行列を返す。
	#
	#
	#   単一の固有ベクトルを求めるためにその他全ての固有値を必要とするため、演算コストが高くなりがち。
	#
	#-----------------------------------------------------------------------
	my( $m , $e ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	if ( ref( $e ) eq __PACKAGE__ ) {
		if	( $e->is_vector() )	{ $e = $e->vec2array() ; }
		elsif	( $e->is_matrix() )	{ $e = $e->diag2array() ; }
		else				{ return undef ; }
	}
	return undef	unless ( ref( $e ) eq 'ARRAY' ) ;
	return undef	unless ( scalar( @{ $e } ) == $m->rows() ) ;

	#
	# B[k] == Π( A - t[j] * E )    ( j == 1 -> n , j != k )
	#
	my $um = $m->unit_matrix() ;
	my $v = [] ;
	foreach my $i ( 0 .. $#{ $e } ) {
		foreach my $j ( 0 .. $#{ $e } ) {
			next	if ( $i == $j ) ;
			if ( defined $v->[ $j ] )	{ $v->[ $j ] *= $m - $um * $e->[ $i ] ; }
			else				{ $v->[ $j ]  = $m - $um * $e->[ $i ] ; }
		}
	}

	#
	# norm( B[k][i] ) != 0 のベクトルを採用
	#
	foreach my $i ( 0 .. $#{ $v } ) {
		$v->[ $i ] = $v->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		foreach my $c ( 0 .. ( $v->[ $i ]->cols() - 1 ) ) {
			my $vec = $v->[ $i ]->cvector( $c ) ;
			next	if ( $vec->norm()->round( 5 ) == 0 ) ;
			$v->[ $i ] = $vec ;
			last ;
		}
	}

	#
	# B[k] が零行列の場合、掃き出し法で固有ベクトルを得る。
	#
	foreach my $i ( 0 .. $#{ $v } ) {
		unless ( $v->[ $i ]->is_cvector() ) {
			$v->[ $i ] = $m->eigen_vector( $e->[ $i ] ) ;
		}

		$v->[ $i ] = $v->[ $i ]->normalize()	if ( defined $v->[ $i ] ) ;	# 正規化
	}

	#
	# ベクトル配列を行列に変換して返す。
	#
	my $n = vec2matrix( $v ) ;
	$n = $n->round( $DECIMAL_PART_LENGTH_LIMIT )	if ( defined $n ) ;

	return $n ;
}

sub eigens_DKA {
	#-----------------------------------------------------------------------
	#
	# DKA 法 ( Durand-Kerner-Aberth method ) による固有値と固有ベクトルの解法
	#
	#   DKA 法は、数値解析による n 次方程式の近似解法の一つ。 ( ニュートン法の応用 )
	#   このモジュールでは、 Decimal オブジェクトの solven メソッドで DKA 法が実装されている。
	#
	#   Vector オブジェクトでは、 固有方程式の係数の導出、及び固有ベクトルを求める際に使用する
	#   n 次方程式の係数の導出が主たる処理となる。
	#
	#   方程式の係数は何れも LF 法によって導出される。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	#
	# 固有値を DKA 法で取得。
	#
	my $eigen = $m->eigen_values_DKA() ;

	return ()	unless ( defined $eigen ) ;

	#
	# 固有ベクトル
	#
	my $ev = $m->eigen_vectors_LF( $eigen ) ;

	#
	# 固有値を格納した配列をベクトルオブジェクトに、
	# 固有ベクトルを格納した配列を行列オブジェクトに変換
	#
	$eigen = __PACKAGE__->new( $eigen ) ;
	$ev = vec2matrix( $ev )		if ( defined $ev ) ;

	return ( $eigen , $ev ) ;
}

sub eigen_values_DKA {
	#-----------------------------------------------------------------------
	#
	# DKA 法 ( Durand-Kerner-Aberth method ) による固有値の解法
	#
	#   DKA 法は、ワイエルシュトラス法 ( Weierstrass method ) とも呼ばれる。
	#
	#   固有方程式
	#
	#     ( A - t * E ) == a[0] * t^n + a[1] * t^(n-1) + a[2] * t^(n-2) + ...... + a[n]
	#                   == 0
	#
	#   の各係数は、 LF 法を用いて導くことができる。
	#
	#   固有方程式を f(X) == 0 , その解を X[j] とすると、
	#
	#     f(X) == a[0] * X^n + a[1] * X^(n-1) + a[2] * X^(n-2) + ...... + a[n]
	#
	#          == a[0] * ( X - x[1] )( X - x[2] ) ..... * ( X - x[n] )
	#
	#          == a[0] * Π( X - x[j] )           ( j == 1 -> n )
	#
	#          == 0
	#
	#   f(X) を微分した f'(X) は、
	#
	#     f'( X[i] ) == a[0] * Π( X[i] - X[j] )        ( j == 1 -> n ; j != i )
	#
	#   と定義される。
	#
	#   これをニュートン法で近似する式は、
	#
	#                                          f( X[i][k] )
	#     X[i][ k + 1 ] == X[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
	#                                 a[0] * Π( X[i][k] - X[j][k] )
	#
	#   と表される。 ( Durand-Kerner の公式 )
	#
	#   この時、各 X[j] の初期値 X[j][0] は、
	#
	#     R0 == ( -1 ) * a[1] / ( n * a[0] )
	#
	#                                   2PI           3
	#     X[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )
	#                                    n            4
	#
	#   で与えられる。 ( Aberth の初期値 )
	#
	#   R は、複素平面上の座標 [ R0 , 0 ] を中心とする円の半径であり、この円の中に解が存在するように設定された値となる。
	#
	#   この時、初期値 X[j][0] は、この円の円弧上に均等に配置されるような値となる。
	#
	#  
	#   R の導出
	#
	#     行列の固有値を求める場合、 R の値としてゲルシュゴリンの定理を用いることができる。
	#
	#       R == max( gershgorin_radius( A ) )
	#
	#
	#   このモジュールでは、 DKA 法に基づく n 次方程式の解法を Decimal オブジェクトの solven メソッドで提供している。
	#   このため、ゲルシュゴリン円板の半径 R を求めた後、 solven に引き継いで固有値を得ることとする。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	#
	# 固有方程式の係数と次数
	#
	my $c = ( $m->lf() )[0] ;	# LF 法による係数列
	my $n = $#{ $c } ;		# 次数 ( 係数の数 - 1 )

	#
	# ゲルシュゴリン円板
	#
	my $r0 = ( -1 ) * $c->[1] / ( $n * $c->[0] ) ;	# 円板の中心
	my $r = undef ;					# 円板の半径
	foreach ( @{ $m->gershgorin_radius() } ) {
		if ( ! defined $r or ( $r < $_ ) ) {
			$r = $_ ;
		}
	}

	#
	# DKA 法により、固有方程式を解く。
	#
	my $eigen = [ solven( $c , $r ) ] ;

	return $eigen ;
}

sub eigen_vectors_LF {
	#-----------------------------------------------------------------------
	#
	# LF 法を用いた固有ベクトルの解法
	#
	#   任意の正方行列 A を以下のように定義する。
	#   ( 展開過程の見通しを良くするために三次の正方行列で例示する。 )
	#
	#     A == [ 2 , -2 ,  3 ]
	#          [ 1 ,  1 ,  1 ]
	#          [ 1 ,  3 , -1 ]
	#
	#   行列 A の固有方程式は以下の通り。
	#
	#     det( A - t * E ) == det( [ 2 - t ,    -2 ,      3 ] ) == det( B ) == det( [ b11 , b12 , b13 ] ) == 0
	#                              [     1 , 1 - t ,      1 ]                       [ b21 , b22 , b23 ]
	#                              [     1 ,     3 , -1 - t ]                       [ b31 , b32 , b33 ]
	#
	#   上記行列 B を以下のように変形した行列 C を定義する。
	#
	#     C == [ c[1,1] , c[1,2] , c[1,3] ]
	#          [ c[2,1] , c[2,2] , c[3,3] ]
	#          [ c[3,1] , c[3,2] , c[3,3] ]
	#
	#     c[ i , j ] == ( -1 )^( i + j ) * cofactor( B , i , j )
	#
	#   C を展開して、
	#
	#    C == [ ( -1 )^2 * det( [ b22 , b23 ] ) , ( -1 )^3 * det( [ b21 , b23 ] ) , ( -1 )^4 * det( [ b21 , b22 ] ) ]
	#                           [ b32 , b33 ]                     [ b31 , b33 ]                     [ b31 , b32 ]
	#
	#         [ ( -1 )^3 * det( [ b12 , b13 ] ) , ( -1 )^4 * det( [ b11 , b13 ] ) , ( -1 )^5 * det( [ b11 , b12 ] ) ]
	#                           [ b32 , b33 ]                     [ b31 , b33 ]                     [ b31 , b32 ]
	#
	#         [ ( -1 )^4 * det( [ b12 , b13 ] ) , ( -1 )^5 * det( [ b11 , b13 ] ) , ( -1 )^6 * det( [ b11 , b12 ] ) ]
	#                           [ b22 , b23 ]                     [ b21 , b23 ]                     [ b21 , b22 ]
	#
	#      == [          det( [ 1 - t ,      1 ] ) , ( -1 ) * det( [     1 ,      1 ] ) ,          det( [     1 , 1 - t ] ) ]
	#                         [     3 , -1 - t ]                   [     1 , -1 - t ] )                 [     1 ,     3 ]
	#
	#         [ ( -1 ) * det( [    -2 ,      3 ] ) ,          det( [ 2 - t ,      3 ] ) , ( -1 ) * det( [ 2 - t ,    -2 ] ) ]
	#                         [     3 , -1 - t ]                   [     1 , -1 - t ] )                 [     1 ,     3 ]
	#
	#         [          det( [    -2 ,      3 ] ) , ( -1 ) * det( [ 2 - t ,      3 ] ) ,          det( [ 2 - t ,    -2 ] ) ]
	#                         [ 1 - t ,      1 ]                   [     1 ,      1 ] )                 [     1 , 1 - t ]
	#
	#      == [ t^2      - 4  ,       t + 2  ,        t + 2 ]
	#         [     - 2t + 7  , t^2 - t - 5  ,       3t - 8 ]
	#         [       3t - 5   ,      t + 1  , t^2 - 3t + 4 ]
	#
	#   を得る。
	#
	#   この時、 C の随伴行列 ( 共役転置行列 ) は、
	#
	#     adjoint( C ) == [ t^2 - 4 ,     -2t + 7 ,       3t - 5 ]
	#                     [   t + 2 , t^2 - t - 5 ,        t + 1 ]
	#                     [   t + 2 ,      3t - 8 , t^2 - 3t + 4 ]
	#
	#                  == [ t^2 ,     -2t ,       3t ] + [ -4 ,  7 , -5 ]
	#                     [   t , t^2 - t ,        t ]   [  2 , -5 ,  1 ]
	#                     [   t ,      3t , t^2 - 3t ]   [  2 , -8 ,  4 ]
	#
	#                  == [ t^2 ,   0 ,   0 ] + [ 0 , -2t ,  3t ] + [ -4 ,  7 , -5 ]
	#                     [   0 , t^2 ,   0 ]   [ t ,  -t ,   t ]   [  2 , -5 ,  1 ]
	#                     [   0 ,   0 , t^2 ]   [ t ,  3t , -3t ]   [  2 , -8 ,  4 ]
	#
	#                  == t^2 * [ 1 , 0 , 0 ] + t * [ 0 , -2 ,  3 ] + [ -4 ,  7 , -5 ]
	#                           [ 0 , 1 , 0 ]       [ 1 , -1 ,  1 ]   [  2 , -5 ,  1 ]
	#                           [ 0 , 0 , 1 ]       [ 1 ,  3 , -3 ]   [  2 , -8 ,  4 ]
	#
	#   であり、固有値 t に関する多項式として表現できる。
	#
	#   行列 A を LF 法で展開して固有多項式の係数を求める過程を以下に示す。
	#
	#     B[1] == A                            -> p[1] == 1/1 * trace( B[1] )
	#     B[2] == A * ( B[1] - p[1] * E )      -> p[2] == 1/2 * trace( B[2] )
	#     B[3] == A * ( B[2] - p[2] * E )      -> p[3] == 1/3 * trace( B[3] )
	#
	#     -> B[1] == A == [ 2 , -2 ,  3 ]                                                                  -> p[1] == 1/1 * trace( B[1] ) == 2
	#                     [ 1 ,  1 ,  1 ]
	#                     [ 1 ,  3 , -1 ]
	#
	#        B[2] == A * ( B[1] - p[1] * E ) 
	#
	#             == A * ( [ 2 , -2 ,  3 ] - [ 2 , 0 , 0 ] ) == A * [  0 , -2 ,  3 ] == [ 1 ,  7 , -5 ]    -> p[2] == 1/2 * trace( B[2] ) == 5
	#                      [ 1 ,  1 ,  1 ]   [ 0 , 2 , 0 ]          [  1 , -1 ,  1 ]    [ 2 ,  0 ,  1 ]
	#                      [ 1 ,  3 , -1 ]   [ 0 , 0 , 2 ]          [  1 ,  3 , -3 ]    [ 2 , -8 ,  9 ]
	#
	#        B[3] == A * ( B[2] - p[2] * E ) 
	#
	#             == A * ( [ 1 ,  7 , -5 ] - [ 5 , 0 , 0 ] ) == A * [ -4 ,  7 , -5 ] == [ -6 ,  0 ,  0 ]   -> p[3] == 1/3 * trace( B[3] ) == -6
	#                      [ 2 ,  0 ,  1 ]   [ 0 , 5 , 0 ]          [  2 , -5 ,  1 ]    [  0 , -6 ,  0 ]
	#                      [ 2 , -8 ,  9 ]   [ 0 , 0 , 5 ]          [  2 , -8 ,  4 ]    [  0 ,  0 , -6 ]
	#
	#   adjoint( C ) と LF 法の展開過程を比較すると、
	#
	#     adjoint( C ) == t^2 * E + t * ( B[1] - p[1] * E ) + ( B[2] - p[2] * E )
	#
	#     B[1] - p[1] * E == [  0 , -2 ,  3 ]
	#                        [  1 , -1 ,  1 ]
	#                        [  1 .  3 , -3 ]
	#
	#     B[2] - p[2] * E == [ -4 ,  7 , -5 ]
	#                        [  2 , -5 ,  1 ]
	#                        [  2 , -8 ,  4 ]
	#
	#   と言う関係を見出すことができる。
	#
	#   この adjoint( C ) に固有値 t を代入することで固有ベクトルを列ベクトルに持つ行列が得られる。
	#
	#   この例で用いている行列 A の固有値は、
	#
	#     A == [ 2 , -2 ,  3 ]
	#          [ 1 ,  1 ,  1 ]
	#          [ 1 ,  3 , -1 ]
	#
	#     t^3 + ( ( -1 ) * p[1] ) * t^2 + ( ( -1 ) * p[2] ) * t + ( ( -1 ) * p[3] ) == 0
	#
	#     -> t^3 - 2t^2 - 5t + 6 == ( t - 3 )( t + 2 )( t - 1 ) == 0
	#
	#     -> t == 3 , -2 , 1
	#
	#   固有ベクトルは、
	#
	#     t == 3 の時、
	#     
	#       3^2 * E + 3 * ( B[1] - p[1] * E ) + ( B[2] - p[2] * E )
	#
	#       == 9 * [ 1 , 0 , 0 ] + 3 * [ 0 , -2 ,  3 ] + [ -4 ,  7 , -5 ]
	#              [ 0 , 1 , 0 ]       [ 1 , -1 ,  1 ]   [  2 , -5 ,  1 ]
	#              [ 0 , 0 , 1 ]       [ 1 ,  3 , -3 ]   [  2 , -8 ,  4 ]
	#
	#       == [ 9 + 0 - 4 , 0 - 6 + 7 , 0 + 9 - 5 ]
	#          [ 0 + 3 + 2 , 9 - 3 - 5 , 0 + 3 + 1 ]
	#          [ 0 + 3 + 2 , 0 + 9 - 8 , 9 - 9 + 4 ]
	#
	#       == [ 5 , 1 , 4 ]
	#          [ 5 , 1 , 4 ]
	#          [ 5 , 1 , 4 ]
	#
	#     t == -2 の時、
	#     
	#       (-2)^2 * E - 2 * ( B[1] - p[1] * E ) + ( B[2] - p[2] * E )
	#
	#       == 4 * [ 1 , 0 , 0 ] - 2 * [ 0 , -2 ,  3 ] + [ -4 ,  7 , -5 ]
	#              [ 0 , 1 , 0 ]       [ 1 , -1 ,  1 ]   [  2 , -5 ,  1 ]
	#              [ 0 , 0 , 1 ]       [ 1 ,  3 , -3 ]   [  2 , -8 ,  4 ]
	#
	#       == [ 4 + 0 - 4 , 0 + 4 + 7 , 0 - 6 - 5 ]
	#          [ 0 - 2 + 2 , 4 + 2 - 5 , 0 - 2 + 1 ]
	#          [ 0 - 2 + 2 , 0 - 6 - 8 , 4 + 6 + 4 ]
	#
	#       == [ 0 ,  11 , -11 ]
	#          [ 0 ,   1 ,  -1 ]
	#          [ 0 , -14 ,  14 ] 
	#
	#     t == 1 の時、
	#     
	#       1^2 * E + 1 * ( B[1] - p[1] * E ) + ( B[2] - p[2] * E )
	#
	#       == 1 * [ 1 , 0 , 0 ] + 1 * [ 0 , -2 ,  3 ] + [ -4 ,  7 , -5 ]
	#              [ 0 , 1 , 0 ]       [ 1 , -1 ,  1 ]   [  2 , -5 ,  1 ]
	#              [ 0 , 0 , 1 ]       [ 1 ,  3 , -3 ]   [  2 , -8 ,  4 ]
	#
	#       == [ 1 + 0 - 4 , 0 - 2 + 7 , 0 + 3 - 5 ]
	#          [ 0 + 1 + 2 , 1 - 1 - 5 , 0 + 1 + 1 ]
	#          [ 0 + 1 + 2 , 0 + 3 - 8 , 1 - 3 + 4 ]
	#
	#       == [ -3 ,  5 , -2 ]
	#          [  3 , -5 ,  2 ]
	#          [  3 , -5 ,  2 ] 
	#
	#   となる。
	#
	#   後は、ノルムが非 0 となる列ベクトルをそれぞれ取り出せば固有ベクトルが得られる。
	#   ( ノルムが非 0 であれば、どの列を採っても規格化されたベクトルは同一のベクトルとなる。 )
	#
	#-----------------------------------------------------------------------
	my( $m , $e ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;
	return undef	unless ( $m->is_square_matrix() ) ;

	if ( ref( $e ) eq __PACKAGE__ ) {
		if	( $e->is_vector() )	{ $e = $e->vec2array() ; }
		elsif	( $e->is_matrix() )	{ $e = $e->diag2array() ; }
		else				{ return undef ; }
	}
	return undef	unless ( ref( $e ) eq 'ARRAY' ) ;

	#
	# adjoint( C ) の係数
	#
	my $cm = ( $m->lf() )[1] ;

	#
	# 固有値を代入 ( ホーナー法で演算 )
	#
	#   行列 A が 4 x 4 の正方行列である場合、
	#
	#   adjoint( C ) == t^3 * E + t^2 * ( B[1] - p[1] * E ) + t * ( B[2] - p[2] * E ) + ( B[3] - p[3] * E )
	#                == t^3 * E + t^2 * CM[1] + t * CM[2] + CM[3]
	#                == t * ( t * ( ( t * E ) + CM[1] ) + CM[2] ) + CM[3]
	#
	my $n = $m->rows() - 1 ;
	my $ev = [] ;
	foreach my $i ( 0 .. $#{ $e } ) {
		my $t = $e->[ $i ] ;
		$ev->[ $i ] = $m->unit_matrix() ;
		foreach my $j ( 1 .. $n ) {
			$ev->[ $i ] = ( $ev->[ $i ] * $t ) + $cm->[ $j ] ;
		}
	}

	#
	# 固有ベクトルを選択
	#
	foreach my $i ( 0 .. $#{ $ev } ) {
		#
		# 固有ベクトルの候補を含む行列
		#
		my $vm = $ev->[ $i ] ;

		next	unless ( ref( $vm ) eq __PACKAGE__ ) ;

		#
		# 列ベクトルを精査してノルムが 0 でないものを採用し、これを規格化 ( 正規化 ) する。
		#
		my $cmax = $vm->cols() - 1 ;
		foreach my $j ( 0 .. $cmax ) {
			my $v = $vm->cvector( $j ) ;
			my $norm = $v->norm() ;
			unless ( $norm == 0 ) {
				$ev->[ $i ] = $v / $norm ;
				last ;
			}
			last	if ( $ev->[ $i ]->is_vector() ) ;
		}

		#
		# 固有ベクトルの候補が全て零ベクトルであれば、先頭の列を選択。
		#
		unless ( $ev->[ $i ]->is_vector() ) {
			$ev->[ $i ] = $ev->[ $i ]->cvector( 0 ) ;
		}
	}

	return $ev ;
}

sub lf {
	#-----------------------------------------------------------------------
	#
	# LF 法 ( ルベリエ・ファディーエフ法 ; Leverrier-Faddeev method ; Le Verrier / Faddeev method )
	#
	#   LF 法は固有方程式 ( 特性多項式 ) の係数を求める方法。
	#
	#   任意の正方行列 A の固有多項式が
	#
	#     c[0] * t^n + c[1] * t^(n-1) + c[2] * t^(n-2) + .... + c[n-1] * t + c[n]
	#
	#   で表される時、補助行列 B[k] を用いて
	#
	#     B[1] == A                            -> p[1] == trace( B[1] )
	#     B[2] == A * ( B[1] - p[1] * E )      -> p[2] == 1/2 * trace( B[2] )
	#     .....................................................................
	#     B[k] == A * ( B[k-1] - p[k-1] * E )  -> p[k] == 1/k * trace( B[k] )
	#     B[n] == A * ( B[n-1] - p[n-1] * E )  -> p[n] == 1/n * trace( B[n] )
	#
	#     -> c[0] == 1
	#        c[k] == ( -1 ) * p[k]
	#
	#   となる。
	#
	#   LF 法を用いると、行列 A の逆行列を
	#
	#     inverse( A ) == 1/p[n] * ( B[n-1] - p[n-1] * E )
	#
	#   として求めることもできる。
	#
	#   LF 法の演算過程で現れる
	#
	#     C[k] == B[k] - p[k] * E       ( k == 1 -> n - 1 )
	#
	#   と言う行列は、固有値から固有ベクトルを求める際に必要な行列となっている。
	#
	#   このメソッドでは、固有方程式の係数となる p[n] 及び固有ベクトルを求める際に使用する行列 C[k] を返す。
	#
	#-----------------------------------------------------------------------
	my( $am ) = @_ ;
	return ()	unless ( ref( $am ) eq __PACKAGE__ ) ;
	return ()	unless ( $am->is_square_matrix() ) ;

	my $n = $am->rows() ;
	my $um = $am->unit_matrix() ;

	my $bm = [ undef , $am->copy() ] ;
	my $cm = [ undef ] ;

	my $p = [
		new_decimal( 1 )	,
		$bm->[1]->trace()	,
	] ;

	foreach my $r ( 2 .. $n ) {
		$cm->[ $r - 1 ] = $bm->[ $r - 1 ] - $p->[ $r - 1 ] * $um  ;
		$bm->[ $r ] = $am * $cm->[ $r - 1 ] ;
		$p->[ $r ] = $bm->[ $r ]->trace() / $r ;
	}

	foreach my $i ( 1 .. $n ) {
		$p->[ $i ] *= ( -1 ) ;
	}

	return ( $p , $cm ) ;
}

sub gershgorin_radius {
	#-----------------------------------------------------------------------
	#
	# ゲルシュゴリン円板の半径 ( radius of Gershgorin discs )
	#
	#   ゲルシュゴリンの定理 ( Gershgorin circle theorem ) は、
	#
	#     行列 A の任意の固有値は少なくとも一つのゲルシュゴリン円板 D( a[i,i] , R[i] ) の上に乗っている。
	#
	#   と言うもの。
	#   これにより、任意の複素正方行列の固有値の大きさを推測することができる。
	#
	#   ゲルシュゴリンの定理で定義される円板の半径は、任意の n x n 行列 A と、その成分 a[i,j] 及び A の固有値 λ[k] を用いて、
	#
	#     R[i] == Σ( abs( a[i,j] ) )      ( j != i )
	#
	#     abs( λ[k] ) <= max( R[i] )
	#
	#   で表される。
	#
	#   複素平面上に原点 a[i,j] , 半径 R[i] の閉円板 D( a[i,j] , R[i] ) を想定すると、
	#
	#     a[i,0] * X^j + a[i,1] * X^( j - 1 ) + ..... + a[i,j-1] * X + a[i,j] == 0
	#
	#   として示される j 次方程式の解は、全てこの閉円板 D の内側に現れると言うことになる。
	#   この閉円板 D が、ゲルシュゴリン円板 ( Gershgorin disc ) と呼ばれるもの。
	#
	#
	#   R を求める際には、通常は行ベクトルを用いるが、ゲルシュゴリンの定理は列ベクトルに対しても成立するとのこと。
	#   よって、転置行列の行ベクトルについて R を採っても定理は成立することになる。
	#
	#
	#   ゲルシュゴリンの定理は、 DKA 法で使用される初期値 R の導出に利用することができる。
	#   演算は行ベクトル単位で行われるため、呼び出し元は必ずしも正方行列である必要はない。
	#
	#-----------------------------------------------------------------------
	my( $m ) = @_ ;
	return undef	unless ( ref( $m ) eq __PACKAGE__ ) ;

	my( $rows , $cols ) = $m->size() ;

	my $radius = [] ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {
		$radius->[ $r ] = new_decimal( 0 ) ;
		foreach my $c ( 0 .. ( $cols - 1 ) ) {
			next	if ( $r == $c ) ;
			$radius->[ $r ] += $m->[ $r ]->[ $c ]->abs() ;
		}
	}

	return $radius ;
}

=head1 'Vector' object - Gaussian elimination.

=cut

#-------------------------------------------------------------------------------
#
# ガウスの消去法 / 掃き出し法
#
#-------------------------------------------------------------------------------

=head2 gaussian_elimination

  $m1 = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m1->gausssian_elimination() ;                 # [              1.00000 ,              0.00000 ,             -1.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              2.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              0.00000 ]

  $m2 = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 0 ] ,
  ) ;

  print $m2->gausssian_elimination() ;                 # [              1.00000 ,              0.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              1.00000 ,              0.00000 ]
                                                       # [              0.00000 ,              0.00000 ,              1.00000 ]

In this case, the matrix $m1 does not have eigen values, $m2 has eigen values.
It also means $m1->det() == 0 , $m2->det() != 0.

The Gausssian elimination may be used to solve the linear equation, or to find inverse matrix.

In this module, gaussian_leanear_equation method is defined to solve the linear equation,
gaussian_inverse method is defined to find inverse matrix.

Please see also these methods.


=cut

sub gaussian_elimination {
	#-----------------------------------------------------------------------
	#
	# ガウスの消去法 ( Gaussian elimination )
	#
	#   掃き出し法とも呼ばれる。
	#
	#   行数と同じ数の列で認識される部分行列を正方行列として扱い、
	#   これを単位行列に変換することによって、正方行列の範囲外の部分行列に数値を掃き出していく。
	#
	#   n 次多項式の n 個の係数を求める際などに使用される。
	#
	#
	#   ガウスの消去法は、連立一次方程式の解法として知られているが、処理自体は任意の n x m 行列 ( ただし m >= n ) に適用できる。
	#   n x ( n + 1 ) 行列に対して適用すると連立一次方程式の解法として知られる処理となり、
	#   右正方行列を単位行列とする n x 2n 行列に適用すると、 左正方行列に関して逆行列を求める演算となる。
	#
	#   n x n 行列に適用した場合は、単に単位行列への変換が試行されるだけだが、前方消去の過程で行列式を得ることができる。
	#   よって、逆行列の存在判定や行列の絶対値としての行列式の取得を目的として使用することもできる。
	#
	#   このメソッドでは行列式の検査は行っておらず、単に前方消去と後退代入を施した結果を返している。
	#   行列式は det メソッドで得られるが、 forward_elimination メソッドでも取得できる。
	#   
	#   逆行列を求めるメソッドとして gaussian_inverse を、連立一次方程式の解を求めるメソッドとして gaussian_linear_equation を別途定義してある。
	#   gaussian_inverse は正方行列を扱うメソッド、 gaussian_linear_equation は n x ( n + 1 ) 行列を扱うメソッドとなっている。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $obj = ( $self->forward_elimination() )[0] ;
	$obj = $obj->backward_substitution() ;

	return $obj ;
}

=head2 gaussian_linear_equation

This method is defined for solving linear equation.

For example, the linear equation is defined as follows.

   x + 2y + 3z == 1
  4x + 5y + 6z == 2
  7x + 8y +  0 == 3

These equations can be expressed by the following matrix.

  [ 1 , 2 , 3 ] * [ x ] == [ 1 ]
  [ 4 , 5 , 6 ]   [ y ]    [ 2 ]
  [ 7 , 8 , 0 ]   [ z ]    [ 3 ]

At the first, define a matrix A as follows.

  A == [ 1 , 2 , 3 , 1 ]
       [ 4 , 5 , 6 , 2 ]
       [ 7 , 8 , 0 , 3 ]

Next, translate A to B using by "forward elimination". ( It is the first step of the Gaussian elimination. )

  B == forward_elimination( A ) == [ 1 , 2 , 3 ,   1 ]
                                   [ 0 , 1 , 2 , 2/3 ]
                                   [ 0 , 0 , 1 ,   0 ]

The matrix B means 

  x + 2y + 3z ==   1
       y + 2z == 2/3
            z ==   0

Next, translate B to C using by "backward elimination". ( It is the second step of the Gaussian elimination. )

  C == backward_substitution( B ) == [ 1 , 0 , 0 , -1/3 ]
                                     [ 0 , 1 , 0 ,  2/3 ]
                                     [ 0 , 0 , 1 ,    0 ]
   -> [ 1 , 0 , 0 ] * [ x ] == [ -1/3 ]
      [ 0 , 1 , 0 ]   [ y ]    [  2/3 ]
      [ 0 , 0 , 1 ]   [ z ]    [    0 ]

   -> x + 0 + 0 == x == -1/3
      0 + y + 0 == y ==  2/3
      0 + 0 + z == z ==    0

The answer is

  x == -1/3
  y ==  2/3
  z ==    0


If the matrix A is

  A == [ 1 , 2 , 3 , 1 ]
       [ 4 , 5 , 6 , 2 ]
       [ 7 , 8 , 9 , 3 ]

Then

  forward_elimination( A ) == [  1 ,  2 ,  3 ,   1 ]
                              [  0 ,  1 ,  2 , 2/3 ]
                              [  0 ,  0 ,  0 ,   0 ]

  -> x + 2y + 3z ==   1
          y + 2z == 2/3
               0 ==   0

These equations cannot be solved.

=cut

sub gaussian_linear_equation {
	#-----------------------------------------------------------------------
	#
	# ガウスの消去法を用いて一次方程式の解を返す。
	#
	#   n 行 n + 1 列の行列オブジェクトを受け取り、これを連立一次方程式とみなして解を求める。
	#   結果は、列ベクトルとして返す。
	#
	#
	#   ガウスの消去法は、連立一次方程式 ( 線型方程式 ; linear equation ) の解法としても有名。
	#   
	#     以下のような連立一次方程式を解くことを考える。
	#
	#        x + 2y + 3z == 1
	#       4x + 5y + 6z == 2
	#       7x + 8y +  0 == 3
	#
	#     これを行列で表現すると、以下のようになる。
	#
	#       [ 1 , 2 , 3 ] * [ x ] == [ 1 ]
	#       [ 4 , 5 , 6 ]   [ y ]    [ 2 ]
	#       [ 7 , 8 , 0 ]   [ z ]    [ 3 ]
	#
	#     これを元に、以下の行列 A を定義する。
	#
	#       A == [ 1 , 2 , 3 , 1 ]
	#            [ 4 , 5 , 6 , 2 ]
	#            [ 7 , 8 , 0 , 3 ]
	#
	#     これを前方消去した結果を B とすると、
	#
	#       B == forward_elimination( A ) == [ 1 , 2 , 3 ,   1 ]
	#                                        [ 0 , 1 , 2 , 2/3 ]
	#                                        [ 0 , 0 , 1 ,   0 ]
	#
	#     となり、上記の連立方程式が
	#
	#       x + 2y + 3z ==   1
	#            y + 2z == 2/3
	#                 z ==   0
	#
	#     に変換されたことを意味する。
	#
	#     続いて、B を後退代入した C を得ると、
	#
	#       C == backward_substitution( B ) == [ 1 , 0 , 0 , -1/3 ]
	#                                          [ 0 , 1 , 0 ,  2/3 ]
	#                                          [ 0 , 0 , 1 ,    0 ]
	#
	#     となり、
	#
	#       [ 1 , 0 , 0 ] * [ x ] == [ -1/3 ]
	#       [ 0 , 1 , 0 ]   [ y ]    [  2/3 ]
	#       [ 0 , 0 , 1 ]   [ z ]    [    0 ]
	#
	#       -> x + 0 + 0 == x == -1/3
	#          0 + y + 0 == y ==  2/3
	#          0 + 0 + z == z ==    0
	#
	#     が得られる。
	#
	#
	#     一方、 A の 3 行 3 列目を 0 -> 9 に変更した
	#
	#       A == [ 1 , 2 , 3 , 1 ]
	#            [ 4 , 5 , 6 , 2 ]
	#            [ 7 , 8 , 9 , 3 ]
	#
	#     を前方消去すると、
	#
	#       forward_elimination( A ) == [  1 ,  2 ,  3 ,   1 ]
	#                                   [  0 ,  1 ,  2 , 2/3 ]
	#                                   [  0 ,  0 ,  0 ,   0 ]
	#     となる。
	# 
	#     これは、
	#
	#       x + 2y + 3z ==   1
	#            y + 2z == 2/3
	#                 0 ==   0
	#     
	#     を意味しており、この方程式に解は存在しない。
	#
	#     解が存在するかどうかは、前方消去の過程で得られる行列式で判別できる。
	#     forward_elimination メソッドは、前方消去の結果と共に行列 A の左正方行列 ( A の右端の列を除いた行列 ) の行列式を返すように実装されている。
	#     この値が 0 であれば、解は存在しない。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
	return undef	unless ( $self->cols() == ( $self->rows() + 1 ) ) ;	# n x ( n + 1 ) 行列でなければならない。

	my( $obj , $det ) = $self->forward_elimination() ;
	return undef	if ( $det == 0 ) ;			# 行列式が 0 であれば解は存在しない。
	$obj = $obj->backward_substitution() ;

	return $obj->cvector( -1 ) ;				# 結果は右端の列ベクトルとして現れる。
}

=head2 forward_elimination

The forward elimination is the first part of the Gaussian elimination.

This method provides two features.

  1. to translate the matrix to upper triangular matrix.
  2. detect the determinant of the matrix.

This method will try to return U , det and vec as array.

  U   : Upper triangular matrix translated from the matrix.
  det : The determinant of the matrix.
  vec : The vector, which contains the factors of the determinant of the matrix.


For example, the matrix A is defined as follows.

  A == [ 1 , 2 , 3 , 1 ]
       [ 4 , 5 , 6 , 2 ]
       [ 7 , 8 , 0 , 3 ]

At the first step, translate the elements A[r,0] and row vector A[r]. ( r > 1 )

  A[1,1] == 1
  A[2,1] == 4

  -> c == A[2,1] / A[1,1] == 4

  -> A[2] == A[2] - A[1] * c

          == [     4 ,     5 ,      6 ,     2 ] - 4 * [ 1 , 2 , 3 , 1 ]

          == [ 4 - 4 , 5 - 8 , 6 - 12 , 2 - 4 ]

          == [     0 ,    -3 ,     -6 ,    -2 ]

  A[1,1] == 1
  A[3,1] == 7

  -> c == A[3,1] / A[1,1] == 7

  -> A[3] == A[3] - A[1] * c

          == [     7 ,      8 ,      0 ,     3 ] - 7 * [ 1 , 2 , 3 , 1 ]

          == [ 7 - 7 , 8 - 14 , 0 - 21 , 3 - 7 ]

          == [     0 ,     -6 ,    -21 ,    -4 ] 

Then the matrix A is translated to

  A' == [ 1 ,  2 ,   3 ,  1 ]
        [ 0 , -3 ,  -6 , -2 ]
        [ 0 , -6 , -21 , -4 ]

  -> x + 2y +  3z ==  1
        -3y -  6z == -2 == 2 - ( 1 * 4 )
        -6y - 21z == -4 == 3 - ( 1 * 7 )

At the second step, translate the elements A'[r,1] and row vector A'[r]. ( r > 2 )

  A'[2,2] == -3
  A'[3,2] == -6

  -> c == A'[3,2] / A'[2,2] == 2

  -> A'[3] == A'[3] - A'[2] * c

          == [     0 ,     -6 ,      -21 ,     -4 ] - 2 * [ 0 , -3 , -6 , -2 ]

          == [ 0 - 0 , -6 + 6 , -21 + 12 , -4 + 4 ]

          == [     0 ,      0 ,       -9 ,      0 ]


Then the matrix A' is translated to

  A'' == [ 1 ,  2 ,   3 ,  1 ]
         [ 0 , -3 ,  -6 , -2 ]
         [ 0 ,  0 ,  -9 ,  0 ]

  -> x + 2y +  3z ==  1
        -3y -  6z == -2 == 2 - ( 1 * 4 )
              -9z ==  0 == 3 - ( 1 * 7 ) - ( -2 * 2 ) 

In this time,

  B == [ 1 , 2 , 3 ]
       [ 4 , 5 , 6 ]
       [ 7 , 8 , 9 ]

  det( B ) == total_product( diag2array( A'' ) ) == 1 * -3 * -9 == 27

Then

  det == 27
  vec == [  1 ]
         [ -3 ]
	 [ -9 ]

At the last, translate the diagonal elements to 1.

  A'' == [ 1 ,  2 ,   3 ,  1 ]
         [ 0 , -3 ,  -6 , -2 ]
         [ 0 ,  0 ,  -9 ,  0 ]

  -> U   == [ 1 ,  2 ,   3 ,  1 ] /  1 == [ 1 , 2 , 3 ,   1 ]
            [ 0 , -3 ,  -6 , -2 ] / -3    [ 0 , 1 , 2 , 2/3 ]
            [ 0 ,  0 ,  -9 ,  0 ] / -9    [ 0 , 0 , 1 ,   0 ]

Then, this method will return 

  ( U , det , vec )


If the matrix A is a square matrix,

  det( A ) == ( forward_elimination( A ) )[1] 

=cut

sub forward_elimination {
	#-----------------------------------------------------------------------
	#
	# ガウスの消去法における前方消去 ( forward elimination )
	#
	#   前方消去の結果として、以下の変数を返す。
	#
	#     ( U , det , vec ) = forward_eliminatoin( A )
	#
	#     U    : 前方消去の結果生成された上三角行列。
	#     det  : 行列 A の行列式。
	#     vec  : det( A ) を導出する元になった数値配列を列ベクトル化したもの。
	#
	#     det != 0 の時、 U の対角は全て 1 となる。
	#     vec は、U の対角成分が 1 に変換される直前の対角成分であり、
	#
	#       det = Π( v[k] )           ( k == 1 -> n )
	#
	#     と言う関係になる。 ( Π は総積 )
	#
	#
	#   以下の行列を変換することを考える。
	#
	#     A == [ 1 , 2 , 3 , 1 ]
	#          [ 4 , 5 , 6 , 2 ]
	#          [ 7 , 8 , 0 , 3 ]
	#
	#   上記行列 A の前方消去は、以下の連立一次方程式を解く過程の前半部分に当たる。
	#
	#      x + 2y + 3z == 1
	#     4x + 5y + 6z == 2
	#     7x + 8y +  0 == 3
	#
	#   この連立方程式を行列の演算で表現すると、
	#
	#     [ 1 , 2 , 3 ] * [ x ] == [ 1 ]
	#     [ 4 , 5 , 6 ]   [ y ]    [ 2 ]
	#     [ 7 , 8 , 0 ]   [ z ]    [ 3 ]
	#
	#   となり、行列 A はこれを反映したものとなっている。
	#
	#
	#   行列 A , B の 1 行目を A[ 1 ] 、1 行 1 列目を A[ 1 , 1 ] とする。
	#
	#   前方消去は、 A[ n , n ] ( 左正方行列の対角 ) を境にしてその下方の成分を 0 に変換していく処理となる。
	#
	#   まず、A[ 1 , 1 ] == 1 を基準とし、行ベクトル A[ 2 ] == [ 4 , 5 , 6 , 2 ] について、A[ 2 , 1 ] == 4 -> 0 にするような演算を行う。
	#
	#     A[ 1 , 1 ] == 1
	#     A[ 2 , 1 ] == 4
	#     -> 係数 c == A[ 2 , 1 ] / A[ 1 , 1 ]
	#               == 4 / 1
	#               == 4
	#
	#     A[ 2 ] == A[ 2 ] - A[ 1 ] * c
	#            == [     4 ,     5 ,      6 ,     2 ] - 4 * [ 1 , 2 , 3 , 1 ]
	#            == [ 4 - 4 , 5 - 8 , 6 - 12 , 2 - 4 ]
	#            == [     0 ,    -3 ,     -6 ,    -2 ]
	#
	#   同様に、 A[ 3 ] についても、
	#
	#     A[ 1 , 1 ] == 1
	#     A[ 3 , 1 ] == 7
	#     c == A[ 3 , 1 ] / A[ 1 , 1 ]
	#       == 7 / 1
	#       == 7
	#
	#     A[ 3 ] == A[ 3 ] - A[ 1 ] * c
	#            == [     7 ,      8 ,      0 ,     3 ] - 7 * [ 1 , 2 , 3 , 1 ]
	#            == [ 7 - 7 , 8 - 14 , 0 - 21 , 3 - 7 ]
	#            == [     0 ,     -6 ,    -21 ,    -4 ] 
	#
	#   とした結果、
	#
	#     A == [ 1 ,  2 ,   3 ,  1 ]
	#          [ 0 , -3 ,  -6 , -2 ]
	#          [ 0 , -6 , -21 , -4 ]
	#
	#     -> x + 2y +  3z ==  1
	#           -3y -  6z == -2 == 2 - ( 1 * 4 )
	#           -6y - 21z == -4 == 3 - ( 1 * 7 )
	#
	#   が得られる。
	#
	#   同様に、 A[ 2 , 2 ] == -3 を基準とし、行ベクトル A[ 3 ] == [ 0 , -6 , -21 , -4 ] について、A[ 3 , 2 ] == -6 -> 0 にするような演算を行う。
	#
	#     A[ 2 , 2 ] == -3
	#     A[ 3 , 2 ] == -6
	#     c == A[ 3 , 2 ] / A[ 2 , 2 ]
	#       == -6 / -3
	#       == 2
	#
	#     A[ 3 ] == A[ 3 ] - A[ 2 ] * c
	#            == [     0 ,     -6 ,      -21 ,     -4 ] - 2 * [ 0 , -3 , -6 , -2 ]
	#            == [ 0 - 0 , -6 + 6 , -21 + 12 , -4 + 4 ]
	#            == [     0 ,      0 ,       -9 ,      0 ]
	#
	#   結果、
	#
	#     A == [ 1 ,  2 ,   3 ,  1 ]
	#          [ 0 , -3 ,  -6 , -2 ]
	#          [ 0 ,  0 ,  -9 ,  0 ]
	#
	#     -> x + 2y +  3z ==  1
	#           -3y -  6z == -2 == 2 - ( 1 * 4 )
	#                 -9z ==  0 == 3 - ( 1 * 7 ) - ( -2 * 2 ) 
	#
	#   となる。
	#
	#   下三角行列が全て 0 になったので、 A の左側 3 x 3 行列 ( これを B とする ) の行列式を求める。
	#   行列式は B の対角の総積となって現れる。
	#
	#     det( B ) == det( [  1 ,  2 ,  3 ] )
	#                      [  0 , -3 , -6 ]
	#                      [  0 ,  0 , -9 ]
	#
	#              == 1 * -3 * -9
	#              == 27
	#
	#   余因子展開で求めると、
	#
	#     det( B ) == det( [  1 ,  2 ,  3 ] )
	#                      [  0 , -3 , -6 ]
	#                      [  0 ,  0 , -9 ]
	#
	#              == 1 * det( [ -3 , -6 ] ) + ( -1 ) * 0 * det( [  2 ,  3 ] ) + 0 * det( [  2 ,  3 ] ) 
	#                          [  0 , -9 ] )                     [  0 , -9 ]              [ -3 , -6 ]
	#
	#              ==      1 * ( ( -3 * -9 ) - ( -6 *  0 ) )
	#                 -1 * 0 * ( (  2 * -9 ) - (  2 *  3 ) )
	#                 +    0 * ( (  2 * -6 ) - (  3 * -3 ) )
	#
	#              == 27
	#
	#   であり、これらは一致する。
	#   これは、変換前の A から左側 3 x 3 行列を取り出した行列 C の行列式に等しい。
	#
	#     A == [ 1 , 2 , 3 , 1 ] -> C == [ 1 , 2 , 3 ]
	#          [ 4 , 5 , 6 , 2 ]         [ 4 , 5 , 6 ]
	#          [ 7 , 8 , 0 , 3 ]         [ 7 , 8 , 0 ]
	#
	#   C を余因子展開すると、
	#
	#     det( C ) == det( [ 1 , 2 , 3 ] )
	#                      [ 4 , 5 , 6 ]
	#                      [ 7 , 8 , 0 ]
	#
	#              == 1 * det( [ 5 , 6 ] ) + ( -1 ) * 4 * det( [ 2 , 3 ] )  + 7 * det( [ 2 , 3 ] )
	#                          [ 8 , 0 ]                       [ 8 , 0 ]               [ 5 , 6 ]
	#
	#              ==   1 * ( ( 5 * 0 ) - ( 6 * 8 ) )
	#                 - 4 * ( ( 2 * 0 ) - ( 3 * 8 ) )
	#                 + 7 * ( ( 2 * 6 ) - ( 3 * 5 ) )
	#
	#              == -1 * ( 2 * 3 * 8 ) + ( 4 * 3 * 8 ) - ( 7 * 3 )
	#              == ( 3 * 8 ) * ( -2 + 4 ) - ( 7 * 3 )
	#              == 3 * ( 16 - 7 )
	#              == 27
	#
	#
	#   最後に、対角成分を全て 1 に変換する。
	#   これは、対角成分の値を用いて、その行全体を除算することで得られる。
	#
	#   上記の例では、
	#
	#     A == [  1 ,  2 ,  3 ,  1 ] /  1  == [ 1 , 2 , 3 ,   1 ]
	#          [  0 , -3 , -6 , -2 ] / -3     [ 0 , 1 , 2 , 2/3 ]
	#          [  0 ,  0 , -9 ,  0 ] / -9     [ 0 , 0 , 1 ,   0 ]
	#
	#     -> [ 1 , 2 , 3 ] * [ x ] == [   1 ]
	#        [ 0 , 1 , 2 ]   [ y ]    [ 2/3 ]
	#        [ 0 , 0 , 1 ]   [ z ]    [   0 ]
	#
	#     ->  x + 2y + 3z ==   1
	#              y + 2z == 2/3 == ( 2 - ( 1 * 4 ) ) / ( -3 )
	#                   z ==   0 == ( 3 - ( 1 * 7 ) - ( -2 * 2 ) ) / ( -9 )
	#
	#   となる。
	#
	#   前方消去の戻り値は、この行列 A と行列式 det( B ) == 27 となる。
	#   これに対して、上記の z == 0 を基点として、 x , y を求める処理が「後退代入」に当たる。
	#
	#
	#   前方消去では、対角成分に 0 が現れると演算不能になるが、この場合にはより後方の行で同じ桁が 0 でないものを選び、
	#   この 2 つの行を交換することで処理を継続することができる。 ( 「ピボット選択」や「枢軸選択」と呼ばれる。 )
	#   ピボット選択を行う際には、その桁の値が最も大きい行を選択して交換すると演算効率が上がるとされている。
	#
	#   なお、行列式の正負の符号は、このピボット選択が行われる度に反転する。
	#   よって、ピボット選択の回数が奇数回の時 det *= ( -1 ) となるような演算が必要となる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return []    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	my $det = new_decimal( 1 ) ;			# 行列式を格納する変数。
	my $diag = $m->cvector()->zero_vector() ;	# 行列式の元になった数列を列ベクトル化して格納する変数。
	my $pvtr = [] ;					# ピボット選択の実績を管理する。

	my( $rows , $cols ) = $m->size() ;
	my $c = 0 ;
	foreach my $r ( 0 .. ( $rows - 2 ) ) {
		#
		# ピボット選択 ( 枢軸選択 )
		#
		#   [ $r , $r ] == 0 であれば、後続の行の $c 列に絶対値最大の値を持つ行と差し替える。
		#
		if ( $m->[ $r ]->[ $r ] == 0 ) {
			last   if ( $r >= ( $rows - 1 ) ) ;
			my $ix = (
				sort { $m->[ $b ]->[ $r ]->abs() <=> $m->[ $a ]->[ $r ]->abs() }
				( $r + 1 .. ( $rows - 1 ) )
			)[0] ;
			( $m->[ $r ] , $m->[ $ix ] ) = ( $m->[ $ix ] , $m->[ $r ] ) ;

			#
			# ピボット選択が行われるごとに行列式の符号が反転する。
			#
			unless ( $r == $ix ) {
				$det *= ( -1 ) ;
				unshift( @{ $pvtr } , [ $r , $ix ] ) ;
			}
		}

		last    if ( $m->[ $r ]->[ $r ] == 0 ) ;

		#
		# $r + 1 行以降の $r 列を 0 にする。
		#
		foreach my $r1 ( $r + 1 .. ( $rows - 1 ) ) {
			my $v = $m->[ $r1 ]->[ $r ] / $m->[ $r ]->[ $r ] ;			# $v == [ $r1 , $r ] / [ $r , $r ]
			foreach my $c1 ( $c .. ( $cols - 1 ) ) {
				$m->[ $r1 ]->[ $c1 ] -= $m->[ $r ]->[ $c1 ] * $v ;		# [ $r1 , $c1 ] -= ( [ $r , $c1 ] * $v )
			}
		}
	}

	#
	# [ $r , $r ] ( 対角成分 ) の値で $r 行の全ての値を除算する。 ( [ $r , $r ] == 1 になる。)
	#
	# この処理の過程で対角成分 [ $r , $r ] の総積を採ることで行列式が算出される。
	#
	#$m = $m->round( $DECIMAL_PART_LENGTH_LIMIT * 0.7 ) ;
	foreach my $r ( 0 .. ( $rows - 1 ) ) {

		my $v = $m->[ $r ]->[ $r ] ;	# 対角成分の値
		$det *= $v ;			# 行列式 ( 対角成分の総積 )
		$diag->[ $r ]->[0] = $v ;	# 対角成分をベクトルの成分として格納

		unless ( $v == 0 ) {
			foreach my $c ( 0 .. ( $cols - 1 ) ) {
				$m->[ $r ]->[ $c ] /= $v ;
			}
		}
	}

	#
	# ピボット選択によって交換された行を戻す。
	#
	foreach my $p ( @{ $pvtr } ) {
		( $m->[ $p->[0] ] , $m->[ $p->[1] ] ) = ( $m->[ $p->[1] ] , $m->[ $p->[0] ] ) ;
	}

	$det = $det->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	return ( $m , $det , $diag ) ;
}

=head2 backward_substitution

The backward substitution is the second part of the Gaussian elimination.

When the result of forward elimination is 

  A == [ 1 , 2 , 3 , 1 ]
       [ 4 , 5 , 6 , 2 ]
       [ 7 , 8 , 0 , 3 ]

  B == forward_elimination( A ) == [ 1 , 2 , 3 ,   1 ]
                                   [ 0 , 1 , 2 , 2/3 ]
                                   [ 0 , 0 , 1 ,   0 ]
At the first,

  C == B == [ 1 , 2 , 3 ,   1 ]
            [ 0 , 1 , 2 , 2/3 ]
            [ 0 , 0 , 1 ,   0 ]

  -> C[2,3] == 2 -> 0

     C[3,3] == 1
     C[2,3] == 2
     c == C[2,3] / C[3,3] == 2

     C[2] == C[2] - C[3] * c

          == [ 0 , 1 , 2 ,  2/3 ] - 2 * [ 0 , 0 , 1 , 0 ]

          == [ 0 , 1 , 0 ,  2/3 ]


  -> C[1,3] == 3 -> 0

     C[3,3] == 1
     C[1,3] == 3
     c == C[1,3] / C[3,3] == 3

     C[1] == C[1] - C[3] * c

          == [ 1 , 2 , 3 , 1 ] - 3 * [ 0 , 0 , 1 , 0 ]

          == [ 1 , 2 , 0 , 1 ]

Then

  C == [ 1 , 2 , 0 ,   1 ]
       [ 0 , 1 , 0 , 2/3 ]
       [ 0 , 0 , 1 ,   0 ]

Next, 

  C[1,2] == 2 -> 0

  C[2,2] == 1
  C[1,2] == 2
  c == C[1,2] / C[2,2] == 2

  C[1] == C[1] - C[2] * c

       == [ 1 , 2 , 0 ,    1 ] - 2 * [ 0 , 1 , 0 , 2/3 ]

       == [ 1 , 0 , 0 , -1/3 ]

The result is 

  C == [ 1 , 0 , 0 , -1/3 ]
       [ 0 , 1 , 0 ,  2/3 ]
       [ 0 , 0 , 1 ,    0 ]

This method will return this C.

=cut

sub backward_substitution {
	#-----------------------------------------------------------------------
	#
	# ガウスの消去法における後退代入 ( backward substitution )
	#
	#   行列の対角を採りながら上三角行列を 0 に変えていく。
	#
	#   前方消去によって
	#
	#     A == [ 1 , 2 , 3 , 1 ]
	#          [ 4 , 5 , 6 , 2 ]
	#          [ 7 , 8 , 0 , 3 ]
	#
	#     B == forward_elimination( A ) == [ 1 , 2 , 3 ,   1 ]
	#                                      [ 0 , 1 , 2 , 2/3 ]
	#                                      [ 0 , 0 , 1 ,   0 ]
	#
	#   が得られたとする。
	#
	#   後退代入後の行列を C とする。
	#
	#     C == backward_substitution( B )
	#   
	#   C の演算過程は以下のようになる。
	#
	#   まず、 C == B として初期化する。
	#
	#     C == B == [ 1 , 2 , 3 ,   1 ]
	#               [ 0 , 1 , 2 , 2/3 ]
	#               [ 0 , 0 , 1 ,   0 ]
	#
	#   C[ 3 ] == [ 0 , 0 , 1 , 0 ] を基準として、 C[ 2 , 3 ] == 2 -> 0 となるような変換を施す。
	#
	#     C[ 3 , 3 ] == 1
	#     C[ 2 , 3 ] == 2
	#     c == C[ 2 , 3 ] / C[ 3 ,3 ] == 2
	#
	#     C[ 2 ] == C[ 2 ] - C[ 3 ] * c
	#            == [ 0 , 1 , 2 ,  2/3 ] - 2 * [ 0 , 0 , 1 , 0 ]
	#            == [ 0 , 1 , 0 ,  2/3 ]
	#
	#   同じく、 C[ 3 ] == [ 0 , 0 , 1 , 0 ] を基準として、 C[ 1 , 3 ] == 3 -> 0 となるような変換を施す。
	#
	#     C[ 3 , 3 ] == 1
	#     C[ 1 , 3 ] == 3
	#     c == C[ 1 , 3 ] / C[ 3 ,3 ] == 3
	#
	#     C[ 1 ] == C[ 1 ] - C[ 3 ] * c
	#            == [ 1 , 2 , 3 , 1 ] - 3 * [ 0 , 0 , 1 , 0 ]
	#            == [ 0 , 2 , 0 , 1 ]
	#
	#   この時点で C は、
	#
	#     C == [ 1 , 2 , 0 ,   1 ]
	#          [ 0 , 1 , 0 , 2/3 ]
	#          [ 0 , 0 , 1 ,   0 ]
	#
	#   となる。
	#
	#   次に、 C[ 2 ] == [ 0 , 1 , 0 , 2/3 ] を基準として C[ 1 , 2 ] == 2 -> 0 とする処理を行う。
	#
	#     C[ 2 , 2 ] == 1
	#     C[ 1 , 2 ] == 2
	#     c == C[ 1 , 2 ] / C[ 2 , 2 ] == 2
	#
	#     C[ 1 ] == C[ 1 ] - C[ 2 ] * c
	#            == [ 1 , 2 , 0 ,    1 ] - 2 * [ 0 , 1 , 0 , 2/3 ]
	#            == [ 1 , 0 , 0 , -1/3 ]
	#
	#   結果は、
	#
	#     C == [ 1 , 0 , 0 , -1/3 ]
	#          [ 0 , 1 , 0 ,  2/3 ]
	#          [ 0 , 0 , 1 ,    0 ]
	#
	#   であり、左 3 x 3 行列の非対角成分が全て 0 となったので、ここで後退代入は完了となる。
	#   ( この行列が後退代入の戻り値。 )
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;

	#
	# 後方の行から遡って処理する。
	#
	foreach my $r ( reverse( 0 .. ( $rows - 2 ) ) ) {
		my $c = $r + 1 ;				# [ $r , $r ] の右隣の列に注目。
		next    if ( $m->[ $c ]->[ $c ] == 0 ) ;	# [ $c , $c ] == [ $r + 1 , $r + 1 ] == 0 であればスキップ。
	
		#
		# 現在行とその上方の三角行列を 0 に変換。
		#
		foreach my $r1 ( reverse( 0 .. $r ) ) {
			my $v = $m->[ $r1 ]->[ $c ] / $m->[ $r + 1 ]->[ $c ] ;			# $v == [ $r1 , $c ] / [ $r + 1 , $c ]
			foreach my $c1 ( $c .. ( $cols - 1 ) ) {
				$m->[ $r1 ]->[ $c1 ] -= $v * $m->[ $r + 1 ]->[ $c1 ] ;		# [ $r1 , $c1 ] -= $v * [ $r + 1 , $c1 ]
			}
		}
	}

	return $m ;
}

sub gauss_jordan_elimination {
	#-----------------------------------------------------------------------
	#
	# ガウスジョルダンの消去法 ( Gauss Jordan elimination )
	#
	#   ガウスの消去法は前進消去と後退代入によって実現される。
	#   ガウスジョルダンの消去法は、前進消去の際に後退代入相当の処理を同時に実施する手法。
	#
	#   ロジックは非常に単純になるが、演算回数は増える。
	#
	#
	#   以下の行列を変換することを考える。
	#
	#     A == [ 1 , 2 , 3 , 1 ]
	#          [ 4 , 5 , 6 , 2 ]
	#          [ 7 , 8 , 0 , 3 ]
	#
	#   まず、 A[ 1 ] を用いて A[ 2 ] , A[ 3 ] を処理する。
	#
	#     c == A[ 2 , 1 ] / A[ 1 , 1 ] == 4 / 1 == 4
	#
	#     A[ 2 ] == A[ 2 ] - A[ 1 ] * c
	#            == [     4 ,     5 ,      6 ,     2 ] - [ 1 , 2 , 3 , 1 ] * 4
	#            == [ 4 - 4 , 5 - 8 , 6 - 12 , 2 - 4 ]
	#            == [     0 ,    -3 ,     -6 ,    -2 ]
	#
	#     c == A[ 3 , 1 ] / A[ 1 , 1 ] == 7 / 1 == 7
	#
	#     A[ 3 ] == A[ 3 ] - A[ 1 ] * c
	#            == [     7 ,      8 ,      0 ,     3 ] - [ 1 , 2 , 3 , 1 ] * 7
	#            == [ 7 - 7 , 8 - 14 , 0 - 21 , 3 - 7 ]
	#            == [     0 ,     -6 ,    -21 ,    -4 ]
	#
	#     A[ 1 , 1 ] == 1 で A[ 1 ] 全体を除算。
	#
	#       A[ 1 ] == A[ 1 ] / A[ 1 , 1 ]
	#              == [ 1 , 2 , 3 , 1 ] / 1
	#              == [ 1 , 2 , 3 , 1 ]
	#
	#   ここまでの処理で、
	#
	#     A == [   1 ,   2 ,   3 ,  1 ]
	#          [   0 ,  -3 ,  -6 , -2 ]
	#          [   0 ,  -6 , -21 , -4 ]
	#
	#   となる。
	#
	#   次に、 A[ 2 ] を用いて A[ 1 ] , A[ 3 ] を処理する。
	#
	#     A[ 1 ] == A[ 1 ] - A[ 2 ] * ( A[ 1 , 2 ] / A[ 2 , 2 ] )
	#            == [     1 ,     2 ,     3 ,       1 ] - [ 0 , -3 , -6 , -2 ] * ( -2/3 )
	#            == [ 1 - 0 , 2 - 2 , 3 - 4 , 1 - 4/3 ]
	#            == [     1 ,     0 ,    -1 ,    -1/3 ]
	#
	#     A[ 3 ] == A[ 3 ] - A[ 2 ] * ( A[ 3 , 2 ] / A[ 2 , 2 ] )
	#            == [     0 ,     -6 ,      -21 ,     -4 ] - [ 0 , -3 , -6 , -2 ] * 2
	#            == [ 0 - 0 , -6 + 6 , -21 + 12 , -4 + 4 ]
	#            == [     0 ,      0 ,       -9 ,      0 ]
	#
	#     A[ 2 ] == A[ 2 ] / A[ 2 ,2 ] 
	#            == [  0 ,  -3 ,  -6 ,  -2 ] / ( -3 )
	#            == [  0 ,   1 ,   2 , 2/3 ]
	#
	#     -> A == [  1 ,  0 , -1 , -1/3 ]
	#             [  0 ,  1 ,  2 ,  2/3 ]
	#             [  0 ,  0 , -9 ,    0 ]
	#
	#   同様に、 A[ 3 ] を用いて A[ 1 ] , A[ 2 ] を処理する。
	#
	#     A[ 1 ] == A[ 1 ] - A[ 3 ] * ( A[ 1 , 3 ] / A[ 3 , 3 ] )
	#            == [     1 ,     0 ,     -1 ,     -1/3 ] - [ 0 ,  0 , -9 ,  0 ] * ( 1/9 )
	#            == [ 1 - 0 , 0 - 0 , -1 + 1,  -1/3 + 0 ]
	#            == [     1 ,     0 ,      0 ,     -1/3 ]
	#
	#     A[ 2 ] == A[ 2 ] - A[ 3 ] * ( A[ 2 , 3 ] / A[ 3 , 3 ] )
	#            == [     0 ,     1 ,      2 ,      2/3 ] - [ 0 ,  0 , -9 ,  0 ] * ( -2/9 )
	#            == [ 0 - 0 , 1 - 0 ,  2 - 2 ,  2/3 - 0 ]
	#            == [     0 ,     1 ,      0 ,      2/3 ]
	#
	#     A[ 3 ] == A[ 3 ] / A[ 3 ,3 ] 
	#            == [  0 ,   0 ,  -9 ,   0 ] / ( -9 )
	#            == [  0 ,   0 ,   1 ,   0 ]
	#
	#     -> A == [  1 ,  0 ,  0 , -1/3 ]
	#             [  0 ,  1 ,  0 ,  2/3 ]
	#             [  0 ,  0 ,  1 ,    0 ]
	#
	#   上記 A を返して完了。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = $self->copy() ;
	my( $rows , $cols ) = $m->size() ;

	foreach my $r ( 0 .. ( $rows - 1 ) ) {

		my $v = $m->[ $r ]->[ $r ] ;
		return undef	if ( $v == 0 ) ;

		#
		# A[r] 行を基準として他の行を減算
		#
		#   v == A[r1,r] / A[r,r]
		#   A[r1,c] -= A[r,c] * v
		#
		foreach my $r1 ( 0 .. ( $rows - 1 ) ) {
			next	if ( $r1 == $r ) ;
			my $w = $m->[ $r1 ]->[ $r ] / $m->[ $r ]->[ $r ] ;
			foreach my $c ( 0 .. ( $cols - 1 ) ) {
				$m->[ $r1 ]->[ $c ] -= $m->[ $r ]->[ $c ] * $w ;
			}
		}

		#
		# A[r,r] == 1 となるように A[r] 行を変換。
		#
		foreach my $c ( 0 .. ( $cols - 1 ) ) {
			$m->[ $r ]->[ $c ] /= $v ;
		}
	}

	return $m ;
}

=head1 'Vector' object - FFT / DCT

=cut

#-------------------------------------------------------------------------------
#
# 離散フーリエ変換 / 離散コサイン変換
#
#-------------------------------------------------------------------------------

=head2 fft , ifft

Two-Dimensional Fast Fourier Transform.

When the m x n matrix F transform to matrix f,

  f == fft( F ) == W * transpose( F ) * W

If the elements of F are defined as F[x,y], and the elements of f are defined as f[r,c],

                        2PI
  W[r,c] == exp( -i * ------- * ( ( n * r * x + n * c * y ) % ( m * n ) ) )
                       m * n

If the elements of F are defined as F[r,c], and the elements of f are defined as f[x,y], the inverse FFT is defined as follows.

  F == ifft( f ) == W * transpose( f ) * W

                       2PI
  W[r,c] == exp( i * ------- * ( ( n * r * x + n * c * y ) % ( m * n ) ) )
                      m * n

The FFT causes the clockwise rotation by -i, and iFFT causes the counter clockwise rotation by +i.



  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m->fft() ;                                    # [             45.00000 ,       -4.50 + 2.60 i ,       -4.50 - 2.60 i ]
                                                       # [      -13.50 + 7.79 i ,              0.00000 ,              0.00000 ]
                                                       # [      -13.50 - 7.79 i ,              0.00000 ,              0.00000 ]

  print $m->fft()->ifft() ;                            # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

=cut

sub fft {
	#-----------------------------------------------------------------------
	#
	# 二次元高速フーリエ変換 ( Two-Dimensional Fast Fourier Transform )
	#
	#   m x n 行列 F -> f への変換を正変換とし、 f -> F の変換を逆変換とする。
	#
	#   正変換
	#                                                                                 2PI                      2PI
	#     f[r,c] == Σ( x == 0 -> m - 1 ){ Σ( y == 0 -> n - 1 ){ F[x,y] * exp( -i * ----- * rx ) * exp( -i * ----- * cy ) } }
	#                                                                                  m                        n
	#
	#                                                                                 2PI
	#            == Σ( x == 0 -> m - 1 ){ Σ( y == 0 -> n - 1 ){ F[x,y] * exp( -i * ----- * ( nrx + mcy ) ) } }
	#                                                                                 mn
	#   逆変換
	#                 1                                                                        2PI                       2PI
	#     F[r,c] == ------ * Σ( x == 0 -> m - 1 ){ Σ( y == 0 -> n - 1 ){ f[x,y] * exp( i * ------- * rx ) * exp( i * ------- * cy ) } }
	#                 mn                                                                        m                         n
	#
	#                 1                                                                        2PI
	#            == ------ * Σ( x == 0 -> m - 1 ){ Σ( y == 0 -> n - 1 ){ f[x,y] * exp( i * ------- * ( nrx + mcy ) ) } }
	#                 mn                                                                       mn
	#
	#   変換行列を W とおくと、二次元のフーリエ正変換の行列表現は以下のようになる。
	#
	#     f == W * transpose( F ) * W
	#     F == W * transpose( f ) * W
	#
	#   W はユニタリー行列 ( 直交行列 ) であり、 inverse( W ) == adjoint( W )
	#
	#   W の成分は、正変換の場合
	#                            2PI
	#     W[r,c] == exp( -i * --------- * ( ( nrx + ncy ) % mn ) )
	#                            mn
	#
	#   逆変換では
	#                           2PI
	#     W[r,c] == exp( i * --------- * ( ( nrx + ncy ) % mn ) )
	#                           mn
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my( $m , $n ) = $self->size() ;
	my $mn = $m * $n ;

	return undef	if ( $mn == 0 ) ;

	my $t = $self->zero_matrix() ;		# m x n の零行列

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::ifft$/ ) ? 1 : 0 ;

	#
	# 回転因子 ( 1 の原始 mn 乗根 ) を生成。
	#
	# 正変換の場合は各要素の複素共役を採る。
	#
	my $w = [ new_complex( [ 1 , 0 ] )->circle_group( $mn ) ] ;

	unless ( $inverse ) {
		#
		# w[ k ] = conj( w[ k ] ) に当たる処理。
		#
		$w = [ $w->[0] , reverse( @{ $w }[ 1 .. $#{ $w } ] ) ] ;
	}

	#
	# 変換
	#
	foreach my $r ( 0 .. ( $m - 1 ) ) {
		foreach my $c ( 0 .. ( $n - 1 ) ) {
			foreach my $x ( 0 .. ( $m - 1 ) ) {
				foreach my $y ( 0 .. ( $n - 1 ) ) {
					my $k = ( $n * $r * $x + $m * $c * $y ) % $mn ;
					$t->[ $r ]->[ $c ] += $self->[ $x ]->[ $y ] * $w->[ $k ] ;
				}
			}
		}
	}

	if ( $inverse ) {
		$t /= $mn ;
	}

	return $t ;
}

sub ifft {
	#-----------------------------------------------------------------------
	#
	# 二次元高速フーリエ逆変換 ( Inverse Two-Dimensional Fast Fourier Transform )
	#
	#   正変換か逆変換かは fft 内で判別する。 ( 呼び出し元の関数名を見ている。 )
	#
	#-----------------------------------------------------------------------
	return fft( @_ ) ;
}

sub fft2d	{ return fft( @_ ) ; }
sub ifft2d	{ return ifft( @_ ) ; }

=head2 dct , idct

Two-Dimensional Discrete Cosine Transform.


When the m x n matrix D transform to matrix d.

  d == dct( D )  == T * D

The Inverse DCT is defined as follows.

  D == idct( d ) == inverse( T ) * d 

The transition matrix T is defined as follows.

  T[0,j] == sqrt( 1/m ) * real( w[t] )                  ( j == 0 -> m - 1 )
  T[k,j] == sqrt( 2/m ) * real( w[t] )                  ( k == 1 -> m - 1 , j == 0 -> m - 1 )

  w = root( complex( [ 1 , 0 ] ) , m * 4 )

  -> w[0] == exp( 0 ) == 1

                       2 * PI
     w[t] == exp( i * -------- * t )                    ( t == ( k * ( 2 * j + 1 ) % m ) )
                       m * 4

The transition matrix T is a unitary matrix.

  inverse( T ) == adjojnt( T ) == conj( transpose( T ) )


For example.

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ;

  print $m->dct() ;                                    # [              6.92820 ,              8.66025 ,             10.39230 ]
                                                       # [             -4.24264 ,             -4.24264 ,             -4.24264 ]
                                                       # [              0.00000 ,              0.00000 ,              0.00000 ]

  print $m->dct()->idct() ;                            # [              1.00000 ,              2.00000 ,              3.00000 ]
                                                       # [              4.00000 ,              5.00000 ,              6.00000 ]
                                                       # [              7.00000 ,              8.00000 ,              9.00000 ]

The DCT and iDCT will affect to vector. ( not affect to matrix )

  $m = matrix(
    [ 1 , 2 , 3 ] ,
    [ 4 , 5 , 6 ] ,
    [ 7 , 8 , 9 ] ,
  ) ; 

 
  print $m->dct() ;                                    # [              6.92820 ,              8.66025 ,             10.39230 ]
                                                       # [             -4.24264 ,             -4.24264 ,             -4.24264 ]
                                                       # [              0.00000 ,              0.00000 ,              0.00000 ]

  print $m->vector( 0 )->dct() ;                       # [              6.92820 ]
                                                       # [             -4.24264 ]
                                                       # [              0.00000 ]

  print $m->vector( 0 )->dct()->idct() ;               # [              1.00000 ]
                                                       # [              4.00000 ]
                                                       # [              7.00000 ]

  print $m->vector( 1 )->dct() ;                       # [              8.66025 ]
                                                       # [             -4.24264 ]
                                                       # [              0.00000 ]

  print $m->vector( 1 )->dct()->idct() ;               # [              2.00000 ]
                                                       # [              5.00000 ]
                                                       # [              8.00000 ]

  print $m->vector( 2 )->dct() ;                       # [             10.39230 ]
                                                       # [             -4.24264 ]
                                                       # [              0.00000 ]

  print $m->vector( 2 )->dct()->idct() ;               # [              3.00000 ]
                                                       # [              6.00000 ]
                                                       # [              9.00000 ]


=cut

sub dct {
	#-----------------------------------------------------------------------
	#
	# 二次元離散コサイン変換 ( Two-Dimensional Discrete Cosine Transform )
	#
	#
	#   列ベクトル v のサイズを n とおくと、回転因子は、
	#
	#     w = root( complex( [ 1 , 0 ] ) , n * 4 )
	#
	#   で得られる複素数列 w ( 1 の 4n 乗根の集合 ) となる。
	#  
	#   離散コサイン正変換における変換行列 T は、
	#
	#     t == ( k * ( 2j + 1 ) ) % ( n * 4 )
	#
	#     T[ k , j ] == real( w[ t ] )       ( k == 0 -> n - 1 , j == 0 -> n - 1 )
	#
	#   で生成することができ、正変換は、
	#
	#     dct( v ) == T * v
	#
	#   となる。
	#
	#   離散コサイン逆変換は、正変換の場合と同じ変換行列 T の逆行列を用いて、
	#
	#     idct( v ) == inverse( T ) * v
	#
	#   となる。
	#
	#   行列の演算において逆行列を求める際には、その演算過程において直交行列 ( ユニタリー行列 ) を生成する必要があり、
	#   このユニタリー化の処理に非常に大きな演算コストが必要となる。
	#   このため、変換行列 T を生成する際、これがユニタリー行列となるように予め調整を施した実装が一般に用いられる。
	#
	#   ユニタリー行列は、
	#
	#     inverse( T ) == adjoint( T )
	#                  == transpose( conj( T ) )
	#
	#   となるような複素行列であり、行列の各要素が全て実数であれば、これは直交行列となる。
	#
	#   ユニタリー行列化された変換行列は、以下の演算によって導出される。
	#
	#                          2                 k * ( 2j + 1 )
	#     T[ k , j ] == sqrt( --- ) * c * cos( ------------------ * PI )
	#                          n                    2 * n
	#
	#     c == sqrt( 1/2 )   if ( k == 0 )   -> sqrt( 2/n ) * c == sqrt( 1/n )
	#     c == 1             if ( k != 0 )   -> sqrt( 2/n ) * c == sqrt( 2/n )
	#     k == 0 -> n - 1
	#     j == 0 -> n - 1
	#
	#   余弦の演算箇所を整理すると、
	#
	#            k * ( 2j + 1 )
	#     cos( ------------------ * PI ) == cos( ( PI / 2n ) * ( k * ( 2j + 1 ) )
	#                2 * n
	#                                    == cos( ( 2PI / 4n ) * ( k * ( 2j + 1 ) )
	#
	#   であり、回転因子となる複素数列 w の導出と T[ k , j ] へのマッピングには何ら影響はなく、
	#   T の各成分 T[ k , j ] に掛ける係数を調整するだけでユニタリー化された変換行列を得ることができる。
	#
	#   即ち、
	#
	#     k == 0 -> n - 1
	#     j == 0 -> n - 1
	#
	#     t == ( k * ( 2j + 1 ) ) % n
	#
	#     T[ k , j ] == sqrt( 2/n ) * c * real( w[ t ] )
	#
	#     -> T[ 0 , j ] == sqrt( 1/n ) * real( w[ t ] )
	#        T[ k , j ] == sqrt( 2/n ) * real( w[ t ] )     ( k != 0 )
	#
	#   によって、変換行列 T が得られることになる。
	#
	#-----------------------------------------------------------------------
	my( $self ) = @_ ;
	return undef    unless ( ref( $self ) eq __PACKAGE__ ) ;

	my $m = undef ;
	my $n = undef ;

	if ( $self->is_vector() )	{ $m = $self->cvector() ; $n = $m->rows() ; }
	else				{ $m = $self->copy() ;    $n = $m->rows() ; }

	my $n4 = $n * 4 ;

	#
	# 正変換か逆変換かを抑える。
	#
	my $caller = ( caller 1 )[3] ;
	my $inverse = ( defined $caller and $caller =~ /::idct$/ ) ? 1 : 0 ;

	#
	# 回転因子
	#
	my $w = [ new_complex( [ 1 , 0 ] )->circle_group( $n4 ) ] ;

	#
	# 変換行列を生成
	#
	my $t = __PACKAGE__->zero_matrix( [ $n ] ) ;		# n x n の正方零行列
	my $sq1 = new_decimal( 1 )->divide( $n )->sqrt() ;	# sqrt( 1/n )
	my $sq2 = new_decimal( 2 )->divide( $n )->sqrt() ;	# sqrt( 2/n )

	foreach my $k ( 0 .. ( $n - 1 ) ) {
		#
		# ユニタリー化 ( 直交化 ) のための係数。
		#
		my $c = ( $k == 0 ) ? $sq1 : $sq2 ;

		#
		# 回転因子と係数の積を T[ k , j ] にマッピング。
		#
		foreach my $j ( 0 .. ( $n - 1 ) ) {
			#
			# T[ k , j ] == c * real( w[ ( k * ( 2j + 1 ) ) % 4n ] )
			#
			my $ix = $k * ( $j * 2 + 1 ) ;
			$ix %= $n4 ;
			$t->[ $k ]->[ $j ] = $c * $w->[ $ix ]->real() ;
		}
	}

	#
	# 変換
	#
	if ( $inverse ) {
		$m = $t->adjoint() * $m ;
	}
	else {
		$m = $t * $m ;
	}

	return $m ;
}

sub idct {
	#-----------------------------------------------------------------------
	#
	# 二次元離散コサイン逆変換 ( Inverse Two-Dimensional Discrete Cosine Transform )
	#
	#   正変換か逆変換かは dct 内で判別する。 ( 呼び出し元の関数名を見ている。 )
	#
	#-----------------------------------------------------------------------
	return dct( @_ ) ;
}

sub dct2d	{ return dct( @_ ) ; }
sub idct2d	{ return idct( @_ ) ; }

{
	sub _eigen_values_sq {
		#---------------------------------------------------------------
		#
		# 二次の正方行列の固有値を返す。
		#
		#   二次の正方行列では、平方完成が使える。
		#
		#
		#   以下のような二次の正方行列について、
		#
		#     A == [ a , b ]
		#          [ c , d ]
		#
		#     det( A - tI ) == 0
		#     -> ( a - t )( d - t ) - bc == 0
		#        t^2 - ( a + d ) * t + ad - bc == 0
		#
		#   となる t を求める。
		#
		#   ここで、
		#
		#     ( a + d )   == trace( A ) 
		#     ( ad - bc ) == det( A )
		#
		#   より、 c == trace( A )/2 , d == det( A ) とおくと、
		#
		#     t^2 - ( a + d ) * t + ad - bc == t^2 - 2ct + d == 0
		#
		#
		#   平方完成を適用して、
		#
		#     t^2 - 2ct + d == 0
		#
		#     -> t^2 - 2ct + c^2 - c^2 + d == 0
		#
		#     -> ( t - c )^2 == c^2 - d
		#
		#     -> t == c ± sqrt( c^2 - d )
		#
		#               trace( A )              trace( A )^2 - 4 * det( A )
		#          == -------------- ± sqrt( ------------------------------- )
		#                    2                               4
		#
		#          == ( trace( A ) ± sqrt( trace( A )^2 - 4 * det( A ) ) ) / 2
		#
		#   この時、 trace( A )^2 - 4 * det( A ) < 0 の場合、 t は虚数となる。
		#   二次の正方行列の固有値は常に 2 つの解を持つので、 trace( A )^2 - 4 * det( A ) を複素数として扱うのが正しい実装と言える。
		#
		#---------------------------------------------------------------
		my( $self ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
		return undef    unless ( $self->is_square_matrix() ) ;

		my $obj = $self->copy() ;

		my $r = [] ;

		my( $tr , $d ) = ( $obj->trace() , $obj->det() ) ;
		#my $diff = $tr->power( 2 )->subtract( $d->multiply( 4 ) )->sqrt() ;
		my $diff = $tr->power( 2 )->subtract( $d->multiply( 4 ) ) ;

		if ( $diff->is_complex() )	{ $diff = [ $diff->sqrt() ] ; }
		else				{ $diff = [ $diff->complex()->sqrt() ] ; }

		$r = [
			$tr->add( $diff->[0] )->divide( 2 , $DECIMAL_PART_LENGTH_LIMIT ) ,
			$tr->add( $diff->[1] )->divide( 2 , $DECIMAL_PART_LENGTH_LIMIT ) ,
		] ;

		return ( @{ $r } ) ? @{ $r } : () ;
	}

	sub _eigen_values_sarrus {
		#---------------------------------------------------------------
		#
		# 三次の正方行列の固有値を返す。
		#
		#   三次の正方行列では、固有多項式の導出にサラスの公式が使える。
		#
		#
		#   三次の正方行列を
		#
		#     A == [ a11 , a12 , a13 ]
		#          [ a21 , a22 , a23 ]
		#          [ a31 , a32 , a33 ]
		#
		#   と定義すると、行列式は、
		#
		#     det( A ) ==  ( ( a11 * a22 * a33 ) + ( a12 * a23 * a31 ) + ( a13 * a21 * a32 ) )
		#                - ( ( a13 * a22 * a31 ) + ( a12 * a21 * a33 ) + ( a11 * a23 * a32 ) )
		#
		#   となる。
		#
		#   これがサラス ( Sarrus ) の公式と呼ばれるもの。
		#   ( 二次の正方行列における行列式の演算もサラスの方法の一種。 )
		#
		#   固有値を求める演算では、
		#
		#     det( A - tE ) ==   ( ( ( a11 - t ) * ( a22 - t ) * ( a33 - t ) ) + ( a12 * a23 *   a31       ) + (   a13       * a21 * a32 ) )
		#                      - ( (   a13       * ( a22 - t ) *   a31       ) + ( a12 * a21 * ( a33 - t ) ) + ( ( a11 - t ) * a23 * a32 ) )
		#
		#                   == 0
		#   となる。
		#
		#   行列  A を
		#
		#     A == [ a , b , c ] == [ a11 , a12 , a13 ]
		#          [ d , e , f ]    [ a21 , a22 , a23 ]
		#          [ g , h , i ]    [ a31 , a32 , a33 ]
		#
		#   と再定義すると、
		#
		#     det( A - tE ) ==   ( ( a - t ) * ( e - t ) * ( i - t ) + ( b * f * g         ) + ( c * d * h )         )
		#                      - ( ( c * ( e - t ) * g )             + ( b * d * ( i - t ) ) + ( ( a - t ) * f * h ) )
		#
		#                   ==   ( ae - ( a + e ) * t + t^2 ) * ( i - t ) + bfg + cdh
		#                      - ( ceg - cg * t + bdi - bd * t + afh - fh * t )
		#
		#                   ==   aei - ( ai + ei ) * t + i * t^2 - ae * t + ( a + e ) * t^2 - t^3 + bfg + cdh
		#                      - ( ceg + bdi + afh ) - ( cg + bd + fh ) * t
		#
		#                   == -t^3 + ( a + e + i ) * t^2 - ( ai + ei + ae ) * t + aei + bfg + cdh
		#                      - ( ( ceg + bdi + afh ) - ( cg + bd + fh ) * t )
		#
		#                   == -t^3 + ( a + e + i ) * t^2 - ( ai + ei + ae - cg - bd - fh ) * t + ( ( aei + bfg + cdh ) - ( ceg + bdi + afh ) )
		#
		#                   == -t^3 + trace( A ) * t^2 - ( ai + ei + ae - cg - bd - fh ) * t + det( A )
		#
		#                   == 0
		#
		#   よって、行列 A の固有多項式は、
		#
		#     t^3 - trace( A ) * t^2 + ( ai + ei + ae - cg - bd - fh ) * t - det( A ) == 0
		#
		#   となる。
		#
		#   この時、
		#   
		#     c == ai + ei + ae - cg - bd - fh
		#       == a11 * a33 + a22 * a33 + a11 * a22 - a13 * a31 - a12 * a21 - a23 * a32
		#       == ( a11 * a33 - a13 * a31 ) + ( a22 * a33 - a23 * a32 ) + ( a11 * a22 - a12 * a21 )
		#
		#       == det( [ a11 , a13 ] ) + det( [ a22 , a23 ] ) + det( [ a11 , a22 ] )
		#               [ a31 , a33 ]          [ a32 , a33 ]          [ a12 , a21 ]
		#
		#       == cofactor( A , 2 , 2 ) + cofactor( A , 1 , 1 ) + cofactor( A , 3 , 3 )
		#
		#
		#   であり、これは行列 A の主小行列式 ( principal minor ) の総和となっている。
		#
		#   ここまでで導出した固有多項式の係数に注目すると、
		#
		#     t^2 の係数 trace( A ) == a + e + i
		#                           == a11 + a12 + a13
		#
		#     t^1 の係数 c          == ( ai - cg ) + ( ei - bd ) + ( ae - fh )
		#                           == ( a11 * a33 - a13 * a31 ) + ( a22 * a33 - a23 * a32 ) + ( a11 * a22 - a12 * a21 )
		#
		#     t^0 の係数 det( A )   == ( aei - ceg ) + ( bfg - bdi ) + ( cdh - afh )
		#                           == ( a11 * a22 * a33 - a13 * a22 * a31 ) + ( a12 * a23 * a31 - a12 * a21 * a33 ) + ( a13 * a21 * a32 - a11 * a23 * a32 )
		#
		#   となっている。
		#
		#   この固有多項式の解を x , y , z とおくと、
		#
		#     ( t - x ) * ( t - y ) * ( t - z ) == t^3 - ( x + y + z ) * t^2 + ( xy + yz + zx ) * t - xyz
		#                                       == t^3 - trace( A ) * t^2 + c * t - det( A )
		#                                       == 0
		#
		#     -> x + y + z    == trace( A )                       == ( -1 ) * p
		#        xy + yz + zx == c == Σ( principal_minor( A ) )  == q
		#        xyz          == det( A )                         == ( -1 ) * r
		#
		#   これらの係数をカルダノの方法に掛けて三次方程式を解くことによって固有値が得られる。
		#
		#     ( x , y , z ) == solve3( 1 , ( -1 ) * p , q , ( -1 ) * r )
		#
		#   ラグランジェのリゾルベントという概念を使っても同様の結果を得ることができるが、行き着く先は同じ。
		#
		#---------------------------------------------------------------
		my( $self ) = @_ ;
		return undef	unless ( ref( $self ) eq __PACKAGE__ ) ;
		return undef    unless ( $self->is_square_matrix() ) ;
		return undef	unless ( $self->rows() == 3 ) ;

		my $m = $self->copy() ;

		#-------------------------------------------------------
		#
		# カルダノの方法
		#
		#-------------------------------------------------------

		#
		#  A == [ a11 , a12 , a13 ]
		#       [ a21 , a22 , a23 ]
		#       [ a31 , a32 , a33 ]
		#
		#  t^3 - trace( A ) * t^2 + Σ( principal_minor( A ) ) * t - det( A )
		#  == X^3 + aX^2 + bX + c
		#  == 0
		#
		#    a == ( -1 ) * trace( A )
		#    b == Σ( principal_minor( A ) )
		#    c == ( -1 ) * det( A )
		#
		#  λ[k] == solve3( 1 , a , b , c )       ( k == 0 , 1 , 2 )
		#
		my $tr = $m->trace() * ( -1 ) ;

		my $pr =  $m->cofactor( 0 , 0 )
			+ $m->cofactor( 1 , 1 )
			+ $m->cofactor( 2 , 2 )
		;

		my $dt = $m->det() * ( -1 ) ;

		my ( $x , $y , $z ) = new_decimal( 1 )->solve3( $tr , $pr , $dt ) ;

		return ( $x , $y , $z ) ;
	}
}


=head1 'Polynomial' object

The 'Polynomial' object provides some functions about "the polynomial in a single indeterminate".

  $fx = polynomial( 1 , 2 , 3 , 4 , 5 ) ;
  print $fx ;                                          # 4 : 1
                                                       # 3 : 2
						       # 2 : 3
						       # 1 : 4
						       # 0 : 5
This means

  f(x) == x^4 + 2x^3 + 3x^2 + 4x + 5

Then

  print $fx->substitute( 10 ) ;                        # 12345           ( == f(10) )
  print $fx->substitute( 100 ) ;                       # 102030405       ( == f(100) )
  print $fx->substitute( 2 ) ;                         # 50              ( == f(2) )


If the argument is specified as a array reference, its indexes are regarded as degrees of the polynomial.

  $c = [ 1 , 2 , 3 , 4 , 5 ] ;
  $fx = polynomial( $c ) ;
  print $fx ;                                          # 4 : 5           ( == $c->[4] )
                                                       # 3 : 4           ( == $c->[3] )
						       # 2 : 3           ( == $c->[2] )
						       # 1 : 2           ( == $c->[1] )
						       # 0 : 1           ( == $c->[0] )
This means

  f(x) == 5x^4 + 4x^3 + 3x^2 + 2x + 1

Then

  print $fx->substitute( 10 ) ;                        # 54321           ( == f(10) )
  print $fx->substitute( 100 ) ;                       # 504030201       ( == f(100) )
  print $fx->substitute( 2 ) ;                         # 129             ( == f(2) )

This object has some calculation methods.

  $fx = polynomial( 1 ,  1 ) ;                          # == x + 1 
  $gx = polynomial( 1 , -1 ) ;                          # == x - 1
  
  print $fx + $gx ;                                     # 1 : 2          ( == 2x )
                                                        # 0 : 0

  print $fx - $gx ;                                     # 1 : 0          ( == 2 )
                                                        # 0 : 2

  print $fx * $gx ;                                     # 2 : 1          ( == x^2 - 1 )
                                                        # 1 : 0
                                                        # 0 : -1

  print $hx = ( $fx * $gx ) / $fx ;                     # 1 : 1          ( == x - 1 )
                                                        # 0 : -1

  print $fx ** 2 ;                                      # 2 : 1          ( == x^2 + 2x + 1 )
                                                        # 1 : 2
							# 0 : 1

  print $hx = ( $fx ** 2 ) / $gx ;                      # 1 : 1          ( == x + 3 )
                                                        # 0 : 3

  print $hx = ( $fx ** 2 ) % $gx ;                      # 0 : 4          ( == 4 )

  print $gx * polynomial( 1 , 3 ) + 4 ;                 # 2 : 1          ( == ( x - 1 ) * ( x + 3 ) + 4 == x^2 + 2x + 1 )
                                                        # 1 : 2
							# 0 : 1

=cut

#===============================================================================
#
# 一変数 n 次多項式 ( polynomial in a single indeterminate ; 単一不定元多項式 )
#
#===============================================================================

package Polynomial ;

#
#   一変数 n 次多項式は、
#
#     f(X) == Σ( a[k] * X^k )            ( k == 0 -> n )
#          == Π( X - x[i] )              ( i == 1 -> n )
#
#   で表される。
#
#
#   関数 ( polynomial function )
#
#     多項式 f(X) を右辺に持つ
#
#       Y == f(X)
#
#     は、関数と呼ばれ、任意の X を「代入」することによって Y が決定する。
#
#     三次または四次の多項式を右辺に持つ
#
#       Y^2 == f(X)
#
#     は、楕円曲線関数と呼ばれ、多項式が五次以上の場合には、超楕円曲線関数と呼ばれる。
#
#
#   方程式 ( polynomial equation )
#   
#     多項式 f(X) を左辺に持つ
#
#       f(X) == 0
#
#     は方程式と呼ばれ、これを満たす任意の値 ( 上記 x[i] ) は、その解 ( 根 ) と呼ばれる。
#     一変数 n 次方程式は、必ず n 個の複素数解を持つ。 ( 代数学の基本定理 ; fundamental theorem of algebra )
#
#
#   冪級数 ( power series )
#
#     多項式の次数の上限を無限大においたものは冪級数 ( 形式冪級数 ; formal power series ) と呼ばれる。
#     
#       f(X) == Σ( a[k] * X^k )          ( k == 0 -> ∞ )
#
#     より一般には、
#
#       f(X) == Σ( a[k] * ( x - c )^n    ( k == 0 -> ∞ )
#
#     を指して、 c を中心 ( center ) とする冪級数と呼ばれる。
#
#     冪級数は多項式の概念をより一般に拡張したものと考えることもできる。
#
#
#   多項式の演算
#   
#     多項式の演算は、次数と係数の演算に還元される。
#
#     加減算は、次数を同じくする項同士の係数の加減算となる。
#     乗算は次数の加算と係数の積和演算に還元される。
#
#     除算は、除数の種類によって演算方法が変わる。
#
#       定数 ( スカラー ) による除算は、係数の除算に還元される。
#       一次式 ( 一次の二項式 ) による除算は、組み立て除法を用いて演算を行うことができる。
#       その他の n 次多項式による除算は、筆算を模した処理によって演算を行うことができる。
#
#       多項式同士の除算では、多くの場合、剰余値としての多項式が存在する。
#

use utf8 ;

use strict ;
use warnings ;

use Carp ;

use POSIX qw() ;

use overload
	'""'    => 'as_string'		,
	#'0+'    => 'as_numeric'		,
	'+'	=> 'add'		,
	'-'	=> 'subtract'		,
	'*'	=> 'multiply'		,
	'/'	=> 'divide'		,
	'%'	=> 'modulus'		,
	'**'    => 'power'		,
	'=='	=> 'equal'		,
	'eq'	=> 'equal'		,
	'!='	=> 'not_equal'		,
	'ne'	=> 'not_equal'		,
	#'>'	=> 'greater_than'	,
	#'>='	=> 'greater_equal'	,
	#'<'	=> 'less_than'		,
	#'<='	=> 'less_equal'		,
;

#-------------------------------------------------------------------------------
#
# コンストラクター
#
#-------------------------------------------------------------------------------

sub new_decimal { return MyDecimal->new( $_[0] ) ; }
sub new_complex { return Complex->new( $_[0] ) ; }
sub pi		{ return MyDecimal::pi() ; }

sub new {
	#-----------------------------------------------------------------------
	#
	# 多項式の係数を受け取り、多項式オブジェクトを生成する。
	#
	#   polynomial( c ) == c[n] * X^0 + c[n-1] * X^1 + .... + c[0] * X^n
	#                   == Σ( c[ n - i ] * X^i )        ( i == 0 -> n )
	#
	#-----------------------------------------------------------------------
	my( $self , @c ) = @_ ;
	my( $class ) = ref( $self ) || $self ;

	#
	# 引数が配列参照で与えられている場合には、その添え字が各項の次数を示しているものとみなす。
	# 引数が数値配列で与えられている場合には、より高次の係数から次数降順に羅列されているものとみなす。
	#
	if ( ref( $c[0] ) eq 'ARRAY' ) {
		@c = @{ $c[0] } ;	# 添え字を次数とみなす。
	}
	else {
		@c = reverse( @c ) ;	# 反転して次数と添え字を一致させる。
	}

	foreach ( @c ) {
		return undef		unless ( defined $_ ) ;
		$_ = new_decimal( $_ )	unless ( ref( $_ ) ) ;
		return undef		unless ( defined $_ ) ;
	}

	while ( @c > 1 and $c[-1] == 0 ) { pop( @c ) ; }

	#
	# オブジェクトを生成
	#
	my $obj = bless [ @c ] , $class ;

	return $obj ;
}

sub copy {
	#-----------------------------------------------------------------------
	#
	# コピーコンストラクター
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my( $class ) = ref( $fx ) || $fx ;

	my $c = [ @{ $fx } ] ;
	foreach ( @{ $c } ) {
		$_ = new_decimal( $_ )	unless ( ref( $_ ) ) ;
		return undef		unless ( defined $_ ) ;
		$_ = $_->copy() ;
	}

	my $obj = bless $c , $class ;
}

=head1 'Polynomial' object - Some distinctive polynomial is pre-defined.

=cut

#
# 特殊な多項式
#
=head2 hermite( $degree , $type )

Return the Hermite polynomial object.

If $type == 1, it will return  the physicists' Hermite polynomial. ( default )

The physicists' Hermite polynomial is defined as follows.

                                    d^n
  H[n](x) == (-1)^n * exp( x^2 ) * ------  * exp( -x^2 )
                                    dx^n

If $type == 2, it will return  the probabilists' Hermite polynomial.

The probabilists' Hermite polynomial is defined as follows.

                                         d^n
  He[n](x) == (-1)^n * exp( x^2 / 2 ) * ------ * exp( -x^2 / 2 )
                                         dx^n


for example.

  print polynomial()->hermite( 0 ) ;                   # 0 : 1          ( == 1 )

  print polynomial()->hermite( 1 ) ;                   # 1 : 2          ( == 2x )
                                                       # 0 : 0

  print polynomial()->hermite( 2 ) ;                   # 2 : 4          ( == 4 * x^2 - 2 )
                                                       # 1 : 0
						       # 0 : -2

  print polynomial()->hermite( 0 , 2 ) ;               # 0 : 1          ( == 1 )

  print polynomial()->hermite( 1 , 2 ) ;               # 1 : 1          ( == x )
                                                       # 0 : 0

  print polynomial()->hermite( 2 , 2 ) ;               # 2 : 1          ( == x^2 - 1 )
                                                       # 1 : 0
						       # 0 : -1

These two types of polynomial are related as follows.

  H[n](x)  == 2^(n/2)  * He[n]( sqrt(2) * x )
  He[n](x) == 2^(-n/2) * H[n]( x / sqrt(2) )


=cut

sub hermite {
	#-----------------------------------------------------------------------
	#
	# エルミート多項式 ( Hermite polynomial )
	#
	#   物理学的なエルミート多項式 ( physicists' Hermite polynomials )
	#
	#     H[n](x) == (-1)^n * exp( x^2 ) * d^n/dx^n  * exp( -x^2 )
	#
	#     H[0](x) == 1
	#     H[1](x) == 2x
	#     H[2](x) == 4x^2 - 2
	#     H[3](x) == 8x^3 - 12x
	#     .....................
	#     H[n+1](x) == 2x * H[n](x) - 2n * H[n-1](x)
	#
	#   確率論的なエルミート多項式 ( probabilists' Hermite polynomials )
	#
	#     He[n](x) == (-1)^n * exp( x^2/2 ) * d^n/dx^n * exp( -x^2/2 )
	#
	#     He[0](x) == 1
	#     He[1](x) == x
	#     He[2](x) == x^2 - 1
	#     He[3](x) == x^3 - 3x
	#     ....................
	#     H[n+1](x) == x * He[n](x) - n * He[n-1](x)
	#
	#   H(x) と He(x) は互いに以下の関係にある。
	#
	#     H[n](x)  == 2^(n/2) * He[n]( sqrt(2) * x )
	#     He[n](x) == 2^(-n/2) * H[n]( x / sqrt(2) )
	#
	#-----------------------------------------------------------------------
	my( $self , $deg , $type ) = @_ ;

	return undef	unless ( defined $deg ) ;

	$type = 1	unless ( defined $type ) ;
	if	( $type =~ /^phys/ )	{ $type = 1 ; }
	elsif	( $type =~ /^prob/ )	{ $type = 2 ; }
	return undef	if ( $type != 1 and $type != 2 ) ;

	my $hx = [
		__PACKAGE__->new( 1 )		, # H[0](x) == 1
	] ;

	if ( $deg == 0 ) {
		return __PACKAGE__->new( 1 ) ;
	}
	elsif ( $deg == 1 ) {
		return __PACKAGE__->new( 2 , 0 )	if ( $type == 1 ) ;
		return __PACKAGE__->new( 1 , 0 ) ;
	}

	if ( $type == 1 ) {
		#
		# 物理学的なエルミート多項式
		#
		my $fx   = __PACKAGE__->new( 2 , 0 ) ;	# f(x) == 2x
		$hx->[1] = __PACKAGE__->new( 2 , 0 ) ;	# H[1](x) == 2x
		foreach my $n ( 2 .. $deg ) {
			my $n2 = ( $n - 1 ) * 2 ;
			$hx->[2] = $fx * $hx->[1] - $hx->[0] * $n2 ;
			shift( @{ $hx } ) ;
		}
	}
	else {
		#
		# 確率論的なエルミート多項式
		#
		my $fx   = __PACKAGE__->new( 1 , 0 ) ;	# f(x) == x
		$hx->[1] = __PACKAGE__->new( 1 , 0 ) ;	# He[1](x) == x
		foreach my $n ( 2 .. $deg ) {
			$hx->[2] = $fx * $hx->[1] - $hx->[0] * ( $n - 1 ) ;
			shift( @{ $hx } ) ;
		}
	}

	return $hx->[-1] ;
}

=head2 chebyshev( $degree , $type )

Return the Chebyshev polynomial object.

If $type == 1, it will return  the Chebyshev polynomial of first kind. ( default )

The Chebyshev polynomial of first kind is defined as follows.

  T[n](x) == cos( n * t )

  x == cos(t)

  -> T[0](x) == cos(0) == 1
     T[1](x) == cos(t) == x
     T[2](x) == 2x * T[1](x) - T[0](x)
     T[3](x) == 2x * T[2](x) - T[1](x)
     ....................................
     T[n+1](x) == 2x * T[n](x) - T[n-1](x)                   ( n == 1 , 2 , 3 , .... )

If $type == 2, it will return  the Chebyshev polynomial of second kind. ( default )

The Chebyshev polynomial of second kind is defined as follows.

                sin(nt)
  U[n-1](x) == ---------
                sin(t)

  x == cos(t)

  -> U[0](x) == 1
     U[1](x) == 2x
     U[2](x) == 4x^2 - 1  == 2x * 2x - 1            == 2x * U[1](x) - U[0](x)
     U[3](x) == 8x^3 - 4x == 2x * ( 4x^2 - 1 ) - 2x == 2x * U[2](x) - U[1](x)
     .......................
     U[n+1](x) == 2x * U[n](x) - U[n-1](x)                   ( n == 1 , 2 , 3 , .... )


for example.

  print polynomial()->chebyshev( 0 )                   # 0 : 1           ( == 1 )

  print polynomial()->chebyshev( 1 )                   # 1 : 1           ( == x )
                                                       # 0 : 0

  print polynomial()->chebyshev( 2 )                   # 2 : 2           ( == 2x - 1 )
                                                       # 1 : 0
						       # 0 : -1

  print polynomial()->chebyshev( 3 )                   # 3 : 4           ( == 4x^3 - 3x )
                                                       # 2 : 0
						       # 1 : -3
						       # 0 : 0

  print polynomial()->chebyshev( 0 , 2 )               # 0 : 1           ( == 1 )

  print polynomial()->chebyshev( 1 , 2 )               # 1 : 2           ( == 2x )
                                                       # 0 : 0

  print polynomial()->chebyshev( 2 , 2 )               # 2 : 4           ( == 4x^2 - 1 )
                                                       # 1 : 0
						       # 0 : -1

  print polynomial()->chebyshev( 3 , 2 )               # 3 : 8           ( == 8x^3 - 4x )
                                                       # 2 : 0
						       # 1 : -4
						       # 0 : 0

=cut

sub chebyshev {
	#-----------------------------------------------------------------------
	#
	# チェビシェフ多項式 ( Chebyshev polynomial )
	#
	#   第一種チェビシェフ多項式 ( Chebyshev polynomial of first kind )
	#
	#     第一種チェビシェフ多項式は、
	#
	#       T[n](x) == cos(nt)
	#
	#     を x == cos(t) として x についての多項式で表現したもの。
	#
	#     T[n](x) は、以下のようになる。
	#
	#       T[0](x) == cos(0) == 1
	#       T[1](x) == cos(t) == x
	#       T[2](x) == ( cos(t) )^2 - ( sin(t) )^2 == 2 * ( cos(t) )^2 - 1 == 2x^2 - 1  == 2x * x - 1            == 2x * T[1](x) - T[0](x)
	#       T[3](x) == 4 * ( cos(t) )^3 - 3 * cos(t)                       == 4x^3 - 3x == 2x * ( 2x^2 - 1 ) - x == 2x * T[2](x) - T[1](x)
	#       .......................
	#       T[n+1](x) == 2x * T[n](x) - T[n-1](x)                   ( n == 1 , 2 , 3 , .... )
	#
	#
	#   第二種チェビシェフ多項式 ( Chebyshev polynomial of second kind )
	#
	#     第二種チェビシェフ多項式は、
	#
	#                     sin(nt)
	#       U[n-1](x) == ---------
	#                     sin(t)
	#
	#     を x == cos(t) として x についての多項式で表現したもの。
	#
	#     U[n](x) は、以下のようになる。
	#
	#       U[0](x) == 1
	#       U[1](x) == 2x
	#       U[2](x) == 4x^2 - 1  == 2x * 2x - 1            == 2x * U[1](x) - U[0](x)
	#       U[3](x) == 8x^3 - 4x == 2x * ( 4x^2 - 1 ) - 2x == 2x * U[2](x) - U[1](x)
	#       .......................
	#       U[n+1](x) == 2x * U[n](x) - U[n-1](x)                   ( n == 1 , 2 , 3 , .... )
	#
	#-----------------------------------------------------------------------
	my( $self , $deg , $type ) = @_ ;

	return undef	unless ( defined $deg ) ;

	if	( ! defined $type )	{ $type = 1 ; }
	elsif	( $type =~ /^T$/i )	{ $type = 1 ; }
	elsif	( $type =~ /^U$/i )	{ $type = 2 ; }

	return undef	if ( $type != 1 and $type != 2 ) ;

	my $fx = __PACKAGE__->new( 2 , 0 ) ;	# f(x) == 2x
	my $px = [ __PACKAGE__->new( 1 ) ] ;	# p[0](x) == 1

	if ( $type == 1 )	{ $px->[1] = __PACKAGE__->new( 1 , 0 ) ; }	# p[1](x) == x
	else			{ $px->[1] = __PACKAGE__->new( 2 , 0 ) ; }	# p[1](x) == 2x

	if ( $deg == 0 ) {
		return __PACKAGE__->new( 1 ) ;
	}
	elsif ( $deg == 1 ) {
		return $px->[1] ;
	}

	foreach my $i ( 2 .. $deg ) {
		$px->[2] = $fx * $px->[1] - $px->[0] ;
		shift( @{ $px } ) ;
	}

	return $px->[-1] ;
}

=head2 dickson( $alpha , $degree , $type )

Return the Dickson polynomial ( Brewer polynomial ) object.

If $type == 1, it will return  the Dickson polynomial of first kind. ( default )

The Dickson polynomial of first kind is defined as follows.

                       n
  D[n](x,a) == sum( ------- * binomial( n - p , n ) * ( -1 * a )^p * x^(n-2p) )       ( p == 0 -> floor( n/2 ) )
                     n - p

  The 'a' is $alpha.

  -> D[0](x,a) == 2
     D[1](x,a) == x
     D[2](x,a) == x^2 - 2a                                             == x * D[1](x,a) - a * D[0](x,a)
     D[3](x,a) == x^3 - 3ax          == x( x^2 - 2a  ) - a * x         == x * D[2](x,a) - a * D[1](x,a)
     D[4](x,a) == x^4 - 4ax^2 + 2a^2 == x( x^3 - 3ax ) - a( x^2 - 2a ) == x * D[3](x,a) - a * D[2](x,a)

The Dickson polynomial of first kind is defined as follows.

  E[n](x,a) == sum( binomial( n - p , n ) * ( -1 * a )^p * x^(n-2p) )                 ( p == 0 -> floor( n/2 ) )

  The 'a' is $alpha.

  -> E[0](x,a) == 1
     E[1](x,a) == x
     E[2](x,a) == x^2 - a            == x * x - a * 1                  == x * E[1](x,a) - a * E[0](x,a)
     E[3](x,a) == x^3 - 2ax          == x( x^2 - a ) - a * x           == x * E[2](x,a) - a * E[1](x,a)
     E[4](x,a) == x^4 - 3ax^2 + a^2  == x( x^3 - 2ax ) - a( x^2 - a )  == x * E[3](x,a) - a * E[2](x,a)

for example.

  print polynomial()->dickson( 1 , 0 ) ;               # 0 : 2           ( == 2 )

  print polynomial()->dickson( 1 , 1 ) ;               # 1 : 1           ( == x )
                                                       # 0 : 0

  print polynomial()->dickson( 1 , 2 ) ;               # 2 : 1           ( == x^2 - 2 )
                                                       # 1 : 0
						       # 0 : -2

  print polynomial()->dickson( 1 , 3 ) ;               # 3 : 1           ( == x^3 - 3x )
                                                       # 2 : 0
						       # 1 : -3
						       # 0 : 0

  print polynomial()->dickson( 1 , 4 ) ;               # 4 : 1           ( == x^4 - 4x^2 + 2 )
                                                       # 3 : 0
						       # 2 : -4
						       # 1 : 0
						       # 0 : 2

  print polynomial()->dickson( 1 , 0 , 2 ) ;           # 0 : 1           ( == 1 )

  print polynomial()->dickson( 1 , 1 , 2 ) ;           # 1 : 1           ( == x )
                                                       # 0 : 0

  print polynomial()->dickson( 1 , 2 , 2 ) ;           # 2 : 1           ( == x^2 - 1 )
                                                       # 1 : 0
						       # 0 : -1

  print polynomial()->dickson( 1 , 3 , 2 ) ;           # 3 : 1           ( == x^3 - 2x )
                                                       # 2 : 0
						       # 1 : -2
						       # 0 : 0

  print polynomial()->dickson( 1 , 4 , 2 ) ;           # 4 : 1           ( == x^4 - 3x^2 + 1 )
                                                       # 3 : 0
						       # 2 : -3
						       # 1 : 0
						       # 0 : 1


The Dickson polynomial is related to the Chebyshev polynomial as follows.

  D[n]( 2ax , a^2 ) == 2a^n * T[n](x)
  E[n]( 2ax , a^2 ) ==  a^n * U[n](x)

  T[n] : The Chebyshev polynomial of first kind.
  U[n] : The Chebyshev polynomial of second kind.


=cut

sub dickson {
	#-----------------------------------------------------------------------
	#
	# ディクソン多項式 ( Dickson polynomial )
	#
	#   ディクソン多項式は、ブリュワー多項式 ( Brewer polynomials ) とも呼ばれる。
	#
	#   第一種ディクソン多項式 ( Disckson polynomial of first kind )
	#
	#                         n
	#     D[n](x,a) == Σ( ------- * binomial( n - p , n ) * ( -1 * a )^p * x^(n-2p) )
	#                       n - p
	#
	#     ( p == 0 -> floor( n/2 ) )
	#
	#     D[0](x,a) == 2
	#     D[1](x,a) == x
	#     D[2](x,a) == x^2 - 2a                                             == x * D[1](x,a) - a * D[0](x,a)
	#     D[3](x,a) == x^3 - 3ax          == x( x^2 - 2a  ) - a * x         == x * D[2](x,a) - a * D[1](x,a)
	#     D[4](x,a) == x^4 - 4ax^2 + 2a^2 == x( x^3 - 3ax ) - a( x^2 - 2a ) == x * D[3](x,a) - a * D[2](x,a)
	#
	#   第二種ディクソン多項式 ( Disckson polynomial of second kind )
	#
	#     E[n](x,a) == Σ( binomial( n - p , n ) * ( -1 * a )^p * x^(n-2p) )
	#
	#     ( p == 0 -> floor( n/2 ) )
	#
	#     E[0](x,a) == 1
	#     E[1](x,a) == x
	#     E[2](x,a) == x^2 - a            == x * x - a * 1                  == x * E[1](x,a) - a * E[0](x,a)
	#     E[3](x,a) == x^3 - 2ax          == x( x^2 - a ) - a * x           == x * E[2](x,a) - a * E[1](x,a)
	#     E[4](x,a) == x^4 - 3ax^2 + a^2  == x( x^3 - 2ax ) - a( x^2 - a )  == x * E[3](x,a) - a * E[2](x,a)
	#
	#   ディクソン多項式は本質的にチェビシェフ多項式と同値。
	#
	#     D[n]( 2ax , a^2 ) == 2a^n * T[n](x)
	#     E[n]( 2ax , a^2 ) ==  a^n * U[n](x)
	#
	#     T[n] は第一種チェビシェフ多項式
	#     U[n] は第二種チェビシェフ多項式
	#
	#-----------------------------------------------------------------------
	my( $self , $alpha , $deg , $type ) = @_ ;

	return undef	unless ( defined $alpha ) ;
	return undef	unless ( defined $deg ) ;

	$type = 1	unless ( defined $type ) ;
	return undef	if ( $type != 1 and $type != 2 ) ;

	my $fx = __PACKAGE__->new( 1 , 0 ) ;	# f(x) == x
	my $px = [] ;

	if ( $type == 1 )	{ $px->[0] = __PACKAGE__->new( 2 ) ; }	# p[0](x) == 2
	else			{ $px->[0] = __PACKAGE__->new( 1 ) ; }	# p[0](x) == 1

	$px->[1] = __PACKAGE__->new( 1 , 0 ) ;	# p[1](x) == x

	if ( $deg == 0 ) {
		return __PACKAGE__->new( 2 )	if ( $type == 1 ) ;
		return __PACKAGE__->new( 1 ) ;
	}
	elsif ( $deg == 1 ) {
		return $px->[1] ;
	}

	foreach my $i ( 2 .. $deg ) {
		$px->[2] = $fx * $px->[1] - $alpha * $px->[0] ;
		shift( @{ $px } ) ;
	}

	return $px->[-1] ;
}

=head2 legendre( $degree , $shifted )

Return the Legendre polynomial object.

The Legendre polynomial is defined as follows.

                 1         d^n
  p[n](x) == ---------- * ------ * ( x^2 - 1 )^n
              2^n * n!     dx^n


  -> p[0](x) == 1
     p[1](x) == x
     ......................

                      1
     p[n+1](x) == ---------- * ( x * ( 2n + 1 ) * P[n](x) - n * p[n-1](x) )
                   2^n * n! 

                                                                n * k - 1
  -> p[n](x) == 2^n * sum( x^k * binomial( n , k ) * binomial( ----------- , n ) )        ( k == 0 -> n )
                                                                    2


  -> p[0](x) == 1
     p[1](x) == x
     p[2](x) == 3/2 * x^2 - 1/2 
     p[3](x) == 35/8 * x^4 - 15/4 * x^2 + 3/8

If $shifted is true, this method will return the shifted Legendre polynomial.

The shifted Legendre polynomial is defined as follows.

  shifted_legendre( n ) == p[n]( 2x - 1 )

  p[n](x) is the Legendre polynomial.

  -> P[0](x) == p[0]( 2x - 1 ) == 1
     P[1](x) == p[1]( 2x - 1 ) == 2x - 1
     P[2](x) == p[2]( 2x - 1 ) == 6x^2 - 6x - 1
     P[3](x) == p[3]( 2x - 1 ) == 20x^3 - 30x^2 + 12x - 1
     
=cut

sub legendre {
	#-----------------------------------------------------------------------
	#
	# ルジャンドル多項式 ( Legendre polynomial )
	#
	#                  1         d^n
	#   p[n](x) == ---------- * ------ * ( x^2 - 1 )^n )
	#               2^n * n!     dx^n
	#
	#   p[0](x) == 1
	#   p[1](x) == x
	#   .............
	#                   1
	#   p[n+1](x) == ------- * ( x * ( 2n + 1 ) * p[n](x) - n * p[n-1](x) )
	#                 n + 1 
	#
	#                   1
	#   -> p[n](x) == ----- * Σ( ( binomial( n , k ) )^2 * ( x - 1 )^(n-k) * ( x + 1 )^k )   ( k == 0 -> n )
	#                  2^n
	#
	#                                                                      1 - x
	#              == Σ( binomial( n , k ) * binomial( - n - 1 , k ) * ( ------- )^k )       ( k == 0 -> n )
	#                                                                        2
	#
	#                                                                n + k - 1 
	#              == 2^n * Σ( x^k * binomial( n , k ) * binomial( ----------- , n ) )       ( k == 0 -> n )
	#                                                                    2
	#
	#   ずらしルジャンドル多項式 ( shifted Legendre polynomial )
	#
	#     数学では、 ルジャンドル多項式は Pn(x) ( n は下付き ) で表現され、
	#     ずらしルジャンドル多項式は、 P の上にチルダを付加した記号で表現される。
	#
	#     ずらしルジャンドル多項式は、
	#
	#       shifted_legendre( n ) == p[n]( 2x - 1 )
	#
	#     で表される。
	#
	#     ルジャンドル多項式を p[n](x) , ずらしルジャンドル多項式を P[n](x) で表すと、
	#
	#       P[0](x) == p[0]( 2x - 1 ) == 1
	#       P[1](x) == p[1]( 2x - 1 ) == 2x - 1
	#       P[2](x) == p[2]( 2x - 1 ) == 6x^2 - 6x - 1
	#       P[3](x) == p[3]( 2x - 1 ) == 20x^3 - 30x^2 + 12x - 1
	#     
	#     となる。
	#
	#-----------------------------------------------------------------------
	my( $self , $deg , $shifted ) = @_ ;

	return undef	unless ( defined $deg ) ;
	$shifted = 0	unless ( defined $shifted ) ;

	my $fx = __PACKAGE__->new( 1 , 0 ) ;	  # f(x) == x
	my $px = [
		__PACKAGE__->new( 1 )		, # p[0[(x) == 1
		__PACKAGE__->new( 1 , 0 )	, # p[1[(x) == x
	] ;

	if ( $deg == 0 ) {
		return __PACKAGE__->new( 1 ) ;
	}
	elsif ( $deg == 1 ) {
		return __PACKAGE__->new( 2 , -1 )	if ( $shifted ) ;
		return __PACKAGE__->new( 1 ,  0 ) ;
	}

	foreach my $n ( 2 .. $deg ) {
		my $pn = $n - 1 ;
		$px->[2] = ( $fx * ( $pn * 2 + 1 ) * $px->[1] - $pn * $px->[0] ) / $n ;
		shift( @{ $px } ) ;
	}

	$px = $px->[-1] || undef ;

	if ( defined $px and $shifted ) {
		my $qx = __PACKAGE__->new( 2 , -1 ) ;	# q(x) == 2x - 1
		$px = $px->substitute( $qx ) ;
	}

	return $px ;
}

=head2 gegenbauer( $alpha , $degree )

Return the Gegenbauer polynomial ( Brewer polynomial ) object.

The Gegenbauer polynomial is defined as follows.

  C[0](x,a) == 1
  C[1](x,a) == 2ax
  ..................

                1
  C[n](x,a) == --- * ( 2x * ( n + a - 1 ) * C[n-1](x,a) - ( n + 2a - 2 ) * C[n-2](x,a) )
                n

If a == 1/2, the Gegenbauer polynomial is same to the Legendre polynomial.

If a == 1, the Gegenbauer polynomial is same to the Chebyshev polynomial of secod kind.


=cut

sub gegenbauer {
	#-----------------------------------------------------------------------
	#
	# ゲーゲンバウアー多項式 ( Gegenbauer polynomial )
	#
	#   C[0](x,a) == 1
	#   C[1](x,a) == 2ax
	#   ..................
	#
	#                 1
	#   C[n](x,a) == --- * ( 2x * ( n + a - 1 ) * C[n-1](x,a) - ( n + 2a - 2 ) * C[n-2](x,a) )
	#                 n
	#
	#   a == 1/2 の時ルジャンドル多項式に、
	#   a == 1 の時に第二チェビシェフ多項式に相当するとのこと。
	#
	#-----------------------------------------------------------------------
	my( $self , $alpha , $n ) = @_ ;

	return undef	unless ( defined $alpha ) ;
	return undef	unless ( defined $n ) ;

	my $fx = __PACKAGE__->new( 2 , 0 ) ;

	my $cx = [
		__PACKAGE__->new( 1 )			,
		__PACKAGE__->new( $alpha * 2 , 0 )	,
	] ;

	foreach my $k ( 2 .. $n ) {
		$cx->[2] = ( $fx * ( $k + $alpha - 1 ) * $cx->[1] - ( $k + ( $alpha * 2 ) - 2 ) * $cx->[0] ) / $k ;
		shift( @{ $cx } ) ;
	}

	return $cx->[-1] ;
}

=head2 cyclotomic( $degree )

Return the cyclotomic polynomial.

The cyclotomic polynomal is defned as follows.

                                          2 * PI
  F[n](x) == total_product( x - exp( i * -------- * k )        ( k == 1 -> n , gcd( k , n ) == 1 )
                                            n

  x^n - 1 == total_product( F[d](x) )                          ( d == 1 , n and factor( n ) )

  -> F[1](x)  == ( x^1  - 1 )                                        ==                                                        x - 1
     F[2](x)  == ( x^2  - 1 ) / ( F[1]                             ) ==                                                        x + 1
     F[3](x)  == ( x^3  - 1 ) / ( F[1]                             ) ==                                                  x^2 + x + 1
     F[4](x)  == ( x^4  - 1 ) / ( F[1] * F[2]                      ) ==                                                  x^2     + 1
     F[5](x)  == ( x^5  - 1 ) / ( F[1]                             ) ==                                      x^4 + x^3 + x^2 + x + 1
     F[6](x)  == ( x^6  - 1 ) / ( F[1] * F[2] * F[3]               ) ==                                                  x^2 - x + 1
     F[7](x)  == ( x^7  - 1 ) / ( F[1]                             ) ==                          x^6 + x^5 + x^4 + x^3 + x^2 + x + 1
     F[8](x)  == ( x^8  - 1 ) / ( F[1] * F[2] * F[4]               ) ==                                      x^4                 + 1
     F[9](x)  == ( x^9  - 1 ) / ( F[1] * F[3]                      ) ==                          x^6             + x^3           + 1
     F[10](x) == ( x^10 - 1 ) / ( F[1] * F[2] * F[5]               ) ==                                      x^4 - x^3 + x^2 - x + 1
     F[11](x) == ( x^11 - 1 ) / ( F[1]                             ) == x^10 + x^9 + x^8 - x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1
     F[12](x) == ( x^12 - 1 ) / ( F[1] * F[2] * F[3] * F[4] * F[6] ) ==                                      x^4       - x^2     + 1


=cut

sub cyclotomic {
	#-----------------------------------------------------------------------
	#
	# 円分多項式 ( cyclotomic polynomial )
	#
	#
	#   F[n](x) == Π( x - exp( i * 2PI * k / n ) )      ( k == 1 -> n ; gcd( k , n ) == 1 )
	#
	#   x^n - 1 == Π( F[d](x) )                         ( d は 1 と n を含む n の因数 )
	#
	#   F[1]  == ( x^1  - 1 )                                        == x - 1
	#   F[2]  == ( x^2  - 1 ) / ( F[1]                             ) == x + 1
	#   F[3]  == ( x^3  - 1 ) / ( F[1]                             ) == x^2 + x + 1
	#   F[4]  == ( x^4  - 1 ) / ( F[1] * F[2]                      ) == x^2 + 1
	#   F[5]  == ( x^5  - 1 ) / ( F[1]                             ) == x^4 + x^3 + x^2 + x + 1
	#   F[6]  == ( x^6  - 1 ) / ( F[1] * F[2] * F[3]               ) == x^2 - x + 1
	#   F[7]  == ( x^7  - 1 ) / ( F[1]                             ) == x^6 + x^5 + x^4 + x^3 + x^2 + x + 1
	#   F[8]  == ( x^8  - 1 ) / ( F[1] * F[2] * F[4]               ) == x^4 + 1
	#   F[9]  == ( x^9  - 1 ) / ( F[1] * F[3]                      ) == x^6 + x^3 + 1
	#   F[10] == ( x^10 - 1 ) / ( F[1] * F[2] * F[5]               ) == x^4 - x^3 + x^2 - x + 1
	#   F[11] == ( x^11 - 1 ) / ( F[1]                             ) == x^10 + x^9 + x^8 - x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1
	#   F[12] == ( x^12 - 1 ) / ( F[1] * F[2] * F[3] * F[4] * F[6] ) == x^4 - x^2 + 1
	#
	#-----------------------------------------------------------------------
	my( $self , $n ) = @_ ;

	return undef	unless ( defined $n ) ;

	$n = new_decimal( $n ) ;
	return undef	unless ( defined $n ) ;

	my $fx = undef ;

	if ( $n == 1 ) {
		$fx = __PACKAGE__->new( 1 , -1 ) ;
	}
	else {
		my $w = [ new_complex( 1 )->circle_group( $n ) ] ;	# 1 の n 乗根
		my $mx = __PACKAGE__->new( 1 , 0 ) ;			# m(x) == x

		foreach ( my $k = new_decimal( 1 ) ; $k <= $n ; $k++ ) {
			next	unless ( $k->gcd( $n ) == 1 ) ;
			if ( defined $fx )	{ $fx *= ( $mx - $w->[ $k ] ) ; }
			else			{ $fx  = ( $mx - $w->[ $k ] ) ; }
		}
	}

	return $fx ;
}

=head1 'Polynomial' object - the properties.

=cut

#-------------------------------------------------------------------------------
#
# 属性
#
#-------------------------------------------------------------------------------

=head2 is_XXX

  $fx = polynomial() ;

  print $fx->is_scalar() ;                             # 0
  print $fx->is_decimal() ;                            # 0
  print $fx->is_fraction() ;                           # 0
  print $fx->is_complex() ;                            # 0
  print $fx->is_vector() ;                             # 0
  print $fx->is_matrix() ;                             # 0

  print $fx->is_polynomial() ;                         # 1

=cut

sub is_scalar		{ return 0 ; }
sub is_decimal		{ return 0 ; }
sub is_residue		{ return 0 ; }
sub is_fraction		{ return 0 ; }
sub is_complex		{ return 0 ; }
sub is_vector		{ return 0 ; }
sub is_matrix		{ return 0 ; }
sub is_polynomial	{ return 1 ; }

=head2 is_monomial , is_binomial

If the polynomial object is

  f(x) == ax^n

then is_monomial will return 1, else return 0.

If it is

  f(x) == ax^n + bx^m

then is_binomial will return 1, else return 0.

=cut

sub is_monomial {
	#-----------------------------------------------------------------------
	#
	# 単項式かどうか
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $n = $fx->deg() ;

	my $nzt = 0 ;
	foreach my $i ( 0 .. $n ) {
		unless ( $fx->[ $i ] == 0 ) {
			return 0	if ( ++$nzt > 1 ) ;
		}
	}

	return 1	if ( $nzt == 1 ) ;
	return 0 ;
}

sub is_binomial {
	#-----------------------------------------------------------------------
	#
	# 二項式かどうか
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $n = $fx->deg() ;

	my $nzt = 0 ;
	foreach my $i ( 0 .. $n ) {
		unless ( $fx->[ $i ] == 0 ) {
			return 0	if ( ++$nzt > 2 ) ;
		}
	}

	return 1	if ( $nzt == 2 ) ;
	return 0 ;
}

=head2 can_scalar , can_integer , can_decimal

If the polynomial object has a constant term, and all of the other terms are 0, can_scalar will return 1 otherwise return 0.

If can_scalar is true, and the constanat term can be translated to the integer value, can_integer will return 1 otherwise return 0.

If can_scalar is true, and the constanat term can be translated to the decimal value, can_decimal will return 1 otherwise return 0.

  $fx = polynomial( 1 , 1 ) ;                          # == x + 1
  print $fx->can_scalar() ;                            # 0

  $fx = polynomial( 0 ) ;                              # == 0
  print $fx->can_scalar() ;                            # 1
  print $fx->can_integer() ;                           # 1
  print $fx->can_decimal() ;                           # 1

  $fx = polynomial( sqrt(2) ) ;
  print $fx->can_scalar() ;                            # 1
  print $fx->can_integer() ;                           # 0
  print $fx->can_decimal() ;                           # 1

=cut

sub can_scalar {
	#-----------------------------------------------------------------------
	#
	# スカラーに変換可能か
	#
	#   定数項のみで構成されていればスカラーに変換可能。
	#
	#-----------------------------------------------------------------------
	return undef	unless ( ref( $_[0] ) eq __PACKAGE__ ) ;
	return 1	if ( $_[0]->deg() == 0 ) ;
	return 0 ;
}

sub can_integer {
	#-----------------------------------------------------------------------
	#
	# 整数に変換可能か
	#
	#-----------------------------------------------------------------------
	return undef	unless ( ref( $_[0] ) eq __PACKAGE__ ) ;
	return 0	unless ( $_[0]->can_scalar() ) ;
	return $_[0]->[0]->can_integer() ;
}

sub can_decimal {
	#-----------------------------------------------------------------------
	#
	# 実数に変換可能か
	#
	#-----------------------------------------------------------------------
	return undef	unless ( ref( $_[0] ) eq __PACKAGE__ ) ;
	return 0	unless ( $_[0]->can_scalar() ) ;
	return $_[0]->[0]->can_decimal() ;
}

sub as_string {
	#-----------------------------------------------------------------------
	#
	# 次数とそれに対応する係数を羅列した文字列を返す。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $n = $#{ $fx } ;
	my $r = undef ;
	foreach my $i ( reverse( 0 .. $n ) ) {
		if ( $fx->[ $i ]->is_complex() or $fx->[ $i ]->is_fraction() ) {
			$r .= sprintf( "%5d : %-s\n" , $i , $fx->[ $i ] ) ;
		}
		elsif ( $fx->[ $i ]->is_integer() ) {
			$r .= sprintf( "%5d : %-5d\n" , $i , $fx->[ $i ] ) ;
		}
		else {
			$r .= sprintf( "%5d : %-.5f\n" , $i , $fx->[ $i ] ) ;
		}
	}

	return $r ;
}


=head2 as_array

Return the coefficients of the Polynomial object as array.

  $fx = polynomial( 1 .. 5 ) ;                         # == x^4 + 2x^3 + 3x^2 + 4x + 5
  print join( ' ' , $fx->as_array() ) ;                # 1 2 3 4 5

  $fx = polynomial( [ 1 .. 5 ] ) ;                     # == 5x^4 + 4x^3 + 3x^2 + 2x + 1
  print join( ' ' , $fx->as_array() ) ;                # 5 4 3 2 1

=cut

sub as_array {
	#-----------------------------------------------------------------------
	#
	# 係数列を次数降順で返す。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	return reverse( @{ $fx } ) ;
}

=head2 coef

Return the coefficients like "as_array", but this method will return array reference.

The indexs of returned array reference is same to degrees of the 'Polynomial' object.

  $fx = polynomial( 1 .. 5 ) ;                         # == x^4 + 2x^3 + 3x^2 + 4x + 5
  print $fx->coef()->[4] ;                             # 1
  print $fx->coef()->[3] ;                             # 2
  print $fx->coef()->[2] ;                             # 3
  print $fx->coef()->[1] ;                             # 4
  print $fx->coef()->[0] ;                             # 5

  print $fx->coef()->[-1] ;                            # 1
  print $fx->coef()->[-2] ;                            # 2
  print $fx->coef()->[-3] ;                            # 3
  print $fx->coef()->[-4] ;                            # 4
  print $fx->coef()->[-5] ;                            # 5

=cut

sub coef {
	#-----------------------------------------------------------------------
	#
	# 多項式の係数列を配列参照で返す。
	#
	#   戻り値の添え字は各項の次数を示す。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $c = [ @{ $fx } ] ;

	return $c ;
}

=head2 non_zero_terms

Return the list of degrees, which has non-zero terms.

  $fx = polynomial( 1 , 1 ) * polynomial( 1 , -1 ) ;      # == x^2 - 1 == 1 * x^2 + 0 * x^1 - 1 * x^0
  print join( ' ' , $fx->non_zero_terms() ) ;             # 0 2       ( x^2 and x^0 has non-zero term, and the term of x^1 is 0. )

=cut

sub non_zero_terms {
	#-----------------------------------------------------------------------
	#
	# 非零の係数を持つ項の次数の一覧を返す。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $nzt = [] ;
	foreach my $i ( 0 .. $#{ $fx } ) {
		push( @{ $nzt } , $i )	unless ( $fx->[ $i ] == 0 ) ;
	}

	return @{ $nzt } ;
}

=head2 deg , degree

Return the maximum degree.

  $fx = polynomial( 1 , 1 ) ** 3 ;                        # == x^3 * 3x^2 + 3x + 1
  print $fx->deg() ;                                      # 3

=cut

sub deg {
	#-----------------------------------------------------------------------
	#
	# 多項式の最高次数 ( degree ) を返す。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $d = new_decimal( $#{ $fx } ) ;

	return $d ;
}

sub degree { return deg( @_ ) ; }

sub scalar {
	#-----------------------------------------------------------------------
	#
	# 定数項のみであれば、それを返す。
	#
	#-----------------------------------------------------------------------
	return $_[0]->[0]			if ( $_[0]->can_scalar() ) ;
	return undef ;
}

sub integer {
	return $_[0]->[0]->integer()		if ( $_[0]->can_integer() ) ;
	return undef ;
}

sub decimal {
	return $_[0]->[0]->decimal()		if ( $_[0]->can_decimal() ) ;
	return undef ;
}

sub round {
	#-----------------------------------------------------------------------
	#
	# 四捨五入
	#
	#-----------------------------------------------------------------------
	my( $fx , $dlen ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$fx = $fx->copy() ;
	foreach ( @{ $fx } ) {
		$_ = $_->round( $dlen ) ;
	}

	return $fx ;
}

sub round_banker {
	#-----------------------------------------------------------------------
	#
	# 銀行家の丸め
	#
	#-----------------------------------------------------------------------
	my( $fx , $dlen ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$fx = $fx->copy() ;
	foreach ( @{ $fx } ) {
		$_ = $_->round_banker( $dlen ) ;
	}

	return $fx ;
}

sub round_up {
	#-----------------------------------------------------------------------
	#
	# 切り上げ
	#
	#-----------------------------------------------------------------------
	my( $fx , $dlen ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$fx = $fx->copy() ;
	foreach ( @{ $fx } ) {
		$_ = $_->round_up( $dlen ) ;
	}

	return $fx ;
}

sub round_down {
	#-----------------------------------------------------------------------
	#
	# 切り下げ
	#
	#-----------------------------------------------------------------------
	my( $fx , $dlen ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	#$dlen = $DECIMAL_PART_LENGTH_LIMIT	unless ( defined $dlen ) ;
	$dlen = ( defined $dlen and $dlen =~ /^\d+$/ ) ? $dlen : $DECIMAL_PART_LENGTH_LIMIT ;

	$fx = $fx->copy() ;
	foreach ( @{ $fx } ) {
		$_ = $_->round_down( $dlen ) ;
	}

	return $fx ;
}

#-------------------------------------------------------------------------------
#
# 比較
#
#-------------------------------------------------------------------------------

sub equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( == , eq )
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	unless ( ref( $gx ) eq __PACKAGE__ ) {
		return undef	unless ( defined $gx ) ;
		return 0	unless ( $fx->can_scalar() ) ;
		return 1	if ( $fx->scalar() == $gx ) ;
		return 0 ;
	}

	return 0	unless ( $fx->deg() == $gx->deg() ) ;
	return 0	unless ( join( ' ' , @{ $fx } ) eq join( ' ' , @{ $gx } ) ) ;

	return 1 ;
}

sub not_equal {
	#-----------------------------------------------------------------------
	#
	# 比較 ( != , ne )
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $gx ) ;

	return ( $fx->equal( $gx ) ) ? 0 : 1 ;
}

=head1 'Polynomial' object - calculations

The 'Polynomial' object is defined as

  f(X) == a[n] * X^n + a[n-1] * X^(n-1) + ..... + a[1] * X^1 + a[0] * X^0
       == sum( a[i] * X^i )                                                  ( i == 0 -> degree( f(X) ) )

  g(X) == b[n] * X^n + b[n-1] * X^(n-1) + ..... + b[1] * X^1 + b[0] * X^0
       == sum( b[j] * X^j )                                                  ( j == 0 -> degree( g(X) ) )

then add and subtract operation is

 f(X) + g(X) == sum( ( a[k] + b[k] ) * X^k )                                 ( k == 0 -> max( degree( f(X) ) , degree( g(X) ) ) )
 f(X) - g(X) == sum( ( a[k] - b[k] ) * X^k )                                 ( k == 0 -> max( degree( f(X) ) , degree( g(X) ) ) )


The multiply operation is defined as follows.

 f(X) * g(X) == sum( ( a[i] * b[j] ) * X^(i+j) )                             ( i == 0 -> degree( f(X) ) , j == 0 -> degree( g(X) ) )
             == sum( ( a[i] * b[k-i] ) * X^k )                               ( k == i + j )

The multiplication about polynomial is sometimes called "linear convolution".

=cut

#-------------------------------------------------------------------------------
#
# 演算
#
#-------------------------------------------------------------------------------

sub add {
	#-----------------------------------------------------------------------
	#
	# 加算
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$gx = __PACKAGE__->new( $gx )	unless ( ref( $gx ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $gx ) ;

	my $r = $fx->copy() ;
	foreach my $i ( 0 .. $#{ $gx } ) {
		if ( defined $r->[ $i ] )	{ $r->[ $i ] += $gx->[ $i ] ;		}
		else				{ $r->[ $i ]  = $gx->[ $i ]->copy() ;	}
	}

	return $r ;
}

sub subtract {
	#-----------------------------------------------------------------------
	#
	# 減算 
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx , $swapped ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$gx = __PACKAGE__->new( $gx )	unless ( ref( $gx ) ) ;
	return undef			unless ( defined $gx ) ;

	if ( $swapped ) {
		( $fx , $gx ) = ( $gx , $fx ) ;
	}

	$gx = $gx * ( -1 ) ;

	return $fx->add( $gx ) ;
}

sub multiply {
	#-----------------------------------------------------------------------
	#
	# 乗算 ( 合成積 ; 畳み込み )
	#
	#   合成積, 畳み込み ( convolution ) , 畳み込み積分 , 重畳積分とも呼ばれる。
	#   合成積の一般式は、
	#
	#      ( f * g )(t) == ∫( f(τ) * g( t - τ ) * dτ
	#
	#   で表現される。 ( τ はギリシャ文字のタウ。積分範囲は -∞ -> ∞ )
	#
	#   f , g が有限区間でしか定義されない場合、 f , g は周期関数とみなされる。
	#   この時の畳み込みは循環畳み込み ( cyclic convolution ) と呼ばれる。
	#
	#   離散値で定義された関数に対する畳み込みは、総和で定義され、
	#
	#     ( f * g )(m) == Σ( f(n) * g( m - n ) )
	#
	#   で表される。 ( 畳み込み和、重畳和とも呼ばれる。 )
	#
	#   離散系の畳み込みにおいて定義域外の値を 0 と定義しなおした関数での畳み込みが行われることがあり、
	#   これは線形畳み込み ( 直線畳み込み ; linear convolution ) と呼ばれる。
	#
	#   多項式の乗算は係数列を用いた線形畳み込みとなる。
	#
	#     f(X) == Σ( a[i] * X^i )          ( i == 0 -> m )
	#     g(X) == Σ( b[j] * X^j )          ( j == 0 -> n )
	#
	#     f(X) * g(X) == Σ( a[i] * b[j] * X^( i + j ) )
	#                 == Σ( a[i] * b[k-i] * X^k )           ( k == i + j )
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$gx = __PACKAGE__->new( $gx )	unless ( ref( $gx ) eq __PACKAGE__ ) ;
	return undef			unless ( defined $gx ) ;

	my $fn = $fx->deg() ;
	my $gn = $gx->deg() ;

	my $r = [] ;
	foreach my $i ( 0 .. $fn ) {
		foreach my $j ( 0 .. $gn ) {
			my $ix = $i + $j ;
			if ( defined $r->[ $ix ] )	{ $r->[ $ix ] += $fx->[ $i ] * $gx->[ $j ] ; }
			else				{ $r->[ $ix ]  = $fx->[ $i ] * $gx->[ $j ] ; }
		}
	}

	return ( @{ $r } ) ? __PACKAGE__->new( $r ) : undef ;
}

=head2 divmod , divide , modulus

Return the quotient and remainder, which are result of the division of polynomial.

If the divisor is a constant value,

  f(X) == sum( a[i] * X^i ) 

  ( q , m ) = f(X) / c

  -> q == sum( ( a[i] / c ) * X^i )
     m == 0

If the degree of divisor is 1, the 'synthetic_division' method will be used.

  f(X) == sum( a[i] * X^i )                ( i == 0 -> degree( f(X) ) )
  g(X) == b[1] * X^1 + b[0]

  ( q , m ) == f(X) / g(X) == synthetic_division( f(X) , g(X) ) ;

Otherwise, the method based on the calculation by writing will be used.



  $fx = polynomial( 1 .. 5 ) ;
  $gx = polynomial( 1 , 1 ) ;

  ( $hx , $mod ) = $fx->divmod( $gx ) ;

  print $fx ;                                          # 4 : 1    ( == x^4 + 2x^3 + 3x^2 + 4x + 5 )
                                                       # 3 : 2
                                                       # 2 : 3
                                                       # 1 : 4
                                                       # 0 : 5
  
  print $gx ;                                          # 1 : 1    ( == x + 1 )
                                                       # 0 : 1

  print $hx ;                                          # 3 : 1    ( == x^3 + x^2 + 2x + 2 )
                                                       # 2 : 1
                                                       # 1 : 2
                                                       # 0 : 2

  print $mod ;                                         # 0 : 3    ( == 3 )

  print $hx * $gx + $mod ;                             # 4 : 1
                                                       # 3 : 2
                                                       # 2 : 3
                                                       # 1 : 4
                                                       # 0 : 5



  $fx->divide( $gx )  == ( $fx->divmod( $gx ) )[0] ;
  $fx->modulus( $gx ) == ( $fx->divmod( $gx ) )[1] ;

=cut

sub divmod {
	#-----------------------------------------------------------------------
	#
	# 除算 ( 商と余りを返す。 )
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;
	
	$gx = __PACKAGE__->new( $gx )	unless ( ref( $gx ) eq __PACKAGE__ ) ;
	return undef		unless ( defined $gx ) ;

	my $fn = $fx->deg() ;
	my $gn = $gx->deg() ;

	my( $q , $m ) = () ;

	if ( $gn == 0 ) {
		#
		# 定数での除算
		#
		my $r = [] ;
		foreach my $i ( 0 .. $fn ) {
			$r->[ $i ] = $fx->[ $i ] / $gx->[0] ;
			$r->[ $i ] = $r->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		}
	
		if ( @{ $r } ) {
			$q = __PACKAGE__->new( $r ) ;
			$m = __PACKAGE__->new( 0 ) ;
		}
	}
	elsif ( $gn == 1 ) {
		#
		# 一次式での除算
		#
		( $q , $m ) = $fx->synthetic_division( $gx ) ;
		$m = __PACKAGE__->new( $m )	unless ( ref( $m ) eq __PACKAGE__ ) ;
	}
	else {
		#
		# 多項式での除算
		#
		#   ( X^4 + 3X^3 - 4X + 2 ) / ( X^2 - 3X + 1 )
		#
		#                          1   6  17         .... X^2 + 6X + 17  ( 商 )
		#              ----------------------
		#   -> 1 -3  1 )   1   3   0  -4   2
		#              -   1  -3   1
		#              ----------------------
		#                      6  -1  -4
		#              -       6 -18   6
		#              ----------------------
		#                         17 -10   2
		#              -          17 -51  17
		#              ----------------------
		#                             41 -15         .... 41X - 15  ( 剰余 )
		#
		$m = $fx->copy() ;
		my $mn = $m->deg() ;
		my $r = [] ;

		while ( $mn >= $gn ) {

			my $c = $m->[ $mn ] / $gx->[ $gn ] ;
			push( @{ $r } , $c ) ;

			foreach my $i ( 1 .. $gn ) {
				$m->[ $mn - $i ] -= $gx->[ $gn - $i ] * $c ;
			}
			pop( @{ $m } ) ;
			$mn = $m->deg() ;
		}

		#
		# $r は、係数を次数逆順に並べた形になっているので、
		# デリファレンスして配列として渡す。
		#
		$q = __PACKAGE__->new( @{ $r } )	if ( @{ $r } ) ;
	}

	return ( $q , $m ) ;
}

sub divide	{ return ( divmod( @_ ) )[0] ; }
sub modulus	{ return ( divmod( @_ ) )[1] ; }

=head2 synthetic_division

The synthetic division can be used when the degree of divisor g(x) is 1.

If two polynomial is as follows,

  f(x) == x^3 - 2x^2 + 3x + 4
  g(x) == x + 1

The synthetic division will be processed as follows.

  f(x) / g(x) == ( x^3 - 2x^2 + 3x + 4 ) / ( x + 1 )

             1   -2               3    -4
    -> -1 ) ------------------------------
             1   -2 + ( -1 ) * 1 
	
             1   -2   3  -4
    -> -1 ) ----------------
	     1   -3 

             1   -2   3                    -4
    -> -1 ) ----------------------------------
             1   -3   3 + ( -1 ) * ( -3 )

             1   -2   3  -4
    -> -1 ) ----------------
             1   -3   6 

             1   -2   3  -4
    -> -1 ) -----------------------------
             1   -3   6  -4 + ( -1 ) * 6

             1   -2   3   -4
    -> -1 ) -----------------
             1   -3   6  -10              == ( x^2 - 3x + 6 ) - 10

    -> x^3 - 2x^2 + 3x + 4 == ( x + 1 )( x^2 - 3x + 6 ) - 10


If divisor g(x) is 

  g(x) == a[1] * x^1 - a[0]             ( a[1] != 1 )

Then

  ( h(x) , mod ) == synthetic_division( f(x) , g(x) / a[1] )
                 == synthetic_division( f(x) , ( x - p ) )                 ( p == a[0] / a[1] )

  h(x) /= a[1]

  return ( h(x) , mod )


=cut

sub synthetic_division {
	#-----------------------------------------------------------------------
	#
	# 組み立て除法 ( synthetic_division )
	#
	#   組み立て除法は、 n 次多項式を一次式で割る剰余演算。
	#
	#   組み立て除法の流れは以下の通り。
	#
	#     ( x^3 - 2x^2 + 3x + 4 ) / ( x + 1 )
	#
	#              1   -2               3    -4
	#     -> -1 ) ------------------------------
	#              1   -2 + ( -1 ) * 1 
	#
	#              1   -2   3  -4
	#     -> -1 ) ----------------
	#              1   -3 
	#
	#              1   -2   3                    -4
	#     -> -1 ) ----------------------------------
	#              1   -3   3 + ( -1 ) * ( -3 )
	#
	#              1   -2   3  -4
	#     -> -1 ) ----------------
	#              1   -3   6 
	#
	#              1   -2   3  -4
	#     -> -1 ) -----------------------------
	#              1   -3   6  -4 + ( -1 ) * 6
	#
	#              1   -2   3   -4
	#     -> -1 ) -----------------
	#              1   -3   6  -10              == ( x^2 - 3x + 6 ) - 10
	#
	#     -> x^3 - 2x^2 + 3x + 4 == ( x + 1 )( x^2 - 3x + 6 ) - 10
	#
	#
	#   組み立て除法の一般化
	#
	#     被除数を f(x) , 除数を g(x) とする。
	#
	#     g(x) が
	#
	#       g(x) == a[1] * x - a[0]     ( a[1] != 1 )
	#
	#     の場合、
	#
	#       ( h(x) , mod ) == synthetic_division( f(x) , g(x) / a[1] )
	#                      == f(x) / ( ( a[1] * x - a[0] ) / a[1] )
	#                      == f(x) / ( x - p )                           ( p == a[0] / a[1] )
	#
	#       h(x) /= a[1]
	#
	#     として解を求めることができる。
	#
	#-----------------------------------------------------------------------
	my( $fx , $gx ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;
	return ()	unless ( ref( $gx ) eq __PACKAGE__ ) ;

	return ()	unless ( scalar( @{ $fx } ) >  2 ) ;	# 被除数は二次以上の多項式とする。
	return ()	unless ( scalar( @{ $gx } ) == 2 ) ;	# 除数は一次多項式でなければならない。

	$fx = $fx->copy() ;
	my $n = $#{ $fx } ;

	my $p = ( $gx->[0] / $gx->[1] ) * ( -1 ) ;

	foreach my $i ( reverse( 0 .. ( $n - 1 ) ) ) {
		$fx->[ $i ] += $fx->[ $i + 1 ] * $p ;
	}

	my $mod = shift( @{ $fx } ) ;
	$fx /= $gx->[1] ;

	return ( $fx , $mod ) ;
}

=head2 power

If the polynomial f(x) is a monomial,

  f(x) == a[n] * x^n

  -> ( f(x) )^p == ( a[n] )^p * x^( n * p )


  $fx = polynomial( 2 , 0 , 0 ) ;
  
  print $fx ;                                          # 2 : 2  ( == 2x^2 )
                                                       # 1 : 0
						       # 0 : 0
  
  print $fx ** 3                                       # 6 : 8  ( == 8x^6 == 2^3 * x^( 2 * 3 )
                                                       # 5 : 0
						       # 4 : 0
						       # 3 : 0
						       # 2 : 0
						       # 1 : 0
						       # 0 : 0

If the polynomial f(x) is a binomial,

  f(x) == a[i] * x^i + a[j] * x^j

  -> ( f(x) )^n == ( a[i] * x^i + a[j] * x^j )^n
                == sum( nCk * ( a[i] * x^i )^k * ( a[j] * x^j )^( n - k ) )
                == sum( nCk * ( a[i]^k * a[j]^( n - k ) * x^( k( i - j ) + jn ) ) )                  ( k == 0 -> n , n == degree( f(x) ) )



  $fx = polynomial( 2 , 0 , 1 ) ;
  
  print $fx ;                                          # 2 : 2  ( == 2x^2 + 1 )
                                                       # 1 : 0
						       # 0 : 1
  
  print $fx ** 3                                       # 6 : 8  ( == 8x^6 + 12x^4 + 6x^2 + 1 )
                                                       # 5 : 0
						       # 4 : 12
						       # 3 : 0
						       # 2 : 6
						       # 1 : 0
						       # 0 : 1

Otherwise, this method will calculate n - 1 times multiplication.

=cut

sub power {
	#-----------------------------------------------------------------------
	#
	# 冪乗
	#
	#   多項式の整数冪
	#
	#-----------------------------------------------------------------------
	my( $fx , $n ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$n = new_decimal( $n )	unless ( ref( $n ) ) ;
	return undef		unless ( defined $n ) ;
	return undef		unless ( $n->is_integer() ) ;

	my $fn = $fx->deg() ;
	my $r = undef ;

	my $nzt = [ $fx->non_zero_terms() ] ;

	if ( @{ $nzt } == 1 ) {
		#
		# 単項式の場合
		#
		#   f(X) == a[n] * X^n
		#
		#   ( f(X) )^p == ( a[n] * X^n )^p
		#              == ( a[n] )^p * X^( n * p )
		#
		$r = [] ;
		$r->[ $fn * $n ] = $fx->[ $fn ] ** $n ;
		foreach my $k ( 0 .. ( $#{ $r } - 1 ) ) {
			$r->[ $k ] = 0 ;
		}
		$r = __PACKAGE__->new( $r ) ;
	}
	elsif ( @{ $nzt } == 2 ) {
		#
		# 二項式の場合
		#
		#   f(X) == Σ( a[k] * X^k ) が二項式であれば、 i > j として、
		#
		#     f(X) == a[i] * X^i + a[j] * X^j
		#
		#   で表される。
		#
		#     Y == a[i] * X^i
		#     Z == a[j] * X^j
		#
		#   とおくと、二項定理より、
		#
		#     ( f(X) )^n == ( Y + Z )^n
		#                == Σ( nCk * Y^k * Z^( n - k ) )                                    ( k == 0 -> n )
		#                == Σ( nCk * ( a[i] * X^i )^k * ( a[j] * X^j )^( n - k ) )          ( k == 0 -> n )
		#                == Σ( nCk * ( a[i]^k * a[j]^( n - k ) * X^( k( i - j ) + jn ) ) )  ( k == 0 -> n )
		#
		my( $i , $j ) = sort { $b <=> $a } @{ $nzt } ;
		my $nck = [ reverse( $n->binomial_coefficients() ) ] ;

		$r = [] ;
		foreach my $k ( 0 .. $n ) {
			my $ix = $k * ( $i - $j ) + $j * $n ;
			$r->[ $ix ] = $nck->[ $k ] * ( $fx->[ $i ] ** $k ) * ( $fx->[ $j ] ** ( $n - $k ) ) ;
		}

		foreach ( @{ $r } ) {
			$_ = new_decimal( 0 )	unless ( defined $_ ) ;
		}

		$r = __PACKAGE__->new( $r ) ;
	}
	else {
		#
		# n - 1 回の乗算
		#
		$r = $fx->copy() ;
		foreach ( 1 .. ( $n - 1 ) ) {
			$r *= $fx ;
		}
	}

	return $r ;
}

=head2 root( $p )

If $p is not defined, this method will try to solve following equation.

  f(x) == 0

And it will try to return its results.


  $fx = polynomial( 1 , 0 , 1 ) ;                      # x^2 + 1

  print join( "\n" , $fx->root() ) ;                   # 0 + i
                                                       # 0 - i


If $p is defined, this method will try to solve following equation.

  f(x) == ( g(x) )^p

And it will try to return g(x).


  $fx = polynomial( 1 , 2 , 1 ) ;                      # x^2 + 2x + 1 == ( x + 1 )^2

  print join( "\n" , $fx->root( 2 ) ) ;                # 1 : 1        ( == x + 1 )
                                                       # 0 : 1


=cut

sub root {
	#-----------------------------------------------------------------------
	#
	# 冪根
	#
	#   多項式の演算では「冪根」は定義されない。
	#
	#   多項式における "root" は、「根」を意味するものであり、方程式
	#
	#     f(X) == 0
	#
	#   の解と同義。
	#
	#   ここでは、引数 p が与えられている場合には、
	#
	#     f(X) == ( g(X) )^p
	#
	#   となる g(X) の導出を試みることとする。
	#
	#   p が与えられていない場合には、「根」を返す事とする。
	#   この場合、戻り値は solve メソッドの戻り値となる。
	#
	#-----------------------------------------------------------------------
	my( $fx , $p ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	#
	# 根を返す。
	#
	unless ( defined $p ) {
		return $fx->solve() ;
	}

	#
	# f(X) == ( g(X) )^p となる g(X) の導出を試みる。
	#
	$p = new_decimal( $p ) ;
	return undef	unless ( defined $p ) ;
	return undef	unless ( $p->is_integer() ) ;
	return undef	unless ( $p >= 0 ) ;

	return $fx->copy()		if ( $p == 1 ) ;
	return __PACKAGE__->new( 0 )	if ( $p == 0 ) ;

	$fx = $fx->copy() ;
	my $n = $fx->deg() ;

	return undef	unless ( $n >= $p ) ;

	my $px = undef ;

	if ( $n == 2 ) {
		#
		# 二次多項式の平方根
		#
		#   f(X) == a[2] * X^2 + a[1] * X + a[0]
		#        == a[2] * ( X^2 + ( a[1] / a[2] ) * X + ( a[0] / a[2] ) )
		#        == a[2] * ( X^2 + b[1] * X + b[0] )
		#        == a[2] * g(X)
		#
		#   g(X) == 0 が重解を持つ時に限り、平方根が定義できる。
		#
		#   よって、 g(x) == 0 の判別式 D が、
		#
		#     D == b[1]^2 - 4 * b[0] == 0
		#
		#   の時に限り、
		#
		#     sqrt( f(X) ) == sqrt( a[2] ) * ( X - c )
		#                  == sqrt( a[2] ) * ( X + ( b[1] / 2 ) )
		#
		#   となる。
		#
		#   判別式での判定は f(X) == 0 の判別式
		#
		#     D == a[1]^2 - 4 * a[2] * a[0]
		#
		#   を用いても良い。
		#
		my $d = ( $fx->[1] ** 2 ) - ( $fx->[2] * $fx->[0] * 4 ) ;
		$d = $d->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

		if ( $d == 0 ) {
			my $gx = $fx / $fx->[2] ;
			$px = __PACKAGE__->new( 1 , $gx->[1] * 0.5 ) * $fx->[2]->sqrt() ;
		}
	}
	else {
		#
		# n 次多項式の p 乗根
		#
		my $x = [ $fx->solve() ] ;
		my $c = $fx->[ $n ]->root( $p ) ;
		if ( defined $c ) {
			my $ux = {} ;
			foreach my $v ( @{ $x } ) {
				unless ( defined $ux->{ $v } ) {
					$ux->{ $v } = { 'value' => $v , 'count' => 0 } ;
				}
				$ux->{ $v }->{'count'}++ ;
			}

			#
			# 根の出現回数が全て p の倍数であれば、 p 乗根を求めることができる。
			#
			my $valid = 1 ;
			foreach my $v ( keys %{ $ux } ) {
				unless ( ( $ux->{ $v }->{'count'} % $p ) == 0 ) {
					$valid = 0 ;
					last ;
				}
			}

			if ( $valid ) {
				foreach my $k ( keys %{ $ux } ) {
					my $pow = $ux->{ $k }->{'count'} / $p ;
					if ( defined $px )	{ $px *= __PACKAGE__->new( 1 , $ux->{ $k }->{'value'} * ( -1 ) ) ** $pow ; }
					else			{ $px =  __PACKAGE__->new( 1 , $ux->{ $k }->{'value'} * ( -1 ) ) ** $pow ; }
				}
				$px *= $c ;
			}
		}
	}

	return $px ;
}

=head2 substitute

Return substituted result.


  $fx = polynomial( 1 , 2 , 3 , 4 , 5 ) ;
  print $fx ;                                          # 4 : 1           ( f(x) == x^4 + 2x^3 + 3x^2 + 4x + 5 )
                                                       # 3 : 2
						       # 2 : 3
						       # 1 : 4
						       # 0 : 5

  print $fx->substitute( 10 ) ;                        # 12345           ( == f(10) )
  print $fx->substitute( 100 ) ;                       # 102030405       ( == f(100) )
  print $fx->substitute( 2 ) ;                         # 50              ( == f(2) )



=cut

sub substitute {
	#-----------------------------------------------------------------------
	#
	# 代入
	#
	#   多項式オブジェクトを
	#
	#     y == f(x) 
	#
	#   なる関数とみなし、引数 x を代入した結果である y を返す。
	#
	#   演算にはホーナー法を用いる。
	#
	#   引数は複数値を受け取れるものとする。
	#
	#-----------------------------------------------------------------------
	my( $fx , @args ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	@args = @{ $args[0] }	if ( ref( $args[0] ) eq 'ARRAY' ) ;

	my $c = [ @{ $fx } ] ;	# 係数列
	my $n = $#{ $c } ;	# 最高次数
	my $y = [] ;

	foreach my $i ( 0 .. $#args ) {

		my $x = $args[ $i ] ;
		return ()		unless ( defined $x ) ;
		$x = new_decimal( $x )	unless ( ref( $x ) ) ;
		return ()		unless ( defined $x ) ;

		#
		# ホーナー法による代入演算
		#
		#   Y == a[5] * X^5 + a[4] * X^4 + a[3] * X^3 + a[2] * X^2 + a[1] * X + a[0]
		#     == X * ( a[5] * X^4 + a[4] * X^3 + a[3] * X^2 + a[2] * X ) + a[1] ) + a[0]
		#     == X * ( X * ( X * ( a[5] * X^3 + a[4] * X^2 + a[3] * X ) + a[2] ) + a[1] ) + a[0]
		#     == X * ( X * ( X * ( X * ( a[5] * X^2 + a[4] * X ) + a[3] ) + a[2] ) + a[1] ) + a[0]
		#     == X * ( X * ( X * ( X * ( X * ( X * ( a[5] ) ) + a[4] ) + a[3] ) + a[2] ) + a[1] ) + a[0]
		#
		$y->[ $i ] = $c->[ $n ]->copy() ;
		foreach my $j ( reverse( 0 .. ( $n - 1 ) ) ) {

			$y->[ $i ] = $y->[ $i ] * $x + $c->[ $j ] ;

			if ( $j =~ /00$/ ) {
				$y->[ $i ] = $y->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
			}
		}

		$y->[ $i ] = $y->[ $i ]->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}

	return ( scalar( @args ) == 1 ) ? $y->[0] : @{ $y } ;
}

=head2 differential( $order )

  f(x) == sum( a[i] * x^i )                       ( i == 0 -> degree( f(x) ) )
  -> f'(x) == sum( a[i] * i * x^( i - 1 )         ( i == 1 -> degree( f(x) ) )    .... order == 1

                                                  k!
  diferential( f(x) , order ) == sum( a[k] * ------------ * x^( k - j ) )             ( k == j -> n , j == order )
                                              ( k - j )!

  f'(x)  == differntial( f(x) , 1 )
  f''(x) == differntial( f(x) , 2 )


  $fx = polynomial( 1 .. 5 ) ;

  print $fx ;                                          # 4 : 1     ( == x^4 + 2x^3 + 3x^2 + 4x + 5 )
                                                       # 3 : 2
						       # 2 : 3
						       # 1 : 4
						       # 0 : 5

  print $fx->differential() ;                          # 3 : 4     ( == 4x^3 + 6x^2 + 6x + 4 )
                                                       # 2 : 6
						       # 1 : 6
						       # 0 : 4

  print $fx->differential( 2 ) ;                       # 2 : 12    ( == 12x^2 + 12x + 6 )
                                                       # 1 : 12
						       # 0 : 6

  print $fx->differential( 3 ) ;                       # 1 : 24    ( == 24x + 12 )
                                                       # 0 : 12

  print $fx->differential( 4 ) ;                       # 0 : 24    ( == 24 ) 

=cut

sub differential {
	#-----------------------------------------------------------------------
	#
	# 微分 ( 微分法は differentiation 又は derivation と呼ばれる。 )
	#
	#   y == f(x) == a[n] * X^n + a[n-1] * X^(n-1) + .... + a[0]
	#
	#             == Σ( a[i] * X^i )                ( i == 0 -> n )
	#
	#   ->  f'(x) == a[n] * n * X^(n-1) + a[n-1] * ( n-1 ) * X^(n-2) + ... a[1]
	#
	#             == Σ( a[i] * i * X^( i - 1 ) )    ( i == 1 -> n )
	#
	#
	#   任意の多項式を微分して得られる関数は、導関数 ( derivative ) とも呼ばれる。
	#   ( ニュートン法等の解析的な近似計算で利用される関数であることから、導関数と呼ばれているものと考えられる。 )
	#
	#   任意の多項式 f(X) が重根を持つ時、これを微分して得られる f'(X) は f(X) と共通の因数 ( 根 ) を持つ。
	#
	#
	#   高階導関数 ( 高次導関数 ; n 次導関数 ; higher derivative ; n-th derivative ; derivative of order n )
	#
	#     高階導関数は、多項式を n 回微分して得られる導関数。
	#     数学では、
	#
	#       d^n / dx^n 
	#
	#     等の記号が使用される。 ( この他にも様々な記法がある。 )
	#
	#     高階導関数は、 j <= n として、
	#
	#       differntial( f(X) , j ) == Σ( a[k] * Π( m ) * X^( k - j ) )          ( k == j -> n ; m == ( k - ( j - 1 ) ) -> k )
	#
	#                                                  k!
	#                               == Σ( a[k] * ------------ * X^( k - j ) )     ( k == j -> n )
	#                                              ( k - j )!
	#     で表される。
	#
	#
	#  一次の微分で得られる関数 y == f'(x) は、任意の点における接線の傾きを表す。
	#
	#    f'(x) == 0
	#
	#  となる方程式の解を x == a とした時、 a の前後で f'(x) の符合が変わるような場合には、 f(a) が極小値または極大値であることを示す。
	#
	#  二次の微分で得られる関数 y == f''(x) について、
	#
	#    f''(x) == 0
	#
	#  となる方程式の解を x == a とした時、 a の前後で f''(x) の符合が変わるような場合には、 f(a) が y == f(x) の変曲点であることを示す。
	#
	#-----------------------------------------------------------------------
	my( $fx , $order ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$fx = $fx->copy() ;
	my $n = $fx->deg() ;

	my $j = ( defined $order ) ? $order : 1 ;
	$j = new_decimal( $j ) ;
	return undef	unless ( defined $j ) ;
	return undef	unless ( $j <= $n ) ;

	my $px = __PACKAGE__->new( 0 ) ;
	foreach ( my $k = $j->copy() ; $k <= $n ; $k++ ) {
		my $t = $k->copy() ;
		foreach ( 1 .. ( $j - 1 ) ) {
			$t *= ( $k - $_ ) ;
		}
		$px->[ $k - $j ] = $fx->[ $k ] * $t ;
	}

	return $px ;
}

=head2 integral( $x1 , $x2 )

  f(x) == sum( a[k] * x^k )                                   ( k == 0 -> degree( f(x) ) )

                                    a[k]
  F(x) == integral( f(x) ) == sum( ------- * x^( k + 1 ) )    ( k == 0 -> degree( f(x) ) )
                                    k + 1


If the interval [ $x1 , $x2 ] is defined, this method will return

  abs( F( $x2 ) - F( $x1 ) )

else it will return F(x).


  $fx = polynomial( 1 .. 5 ) ;

  print $fx ;                                          # 4 : 1         ( == x^4 + 2x^3 + 3x^2 + 4x + 5 )
                                                       # 3 : 2
						       # 2 : 3
						       # 1 : 4
						       # 0 : 5

  print $fx->integral() ;                              # 5 : 0.20000   ( == 1/5 * x^5 + 1/2 * x^4 + x^3 + 2x^2 + 5x )
                                                       # 4 : 0.50000
						       # 3 : 1
						       # 2 : 2
						       # 1 : 5
						       # 0 : 0

  print $fx->integral( 2 , 3 ) ;                       # 108.7         ( == abs( F(3) - F(2) ) == 149.1 - 40.4 )


=cut

sub integral {
	#-----------------------------------------------------------------------
	#
	# 積分 ( 積分法は integration )
	#
	#   f(X) == Σ( a[k] * X^k )                            ( k == 0 -> n )
	#
	#                            a[k]
	#   integral( f(X) ) == Σ( ------- * X^( k + 1 ) )     ( k == 0 -> n )
	#                            k + 1
	#
	#   積分によって導かれる多項式は、任意の多項式 f(X) を導関数とみなし、
	#   導関数が f(X) となるような関数 y == g(X) を定義して得られる右辺の g(X) を指す。
	#
	#   導関数 f(X) に対する原始関数 g(X) は一つとは限らず、無数に存在する。
	#   これは、微分によって原始関数の定数項が失われていること、そしてそれが復元不可能であることによる。
	#
	#   積分によって得られた多項式 g(X) は、原始関数と呼ばれる。
	#   この種の積分は、「逆微分としての不定積分 ( antiderivative ) 」と呼ばれる。
	#   積分論の中では不定積分は "indefinte integral" とも呼ばれる。
	#
	#   数学の世界では、微分方程式
	#
	#     ( d / dx ) * F(x) == f(x)
	#
	#   の解となる F(x) 全体を表すものとして、
	#
	#     F(x) == ∫( f(x) * dx )
	#
	#   と表される。 ( リーマン積分の記法 ; ライプニッツの記法 )
	#
	#   また、積分の定義より、
	#
	#     ∫( f(x) * dx ) == F(x) + C
	#     ∫( f(x) * dx ) == ∫( f(t) * dt ) + C          ( t == a , x )
	#
	#   も成立する。 ( これが不定積分の厳密な定義となる。 )
	#   C は、 x の値の採り方によって確定する任意の定数であり、積分定数と呼ばれる。
	#
	#   この F(x) の x に区間 [ a , b ] を与えることによって得られる値の差は、
	#   n 次曲線 f(x) とその曲線上の点 f(a) 及び f(b) を直線で結んで得られる閉じた平面の面積の近似値となる。
	#
	#   この時、
	#
	#     F(x) == ∫( f(x) * dx ) + C
	#     ∫( f(x) * dx ) == F(b) - F(a)            ( x == a , b ; a <= b )
	#
	#   であり、この後者の式を指して f(x) の区間 a <= x <= b における定積分と呼ぶ。
	#   ( 前者は不定積分 F(x) )
	#
	#
	#   このメソッドでは、引数に区間が与えられている場合には、定積分の演算結果としての定数を、
	#   そうでない場合には、原始関数を表す多項式オブジェクトを返す事とする。
	#
	#-----------------------------------------------------------------------
	my( $fx , @args ) = @_ ;

	if ( defined $args[0] and ref( $args[0] ) eq 'ARRAY' ) {
		@args = @{ $args[0] } ;
	}

	$fx = $fx->copy() ;
	my $n = $fx->deg() ;

	my $sx = [ new_decimal( 0 ) ] ;
	my $r = undef ;

	foreach my $i ( 0 .. $n ) {
		$sx->[ $i + 1 ] = $fx->[ $i ] / ( $i + 1 ) ;
	}
	$sx = __PACKAGE__->new( $sx ) ;

	return undef	unless ( defined $sx ) ;

	if ( @args ) {
		my( $f , $t ) = @args ;
		foreach ( $f , $t ) {
			$_ = new_decimal( $_ )	unless ( ref( $_ ) ) ;
			return undef		unless ( defined $_ ) ;
		}
		( $f , $t ) = ( $t , $f )	unless ( $f < $t ) ;

		$r = $sx->substitute( $t ) - $sx->substitute( $f ) ;
	}
	else {
		$r = $sx ;
	}

	return $r ;
}

=head2 deflate

Return the deflated polynomial.


The polynomial f(x) is defined as follows.

  f(x) == sum( a[k] * x^k )          ( k = 0 -> degree( f(x) ) ) 

In the deflation, the following equation will be defined at first.

  f(x) == 0

Next, the following y will be defined.

  n == degree( f(x) )
  y == x + ( a[n-1] / ( n * a[n] ) )

Then, deflation is defined as follows.

  deflate( f(x) ) == f(x) / y

for example.

  f(x) == 2x^3 + 6x^2 + 2x + 2 == 0

  -> y == x - p == x + ( 6 / ( 3 * 2 ) ) == x + 1
  -> p == -1
 

            2   6   2   2 
  -> -1 ) -----------------
            2   4  -2   4     ..... ( x + 1 )(   2x^2 + 4x - 2                     ) + 4
          -----------------
            2   2  -4         ..... ( x + 1 )( ( x + 1 )(   2x + 2           ) - 4 ) + 4
          -----------------
            2   0             ..... ( x + 1 )( ( x + 1 )( ( x + 1 )( 2 ) + 0 ) - 4 ) + 4

  -> 2x^3 + 6x^2 + 2x + 2 == ( x + 1 )( ( x + 1 )( ( x + 1 ) * 2 + 0 ) - 4 ) + 4
                          == y * ( y * ( 2y + 0 ) - 4 ) + 4
                          == 2y^3 - 4y + 4
                          == y^3 - 2y + 2
                          == 0

  -> y^3 - 2y + 2 == ( x + 1 )^3 - 2 * ( x + 1 ) + 2 == 0

  -> g(y) == deflate( f(x) ) == y^3 - 2y + 2


This method will return this g(y) and p.


  $fx = polynomial( 2 , 6 , 2 , 2 ) ;
  
  print $fx ;                                          # 3 : 2      ( == 2x^3 + 6x^2 + 2x + 2 )
                                                       # 2 : 6
						       # 1 : 2
						       # 0 : 2
  ( $gy , $p ) = $fx->deflate() ;

  print $gy ;                                          # 3 : 1      ( == y^3 - 2y + 2 )
                                                       # 2 : 0
						       # 1 : -2
						       # 0 : 2

  print $p ;                                           # -1         ( p == -1 )

  $hx = polynomial( 1 , $p * (-1) ) ;

  print $hx ;                                          # 1 : 1      ( == x + 1 )
                                                       # 0 : 1
  
  print $gy->substitue( $hx ) ;                        # 3 : 1      ( == x^3 + 3x^2 + x + 1 == 1/2 * f(x) )
                                                       # 2 : 3
						       # 1 : 1
						       # 0 : 1


The deflation makes the n - 1 terms of the deflated polynomial to 0.

The deflation is sometimes used as a part of solving equation.

=cut

sub deflate {
	#-----------------------------------------------------------------------
	#
	# 減次 ( deflation )
	#
	#   多項式を f(x) == 0 なる方程式とみなし、組み立て除法を利用して n - 1 項を消去した方程式に変換する。
	#
	#   組み立て除法を繰り返し適用すると、任意の n 次方程式を Y == X + s で定義される Y についての n 次方程式に変換することができる。
	#   これを応用したものが減次と呼ばれる処理。
	#
	#   X についての n 次方程式
	#
	#     f(X) == Σ( a[k] * X^k ) == 0            ( k == 0 -> n )
	#
	#   に対して減次を行うには、 Y を
	#
	#     Y == X + ( a[n-1] / n * a[n] )
	#
	#   と定義する。
	#   これを用いて f(X) を完全に分解することで Y についての n 次方程式 g(Y) == 0 を得る。
	#   この時、 g(Y) の n - 1 次の項の係数は必ず 0 になる。
	#
	#   以下、その一例。
	#
	#     2x^3 + 6x^2 + 2x + 2 == 0
	#     -> y == x + ( 6 / ( 3 * 2 ) ) == x + 1
	#
	#               2   6   2   2 
	#     -> -1 ) -----------------
	#               2   4  -2   4     ..... ( x + 1 )(   2x^2 + 4x - 2                     ) + 4
	#             -----------------
	#               2   2  -4         ..... ( x + 1 )( ( x + 1 )(   2x + 2           ) - 4 ) + 4
	#             -----------------
	#               2   0             ..... ( x + 1 )( ( x + 1 )( ( x + 1 )( 2 ) + 0 ) - 4 ) + 4
	#
	#     -> 2x^3 + 6x^2 + 2x + 2 == ( x + 1 )( ( x + 1 )( ( x + 1 ) * 2 + 0 ) - 4 ) + 4
	#                             == y * ( y * ( 2y + 0 ) - 4 ) + 4
	#                             == 2y^3 - 4y + 4
	#                             == y^3 - 2y + 2
	#                             == 0
	#
	#     -> y^3 - 2y + 2 == ( x + 1 )^3 - 2 * ( x + 1 ) + 2 == 0
	#
	#
	#   二次方程式を減次すると、平方完成と同じ結果が得られる。
	#   三次方程式の減次は、立方完成とも呼ばれる。
	#   三次以上の高次方程式の解法においても、減次の概念は非常に重要なものとなっている。
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$fx = $fx->copy() ;

	my $n = $#{ $fx } ;
	my $p = ( $fx->[ $n - 1 ] / ( $fx->[ $n ] * $n ) ) * ( -1 ) ;
	my $c = [] ;

	#
	# 組み立て除法を繰り返し、剰余値を都度分離する。
	#
	while ( @{ $fx } > 1 ) {
		my $m = $#{ $fx } ;
		foreach my $i ( reverse( 0 .. ( $m - 1 ) ) ) {
			$fx->[ $i ] += $fx->[ $i + 1 ] * $p ;
		}
		push( @{ $c } , shift( @{ $fx } ) ) ;
	}
	push( @{ $c } , @{ $fx } ) ;

	#
	# Y^n の係数が 1 になるように調整し、多項式オブジェクトに変換して返す。
	#
	my $cn = $c->[-1] ;
	if ( $cn != 0 and $cn != 1 ) {
		foreach ( @{ $c } ) { $_ /= $cn ; }
	}

	foreach ( @{ $c } ) {
		$_ = $_->round( $DECIMAL_PART_LENGTH_LIMIT * 0.7 ) ;
	}

	my $gx = ( @{ $c } ) ? __PACKAGE__->new( $c ) : undef ;

	return ( defined $gx ) ? ( $gx , $p ) : () ;
}

=head2 avgrc( $p , $q )

Return the average rate of change.


                                         f(x)
  avgrc( f(x) , p , q ) == mod( ----------------------- )
                                 ( x - p ) * ( x - q )


=cut

sub avgrc {
	#-----------------------------------------------------------------------
	#
	# 平均変化率 ( Average Rate of Change )
	#
	#   n 次多項式 f(x) において、 x が a -> b へ変化する時の変化の割合を平均変化率と呼ぶ。
	#
	#   平均変化率は、
	#
	#     f(x) / ( x - a ) の商を更に ( x - b ) で除した剰余値
	#
	#   として得ることができる。
	#
	#   これは、組み立て除法で求めることができる。
	#
	#-----------------------------------------------------------------------
	my( $fx , $p , $q ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $px = __PACKAGE__->new( 1 , $p * ( -1 ) ) ;	# p(x) == x - p
	my $qx = __PACKAGE__->new( 1 , $q * ( -1 ) ) ;	# q(x) == x - q

	foreach ( $px , $qx ) {
		return ()	unless ( defined $_ ) ;
	}

	my( $gx , $mod ) = $fx->synthetic_division( $px ) ;
	return undef	unless ( defined $gx ) ;

	( $gx , $mod ) = $gx->synthetic_division( $qx ) ;

	return $mod ;
}

=head1 'Polynomial' object - Solving equation

=cut

#-------------------------------------------------------------------------------
#
# 方程式の解法
#
#   一変数 n 次多項式 f(X) を f(X) == 0 なる方程式と見なし、これを解く。
#   方程式の解を求める処理は、 n 次多項式の因数分解に等しい。
#   方程式の解は多項式の根 ( root ) とも呼ばれる。
#   幾何学的な表現として、関数 y == f(X) の零点 ( zero ) と呼ばれることもある。
#
#-------------------------------------------------------------------------------

=head2 newton

The approximation to solve f(x) == 0 , using by the Newton's method.

  f(x) == a[n] * x^n
        + a[n-1] * x^(n-1)
        + ..... 
        + a[0]

  d(x) == f'(x)
       == a[n]   *   n       * X^(n-1)
        + a[n-1] * ( n - 1 ) * X^(n-2) 
        + .... 
        + a[1]

  x[0] == root( (-1) * a[0] / a[n] , n ) 

  x[k] == newton( f(x) )
  
                    f( x[k-1] )
       == x[k-1] - -------------             ( k == 1 -> INF )
                    d( x[k-1] )

This method can find only one root of the equation, it cannot find the all of the roots, one time.

This method sometimes may cause divergence or oscillation.


  $fx = polynomial( 1 , 1 , 1 , 1 ) ;          # == x^3 + x^2 + x + 1

  $p = $fx->newton() ;
  print $p ;                                   # -1

  $gx = $fx / polynomial( 1 , $p * (-1) ) ;    # $gx = $fx / ( x - $p )

  print $gx ;                                  # 2 : 1            ( == x^2 + 1 )
                                               # 1 : 0
					       # 0 : 1

  -> $fx == ( x - $p ) * $gx
         == ( x + 1 ) * ( x^2 + 1 )
         ==  x^3 + x^2 + x + 1

=cut

sub newton {
	#-----------------------------------------------------------------------
	#
	# ニュートン法による近似
	#
	#   n 次方程式の解の一つを返す。
	#
	#   三次以上の方程式は実根を持つとは限らない上、 四次以上の方程式では実根を持つかどうかの判別すら困難となる。
	#   このため、演算は複素数の領域で行っている。
	#
	#   ニュートン法は任意に定めた初期値から値を近似させて行くため、 n 次方程式の解を一度に全て得る事はできない。
	#   また、適切な初期値を導く法則も存在しないため、全ての解を適切に導く手段とは成りえない。
	#
	#   ニュートン法は初期値の採り方によって発散や振動といった現象が発生することがあり、必ずしも収束するとは限らない。
	#   発散は演算過程の値が正負何れかの方向の無限大へ向かう現象であり、振動は演算過程の値が変曲点付近を往復する現象。
	#   何れも、初期値と変曲点の位置関係によって生じる問題であり、発生頻度は非常に低い。
	#
	#   発散や振動が発生した場合、初期値を採り直して再実行することで多くの場合問題は解決するはずだが、
	#   適切な初期値を選び取るのは容易ではなく、一般化された手法も存在しない。
	#
	#   その代わりに、 n 次方程式を減次することで対処することもできる。
	#   減次は n 次多項式で表現されるグラフを X 軸方向にずらした写像を採ることに等しく、
	#   これを行うことで変曲点の位置を変えることができる。
	#
	#   このメソッドでは、
	#
	#     a[0] * X^n + a[1] * X^(n-1) + .... + a[n] == 0
	#
	#   の係数列を受け取り、
	#
	#     X^n + ( a[n] / a[0] ) == 0
	#
	#   の解の一つを初期値として近似値を計算している。
	#   ( 実数解が存在すれば、それが採用される。 )
	#   
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$fx = $fx->copy() ;
	my $x = undef ;

	#
	# X == 0 は除く。
	#
	while ( $fx->[0] == 0 ) {
		shift( @{ $fx } ) ;
	}

	#
	# 次数
	#
	my $n = $fx->deg() ;

	return undef	if ( $n == 0 ) ;

	#-----------------------------------------------------------------------
	#
	# シンプルな方程式
	#
	#-----------------------------------------------------------------------
	if ( $n == 1 ) {
		#---------------------------------------------------------------
		#
		# 一次方程式
		#
		#   a[1] * X + a[0] == 0
		#
		#   -> X == ( -1 ) * a[0] / a[1]
		#
		#---------------------------------------------------------------
		$x = $fx->[0] * ( -1 ) / $fx->[1] ;
		$x = $x->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}
	elsif ( $fx->is_binomial() ) {
		#---------------------------------------------------------------
		#
		# 二項式
		#
		#   X == 0 のケースは除外されているので、定数項 a[0] は、
		#
		#     a[0] != 0
		#
		#   この時、 f(X) が二項式であれば、
		#
		#     f(X) == a[n] * X^n + a[0] == 0
		#
		#     -> X == root( ( ( -1 ) * a[0] / a[n] ) , n )
		#
		#   となる。
		#
		#   ここでは、 X の解として n 乗根の一つを採用する。
		#   ( 実数解があればこれを採用する。 )
		#
		#---------------------------------------------------------------
		$x = ( $fx->[0] * ( -1 ) ) / $fx->[ $n ] ;
		$x = $x->complex()	unless ( $x->is_complex() ) ;
		$x = [ $x->root( $n ) ] ;
		foreach ( @{ $x } ) {
			$x = $_->decimal()	if ( $_->can_decimal() ) ;
		}
		$x = $x->[0]	if ( ref( $x ) eq 'ARRAY' ) ;
		$x = $x->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}
	elsif ( $n == 2 ) {
		#---------------------------------------------------------------
		#
		# 二次方程式
		#
		#   a[2] * X^2 + a[1] * X + a[0] == 0
		#
		#   判別式
		#
		#     D == ( a[1] )^2 - 4 * ( a[2] * a[0] )
		#
		#   解
		#           ( -1 ) * a[1] ± sqrt( D )
		#     X == -----------------------------
		#                   2 * a[2]
		#
		#   解はこの内の一つのみを採る。
		#
		#---------------------------------------------------------------
		my $d = ( ( $fx->[1] ) ** 2 ) - ( ( $fx->[2] * $fx->[0] * 4 ) ) ;	# 判別式
		$d = $d->complex()	unless ( $d->is_complex() ) ;
		$d = ( $d->sqrt() )[0] ;
		$x = ( $d - $fx->[1] ) / ( $fx->[2] * 2 ) ;
		$x = $x->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
	}

	return $x	if ( defined $x ) ;

	#-----------------------------------------------------------------------
	#
	# 高次多項式
	#
	#   三次以上の方程式は漸化式を用いて近似する。
	#
	#   n 次多項式 f(X) を
	#
	#     f(X) == a[n] * X^n
	#           + a[n-1] * X^(n-1)
	#           + ..... 
	#           + a[0]
	#
	#   とすると、その微分方程式 d(X) は、
	#
	#     d(X) == a[n]   *   n       * X^(n-1)
	#           + a[n-1] * ( n - 1 ) * X^(n-2) 
	#           + .... 
	#           + a[1]
	#
	#   となる。
	#
	#   漸化式は、
	#
	#                       f( X[k-1] )
	#     X[k] == X[k-1] - -------------
	#                       d( X[k-1] )
	#
	#   X の初期値として、
	#
	#     a[n] * X^n + a[0] * X^0 == 0
	#
	#   の解 ( a[0] / a[n] の n 乗根 ) の一つを使用する。
	#
	#   この解に実数解があればこれを採用する。
	#   実数解がない場合には、任意の解を一つ選択する。 ( 複素数の n 乗根の絶対値は全て等しい。 )
	#
	#   補足 :
	#
	#     X についての n 次方程式 f(X) == 0 は、その解 x[i] と各項の係数 a[j] によって
	#
	#       f(X) == Π( X - x[i] )             ( i == 1 -> n )
	#            == Σ( a[n-j] * X^(n-j) )     ( j == 0 -> n )
	#            == 0
	#
	#     と表される。
	#
	#     この時、 X^0 の項 a[0] は、
	#
	#       a[0] == Π( x[i] )               ( i == 1 -> n )
	#
	#     であり、 f(X) == 0 の解 x[i] と a[n] との間に
	#
	#       abs( x[i] ) <= abs( a[0] )       ( i == 1 -> n )
	#
	#     と言う関係が成り立つ。
	#
	#     つまり、 abs( a[0] ) は abs( x[i] ) の上限であり、 a[0] の n 乗根は x[i] の中央値の近似値としての意味を持つことになる。
	#
	#-----------------------------------------------------------------------
	
	#
	# X の初期値
	#
	$x = $fx->[0] * ( -1 ) / $fx->[ $n ] ;
	$x = $x->complex()	unless ( $x->is_complex() ) ;

	$x = [ $x->root( $n ) ] ;
	foreach ( @{ $x } ) {
		if ( $_->can_decimal() ) { $x = $_ ; last ; }
	}
	$x = $x->[0]	if ( ref( $x ) eq 'ARRAY' ) ;

	#
	# 微分方程式
	#
	my $dx = $fx->differential() ;

	#
	# 漸化式
	#
	#                     f( X[k-1] )
	#   X[k] == X[k-1] - -------------
	#                     d( X[k-1] )
	#
	my $cnt = 0 ;
	while ( ++$cnt < 100 ) {
		my $diff = $fx->substitute( $x ) / $dx->substitute( $x ) ;
		$diff = $diff->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
		
		$x -= $diff ;

		if ( $diff->is_complex() ) {
			last	if ( $diff->det()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
		}
		else {
			last	if ( $diff->abs()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
		}
	}

	$x = $x->round( $DECIMAL_PART_LENGTH_LIMIT ) ;

	return $x ;
}

=head2 solve

Solve f(x) == 0.

This method will try to solve f(x) == 0, using by DKA method ( Durand-Kerner-Aberth method ; Weierstrass method ).

In DKA method, the eqaution is defined as follows.

  
  f(z) == a[n] * total_product( z - x[j] ) == 0          ( j == 1 -> n ; n == degree( f(z) )

Then

  f'( z[i] ) == a[n] * total_product( z[i] - z[j] )      ( j == 1 -> n ; j != i )

Next, it defines the reccurence formula, using by the Newton's method,


                                           f( z[i][k] )
  z[i][ k + 1 ] == z[i][k] - -------------------------------------------       ( j == 1 -> n ; j != 1 )
                              a[n] * total_product( z[i][k] - z[j][k] )

This formula is called the Duran-Kerner formula.

The z[j][0] is defined as follows.

  R0 == (-1) * a[n-1] / ( n * a[n] )

                                2 * PI           3
  z[j][0] == R0 + R * exp( i * -------- * ( j - --- ) )                       ( j == 1 -> n )
                                  n              4

The initial approximation value R is defined as follows.

  R == abs( newton( deflate( f(z) ) ) )

This is called Aberth method.


  $fx = polynomial( 1 , 1 , 1 , 1 ) ;                  # f(x) == x^3 + x^2 + x + 1
  
  @x = $fx->solve() ;
  print join( ' , ' , @x ) ;                           # -1 , 0 - i , 0 + i        ( x == -1 , -i , +i )

  $gx = polynomial( 1 ) ;
  foreach ( @x ) {
    $gx *= polynomial( 1 , $_ * (-1) ) ;               # g(x) == ( x + 1 )( x + i )( x - i )
  }

  print $gx ;                                          # 3 : 1    ( g(x) == x^3 + x^2 + x + 1 == f(x) )
                                                       # 2 : 1
						       # 1 : 1
						       # 0 : 1


The solving the equation means the factorization of polynomial.


=cut

sub solve {
	#-----------------------------------------------------------------------
	#
	# DKA 法 ( Durand-Kerner-Aberth method ) による n 次方程式の解法
	#
	#   DKA 法は、ワイエルシュトラス法 ( Weierstrass method ) とも呼ばれる。
	#
	#   DKA 法では、 n 次方程式を
	#
	#     f(z) == a[n] * z^n + a[n-1] * z^(n-1) + a[n-2] * z^(n-2) + ...... + a[0]
	#
	#          == a[n] * ( z - x[1] )( z - x[2] ) ..... ( z - x[n] )
	#
	#          == a[n] * Π( z - x[j] )           ( j == 1 -> n )
	#
	#          == 0
	#
	#   と捉え、
	#
	#   f(z) を微分した f'(z) を
	#
	#     f'( z[i] ) == a[n] * Π( z[i] - z[j] )        ( j == 1 -> n ; j != i )
	#
	#   と定義する。
	#
	#   これをニュートン法で近似する式は、
	#
	#                                          f( z[i][k] )
	#     z[i][ k + 1 ] == z[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
	#                                 a[n] * Π( z[i][k] - z[j][k] )
	#
	#   と表される。 ( Durand-Kerner の公式 )
	#
	#   この時、各 z[j] の初期値 z[j][0] は、
	#
	#     R0 == ( -1 ) * a[n-1] / ( n * a[n] )
	#
	#                                   2PI           3
	#     z[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )              ( j == 1 -> n )
	#                                    n            4
	#
	#   で与えられる。 ( Aberth の初期値 )
	#
	#   R は、複素平面上の座標 [ R0 , 0 ] を中心とする円の半径であり、この円の中に解が存在するように設定された値となる。
	#
	#   この時、初期値 z[j][0] は、この円の円弧状に均等に配置されるような値となる。
	#
	#
	#   R の導出
	#
	#     n 次方程式
	#
	#       f(X) == a[n] * X^n + a[n-1] * X^( n-1 ) + ..... + a[0] == 0
	#
	#     を減次した
	#
	#       g(Y) == b[n] * Y^n + b[n-2] * Y^( n-2 ) + ..... + b[0] == 0
	#
	#     を利用する。
	#
	#     g(Y) == 0 は、 b[n] == 1 としても一般性は失われないため、
	#
	#       b[k] = b[k] / b[n]
	#
	#       -> g(Y) == Y^n + b[n-2] * Y^(n-2) + ..... + b[0] == 0
	#
	#     として調整済みとする。
	#
	#     g(Y) の Y^n 以外の項を右辺に移項すると、
	#
	#       Y^n == ( -1 ) * ( b[n-2] * Y^( n-2 ) + b[n-3] * Y^( n-3 ) + .... + b[0] )
	#
	#       -> abs( Y^n ) == b[n-2] * Y^( n-2 ) + b[n-3] * Y^( n-3 ) + .... + b[0]
	#                     <= abs( b[n-2] ) * abs( Y^( n-2 ) ) + .... + abs( b[0] )
	#
	#     と言う関係が得られる。
	#
	#     この不等式は Y の絶対値最大の値に対しても成り立ち、
	#     Y の値として絶対値最大の値を採った時に左右の辺は等式で結ばれる。
	#
	#     よって、
	#
	#       R == max( abs( Y ) ) 
	#
	#       R^n == abs( b[n-2] ) * R^( n-2 ) + ..... + abs( b[0] )
	#
	#       -> R^n - abs( b[n-2] ) * R^(n-2) - .... - abs( b[0] ) == 0
	#
	#     となる。
	#
	#     b[k] が全て実数であれば、 abs( b[0] ) の n 乗根には必ず実数が現れる。
	#
	#     上記 R に関する n 次方程式の解の一つを R の初期値として使用する。
	#
	#-----------------------------------------------------------------------
	my( $fx , $r ) = @_ ;
	return ()	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	$fx = $fx->copy() ;

	#
	# 最高次数の係数が 0 であれば次数を下げる。
	#
	while ( $fx->[-1] == 0 ) { pop( @{ $fx } ) ; }
	return ()	if ( $fx->deg() < 1 ) ;

	#
	# 定数項が 0 の場合
	#
	#   X * ( a[n] * X^(n-1) + a[n-1] * X^(n-2) + .... + a[1] ) == 0
	#
	if ( $fx->[0] == 0 ) {
		shift( @{ $fx } ) ;
		return ( __PACKAGE__->new( 0 ) , $fx->solven() ) ;
	}

	my $n = $fx->deg() ;
	return ()	if ( $n < 1 ) ;

	#-----------------------------------------------------------------------
	#
	# 主処理
	#
	#-----------------------------------------------------------------------
	my $z = [] ;

	if ( $n == 1 ) {
		#---------------------------------------------------------------
		#
		# 一次方程式
		#
		#   a[1] * X + a[0] == 0
		#
		#   -> X == ( -1 ) * a[0] / a[1] 
		#
		#---------------------------------------------------------------
		$z = [ ( $fx->[0] * ( -1 ) ) / $fx->[1] ] ;
	}
	elsif ( $fx->is_binomial() ) {
		#---------------------------------------------------------------
		#
		# 二項式
		#
		#   定数項 a[0] != 0 より、
		#
		#     a[n] * X^n + a[0] == 0
		#
		#     -> X == root( ( ( -1 ) * a[0] / a[n] ) , n )
		#
		#
		#   二項方程式の内、
		#
		#     X^n - 1 == 0
		#
		#   は、円周等分方程式と呼ばれ、この方程式の解は 1 の n 乗根となる。
		#
		#---------------------------------------------------------------
		my $x = ( $fx->[0] * ( -1 ) ) / $fx->[ $n ] ;
		$x = $x->complex()	unless ( $x->is_complex() ) ;
		$z = [ $x->root( $n ) ] ;
	}
	elsif ( $n == 2 ) {
		#---------------------------------------------------------------
		#
		# 二次方程式
		#
		#   a[2] * X^2 + a[1] * X + a[0] == 0
		#
		#            ( -1 ) * a[1] ± sqrt( ( a[1] )^2 - 4 * a[2] * a[0] )
		#   -> X == -------------------------------------------------------
		#                            2 * a[2]
		#
		#---------------------------------------------------------------
		my $x = ( $fx->[1] ** 2 )  - ( $fx->[2] * $fx->[0] * 4 ) ;

		if ( $x == 0 ) {
			$z->[0] = ( $fx->[1] * ( -1 ) ) / ( $fx->[2] * 2 ) ;
			$z->[1] = $z->[0]->copy() ;
		}
		else {
			$x = $x->complex()	unless ( $x->is_complex() ) ;
			$z = [ $x->sqrt() ] ;
			foreach ( @{ $z } ) {
				$_ = ( $_ - $fx->[1] ) / ( $fx->[2] * 2 ) ;
			}
		}
	}
	else {
		#---------------------------------------------------------------
		#
		# 高次方程式
		#
		#   R0 == ( -1 ) * a[n-1] / ( n * a[n] )
		#
		#                                 2PI           3
		#   z[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )              ( j == 1 -> n )
		#                                  n            4
		#
		#                                        f( z[i][k] )
		#   z[i][ k + 1 ] == z[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
		#                               a[n] * Π( z[i][k] - z[j][k] )
		#
		#---------------------------------------------------------------

		#
		# R0 == ( -1 ) * a[n-1] / ( n * a[n] )
		#
		my $r0 = ( $fx->[ $n - 1 ] / ( $n * $fx->[ $n ] ) ) * ( -1 ) ;

		#
		# f(X) == 0 を減次した g(X) == 0 の解の一つを R の省略時値とする。
		#
		#   f(X) == a[n] * X^n + a[n-1] * X^( n-1 ) + ..... + a[0] == 0
		#
		#   -> g(Y) == Y^n + b[n-2] * Y^( n-2 ) + ..... + b[0] == 0
		#
		#   -> R^n - abs( b[n-2] ) * R^(n-2) - .... - abs( b[0] ) == 0
		#
		unless ( defined $r ) {
			#
			# 減次した方程式の解の一つをニュートン法で取得し、 R の初期値とする。
			#
			#   減次した結果が単項式になる場合、
			#
			#     ( X^n , s ) == deflate( f(X) )
			#                                           a[n-1]
			#     -> f(X) == ( X - s ) * X^n == ( X - ---------- ) * X^n == 0
			#                                          n * a[n]
			#
			#     f(X) の定数項 a[0] != 0 であることは確認済みなので、 X != 0 であることは明白。
			#     よって、
			#
			#       X == s == a[n-1] / ( n * a[n] )
			#
			#     となる単一の解を持つ。 ( n 重解 )
			#
			my( $gx , $s ) = $fx->deflate() ;

			if ( $gx->is_monomial() ) {
				$z->[0] = new_decimal( $s ) ;
				foreach my $i ( 1 .. ( $n - 1 ) ) {
					$z->[ $i ] = $z->[0]->copy() ;
				}
			}
			else {
				$r = $gx->newton()	if ( defined $gx ) ;
			}
		}

		unless ( @{ $z } ) {
			return ()	unless ( defined $r ) ;

			#
			#                               2PI           3
			# z[j][0] == R0 + R * exp( i * ----- * ( j - --- ) )      ( j == 1 -> n )
			#                                n            4
			#
			my $pi2 = pi() * 2 ;
			my $np = $pi2 / $n ;
			foreach my $j ( 1 .. $n ) {
				my $t = ( $np * ( ( $j * 4 ) - 3 ) / 4 ) % $pi2 ;
				$z->[ $j - 1 ] = $r0 + $r * new_complex( { 'arg' => $t } ) ;
			}

			#
			#
			# 漸化式
			#
			#                                        f( z[i][k] )
			#   z[i][ k + 1 ] == z[i][k] - --------------------------------     ( j == 1 -> n ; j != i )
			#                               a[n] * Π( z[i][k] - z[j][k] )
			#
			my $cnt = 0 ;
			my $flg = 0 ;
			while ( $cnt++ < 100 ) {
				$flg = 0 ;
				my $w = [] ;
				foreach my $i ( 0 .. $#{ $z } ) {
					my $numer = $fx->substitute( $z->[ $i ] ) ;
					my $denom = $fx->[ $n ] ;
					foreach my $j ( 0 .. $#{ $z } ) {
						next	if ( $i == $j ) ;
						$denom *= ( $z->[ $i ] - $z->[ $j ] ) ;
					}

					my $diff = $numer->divide( $denom ) ;

					if ( $diff->is_complex() ) {
						$flg++	if ( $diff->det()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
					}
					else {
						$flg++	if ( $diff->abs()->round( $DECIMAL_PART_LENGTH_LIMIT ) == 0 ) ;
					}

					$w->[ $i ] = $z->[ $i ]->subtract( $diff )->round( $DECIMAL_PART_LENGTH_LIMIT ) ;
				}

				$z = $w ;

				last	if ( $flg >= scalar( @{ $z } ) ) ;
			}

			$z = []	unless ( $flg >= scalar( @{ $z } ) ) ;
		}
	}

	return @{ $z } ;
}

=head2 factor

This method sames to 'solve', but it return the Polynomial objects, instead of the Decimal object.

It means the factorization of polynomial.


  $fx = polynomial( 1 , 1 , 1 , 1 ) ;                  # f(x) == x^3 + x^2 + x + 1

  print join( "\n" , $fx->solve() ) ;                  # -1
                                                       # 0 - i
						       # 0 + i
  
  prnt join( "\n" , $fx->factor() ) ;                  # 0 : 1            ( == 1 )
                                                       #
                                                       # 1 : 1            ( == x + 1 )
						       # 0 : 1
                                                       #
						       # 1 : 1            ( == x + i )
						       # 0 : 0 + i
						       #
						       # 1 : 1            ( == x - i )
						       # 0 : 0 - i
						       #
						       # -> f(x) == 1 * ( x + 1 ) * ( x + i ) * ( x - i )
						       #


=cut

sub factor {
	#-----------------------------------------------------------------------
	#
	# 因数分解
	#
	#   n 次多項式を一次式の積に分解し、分解の結果として得られた一次式のリストを返す。
	#   リストの先頭には最高次数係数を多項式で表現したオブジェクトを配置する。
	#
	#     f(X) == a[n] * X^n + a[n-1] * X^(n-1) + ..... + a[1] * X + a[0]
	#          == a[n] * Π( X - x[k] )              ( k == 1 -> n )
	#
	#-----------------------------------------------------------------------
	my( $fx ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;

	my $gx = [ __PACKAGE__->new( $fx->[-1] ) ] ;
	foreach my $x ( $fx->solve() ) {
		push( @{ $gx } , __PACKAGE__->new( 1 , $x * ( -1 ) ) ) ;
	}

	return @{ $gx } ;
}

=head1 'Polynomial' object - tangential line and normal line.

=cut

#-------------------------------------------------------------------------------
#
# 接線と法線
#
#-------------------------------------------------------------------------------

=head2 tangent_line( $x )

If the function is defined as y == f(x), the point of this fucntion is defined [ a , f(a) ].

The tangent line is touches the curve, defined this function, with out crossing it.

If the function is defined as follows,

  y == f(x)

the tangent line, which touches the curve at the point [ a , f(a) ], is defined as follows.

  f'(x) == differential( f(x) )

  y - f(a) == f'(a) * ( x - a )

  -> y == tangent_line( f(x) , a ) == f'(a) * ( x - a ) + f(a)

for example

  $fx = polynomial( 1 , 0 , 0 ) ;                      # f(x) == x^2

  print $fx->substitute( 1 ) ;                         # 1              ( the point of y == f(1)  is [  1 , 1 ] )
  print $fx->substitute( -1 ) ;                        # 1              ( the point of y == f(-1) is [ -1 , 1 ] )

  print $fx->tangent_line( 1 ) ;                       # 1 : 2          ( y == 2x - 1 touches to y == f(x) at the point [ 1 , 1 ] )
                                                       # 0 : -1

  print $fx->tangent_line( -1 ) ;                      # 1 : -2         ( y == -2x - 1 touches to y == f(x) at the point [ -1 , 1 ] )
                                                       # 0 : -1


=cut

sub tangent_line {
	#-----------------------------------------------------------------------
	#
	# 接線
	#
	#   関数 y == f(x) における点 [ a , f(a) ] の接線は、
	#
	#     y - f(a) == f'(a)( x - a )
	#
	#     -> y == f'(a)( x - a ) + f(a)
	#
	#  で表される。
	#
	#-----------------------------------------------------------------------
	my( $fx , $x ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	my $gx = $fx->differential() ;
	my $hx = __PACKAGE__->new( 1 , $x * ( -1 ) ) ;	# h(x) == x - a

	my $px = $gx->substitute( $x ) * $hx + $fx->substitute( $x ) ;

	return $px ;
}

=head2 normal_line( $x )

If the function and the tangent line at the point [ a , f(a) ] are defined as follows.

  y == f(x)
  y == g(x) == tangent_line( f(x) , a ) == f'(a) * ( x - a ) + f(a)

The normal line is a perpendicular line to this tangent line, and it is defined as follows.

  y - f(a) == (-1) * ( 1 / f'(a) ) * ( x - a )

  -> y == normal_line( f(x) , a ) == ( -1 ) * ( 1 / f'(a) ) * ( x - a ) + f(a)


for example 

  $fx = polynomial( 1 , 0 , 0 ) ;                      # f(x) == x^2

  print $fx->substitute( 1 ) ;                         # 1              ( the point of y == f(1)  is [  1 , 1 ] )
  print $fx->substitute( -1 ) ;                        # 1              ( the point of y == f(-1) is [ -1 , 1 ] )

  print $fx->norma_line( 1 ) ;                         # 1 : -0.50000   ( y == -1/2 * x + 3/2 )
                                                       # 0 : 1.50000

  print $fx->normal_line( -1 ) ;                       # 1 : 0.50000    ( y == 1/2 * x + 3/2 )
                                                       # 0 : 1.50000


=cut

sub normal_line {
	#-----------------------------------------------------------------------
	#
	# 法線 ( normal )
	#
	#   法線は、関数 y == f(x)  における点 [ a , f(a) ] で接線と垂直に交わる直線。
	#
	#   関数 y == f(x) における点 [ a , f(a) ] の法線は、
	#
	#     y - f(a) == ( -1 ) * ( 1 / f'(a) )( x - a )
	#
	#     -> y == ( -1 ) * ( 1 / f'(a) )( x - a ) + f(a)
	#
	#   で表される。
	#
	#-----------------------------------------------------------------------
	my( $fx , $x ) = @_ ;
	return undef	unless ( ref( $fx ) eq __PACKAGE__ ) ;
	return undef	unless ( defined $x ) ;

	my $gx = $fx->differential() ;
	my $hx = __PACKAGE__->new( 1 , $x * ( -1 ) ) ;	# h(x) == x - a

	my $ga = $gx->substitute( $x ) ;

	my $px = ( $ga == 0 )
		? undef
		: $ga->inverse() * ( -1 ) * $hx + $fx->substitute( $x )
	;

	return $px ;
}

1;

__END__

